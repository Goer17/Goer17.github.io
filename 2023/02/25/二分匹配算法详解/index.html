

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/pi_pi.png">
  <link rel="icon" href="/img/pi_pi.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Captain_Lee">
  <meta name="keywords" content="">
  
    <meta name="description" content="问题介绍 什么是二分图？ 对于图 \(G(V,E)\) 而言，若 \(G\) 中的所有点可以划分为两个子集 \(G_1\)、\(G_2\) ，且图中每条边 \(e\) 关联的两个顶点都属于不同的顶点子集，这样的图我们称为二分图（ Bipartite Graph ），或者二部图。  最大匹配问题和最小点覆盖问题 什么是最大匹配问题？给定一个二分图 \(G(V,E)\)，若 \((a_i,b_j) \">
<meta property="og:type" content="article">
<meta property="og:title" content="二分匹配问题 —— 匈牙利算法">
<meta property="og:url" content="http://example.com/2023/02/25/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Yuanyang-Lee 的个人博客">
<meta property="og:description" content="问题介绍 什么是二分图？ 对于图 \(G(V,E)\) 而言，若 \(G\) 中的所有点可以划分为两个子集 \(G_1\)、\(G_2\) ，且图中每条边 \(e\) 关联的两个顶点都属于不同的顶点子集，这样的图我们称为二分图（ Bipartite Graph ），或者二部图。  最大匹配问题和最小点覆盖问题 什么是最大匹配问题？给定一个二分图 \(G(V,E)\)，若 \((a_i,b_j) \">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p.ipic.vip/ueiehn.png">
<meta property="og:image" content="https://p.ipic.vip/5pnk5n.png">
<meta property="og:image" content="https://p.ipic.vip/phzd9z.png">
<meta property="og:image" content="https://p.ipic.vip/wfjof3.png">
<meta property="og:image" content="https://p.ipic.vip/0dm74v.png">
<meta property="og:image" content="https://p.ipic.vip/zhjyss.png">
<meta property="article:published_time" content="2023-02-24T17:21:01.000Z">
<meta property="article:modified_time" content="2023-03-02T05:08:09.525Z">
<meta property="article:author" content="Captain_Lee">
<meta property="article:tag" content="DFS">
<meta property="article:tag" content="二分匹配">
<meta property="article:tag" content="匈牙利算法">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://p.ipic.vip/ueiehn.png">
  
  
  
  <title>二分匹配问题 —— 匈牙利算法 - Yuanyang-Lee 的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":["home"]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Yuanyang-Lee</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/post-page.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">二分匹配问题 —— 匈牙利算法</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-02-25 01:21" pubdate>
          2023年2月25日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          4.8k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          41 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">二分匹配问题 —— 匈牙利算法</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="问题介绍">问题介绍</h3>
<p><strong>什么是二分图？</strong></p>
<p>对于图 <span class="math inline">\(G(V,E)\)</span> 而言，若 <span
class="math inline">\(G\)</span> 中的所有点可以划分为两个子集 <span
class="math inline">\(G_1\)</span>、<span
class="math inline">\(G_2\)</span> ，且图中每条边 <span
class="math inline">\(e\)</span>
关联的两个顶点都属于不同的顶点子集，这样的图我们称为<strong>二分图（
Bipartite Graph ）</strong>，或者二部图。</p>
<p><img src="https://p.ipic.vip/ueiehn.png" srcset="/img/loading.gif" lazyload style="zoom:67%;" /></p>
<p><strong>最大匹配问题和最小点覆盖问题</strong></p>
<p>什么是<strong>最大匹配问题</strong>？给定一个二分图 <span
class="math inline">\(G(V,E)\)</span>，若 <span
class="math inline">\((a_i,b_j) \in E\)</span> ，我们就称 <span
class="math inline">\(a_i\)</span> 和 <span
class="math inline">\(b_j\)</span>
是可配对的，已知该图中任意顶点至多匹配一个顶点，求最大匹配数。如下图，不难看出该图的最大匹配数为
2。其中一种匹配方式为 <span class="math inline">\((a_1,
b_1)\)</span>、<span class="math inline">\((a_3, b_4)\)</span> 。</p>
<p>什么又是<strong>最小点覆盖问题</strong>呢？即从二分图中删除最少的顶点，使得图
<span class="math inline">\(G\)</span>
中任何一对点都无法匹配。删除顶点的最小数量称为最小点覆盖数。如下图，不难看出最小覆盖数也是
2。我们可以删去 <span class="math inline">\(a_3\)</span> 和 <span
class="math inline">\(b_1\)</span> 使得图中任何一对点都无法匹配。</p>
<p>这两个问题看似不一样，实际上实际上是处理一个相同的问题。为什么这么说呢？因为我们可以证明一条重要性质：</p>
<center>
<strong>最大匹配数 = 最小覆盖数</strong>
</center>
<p>具体证明就不在这里说明了，笔者打算以后单独出一期文章来证明该性质。</p>
<p><img src="https://p.ipic.vip/5pnk5n.png" srcset="/img/loading.gif" lazyload style="zoom:45%;" /></p>
<p>那我们该如何给出二分匹配问题的一般解决方案呢？1955 年，库恩（
W.W.Kuhn ）利用一个匈牙利数学家康哥尼（ D.Kőnig
）的一个定理构造了一种二分匹配问题的解法，后人称之为<strong>匈牙利算法</strong>。</p>
<h3 id="匈牙利算法">匈牙利算法</h3>
<p>在介绍匈牙利算法之前，我们先介绍几个概念：</p>
<ul>
<li><p><strong>交替路</strong>：</p>
<p>从未匹配点出发，依次经过未匹配的边和已匹配的边的路径称为交替路。</p></li>
<li><p><strong>增广路</strong>：</p>
<p>经过除出发点之外其他未匹配点的交替路称为增广路。</p>
<p><strong>当且仅当不存在关于图 <span class="math inline">\(G\)</span>
的增广路径时当前的匹配为图 <span class="math inline">\(G\)</span>
的最大匹配。</strong></p></li>
</ul>
<h4 id="算法讲解">算法讲解</h4>
<p>如下图所示，我们接下来将使用匈牙利算法来计算该二分图的最大匹配数。</p>
<p>我们从 <span class="math inline">\(a_1\)</span> 开始匹配，<span
class="math inline">\(a_1\)</span> 与 <span
class="math inline">\(b_1\)</span> 匹配成功，即当前匹配对数为 1。</p>
<p><left>
<img src="https://p.ipic.vip/phzd9z.png" srcset="/img/loading.gif" lazyload alt="(1)" style="zoom:100%; margin-right: 30px;" />
<img src="https://p.ipic.vip/wfjof3.png" srcset="/img/loading.gif" lazyload alt="(2)" style="zoom:100%; margin-right: 30px;" />
</left></p>
<p>然后再对 <span class="math inline">\(a_2\)</span> 进行匹配，我们发现
<span class="math inline">\(a_2\)</span> 只能匹配 <span
class="math inline">\(b_1\)</span> ，而 <span
class="math inline">\(b_1\)</span> 已经与 <span
class="math inline">\(a_1\)</span> 匹配成功了，此时我们发现 <span
class="math inline">\(a_1\)</span> 和 <span
class="math inline">\(b_3\)</span> 可以成功匹配，于是我们可以取消 <span
class="math inline">\(a_1\)</span> 和 <span
class="math inline">\(b_1\)</span> 的匹配，然后匹配 <span
class="math inline">\(a_1\)</span> 和 <span
class="math inline">\(b_3\)</span> ，这个时候 <span
class="math inline">\(a_2\)</span> 就可以匹配 <span
class="math inline">\(b_1\)</span> 了。匹配对数加一，当前匹配对数为
2。</p>
<p>其实这一步相当于找到了一条增广路 <span class="math inline">\((a_2,
b_1, a_1, b_3)\)</span> ，然后对该增广路取反。</p>
<p><left>
<img src="https://p.ipic.vip/0dm74v.png" srcset="/img/loading.gif" lazyload alt="(3)" style="zoom:100%;" />
</left></p>
<p>接下来对 <span class="math inline">\(a_3\)</span> 进行匹配，<span
class="math inline">\(a_3\)</span> 与 <span
class="math inline">\(b_2\)</span>
成功匹配，匹配对数加一，当前匹配对数为 3。</p>
<p><left>
<img src="https://p.ipic.vip/zhjyss.png" srcset="/img/loading.gif" lazyload alt="(4)" style="zoom:100%;" />
</left></p>
<p>最后对 <span class="math inline">\(a_4\)</span>
进行匹配，发现其只能与 <span class="math inline">\(b_1\)</span> 匹配，而
<span class="math inline">\(b_1\)</span> 已经与 <span
class="math inline">\(a_1\)</span> 匹配过了，而且无法从 <span
class="math inline">\(a_4\)</span> 出发构造一条增广路，因此 <span
class="math inline">\(a_4\)</span> 无法与任何一个顶点成功匹配。</p>
<p><strong>综上所述，展示的二分图的最大匹配数为 3</strong>。</p>
<p><strong>伪代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pseudo-code">// 判断 ai 是否能匹配成功<br>for bj 与 ai 相连:<br>		if bj 未被访问:<br>				更新 bj 访问状态;<br>        if bj 未被匹配或者 bj 的配对点可以出发找到增广路径:<br>        		将 bj 的配对点改为 ai;<br>        		return true;<br><br>return false;<br></code></pre></td></tr></table></figure>
<p>时间复杂度：<span class="math inline">\(O(VE)\)</span></p>
<h4 id="代码实现">代码实现</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NOT_MATCH 0x3f3f3f3f</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  	<span class="hljs-type">int</span> numA, numB; <span class="hljs-comment">// numA、numB 分别表示两个集合的元素个数</span><br>  	vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; G; <span class="hljs-comment">// 假设这里用邻接链表储存图 G，G[i] 表示和 ai 相邻的所有 B 集合的顶点编号</span><br>  	<span class="hljs-type">int</span> match[numB]; <span class="hljs-comment">// 记录 B 集合的元素的匹配点在 A 集合的编号</span><br>  	<span class="hljs-type">bool</span> vis[numB]; <span class="hljs-comment">// 记录 B 集合的元素是否被访问过</span><br>		<br>  	<span class="hljs-comment">// ...</span><br>  	<span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>      	<span class="hljs-comment">// 判断 A 集合中编号为 index 的顶点是否能匹配成功</span><br>      	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[index].<span class="hljs-built_in">size</span>(); i++) &#123;<br>          	<span class="hljs-keyword">if</span> (!vis[G[i]]) &#123;<br>              	vis[G[i]] = <span class="hljs-literal">true</span>;<br>              	<span class="hljs-keyword">if</span> (match[G[i]] == NOT_MATCH || <span class="hljs-built_in">isMatch</span>(match[[G[i]]])) &#123;<br>                		<span class="hljs-comment">// 该顶点未被匹配或着原来匹配该点的顶点可以匹配其他顶点</span><br>                  	match[G[i]] = index;<br>                  	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>      	<br>      	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br><span class="hljs-keyword">public</span>:<br>  	<span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hungarian</span><span class="hljs-params">()</span> </span>&#123;<br>      	<span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>      	<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numA; i++) &#123;<br>          	<span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>          	<span class="hljs-keyword">if</span> (<span class="hljs-built_in">isMatch</span>(i)) &#123;<br>              	cnt++;<br>            &#125;<br>        &#125;<br>      <br>      	<span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="实际应用">实际应用</h4>
<blockquote>
<p><strong>Machine Schedule</strong></p>
<p>Problem Description As we all know, machine scheduling is a very
classical problem in computer science and has been studied for a very
long history. Scheduling problems differ widely in the nature of the
constraints that must be satisfied and the type of schedule desired.
Here we consider a 2-machine scheduling problem.</p>
<p>There are two machines A and B. Machine A has n kinds of working
modes, which is called <span class="math inline">\(mode_0\)</span> ,
<span class="math inline">\(mode_1\)</span> , …, <span
class="math inline">\(mode_{n-1}\)</span> , likewise machine B has m
kinds of working modes, <span class="math inline">\(mode_0\)</span>,
<span class="math inline">\(mode_1\)</span> , … , <span
class="math inline">\(mode_{m-1}\)</span> . At the beginning they are
both work at <span class="math inline">\(mode_0\)</span>.</p>
<p>For k jobs given, each of them can be processed in either one of the
two machines in particular mode. For example, job 0 can either be
processed in machine A at <span class="math inline">\(mode_3\)</span> or
in machine B at <span class="math inline">\(mode_4\)</span> , job 1 can
either be processed in machine A at <span
class="math inline">\(mode_2\)</span> or in machine B at <span
class="math inline">\(mode_4\)</span> , and so on. Thus, for job i, the
constraint can be represent as a triple (i, x, y), which means it can be
processed either in machine A at <span
class="math inline">\(mode_x\)</span>, or in machine B at <span
class="math inline">\(mode_y\)</span> .</p>
<p>Obviously, to accomplish all the jobs, we need to change the
machine’s working mode from time to time, but unfortunately, the
machine’s working mode can only be changed by restarting it manually. By
changing the sequence of the jobs and assigning each job to a suitable
machine, please write a program to minimize the times of restarting
machines.</p>
<p>Input The input file for this program consists of several
configurations. The first line of one configuration contains three
positive integers: n, m (n, m &lt; 100) and k (k &lt; 1000). The
following k lines give the constrains of the k jobs, each line is a
triple: i, x, y.</p>
<p>The input will be terminated by a line containing a single zero.</p>
<p>Output The output should be one integer per line, which means the
minimal times of restarting machine.</p>
<p>输入案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs input">5 5 10<br>0 1 1<br>1 1 2<br>2 1 3<br>3 1 4<br>4 2 1<br>5 2 2<br>6 2 3<br>7 2 4<br>8 3 3<br>9 4 3<br>0<br></code></pre></td></tr></table></figure>
<p>输出案例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3<br></code></pre></td></tr></table></figure>
</blockquote>
<p>对于此题，我们可以将 A、B
机器的所有模式看成二部图看成两个子集，若某个工作需要机器 A 的 x
模式和机器 B 的 y 模式来完成，就将 <span class="math inline">\((a_x,
b_y)\)</span>
连接起来。最后我们的问题就变成了：<strong>应该如何找到该二部图的最小点覆盖数？</strong></p>
<p>而根据我们之前提到的结论可知，最小点覆盖数在数值上等于最大匹配数。</p>
<p><strong>代码</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 105</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NOT_FOUND 0x3f3f3f3f</span><br><br><span class="hljs-type">int</span> G[MAX_NUM][MAX_NUM];<br><span class="hljs-type">bool</span> vis[MAX_NUM];<br><span class="hljs-type">int</span> match[MAX_NUM];<br><br><span class="hljs-type">int</span> n, m, k;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (G[index][i] &amp;&amp; !vis[i]) &#123;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[i] == NOT_FOUND || <span class="hljs-built_in">isMatch</span>(match[i])) &#123;<br>                match[i] = index;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cin &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-built_in">memset</span>(G, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G));<br>        <span class="hljs-built_in">memset</span>(match, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(match));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-type">int</span> t, ax, by;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            cin &gt;&gt; t &gt;&gt; ax &gt;&gt; by;<br>            <span class="hljs-keyword">if</span> (ax != <span class="hljs-number">0</span> &amp;&amp; by != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 0 号模式下可以完成的任务不用添加</span><br>                G[ax][by] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isMatch</span>(i)) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 求出最小点覆盖数</span><br><br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" class="category-chain-item">数据结构与算法</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/DFS/">#DFS</a>
      
        <a href="/tags/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/">#二分匹配</a>
      
        <a href="/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/">#匈牙利算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>二分匹配问题 —— 匈牙利算法</div>
      <div>http://example.com/2023/02/25/二分匹配算法详解/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Captain_Lee</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年2月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/02/26/%E8%AE%B0%E5%BF%86%E5%8C%96%20DFS/" title="记忆化 DFS">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">记忆化 DFS</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/02/22/LLDB%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/" title="LLDB 快速入门">
                        <span class="hidden-mobile">LLDB 快速入门</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>

{"meta":{"title":"Yuanyang-Lee's Blog","subtitle":"","description":"","author":"Captain_Lee","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-02-08T17:20:04.000Z","updated":"2023-02-08T17:21:01.238Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标题","date":"2023-02-08T16:22:53.592Z","updated":"2023-02-08T16:22:53.588Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-02-08T17:23:44.000Z","updated":"2023-02-08T17:24:02.300Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"文件系统","slug":"文件系统","date":"2023-10-06T09:06:04.000Z","updated":"2023-10-13T09:40:41.009Z","comments":true,"path":"2023/10/06/文件系统/","link":"","permalink":"http://example.com/2023/10/06/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"文件系统介绍 文件系统（File system）是操作系统的一层，它将磁盘（或其他块设备）的块接口（Block interface）转换为文件、目录等。 文件系统的主要功能： 磁盘管理（Disk management） 将磁盘块集成文件。 命名（Naming） 接口通过名字访问文件而不是磁盘块。 保护（Protection） 保护文件数据安全。 可靠性/耐用性（Reliability/Durability） 保证文件的持久性。 文件 文件是一种对计算机上非易失性（non-volatile）存储的抽象。 其包括了： 数据（Data）： 在硬件上存储的数据块。 元数据（Metadata） 用户（Owner） 大小（Size） 最近开启时间（Last opened） 最后一次修改时间（Last modified） 权限（Access rights） 在 Unix / Linux 操作系统中，一般用 9 个 bit 来描述文件的权限，分别表示所属用户、群组用户和外部用户对该文件是否有读（Read）、写（Write）和执行（Execute）的权限。 ... 在 Unix / Linux 操作系统中，我们可以使用 ls 指令输出文件详细信息： 1ls -l demo.txt 终端输出： 1-rw-r--r--@ 1 username staff 0 10 12 16:38 demo.txt -rw-r--r-- ： 这部分显示了文件的权限模式。在这个权限模式中，有10个字符，它们按顺序表示了文件的不同权限。这个权限模式可以分为三部分： 第一位是文件的类型， - 表示 demo.txt 是一个普通文件。 接下来的 3 位（rw-）表示文件的所有者（username）具有读（r）和写（w）的权限，但没有执行（x）权限。 再接下来的3位（r--）表示文件的组（staff）具有只读（r）的权限，但没有写入（w）或执行（x）的权限。 最后的3位（r--）表示其他用户也具有只读（r）的权限，但没有写入（w）或执行（x）的权限。 可以使用 chmod 指令对文件权限进行修改： 1 ：这个数字表示文件的硬链接数。在这个示例中，文件 demo.txt 有一个硬链接。硬链接是指多个文件名指向相同的文件数据块。每个文件都有一个硬链接计数，当这个计数变为零时，文件数据才会被删除。 username ：文件所有者（Owner）的用户名。 staff ：文件所属组（Group）名。 0 ：这是文件的大小，以字节为单位。在这个示例中，文件大小为0字节，表示这是一个空文件。 10 12 16:38 ：这是文件的最后修改时间。具体来说，这个文件的最后时间是在 10 月 12 日的 16:38。 文件的需求 可变的大小（Variable size） 可实现多个并发用户和进程，同时能有保护作用（Multiple concurrent users / peocesses but with protection） 高效的查找技术（Being able to find files） 管理空闲磁盘块（Manage free disk blocks） 文件系统的组成部分 目录结构（Directory Structure） 目录结构是文件系统中用于组织和管理文件和目录的方式。通常，它采用树状结构（Hierarchy tree-like structure），类似于文件夹（目录）和文件的层次结构。根目录位于顶层，包含子目录和文件，这些子目录又可以包含更多的子目录和文件，以此类推。每个目录都可以包含文件和其他目录。 Unix / Linux 操作系统使用的目录结构是一个树状结构，根目录通常表示为 /，然后有多个子目录和文件，如 /home、/usr 等等。 文件索引结构（File Index Structure） 文件索引结构是文件系统用于管理文件和文件属性的内部数据结构。它包含有关文件的元数据信息，例如文件名、大小、创建日期、修改日期、权限和链接数等。文件索引结构的设计取决于文件系统的类型。 例如，在 Unix / Linux 中，常见的文件系统如 Ext4 使用了索引节点（Inode）结构来存储文件的元数据。每个文件和目录都有一个唯一的索引节点号，而这个索引节点包含了关于文件的所有信息。这使得操作系统能够有效地查找和管理文件。 我们可以给 ls 指令加上 -i 参数来显示文件的 inode 属性： 数据块（Data Block） 数据块是文件系统用来存储文件内容的基本单位。当文件太大以至于无法一次存储在内存中时，文件会被划分为多个数据块，每个数据块包含文件的一部分内容。这些数据块通常由文件系统管理，而文件索引结构中的信息将告诉操作系统如何组合这些数据块以获取完整的文件内容。 在大多数文件系统中，数据块通常是一个连续的、固定大小的块，例如 4KB 或 8KB。文件系统会维护一个映射，将文件的逻辑块地址映射到物理磁盘上的数据块。 文件的启动与关闭 打开文件表 操作系统需要在内存维护所有开启文件的信息。 打开文件表（Open file table）是操作系统内部用于跟踪已打开文件的数据结构，它包含了文件的元数据和状态信息，允许操作系统和进程有效地管理对文件的访问。每个正在运行的进程都有其自己的打开文件表，用于跟踪该进程所打开的文件。 系统范围的打开文件表（System-wide open file table） 系统范围的打开文件表是操作系统维护的一个数据结构，用于跟踪在整个系统范围内打开的文件。它存储了有关每个系统中已打开文件的信息（Information for every currently open file in the system），例如存储在 inode 属性中的信息（文件名、大小、所属用户等）。 系统范围的打开文件表允许不同的进程共享文件的访问信息。当多个进程打开同一个文件时，它们可以共享相同的系统范围的打开文件表条目，这意味着它们可以看到对该文件的更改。这有助于提高操作系统的效率，因为不需要为每个打开的文件创建独立的系统资源，只需在系统范围的打开文件表中引用相同的信息即可。 进程内的打开文件表（Per-process open file table） 每个进程都有自己的进程内打开文件表，用于跟踪该进程打开的文件。每个进程内的打开文件表包含了一个指向系统打开文件表的指针（A pointer to the system open file table） 和其他信息如文件描述符、文件状态标志、当前文件偏移量等。 进程内的打开文件表使每个进程能够独立地管理其打开的文件，包括读取、写入和定位文件指针等操作。这确保了不同进程之间的文件访问彼此隔离，一个进程的文件操作不会影响其他进程。 open() 和 close() 在 Linux 内核中，open() 和 close() 是两个重要的系统调用函数，用于打开和关闭文件。这些函数在文件操作中起着关键作用，允许进程与文件进行交互。 一下展示两个系统调用在 C 语言中的接口： open() 函数： open() 函数用于打开文件，并返回一个称为文件描述符（File Descriptor）的整数值，该文件描述符在后续的文件操作中用于唯一标识打开的文件。函数原型如下： 1int open(const char* pathname, int flags, mode_t mode); pathname：是要打开的文件的路径或文件名。 flags：是一组标志，用于指定文件的打开方式，如只读、只写、追加等。常见的标志包括O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（读写）、O_APPEND（追加写入）、O_CREAT（如果文件不存在则创建）、O_TRUNC（截断文件）等。 mode：是文件权限的设置，通常与 O_CREAT 标志一起使用，用于新创建的文件。（如果文件已存在则不需要传递该参数） open() 函数返回一个非负整数文件描述符，如果打开文件失败，则返回 -1。文件描述符在进程的打开文件表中唯一标识已打开的文件，可以用于后续的读取、写入和关闭操作。 close() 函数： close() 函数用于关闭先前通过 open() 函数打开的文件，释放与文件描述符相关的资源。函数原型如下： 1int close(int fd); fd：是要关闭的文件描述符。 close() 函数会关闭指定的文件描述符，使该文件描述符不再可用，同时释放与该文件描述符相关的资源，如文件表项和文件描述符表中的条目。关闭文件是一项重要的操作，它有助于避免资源泄漏和确保文件在不再需要时不会继续占用系统资源。 当我们打开一个文件： 先进行 open() 系统调用，从磁盘中读取目标文件的 inode 信息，并存储在系统范围的打开文件表内。 当前进程内的打开文件表新增一个指向系统范围内打开文件表的索引（或指针），并通过 open() 函数返回给程序（在 Unix / Linux 中称为 File descriptor，在 Windows 中称为 File handle）。 当我们关闭一个文件： 释放进程表项（Per-process table entry）。 当前存储在此文件的内存缓存（Memory cache）中的任何数据都将在必要时写入磁盘。 文件的共享 一个文件可以被多个用户 / 进程访问，如果同一时间多个用户或进程以只读方式打开文件，那该过程可以正常执行，但如果多个用户或进程同时读写就可能引发冲突。 因此 OS 中引入了锁（Lock）： 文件锁技术是一种用于控制对文件的并发访问的机制。它允许多个进程或线程协调共享对文件的访问，以防止竞争条件和数据损坏。文件锁通常用于多进程或多线程环境中，其中多个实体需要访问相同的文件。 有两种主要类型的文件锁：共享锁（Shared Lock）和独占锁（Exclusive Lock）。这些锁可以在文件上的不同部分或整个文件上设置。 共享锁（Shared Lock）： 多个进程可以同时持有共享锁。 共享锁允许多个进程同时读取文件，但阻止其他进程获得独占锁。 共享锁通常用于并发读取操作，以防止竞争条件。 独占锁（Exclusive Lock）： 仅一个进程可以持有独占锁。 独占锁阻止其他进程获得任何类型的锁，共享锁和独占锁都被阻止。 独占锁通常用于写入和修改文件的操作，以确保数据的一致性。 例如，用户 A 在读取文件时每个进程都持有共享锁，其他进程无法对文件内容进行修改，只能以只读方式打开文件。 文件索引与文件信息 Unix/Linux Inode 在 Unix 和 Linux 文件系统中，\"inode\"（索引节点）是一个关键的数据结构，用于管理和存储文件的元数据信息。每个文件和目录都有一个唯一的 inode，用于跟踪文件的属性、权限、所在位置等等，我们可以认为一个文件的 inode 主要维护了以下两类信息： 元数据（Metadata） 数据块地址（Which disk blocks belong to which file） 元数据在上文中已经介绍，包括文件的一些基本信息，数据块地址则是文件实际内容的存储地址。 我们可以使用 stat 指令查看文件包括 inode 在内的各种详细信息： 1stat filename 示例： Inode 存储在什么地方？ 在早期的 UNIX 系统中，它们被存储在磁盘。 Inode 不在数据块附近存储。要读一个小文件，先查找索引节点，再查找回数据。（Poor performance） 如果外部磁盘损坏，意味着文件系统会丢失。（Poor reliability） 在后来的系统中，索引节点分布在磁盘块组中，更接近数据块本身。 Unix 目录 目录（Directory）是一种特殊的文件，其包含： 文件名列表（A list of filenames） 指向 Inode 的指针（Pointers to inodes） 有关 Inode 更详细的介绍","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"文件系统","slug":"文件系统","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"}]},{"title":"mysql-connector 学习笔记","slug":"mysql-connector 学习笔记","date":"2023-10-04T10:04:35.000Z","updated":"2023-10-04T13:13:29.294Z","comments":true,"path":"2023/10/04/mysql-connector 学习笔记/","link":"","permalink":"http://example.com/2023/10/04/mysql-connector%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"简介 mysql-connector 是一个用于 Python 编程语言的 MySQL 数据库连接库，它允许开发人员连接到 MySQL 数据库并执行各种数据库操作，如查询、插入、更新和删除数据。 安装 1pip install mysql-connector 使用 创建数据库连接 我们先在本地创建一个名为 demo 的数据库： 12345678mysql -u root -p# 以 root 登陆 mysql 客户端create table demo;# 创建数据库show databases;# 如果显示有 demo，则表示创建成功 创建成功后，我们就可以使用 mysql-connector 连接到数据库了。 123456789101112131415import mysql.connectordef main(): try: demo_connection = mysql.connector.connect( host=&#x27;localhost&#x27;, user=&#x27;root&#x27;, passwd=&#x27;xxxxx&#x27;, # Your password database=&#x27;demo&#x27; # 指定具体的数据库，也可以不加 ) except mysql.connector.Error as err: print(&#x27;Connection Error!&#x27;, err)if __name__ == &#x27;__main__&#x27;: main() 操作数据库 连接成功后我们就可以操作本地数据库了。为了操作数据库，我们需要创建一个 「Cursor」 对象。 Cursor 是一个重要的对象，它用于执行 SQL 查询和操作数据库。 创建 Cursor 对象： 在使用 mysql-connector 连接到 MySQL 数据库后，首先需要创建一个 cursor 对象。通常，可以使用 connection.cursor() 方法来创建一个新的 cursor 对象，其中 connection 是数据库连接的实例。 1my_cursor = demo_connection.cursor() 执行 SQL 语句： 通过 cursor 对象，可以执行各种 SQL 查询。要执行查询，可以使用 cursor.execute(sql_query) 方法，其中 sql_query 是包含 SQL 语句的字符串。 假设 demo 数据库中有表格 stuff(s_id, s_name, gender, salary, dept_id) 123my_cursor.execute(&#x27;select * from stuff&#x27;)my_cursor.execute(&#x27;insert into stuff values(%s, %s, %s, %s, %s)&#x27;, (2023100, &#x27;Frank&#x27;, &#x27;男&#x27;, 40000, 3)) 注：如果要一次性向表格插入多个数据，execute() 方法的第二个参数可以接收一个包含了多个元组的列表。 获取查询结果： 一旦执行了查询，可以使用不同的方法来获取查询结果。例如，可以使用 cursor.fetchone() 获取一行记录，或者使用 cursor.fetchall() 获取所有匹配的记录。 12345# 获取一行记录row = my_cursor.fetchone()# 获取所有匹配的记录rows = my_cursor.fetchall() 提交事务： 在执行写操作（如 INSERT、UPDATE 或 DELETE ）后，通常需要提交事务以确保更改生效。可以使用 connection.commit() 方法来提交事务。 12# 提交事务demo_connection.commit() 关闭 Cursor 和连接： 使用完 cursor 和数据库连接后，应该关闭它们以释放资源。 12345# 关闭 Cursormy_cursor.close()# 关闭连接demo_connection.close()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"数据库系统","slug":"数据库系统","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"}]},{"title":"进程管理","slug":"进程管理","date":"2023-09-24T05:13:21.000Z","updated":"2023-10-02T15:15:26.754Z","comments":true,"path":"2023/09/24/进程管理/","link":"","permalink":"http://example.com/2023/09/24/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"进程 早期的计算机一次只能执行一个程序（如 MS-DOS），这种程序完全控制系统，并且访问所有系统资源。 相比之下，现代计算机系统允许加在多个程序到内存，以便并发执行。这种改进要求：对各种程序提供更严格的控制和划分。这些需求导致了进程（Process）概念的产生，即进程为执行程序。进程是现代分时操作系统的工作单元。 进程概念 一个进程就是一个运行程序的实例，其由以下两个部分组成： 当前状态（Current state） 内存信息（Memory contents） 程序计数器（Program counter） 堆栈指针（Stack / Heap pointers） ... 系统资源（System resources） 我们强调：程序本身不是进程。程序只是被动（passive）实体，进程是活动（active）实体。 当一个可执行文件（executable file）被加载到内存时，这个程序就成为进程。 进程状态 二状态模型 &amp; 排队模型 在任何时刻，一个进程要么在执行中，要么未执行，因此我们可以简单将线程构建为最简单的两个状态： 执行中（Running） 未执行（Not running） Enter 即产生新的进程，进入队列。 Dispatch Dispatch 在这里是调度器的意思，即进行进程切换，处理器将处理新的进程。 Pause 当前运行的进程被中断，操作系统的调度器将选择一个新的进程运行。 这里中断的原因有很多，最常见的原因就是超过了操作系统的指令周期。 假设操作系统为了避免任何一个进程独占处理器时间，仅允许一个进程最多连续执行 6 个指令周期： 若进程 A 有 12 条指令，且刚刚出队列进入运行状态，则其执行完前 6 条指令后则会超时而重新入队，同时处理器切换到下一个进程。进程 A 在下一次出队后执行完接下来的 6 条指令后结束，然后退出该系统。 Exit 即进程结束退出系统。 二状态模型具有很大的漏洞，即如果存在一些处于运行状态但已经就绪等待执行的进程，同时还存在一些阻塞状态例如等待 I/O 结束的进程，又由于该模型使用单队列，因此无法区分出未被阻塞的进程从而在阻塞状态的进程上浪费大量处理器资源。具体来说就是若进程 A 处于 I/O 阻塞状态，则在需要的 I/O 结束之前进程 A 会一直参与到进程排队的循环中，既浪费了处理器的工作时间，也增加了其他正常可执行的进程的排队时间。 五状态模型 为了解决以上二状态模型的问题，又提出了五状态模型： 新的（New） 运行（Running） 阻塞（Blocked） 就绪（Ready） 退出（Exit） 五状态模型在二状态模型的基础上新增了阻塞态，可以理解为用于存放等待 I/O 的阻塞态进程的队列。 当相关的 I/O 发生后，处于阻塞态的进程将会进入就绪态。 五状态模型依然存在潜在的问题。对于一般的计算机而言，处理器远快于 I/O，会出现内存中所有进程都在等待 I/O 的现象，此时处理器多数时间处于空闲状态，且需要大量的空间来维护处于阻塞状态的进程。 被挂起的进程 为了解决以上问题，操作系统会将部分进程挂起（Suspend），即把内存内存中某个进程的一部分或者全部移动到磁盘中。 当内存中不存在就绪态的进程时，操作系统就会把被阻塞的进程换出到磁盘的挂起队列（Suspend queue），即临时从内存中移除的进程队列。操作系统从此要么从挂起队列中取出一个进程，要么接受一个新的进程，将其放在内存中运行。 特别说明： Blocked \\(\\to\\) Blocked/Suspend 若没有就绪进程，则至少换出一个阻塞进程，以便为另外一个未阻塞进程腾出空间。 Blocked/Suspend \\(\\to\\) Ready/Suspend 若等待的时间发生 I/O，则处于 阻塞/挂起 状态的进程可以转化到 就绪/挂起 状态。 Ready/Suspend \\(\\to\\) Ready 若内存没有就绪态进程，则操作系统需要调入一个进程来执行。处于 就绪/挂起 状态的进程与处于就绪状态的进程相比优先级更高。 Ready \\(\\to\\) Ready/Suspend 通常，操作系统更倾向于挂起阻塞态进程而非就绪态进程，因为就绪态进程可以立即执行，而阻塞态进程虽然占用了空间却不能执行。若释放内存来得到足够空间的唯一方式是挂起一个就绪态进程，则这种转化是必须的。 操作系统的控制结构： 操作系统为了管理进程和资源，必须掌握每个进程和资源的当前状态。 普遍采用的方法是：OS 构造并维护其管理的每个实体的信息表。我们称其为 OS control table，如下图。 内存表（Memory table） 用于跟踪内存和外存。 I/O 表（I/O table） 管理计算机的 I/O 设备和通道。 文件表（files table） 用于提供文件信息。 进程表（Process table） 用于管理计算机进程。 进程控制块（PCB） 操作系统在管理和控制进程时，首先要知道进程的位置，其次要知道进程的属性（如 PID，进程状态等）。 为了维护进程的这些值，我们采用进程控制块（Process Control Block, PCB），它包括许多与某个特定进程相关的消息： 进程状态（Process state） 程序计数器（Program counter，PC） 计数器表示进程将要执行的下个指令的地址。这里可以理解为 8086 CPU 中的 CS 和 IP 寄存器指向的地址。 CPU 寄存器（CPU register） 包括累加器、索引寄存器、堆栈指针、通用寄存器、条件码寄存器等等。 CPU 调度信息（CPU-sheduling information） 这类信息包括进程优先级、调度队列的指针和其他参数。 内存管理信息（Memory-management information） 根据操作系统使用的内存系统，这类信息可以包括基地址和界限寄存器的值、页表或段表。 记账信息（Accounting information） 这类信息包括 CPU 时间、实际使用时间、时间期限、记账数据、作业或进程数量等。 I/O 状态信息（I/O status information） 这类信息包括分配给进程的 I/O 设备列表、打开文件列表等等。 Linux 操作系统的进程控制块采用 C 语言结构体 task_struct 来表示，它位于内核源码目录内的头文件 &lt;linux/sched.h&gt; 内。 linux/sched.h 内核源码 进程控制 执行模式 大多数处理器至少支持两种执行模式。某些指令只能在特权模式下运行，包括读取或改变诸如程序状态字之类的控制寄存器的指令、原始 I/O 指令和与内存管理相关的指令。另外，部分内存区域仅能在特权模式下访问。 非特权模式通常称为用户模式（User mode），特权模式通常称为内核模式（Kernel mode），后者也常常被称为系统模式（System mode）或者控制模式（Control mode），内核模式指的是操作系统的内核，它是操作系统中包含重要系统功能的部分。 使用两种模式的原因是保护操作系统和重要的操作系统表（如 PCB）不受用户程序的干扰。在内核模式下，软件会完全控制处理器及其所有指令、寄存器和内存。为了安全起见，这种级别的控制对用户程序而言没有必要。 在给出两种模式后，我们就遇到了两个问题： 处理器如何区分当前的进程是以什么模式来运行的？ 我们通常在程序状态字中设定几个指示执行模式的位。 当用户调用一个操作系统服务或中断来触发系统例程的执行时，执行模式被置为内核模式；而当从系统服务返回到用户进程时，执行模式将被置为用户模式。 例如 64 位 IA-64 体系的 Intel Itanium 处理器中，就有一个包含 2 位 CPL（Current Privilege Level）字段的处理器状态寄存器（PSR）。级别 0 表示内核模式，是最高特权级别，其他级别（1 ~ 3）则是用户模式。 模式如何转变？ User \\(\\to\\) Kernel 开启内核模式，并存储当前的用户 PC 指针。 Kernel \\(\\to\\) User 清空内核模式，将 PC 指针指向合适的用户进程。 进程创建 ☁️ 操作系统创建一个新进程时，会按照如下步骤操作： 为新进程创建一个唯一标识符 为进程分配空间 初始化 PCB 设置正确的链接 若操作系统将每个调度队列都维护为一个链表，则新进程必须放在就绪或者 就绪/挂起 链表中。 创建或扩充其他数据结构 例如为每个进程维护一个记账文件。 进程切换 何时切换进程？进程切换可能在操作系统从当前正在运行进程中获得控制权的任何时刻发生。 由于进程切换需要内核模式的权限，所以进程切换的过程中一般都会发生执行模式的改变。 其一般有 3 种原因： 中断（Interrupt） 与当前正运行进程无关的某种外部事件相关，如： 时钟中断（Timer interrupt） 当前进程运行时间已经达到最大允许时间段（Time slice）。若超时，进程就切换到就绪态，并调入另一个进程。 I/O 中断（I/O interrupt） 操作系统确定是否已发生 I/O 活动。若 I/O 活动是一个或多个进程进程正在等待的事件，则操作系统就会把所有处于阻塞态的进程转化为就绪态，此时操作系统必须决定是继续执行当前处于运行态的进程还是让优先级更高的就绪态进程抢占该进程。 陷阱（Trap） 与当前正在运行的进程相关，一般指当前进程出现错误或者异常条件时发生的进程切换。 此时，操作系统会判断该进程的错误或异常条件是否致命，致命时会直接进入退出态，并切换进程；若不致命，操作系统的动作取决于错误的性质和操作系统本身的设计。 Trap 有很多例子，比如常见的 Segmentation fault（段错误）、Divide by zero Exception（除 0 异常）等等。 系统调用（System call） 类似于函数调用，不过在当前进程之外。例如，当用户执行了一个 I/O 操作的指令，如打开一个文件，这时该调用会转移到操作系统代码一部分的一个例程。使用系统调用会将用户进程置为阻塞态。 Linux 常见系统调用的 C 语言接口： fork() ： 创建一个新的子进程，该子进程是当前进程的复制。子进程和父进程将在不同的地址空间中运行，但它们会共享相同的代码和文件描述符。用于创建新进程。 wait() 和 waitpid() ： 用于等待子进程的终止，并获取子进程的终止状态。这些函数通常与 fork() 配合使用，用于处理子进程的退出状态。 exec() 系列函数（如 execve() 、execl() 、execp() 等）： 用于加载并执行新的程序。这些函数会替代当前进程的映像，将其替换为一个新的程序。exec() 函数允许传递参数、环境变量和命令行参数给新程序。 open() 和 close() ： 用于打开和关闭文件。open() 函数用于打开文件，并返回文件描述符，close() 函数用于关闭文件。 read() 和 write() ： 用于从文件描述符读取数据和将数据写入文件描述符。它们是输入和输出的基本系统调用。 进程调度 知道了进程的工作模式，OS 就需要采取合适的策略进行进程调度（Process scheduling）。进程调度有以下目标： 响应时间（Response time）：降低任务的响应时间，以满足实时要求或减少用户感知的等待时间。低延迟对于需要快速响应的应用程序非常重要。 高吞吐量（High Throughput）：确保系统可以同时运行多个任务，并且能够高效地处理大量的工作负载。这对于服务器和数据中心等高负载环境至关重要。保证处理器在一定的时间内可以尽可能处理更多任务。 资源利用率（Resource Utilization）：最大化系统资源的利用率，以确保资源得到有效利用，同时避免浪费。这包括处理器时间、内存、I/O 设备等资源的有效管理。 避免进程饥饿（Process starvation）：不要出现某个进程长时间等待而没有执行。 公平性（Fairness）：确保每个进程都有平等的机会获得处理器时间和其他系统资源。 批处理进程和交互式进程 批处理进程（Batch processes，CPU-intensive） 批处理进程通常用于执行大量相似的、非交互性的任务，这些任务按照一定的顺序依次执行，而不需要用户的交互或实时响应。 对于批处理进程而言，吞吐量（Throughput）最重要。 交互式进程（Interactive processes，I/O-intensive） 交互式进程是需要与用户进行实时交互的进程。它们等待用户的输入并立即做出响应，通常以图形用户界面（GUI）或命令行界面的形式展示给用户。 对于交互式进程而言，响应时间（Response time）最重要。 FCFS 策略 先来先服务（First-Come-First-Served）策略，顾名思义就是让进程按照排队的策略进行调度。 FCFS 策略十分容易实现，只需要维护一个就绪进程的队列结构，让每个新进程入队，将要执行的进程出队即可。 优点： 易于实现； 当所有进程耗时差不多时 FCFS 策略的效果会很好。 缺点： 一些短进程可能需要长时间的等待，可能造成进程饥饿。 SJF 策略 SJF 策略即最短作业优先策略（Shortest-Job-First）策略，在 SJF 策略中，操作系统会选择等待队列中最短的作业（最短的执行时间）来执行，以期望最小化平均等待时间，提高系统的性能。 非抢占性策略和抢占性策略 非抢占性策略（Non-Preemptive Scheduling）： 特点：在非抢占性策略中，一旦一个进程开始执行，它将一直运行，直到完成。其他进程无法强制中断正在执行的进程，除非当前进程主动放弃 CPU（Voluntarily gives up the CPU），例如等待 I/O 操作完成。 优点：非抢占性策略通常比抢占性策略具有较低的上下文切换开销，因为不需要频繁地切换执行的进程。 适用性：这种策略适用于不需要实时性要求的场景，如批处理系统或一些传统的桌面应用程序。它也可以简化并发编程，因为无需处理抢占和竞争条件。 以上讨论的 FCSF、SJF 调度策略都属于非抢占性策略。 抢占性策略（Preemptive Scheduling）： 特点：在抢占性策略中，操作系统可以强制中断当前正在执行的进程，并将 CPU 分配给其他等待的进程。这种策略允许更灵活地管理进程，根据进程的优先级、时间片或其他条件来决定进程的执行。 优点：抢占性策略可以提高系统的响应性，因为操作系统可以在需要时迅速切换到更高优先级的进程，以满足实时性要求或更紧急的任务。 适用性：抢占性策略通常适用于需要实时性、响应性和更精细的调度控制的场景，如操作系统内核、服务器应用、多媒体处理和实时系统。 RR 策略 轮转调度（Round Robin，RR）是一种抢占性的进程调度策略。在 RR 调度中，操作系统将 CPU 时间分成固定大小的时间片（也称为时间量或量子），然后按照先来先服务（FCFS）的顺序将这些时间片分配给就绪队列中的进程。每个进程在一个时间片内运行，然后如果它还没有完成，就被移到队列的末尾等待下一个时间片。 RR 调度比 FCFS 更加公平，特别是对于时间差别较大的进程。 时间片的选择： 选择一个合适长度的时间片对于 RR 策略而言至关重要，太长或者太短都不合适。 太长： 响应性差（Poor responsiveness）。 太短： 过于频繁的上下文切换（Overhead of context switching）可能造成较大的时间开销。 备用队列（Auxiliary queue）： 用于存放那些从 I/O 阻塞状态释放的进程； 相对于那些在就绪队列中的进程而言拥有更高的优先级。 优先级调度策略 优先级调度策略（Scheduling with Priorities）根据进程的优先级来决定下一个执行的进程。具有较高优先级的进程先执行。这可以用于根据进程的重要性和紧迫性来调度。其会给每个进程设定一个优先级（Priority value），调度器总是先选择优先级更高的进程来运行。 优先级可分为静态和动态两种，对于动态优先级而言，OS 可以动态调整进程的优先级。 实现方式：对于不同优先级的进程，使用不同的队列来维护。 如下图，RQ0 级别的队列优先级最高，然后随着编号增加，优先级递减。则每次处理器会先从优先级高的队列选择进程运行。 多级反馈队列 多级反馈队列（Multi-Level Feedback Queue，MLFQ）特别是用于多任务处理系统。MLFQ 结合了多个队列和反馈机制，以实现灵活的进程调度，同时考虑了进程的优先级、等待时间和历史执行表现。 MLFQ 包含多个队列，每个队列具有不同的优先级。通常，系统会维护一个队列数组，其中队列的优先级逐渐降低。高优先级队列中的进程在低优先级队列中的进程之前执行。在每个队列中，通常会使用一种基本的调度策略，如先来先服务（FCFS）或轮转调度（Round Robin）。不同队列可以使用不同的基本调度策略。 反馈机制： MLFQ 使用反馈机制来动态调整进程的优先级。如果一个进程在高优先级队列中等待了一段时间但没有完成，它将被移到较低优先级的队列中，从而允许其他进程有机会获得 CPU 时间。如果进程执行了很长时间（例如 I/O 阻塞），它可能会升级到更高优先级的队列，以防止长时间运行的进程垄断 CPU。 解决饥饿问题： MLFQ 调度中如果频繁有新的进程进入系统，可能导致优先级低的进程频繁被抢占，从而造成进程饥饿问题。 这个问题有很多解决方案，比如对于不同的优先级的队列，我们设置不同的抢占时间。 例如，对于 \\(RQ_i\\) 队列，我们将抢占时间设定为 \\(2 ^ i\\)，从而给低优先级队列的进程更多执行时间。 抢占时间（Preemption time）是指一个进程在被操作系统抢占（即中断并停止执行）之前能够持续执行的时间长度。这个概念在抢占式进程调度策略中非常重要，因为它决定了操作系统何时可以选择停止当前正在执行的进程，以分配 CPU 时间给其他等待的进程。 进程优先级在 Unix/Linux 操作系统的具体体现 —— Niceness 在 Unix 和类 Unix 操作系统中，Niceness（也称为 Nice 值）是一个用于表示进程优先级的概念。Niceness 值通常在 -20 到 19 之间，其中 -20 表示最高优先级，19 表示最低优先级。更负的 Niceness 值表示更高的优先级，而更正的 Niceness 值表示更低的优先级。 我们可以使用 ps 指令打印进程信息，从而看到进程的 Nice 值。 ps aux：显示所有用户的详细进程列表。 ps aux | grep &lt;进程名&gt;：通过管道和grep命令来筛选特定进程。 ps -e：显示所有进程，包括系统进程。 ps -ef：以全格式显示所有进程。 ps -u &lt;用户名&gt; : 查看某个用户的进程。 CFS CFS（Completely Fair Scheduler）是 Linux 操作系统中的一种进程调度算法，用于在多任务环境中公平地分配 CPU 时间给不同的进程。CFS 的目标是实现公平的 CPU 时间分配，确保每个进程在一定时间内获得相同比例的 CPU 时间，而不受其他进程的干扰。 底层实现原理 —— 红黑树。 Ubuntu 实操 其实也不一定得是 Ubuntu，其他类 Unix 系统如 MacOS，本身就可以完成以下实验。 使用 Python 的 os 模块实现部分 System call Python 的 os 模块提供了标准 UNIX 库接口，os 模块提供了不少 POSIX 系统调用，如 fork() ，exec() 系列函数等等。 fork() fork() 函数用于创建一个新进程。fork() 函数不接收任何参数，当 fork() 被调用后，其会复制一份相同的进程，对于两个相同的进程，fork() 函数返回不同的值，对于当前进程，返回子进程的 pid，对于子进程，会返回 0。 示例： 123456789101112import osdef main(): pid = os.fork() if pid == 0: print(&quot;Child process&quot;) else: print(f&quot;Father process, child pid = &#123;pid&#125;&quot;)if __name__ == &#x27;__main__&#x27;: main() 运行结果： 12Father process, child pid = 37012Child process waitpid() os.waitpid() 是 Python 中用于等待子进程结束的函数之一，它允许你在父进程中等待指定的子进程完成执行。这个函数通常与 os.fork() 一起使用，以管理子进程的执行。 1os.waitpid(pid, options) pid ：要等待的子进程的进程 ID（Process ID）； options：控制等待行为的选项标志，有以下取值： os.WNOHANG：如果没有子进程退出，立即返回，不会阻塞。 os.WUNTRACED：如果子进程进入暂停状态（例如，收到了 SIGTSTP 信号），也会返回。 0，表示在子进程结束前，父进程始终是阻塞状态。 os.waitpid() 的返回值是一个包含两个值的元组 (pid, status)，其中： pid 是已经退出的子进程的进程 ID。 status 包含有关子进程退出状态的信息，可以使用 os.WIFEXITED(status)、os.WEXITSTATUS(status)、os.WIFSIGNALED(status)、os.WTERMSIG(status) 等函数来提取这些信息。 示例： 12345678910111213import osdef main(): pid = os.fork() if pid == 0: print(&quot;Child process&quot;) else: os.waitpid(pid, 0) # 等待子进程完成 print(f&quot;Father process, child pid = &#123;pid&#125;&quot;)if __name__ == &#x27;__main__&#x27;: main() 输出： 12Child processFather process, child pid = 37267","categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"进程管理","slug":"进程管理","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"}]},{"title":"Linux Shell 学习笔记","slug":"Linux Shell 学习笔记","date":"2023-09-21T10:02:30.000Z","updated":"2023-10-11T16:53:21.945Z","comments":true,"path":"2023/09/21/Linux Shell 学习笔记/","link":"","permalink":"http://example.com/2023/09/21/Linux%20Shell%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"文件管理 ls 命令 ls 来自英文单词中的 \"list\" 的缩写，用于列出目录中文件以及其属性信息。 1ls [参数] [文件名] 常用参数： 参数 解释 -a 显示所有文件及目录 -A 在 -a 的基础上不显示当前目录和父目录 -d 显示目录本身的属性信息 -i 显示文件的 inode 属性 -l 显示文件的详细属性信息，包括类型、权限等 -m 以逗号为间隔符，水平显示文件信息 -r 依据首字母将文件以相反次序显示 -R 递归显示所有子文件 -S 依据内容大小将文件排序显示 -t 依据最后修改时间将文件排序显示 -X 依据拓展名将文件排序显示 --color 显示信息带有着色效果 不添加任何参数的情况下，ls 命令会列出当前工作目录的文件信息。 cp 命令 cp 命令来自英文单词中 \"copy\" 的缩写，用于复制文件或目录。 1cp [参数] 源文件名 目标文件名/复制目录 常用参数： 参数 解释 -b 覆盖目标文件前先进行备份 -d 复制链接文件时，将目标文件也建立成链接文件 -f 若目标文件已存在，则会直接覆盖 -i 若目标文件已存在，则会询问是否覆盖 -l 对源文件建立硬链接，而非复制文件 -p 保留源文件或者目录的所有基本属性 -r 递归复制所有子文件 -s 对源文件建立软链接，而非复制文件 -a 功能等同于 -d -p -r -v 显示执行过程详细信息 示例： 在同一目录下复制 demo.txt 的副本： 1cp demo.txt demo_copy.txt 将 demo.txt 复制到 ./demo_dict 目录，如果目标文件存在则覆盖： 1cp -f demo.txt ./demo_dict 建立 dmeo.txt 的软链接： 1cp -s demo.txt demo_soft_link mkdir 命令 mkdir 命令来自于英文 \"Make directories\" 的缩写，用于创建目录文件。 1mkdir [参数] 目录名 常用参数： 参数 解释 -m 创建目录的同时设置权限 -p 递归创建多级目录 -v 显示执行过程详细信息 -z 设置目录安全上下文 示例： 创建一个权限为 740 的文件： 1mkdir -m 740 dir_test 123ls -ld dir_test# 输出结果：drwxr-----@ 2 username staff 64 9 29 23:20 dir_test 一次创建多个嵌套关系的目录： 1mkdir -p dir1/dir2/dir3 mv 指令 mv 指令，来自于英文单词中的 \"move\"，用于移动或者更改文件名。 1mv [参数] 源文件名 目标文件名 常用参数： 参数 解释 -b 覆盖前为目标文件创建备份 -f 若文件已存在，强制覆盖目标文件 -i 若文件已存在，则询问用户是否覆盖 -n 不要覆盖已有文件 -u 当源文件比目标文件更新时，才执行覆盖操作 -v 显示执行过程详细信息 -Z 设置文件安全上下文 示例： 将 demo.txt 改名为 demo2.txt ： 1mv demo.txt demo2.txt 将 dir1 移动到 dir2 ： 1mv dir1 ./dir2 在 (1) 的基础上将 dir1 重命名为 dir0 1mv dir1 ./dir2/dir0 pwd 指令 pwd 指令来自于英文中的 \"Print working directory\" 的缩写，用于显示当前工作目录的路径。 1pwd [参数] 常用参数： 参数 解释 -L 显示逻辑路径（默认） -P 显示实际物理地址 tar 指令 tar 指令用于压缩和解压文件，能解压或压缩 Linux 系统中常见的 .tar 、.tar.gz 、tar.bz2 等格式的压缩包文件。 1tar 参数 压缩包名 [文件或目录名] 常用参数： 参数 说明 -A 添加文件到已存在压缩包 -B 设置区块大小 -c 创建新的压缩包 -C 解压缩到指定目录 -d 记录文件的差别 -f 指定压缩包文件 -j 使用 bzip2 压缩格式 -l 设置文件系统边界 -m 保护文件不被覆盖 -N 只将较新日期的文件保存到压缩包中 -p 保留原来的文件权限和属性 -t 显示压缩包的内容 -u 更新压缩包内的文件 -v 显示执行过程详细信息 -w 确认压缩包的完整性 -x 从压缩包内提取文件 -z 使用 gzip 压缩格式 --exclude 排除指定的文件不压缩 --remove-files 操作完后删除源文件 示例： 使用 gzip 压缩格式将 demo 目录打包，压缩包后缀指定为 .tar ： 1tar -czvf demo.tar ./demo 将 demo.tar 解压到当前工作目录： 1tar -xvf demo.tar 查看压缩包 demo.tar 内到文件信息： 1tar -tvf demo.tar 文档编辑 cat 命令 cat 命令来自于英文中 \"concatenate files and print\" 的缩写，用于在终端设备上显示文件内容。 1cat [参数] 文件名 常用参数： 参数 解释 -b 显示行数 -E 每行结束时以 $ 结尾 -n 显示行数，空行也编号 -s 显示行数，多个空行算一个编号 echo 命令 echo 在英文中译为回声，用于在终端输出字符串或提取后的变量值。 1echo [参数] 字符串或$&#123;变量名&#125; 常用参数： 参数 解释 -E 禁止转义字符 -e 启动转义字符的解释 -n 不输出结尾的换行符 示例： 打印两行话到终端： 1echo -e &quot;Hello\\nWorld!&quot; 打印环境变量 PATH ： 1echo $&#123;PATH&#125; 显示当前系统的运行时间和当前系统负载的信息： 1echo $(uptime) rm 命令 rm 命令来自英文单词 \"remove\" 的缩写，用来删除文件或目录。 1rm [参数] 文件名 常用参数： 参数 解释 -d 删除无子文件的空目录 -f 强制删除文件不询问 -i 删除文件前询问用户是否删除 -r 递归删除目录及其全部子文件 -v 显示执行过程详细信息 示例： 强制删除当前工作目录下所有 .txt 后缀的文件： 1rm -f *.txt 强制删除目录 dir 以及其所有子文件： 1rm -rf dir grep 命令 grep 命令来自英文 \"Global search regular expression and print out the line\" 的缩写，是一个强大的文本搜索工具。 1grep [参数] 文件名 常用参数： 参数 解释 -b 显示匹配行距文件头部的偏移量 -c 只显示匹配的行数 -E 支持拓展正则表达式 -F 匹配固定字符串的内容 -h 搜索多文件时不显示文件名 -i 忽略关键词大小写 -l 只显示符合匹配条件的文件名 -n 显示所有匹配行及其行号 -o 显示匹配词距文件头部的偏移量 -q 静默执行模式 -r 递归搜索模式 -s 不显示没有匹配文本的错误信息 -v 显示不包括匹配文本的所有行 -w 精准匹配整词 -x 精准匹配整行 示例： 查找文件 OS.md 中所有包含 process 的行，并且显示其行号： 1grep -n process OS.md 搜索当前工作目录中包含关键词 Java 的文件： 1grep -lrs Java * tail 命令 顾名思义，tail 命令用于查看文件尾部内容。 1tail [参数] 文件名 常用参数： 参数 解释 -c 设置显示文件尾部的字符数 -f 持续显示文件尾部的最新内容 -n 设置显示文件尾部的行数 示例： 显示 demo.txt 最后 15 行： 1tail -n 15 demo.txt 显示 demo.txt 最后 20 个字符： 1tail -c 20 demo.txt rmdir 命令 rmdir 命令来自于英文中的 \"Remove directory\" 的缩写，用于删除空目录文件。 1rmdir [参数] 目录名 常用参数： 参数 解释 -p 递归处理所有子文件 -v 显示执行过程详细信息 系统管理 find 命令 find 命令的功能是用于根据给定的路径和条件查找相关文件或目录，参数灵活方便，且支持正则表达式。 1find [路径] [条件] 文件名 常用参数： 参数 解释 -name 匹配文件名 -perm 匹配文件权限 -user 匹配文件所属主 -group 匹配文件所属组 -mtime 匹配最后修改文件内容的时间 -atime 匹配最后读取文件内容的时间 -ctime 匹配最后修改文件属性的时间 -type 匹配文件类型 -size 匹配文件大小 -exec ... &#123;&#125; \\ 进一步执行语句 示例： 查找当前目录下所有 zip 压缩包： 1find ./ -name *.zip 查找当前目录下 demo_dir 文件夹下所有大于 1M 的文件： 1find ./demo_dir -size +1M 查找工作目录最近 3 天被修改过的文件并且打印其长格式： 1find ./ -mtime +3 -exec ls -l &#123;&#125; \\; ps 命令 ps 命令是 \"process\" 的缩写，用于显示进程信息。 1ps [参数] 常用参数： 参数 解释 -a 显示当前终端会话的所有进程 -x 显示没有控制终端的进程 -e 显示系统所有进程 aux 也是显示系统所有进程，但输出格式更加详细 -u 显示某个用户的进程 -p 显示特定 PID 的进程 -o 自定义输出进程格式 -t 显示在特定终端运行的进程 -H 显示进程的层次结构，包括父进程和子进程 示例： 显示系统所有进程，展示其 PID 和控制终端： 1ps -eo pid,tty 显示 PID 为 100 的进程信息： 1ps -p 100 uname 命令 uname 命令来自英文中的 \"Unix name\"，用于查看系统主机名、内核及硬件架构等信息。 1uname [参数] 常用参数： 参数 说明 -s 显示内核名称（默认） -a 显示系统所有相关信息 -i 显示硬件平台 -m 显示计算机硬件架构 -n 显示主机名称 -o 显示操作系统名称 -p 显示主机处理器类型 -r 显示内核发行版本号 -v 显示内核版本","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"}]},{"title":"表达式树","slug":"表达式树","date":"2023-09-18T01:23:12.000Z","updated":"2023-09-20T07:59:16.656Z","comments":true,"path":"2023/09/18/表达式树/","link":"","permalink":"http://example.com/2023/09/18/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/","excerpt":"","text":"三种表达式 在计算机做数值运算时，我们有三种常见的表达式，分别是中缀表达式、前缀表达式、后缀表达式。 中缀表达式 中缀表达式是我们通常在数学中使用的表达式表示方法，操作符位于两个操作数之间。例如，加法操作 3 + 4 通常表示为 \"3 + 4\"。中缀表达式具有运算符优先级规则，需要考虑括号来明确运算顺序。中缀表达式可以通过算法（如递归解析或运算符优先级解析器）转换为其他表达式形式，如前缀或后缀表达式。 示例： \\[ (a + b) \\times c \\] 前缀表达式 前缀表达式，也被称为波兰记法（Polish Notation）。在前缀表达式中，运算符位于操作数之前，例如，加法操作 3 + 4 可以表示为\"+ 3 4\"。前缀表达式没有优先级问题，因为每个运算符都在其操作数之前，而计算前缀表达式通常需要使用栈数据结构来执行。 示例： \\[ \\times +\\ a\\ b\\ c \\] 后缀表达式 后缀表达式，也被称为逆波兰记法（Reverse Polish Notation，RPN）。在后缀表达式中，运算符位于操作数之后，例如，加法操作 3 + 4 可以表示为\"3 4 +\"。后缀表达式也不涉及运算符优先级，因此计算顺序是十分明确的，计算后缀表达式通常使用栈数据结构来执行。 示例： \\[ a\\ b\\ + c\\ \\times \\] 表达式树 以上三种表达式都可以相互转化并且使用特定的方法求值，我们在此不做赘述，那么我们是否可以将三种表达式统一为某种适合计算机运算的数据结构呢？我们在此引入表达式树（Expression Tree）。 表达式树是一种数据结构，用于表示数学表达式的层次结构，其中每个节点表示操作数或运算符，而边表示它们之间的关系。表达式树可以用来表示前缀、中缀或后缀表达式，并提供了一种有效的方式来表示和计算复杂的数学表达式。 以 \\((a + b) \\times c\\) 为例，我们可以构造如下表达式树： 不难发现，表达式树有如下性质： 叶节点只能是操作数，非叶节点只能是运算符； 表达式树的非叶节点的度数只能是 2。 表达式 \\(\\to\\) 表达式树 在这里我们以后缀表达式为例，展示一下表达式树的构建过程。 事实上，我们只需要创建一个栈，然后从左至右遍历表达式并重复以下步骤即可： 如果遇到操作数，创建操作数节点，并压入栈内； 如果遇到运算符，创建运算符节点，从栈内弹出两个元素分别做运算符节点的右节点和左节点； ... 如此重复，最后栈内会剩下唯一的节点，该节点就是表达式树的根节点。 代码实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;stack&gt;namespace __expression_tree &#123; enum node_type &#123; // 节点类型 OPEROTOR, NUMBER &#125;; struct ExpTreeNode &#123; node_type type; union &#123; char op; int val; &#125;; ExpTreeNode* left; ExpTreeNode* right; ExpTreeNode(node_type _type, int _val, ExpTreeNode* l = nullptr, ExpTreeNode* r = nullptr): type(_type), left(l), right(r) &#123; if (type == OPEROTOR) &#123; op = _val; &#125; else &#123; val = _val; &#125; &#125; &#125;; ExpTreeNode* suffix2tree(std::vector&lt;std::string&gt;&amp; ex) &#123; // 后缀表达式转化为表达式树 std::stack&lt;ExpTreeNode*&gt; st; for (const auto&amp; ele : ex) &#123; ExpTreeNode* rt = nullptr; if (ele == &quot;+&quot; || ele == &quot;-&quot; || ele == &quot;*&quot; || ele == &quot;/&quot;) &#123; ExpTreeNode* r = st.top(); st.pop(); ExpTreeNode* l = st.top(); st.pop(); rt = new ExpTreeNode(OPEROTOR, ele[0], l, r); &#125; else &#123; rt = new ExpTreeNode(NUMBER, stoi(ele)); &#125; st.push(rt); &#125; return st.top(); &#125; int compute(ExpTreeNode* root) &#123; // 计算以 root 为根节点的表达式树的值 if (root-&gt;type == NUMBER) return root-&gt;val; int l_val = compute(root-&gt;left), r_val = compute(root-&gt;right); switch (root-&gt;op) &#123; case &#x27;+&#x27;: return l_val + r_val; case &#x27;-&#x27;: return l_val - r_val; case &#x27;*&#x27;: return l_val * r_val; case &#x27;/&#x27;: return l_val / r_val; &#125; exit(1); // error &#125;&#125;using namespace __expression_tree;int main() &#123; std::vector&lt;std::string&gt; ex&#123;&quot;9&quot;, &quot;8&quot;, &quot;+&quot;, &quot;2&quot;, &quot;*&quot;, &quot;8&quot;, &quot;4&quot;, &quot;/&quot;, &quot;-&quot;&#125;; ExpTreeNode* rt = suffix2tree(ex); std::cout &lt;&lt; compute(rt) &lt;&lt; &#x27;\\n&#x27;; // (9 + 8) * 2 - 8 / 4 == 32 return 0;&#125; 如果是前缀表达式，则只需从右往左遍历表达式，然后采取相同的步骤即可（左右子树的顺序上会有差异）。 如果是中缀表达式，可以考虑使用递归构造表达式树，也可以先将前缀表达式转化为后缀表达式，然后再转化为表达式树。 表达式树 \\(\\to\\) 表达式 事实上，中缀表达式、前缀表达式、后缀表达式，本质上就是表达式树的中序遍历、前序遍历与后续遍历。 代码实现： 123456789101112131415161718192021222324std::string tree2prefix(ExpTreeNode* root) &#123; // 表达式树 -&gt; 前缀表达式 if (root-&gt;type == NUMBER) return std::to_string(root-&gt;val); return std::string(1, root-&gt;op) + &quot; &quot; + tree2prefix(root-&gt;left) + &quot; &quot; + tree2prefix(root-&gt;right);&#125;std::string tree2infix(ExpTreeNode* root, char pre_op = 0) &#123; // 表达式树 -&gt; 中缀表达式 if (root-&gt;type == NUMBER) return std::to_string(root-&gt;val); if ((root-&gt;op == &#x27;+&#x27; || root-&gt;op == &#x27;-&#x27;) &amp;&amp; (pre_op == &#x27;*&#x27; || pre_op == &#x27;/&#x27;)) &#123; return &quot;(&quot; + tree2infix(root-&gt;left, root-&gt;op) + &quot; &quot; + std::string(1, root-&gt;op) + &quot; &quot; + tree2infix(root-&gt;right, root-&gt;op) + &quot;)&quot;; &#125; return tree2infix(root-&gt;left, root-&gt;op) + &quot; &quot; + std::string(1, root-&gt;op) + &quot; &quot; + tree2infix(root-&gt;right, root-&gt;op);&#125;std::string tree2sufix(ExpTreeNode* root) &#123; // 表达式树 -&gt; 后缀表达式 if (root-&gt;type == NUMBER) return std::to_string(root-&gt;val); return tree2sufix(root-&gt;left) + &quot; &quot; + tree2sufix(root-&gt;right) + &quot; &quot; + std::string(1, root-&gt;op);&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"表达式树","slug":"表达式树","permalink":"http://example.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"},{"name":"波兰记法","slug":"波兰记法","permalink":"http://example.com/tags/%E6%B3%A2%E5%85%B0%E8%AE%B0%E6%B3%95/"},{"name":"逆波兰记法","slug":"逆波兰记法","permalink":"http://example.com/tags/%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%B0%E6%B3%95/"}]},{"title":"Pandas 库学习笔记","slug":"Pandas 库学习笔记","date":"2023-09-07T16:19:56.000Z","updated":"2023-09-10T16:26:38.339Z","comments":true,"path":"2023/09/08/Pandas 库学习笔记/","link":"","permalink":"http://example.com/2023/09/08/Pandas%20%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"简介 pandas 是一个用于数据分析和处理的强大 Python 库。它提供了高性能、易于使用的数据结构和数据分析工具，使数据科学家、分析师和工程师能够更轻松地进行数据处理和探索性数据分析。以下是一些 pandas 库的主要特点和功能： 数据结构： Series：类似于一维数组的数据结构，是构建 DataFrame 的基本组成部分。 DataFrame：pandas 最重要的数据结构之一，它类似于表格或电子表格，可以包含多种数据类型的列。DataFrame 是处理和分析数据的主要工具，支持标签和位置索引。 数据导入和导出： 支持从多种数据源导入数据，包括 Excel、CSV、SQL 数据库、JSON 等。 可以将数据导出为各种格式的文件。 数据清洗和处理： 支持缺失数据的处理，包括填充、删除等。 提供强大的数据过滤、排序、切片和选择功能。 可以进行数据合并和连接，以及数据的重塑和透视操作。 数据分析和探索： 支持基本统计分析，如均值、中位数、标准差等。 提供强大的分组和聚合功能，可以进行分组统计。 可以进行时间序列数据分析和处理。 数据可视化： pandas 可以与其他数据可视化库（如 Matplotlib 和 Seaborn ）集成，用于创建各种图表和图形。 高性能： pandas 经过优化，可以处理大规模数据集，提供快速的数据操作和计算。 多级索引： 允许在 DataFrame 中创建多级索引，使数据的层次化表示更容易。 时间序列分析： pandas 具有强大的时间序列功能，支持日期和时间的操作、分组和重采样。 互动式数据分析： 在 Jupyter Notebook 等互动式环境中，pandas 非常适合用于数据探索和分析。 开源和社区支持： pandas 是一个开源项目，拥有庞大的社区支持，有大量文档、教程和示例可供学习和参考。 pandas 是数据科学工作流程中不可或缺的工具之一，可以帮助你加载、处理、分析和可视化数据，从而更好地理解数据并做出决策。无论是进行数据探索性分析、数据清洗、数据预处理还是建模，pandas 都是一个强大而灵活的工具。 重要数据结构 Series Series 类似于一维数组，但可以自定义索引，这方面又有些像 Python 中的字典。 示例： 12arr = pd.Series([1, 2, 3], index = [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;])# 或者 arr = pd.Series(&#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;) 如果不定义 index ，就是默认的数组索引（0 ～ 数组长度 - 1） pandas 具有强大的数据对齐功能，具体体现在两个数据结构在相加时，可以将相同键值对应的值进行相加，Eg： 1234s1 = pd.Series(&#123;&#x27;高等数学&#x27;: 98, &#x27;大学物理&#x27;: 90, &#x27;C++&#x27;: 100&#125;)s2 = pd.Series(&#123;&#x27;高等数学&#x27;: 100, &#x27;大学物理&#x27;: 93, &#x27;C++&#x27;: 91&#125;)print((s1 + s2) / 2) 输出结果： 1234高等数学 99.0大学物理 91.5C++ 95.5dtype: float64 但是，如果两组数据中出现不同的标签，对于标签不相同的数据，运算后结果是 NaN ，此时可以使用 Pandas 自己提供的 add() 方法。 12print(s1.add(s2, fill_value = 0))# fill_value 表示缺省情况的默认值 除 add() 方法对应加法外，数学中的减、乘、除在 pandas 中也有对应的方法，分别是 sub()、mul() 和 div() 。 DataFrame DataFrame 是一个表格，有行和列两个维度，其中每一行或者每一列都是一个 Series 。 示例： 123456789101112import pandas as pdpd.set_option(&#x27;display.unicode.ambiguous_as_wide&#x27;, True)pd.set_option(&#x27;display.unicode.east_asian_width&#x27;, True)# 将中文对齐def main(): s = pd.DataFrame(&#123;&#x27;高等数学&#x27;: [100, 98], &#x27;大学物理&#x27;: [90, 93], &#x27;C++&#x27;: [100, 91]&#125;) print(s)if __name__ == &#x27;__main__&#x27;: main() 输出结果： 123 高等数学 大学物理 C++0 100 90 1001 98 93 91 一般来说一个 DataFrame 对象通过一个字典和 index 参数来设置： 123dat = &#123;&#x27;高等数学&#x27;: [100, 98], &#x27;大学物理&#x27;: [90, 93], &#x27;C++&#x27;: [100, 91]&#125;s = pd.DataFrame(data = dat, index = [&#x27;Carl&#x27;, &#x27;Tony&#x27;])print(s) 输出结果： 123 高等数学 大学物理 C++Carl 100 90 100Tony 98 93 91 导入、导出表格文件 很多情况下，我们需要读取表格文件，Pandas 提供了多种函数来读取和输出表格文件。 导入 导出 .csv 表格 read_csv(file_path) to_csv(file_path, index) Excel 文件 read_excel(file_path) to_excel(file_path, index) index 的值表示是否将最左侧的索引保存到文件中。 忽略无关数据 在读取表格的时候，有些行是无关紧要的，我们可以通过相关参数进行控制，比如我们忽略某个表格前 40 行，且只读取 40 行，可以考虑添加 skiprows 参数和 nrows 参数： 12# 读取 Excel 文件，跳过前 40 行，并且只读取接下来 40 行df = pd.read_excel(&#x27;data.xlsx&#x27;, skiprows = range(40), nrows = 40) 成功读取表格后，我们就可以进行对应的操作了。 假设我们成功读取工作目录下的表格 scores.csv ： 12345678910import pandas as pdpd.set_option(&#x27;display.unicode.ambiguous_as_wide&#x27;, True)pd.set_option(&#x27;display.unicode.east_asian_width&#x27;, True)def main(): sc = pd.read_csv(&#x27;./scores.csv&#x27;)if __name__ == &#x27;__main__&#x27;: main() 列操作 查看列 例如，我需要查看每个人的高数成绩： 1print(sc[&#x27;高等数学&#x27;]) 输出结果： 12340 1001 922 94Name: 高等数学, dtype: int64 修改列 直接采用赋值修改即可： 1sc[&#x27;大学物理&#x27;] = [96, 94, 99] 此时，三个人的大物成绩就分别修改成了 96、94、99。 新增列 比如现在我需要新增「数据结构」这门课，可以考虑以下方式： 12sc[&#x27;数据结构&#x27;] = [100, 90, 90]print(sc) 输出结果： 1234 姓名 高等数学 大学物理 C++ 数据结构0 Carl 100 93 91 1001 Jack 92 94 93 902 Jennie 94 98 89 90 删除列 删除列考虑使用 drop() 方法： 1sc.drop(&#x27;大学物理&#x27;, axis = 1, inplace = True) 这样，我们就成功删除了「大学物理」这一列，参数 axis 表示行或列，行为 0，列为 1，默认值为 0，inplace 参数表示删除后是否替换原表格还是只返回删除后的表格，默认值为 False 。 行操作 行是通过最左边的索引来获取的，再不指定的情况下，索引值默认从 0 开始依次递增，可以使用 loc 基于索引进行表格行的操作。 查看行 1print(sc.loc[0]) # 查看第一行学生的成绩 如果指定了表格的索引列，则通过相应的索引来查找行： 12sc = pd.read_csv(&#x27;./scores.csv&#x27;, index_col = &#x27;姓名&#x27;)print(sc.loc[&#x27;Carl&#x27;]) 运行结果： 12345性别 M高等数学 100大学物理 93C++ 91Name: Carl, dtype: object 除了第一个参数外，还支持第二个参数列名，同时基于行和列获取指定数据： 1print(sc.loc[&#x27;Carl&#x27;, &#x27;高等数学&#x27;]) # 100 注：loc 方法也支持切片和传入条件判断，但对于切片 l : r 而言左右都是闭区间。 修改行、新增行、删除行和列操作是类似的，故此处不加以赘述。 排序 考虑使用 sort_values() 方法，第一个参数表示排序所依靠的键值。在如下示例中，我们按照高等数学的成绩降序排列学生： 12sc.sort_values(&#x27;高等数学&#x27;, ascending = False, inplace = True)print(sc) 输出结果： 1234 姓名 高等数学 大学物理 C++0 Carl 100 93 912 Jennie 94 98 891 Jack 92 94 93 分组 分组是个很有用的功能，熟悉 SQL 语句的同学应该不会陌生，在 Pandas 库中的分组功能也是差不多的。例如，接下来我们需要统计以下表格中男女生高等数学和 C++ 的平均分： 1print(sc.groupby(&#x27;性别&#x27;)[[&#x27;高等数学&#x27;, &#x27;C++&#x27;]].mean()) 输出结果： 1234 高等数学 C++性别 F 94.0 89.0M 96.0 92.0 类似的和分组功能一同使用的函数还有：max() 、min() 、sum() 等。 筛选数据 与 Numpy 一样，可以传入筛选条件来返回所有符合条件的数据，例如查找所有 C++ 分数不少于 90 的同学： 1print(sc[sc[&#x27;C++&#x27;] &gt;= 90][&#x27;姓名&#x27;]) 输出结果： 1230 Carl1 JackName: 姓名, dtype: object 注：索引中条件的分隔符如下： 或：| 且：&amp; 数据标签 Pandas 提供了 cut() 方法用于给数据添加标签并分类。 例如： 1csc = pd.cut(sc[&#x27;高等数学&#x27;], bins = [0, 59, 79, 89, 100], labels = [&#x27;不及格&#x27;, &#x27;及格&#x27;, &#x27;良好&#x27;, &#x27;优秀&#x27;]) 第一个参数表示需要分类的键，第二个表示分类区间，默认为左开右闭，第三个参数表示每个区间对应的标签。 表格合并 纵向合并 1df = pd.concat([df_1, df_2, df_3]) 横向合并 1df = pd.merge(df_1, df_2)","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"},{"name":"数据科学","slug":"数据科学","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"}]},{"title":"Z 函数","slug":"Z 函数","date":"2023-09-07T11:44:46.000Z","updated":"2023-09-09T13:36:47.750Z","comments":true,"path":"2023/09/07/Z 函数/","link":"","permalink":"http://example.com/2023/09/07/Z%20%E5%87%BD%E6%95%B0/","excerpt":"","text":"介绍 Z 函数是字符串算法中的一个重要函数，对于一个字符串 \\(s\\) 而言，\\(z[i]\\) 描述了以 \\(s[i]\\) 开始的后缀与 \\(s\\) 的最长公共前缀。 在此约定 \\(z[0] = 0\\) 。 示例：对于字符串 aabaabc 而言，其 Z 函数为：\\(\\{ 0, 1, 0, 3, 1, 0, 0 \\}\\) 。 Z 函数有很多应用，比如字符串匹配等，等会我们会一一介绍。 线性时间复杂度计算 Z 函数 假设要计算 \\(s\\) 的 Z 函数，考虑对于任意 \\(i \\in [0, |s| - 1]\\) ，都计算后缀 \\(s[i :]\\) 和 \\(s\\) 的最长公共前缀，则时间复杂度为 \\(O(|s| ^ 2)\\) 。 所以在这里我们给出一种线性计算 Z 函数的方法： 我们在这里使用两个变量：\\(l\\) 和 \\(r\\) ，初始化均为 0，\\(r\\) 维护当前已经计算过的最大的 \\(i + z[i] - 1\\) ，即目前计算的过的 \\(s[i :]\\) 公共前缀最长延续的下标，\\(l\\) 则表示取最大值时 \\(i\\) 的索引，即 \\(r = l + z[l] - 1\\) 。 接下来从 1 开始便利字符串下标 \\(i\\) 即可： 若 \\(i \\leq r\\) ： 根据定义有 \\(s[i : r] = s[i - l : r - l]\\) ，因此： 若 \\(z[i - l] &lt; r - i + 1\\) ，则 \\(z[i] = z[i - l]\\) ； 若 \\(z[i - l] \\geq r - i + 1\\) ，则 \\(z[i] = r - i + 1\\) ，然后按照 Z 函数的定义继续扩展。 若 \\(i &gt; r\\) ： 我们只需令 \\(z[i] = 0\\) ，然后按照 Z 函数的定义继续拓展即可。 每一轮循环结束后对 \\(l\\) 和 \\(r\\) 进行更新。 代码实现： 12345678910111213141516171819std::vector&lt;int&gt; z_function(const std::string&amp; pat) &#123; int n = pat.size(); std::vector&lt;int&gt; z(n); for (int i = 1, l = 0, r = 0; i &lt; n; i++) &#123; if (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + 1) &#123; z[i] = z[i - l]; &#125; else &#123; z[i] = std::max(0, r - i + 1); while (i + z[i] &lt; n &amp;&amp; pat[z[i]] == pat[i + z[i]]) z[i]++; &#125; if (i + z[i] - 1 &gt; r) &#123; l = i; r = i + z[i] - 1; &#125; &#125; return z;&#125; 注意到，内层 while 循环每一轮都会使得 r 加 1，而外层循环只有一次遍历，因此时间复杂度为 \\(O(n)\\) 。 Z 函数的应用 线性时间复杂度匹配子串 众所周知，KMP 算法可以实现线性时间复杂度内查找字符串 \\(s\\) 中是否存在子串 \\(p\\) ，使用 Z 函数则可以更为简洁地实现同样的效果： 我们构造一个新字符串 \\(sp = p + \\Delta + s\\) ，\\(\\Delta\\) 表示一个分割字符，其不在 \\(p\\) 和 \\(s\\) 中出现，接下来计算 \\(sp\\) 的 Z 函数，若 \\(sp\\) 的 Z 函数存在某个值等于 \\(|p|\\) ，则说明 \\(p\\) 是 \\(s\\) 的子串，反之则说明不是。 示例代码（ haystack 为文本串，needle 为模式串）： 时间复杂度：\\(O(|s| + |p|)\\) 123456789101112131415161718192021222324class Solution &#123;public: int strStr(std::string&amp; haystack, std::string&amp; needle) &#123; std::string str = needle + &#x27;&amp;&#x27; + haystack; int n = str.size(), p = needle.size(); std::vector&lt;int&gt; z(n); for (int i = 1, l = 0, r = 0; i &lt; n; i++) &#123; if (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + 1) &#123; z[i] = z[i - l]; &#125; else &#123; z[i] = std::max(0, r - i + 1); while (i + z[i] &lt; n &amp;&amp; str[z[i]] == str[i + z[i]]) z[i]++; &#125; if (z[i] == p) return i - p - 1; if (i + z[i] - 1 &gt; r) &#123; l = i; r = i + z[i] - 1; &#125; &#125; return -1; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"杜教筛与莫比乌斯反演","slug":"杜教筛与莫比乌斯反演","date":"2023-08-30T12:20:09.000Z","updated":"2023-09-10T07:06:45.333Z","comments":true,"path":"2023/08/30/杜教筛与莫比乌斯反演/","link":"","permalink":"http://example.com/2023/08/30/%E6%9D%9C%E6%95%99%E7%AD%9B%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/","excerpt":"","text":"此篇文章是笔者参考 OI-wiki 写的一份简单的学习笔记。 杜教筛 简介 杜教筛，是一种用于快速求形如 \\(\\sum_{i = 1} ^ n f(i)\\) 这样前缀和形式的算法，最高效时可以达到 \\(O(n ^ {\\frac{2}{3}})\\) 的时间复杂度。 算法思想 对于 \\(S(n) = \\sum_{i = 1} ^ n f(i)\\) 想办法构造一个 \\(S(n)\\) 关于 \\(S([\\frac{n}{k}])\\) 的递推式。 考虑一个辅助函数 \\(g(i)\\) ，考虑 \\(f\\) 和 \\(g\\) 的狄利克雷卷积之和： \\[ \\sum_{i = 1} ^ n (f * g)(i) = \\sum_{i = 1} ^ n \\sum_{d | i} g(d)f(\\frac{i}{d}) \\\\ = \\sum_{d = 1} ^ n g(d) \\sum_{d | i} f(\\frac{i}{d}) \\\\ = \\sum_{d = 1} ^ n g(d) \\sum_{k = 1} ^ {[\\frac{n}{d}]} f(k) \\\\ = \\sum_{d = 1} ^ n g(d) S([\\frac{n}{d}]) \\] \\[ \\implies g(1)S(n) = \\sum_{i = 1} ^ n (f * g)(i) - \\sum_{d = 2} ^ n g(d) S([\\frac{n}{d}]) \\] 若 \\(\\sum_{i = 1} ^ n (f * g)(i)\\) 可以在 \\(O(1)\\) 之内算出，且 \\(\\sum_{d = 2} ^ n g(d) S([\\frac{n}{d}])\\) 可以分块计算，则总时间复杂度为：\\(O(n ^ {\\frac{3}{4}})\\) 如果线性预处理 \\(S(1)\\) 到 \\(S([n ^ {\\frac{2}{3}}])\\) 的值，则时间复杂度为：\\(O(n ^ {\\frac{2}{3}})\\) 。 模板题，求莫比乌斯函数和欧拉函数的前缀和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;unordered_map&gt;namespace Solution &#123; using i64 = long long; const int MAX_N = 2000000; std::vector&lt;int&gt; mu(MAX_N + 1); std::vector&lt;i64&gt; phi(MAX_N + 1); void init() &#123; // 预处理 std::vector&lt;int&gt; pri; std::vector&lt;bool&gt; notPrime(MAX_N + 1, false); mu[1] = phi[1] = 1; for (int i = 2; i &lt;= MAX_N; i++) &#123; if (!notPrime[i]) &#123; pri.push_back(i); mu[i] = -1; phi[i] = i - 1; &#125; for (int p : pri) &#123; if (i * p &gt; MAX_N) break; notPrime[i * p] = true; if (i % p == 0) &#123; mu[i * p] = 0; phi[i * p] = phi[i] * p; break; &#125; mu[i * p] = -mu[i]; phi[i * p] = phi[i] * (p - 1); &#125; &#125; for (int i = 2; i &lt;= MAX_N; i++) &#123; mu[i] += mu[i - 1]; phi[i] += phi[i - 1]; &#125; &#125; std::unordered_map&lt;int, int&gt; mob_res; int mobius_sum(int n) &#123; if (mob_res.find(n) != mob_res.end()) return mob_res[n]; if (n &lt;= MAX_N) return mu[n]; i64 res = 1; i64 left = 2, right; while (left &lt;= n) &#123; right = n / (n / left); res -= (right - left + 1) * mobius_sum(n / left); left = right + 1; &#125; return mob_res[n] = res; &#125; std::unordered_map&lt;int, i64&gt; phi_res; i64 phi_sum(i64 n) &#123; if (phi_res.find(n) != phi_res.end()) return phi_res[n]; if (n &lt;= MAX_N) return phi[n]; i64 res = (i64)n * (n + 1) / 2; i64 left = 2, right; while (left &lt;= n) &#123; right = n / (n / left); res -= (right - left + 1) * phi_sum(n / left); left = right + 1; &#125; return phi_res[n] = res; &#125; void solve() &#123; int n; std::cin &gt;&gt; n; std::cout &lt;&lt; phi_sum(n) &lt;&lt; &#x27; &#x27; &lt;&lt; mobius_sum(n) &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); Solution::init(); int numTest; std::cin &gt;&gt; numTest; while (numTest--) Solution::solve(); return 0;&#125; 莫比乌斯反演 莫比乌斯函数 \\[ \\begin{equation} \\mu(n) = \\begin{cases} 1 &amp; n = 1 \\\\ 0 &amp; n \\ 存在平方因子 \\\\ (-1) ^ k &amp; n = \\prod_{i = 1} ^ k p_i \\end{cases} \\end{equation} \\] 莫比乌斯函数常用性质 \\(\\mu\\) 函数为积性函数，若 \\(gcd(x, y) = 1\\) ，则有 \\(\\mu (xy) = \\mu (x) \\mu( y)\\) \\(\\sum_{d | n} \\mu(d) = \\epsilon (n) = [n = 1]\\) 因为莫比乌斯函数是积性函数，所以可以用线性筛筛选： 12345678910111213141516171819202122int mu[MAX_N];int pri[MAX_N];int tot = 0;bool notPrime[MAX_N];void getMU(int n) &#123; mu[1] = 1; for (int i = 2; i &lt;= n; i++) &#123; if (!notPrime[i]) &#123; pri[tot++] = i; mu[i] = -1; &#125; for (int j = 0; j &lt; tot &amp;&amp; i * pri[j] &lt;= n; j++) &#123; notPrime[i * pri[j]] = true; if (i % pri[j] == 0) &#123; mu[i * pri[j]] = 0; break; &#125; mu[i * pri[j]] = -mu[i]; &#125; &#125;&#125; 莫比乌斯变换 设 \\(g(n)\\) 和 \\(f(n)\\) 是两个数论函数，如果有： \\[ f(n) = \\sum_{d | n} g(d) \\] 则有： \\[ g(n) = \\sum_{d | n} \\mu (d) f(\\frac{n}{d}) \\] 这里称 \\(f(n)\\) 为 \\(g(n)\\) 的莫比乌斯变换，\\(g(n)\\) 为 \\(f(n)\\) 的莫比乌斯反演。 反演结论 根据以上结论，我们不难得到 \\([gcd(i, j) = 1] = \\sum_{d | gcd(i, j)} \\mu(d)\\)（事实上就是将 \\(\\sum_{d | n} \\mu(d) = \\epsilon (n) = [n = 1]\\) 中的 \\(n\\) 替换为了 \\(gcd(i, j)\\)），这种替换有时候可以给我们带来意想不到的便利。 接下来我们给出一个例题：题目链接 题意大概就是说有 \\(n\\) 组查询，每组查询有 5 个数字 \\(a, b, c, d\\ (a \\leq b, c \\leq d)\\) 以及 \\(k\\)，然后求解 \\(\\sum_{x = a} ^ b \\sum_{y = c} ^ d [gcd(x, y) = k]\\) 。 不妨设 \\(f(m, n) = \\sum_{x = 1} ^ m \\sum_{y = 1} ^ n[gcd(x, y) = k]\\) ，根据容斥原理，题目的答案为： \\[ f(b, d) - f(b, c - 1) - f(a - 1, d) - f(a - 1, c - 1) \\] 因此我们只需要求解 \\(f(m, n)\\) 的表达式即可。 \\[ \\begin{array}{} f(m, n) = \\sum_{x = 1} ^ m \\sum_{y = 1} ^ n[gcd(x, y) = k] \\\\ = \\sum_{x = 1} ^ {[\\frac{m}{k}]} \\sum_{y = 1} ^ {[\\frac{n}{k}]} [gcd(x, y) = 1] \\\\ \\end{array} \\] 接下来使用莫比乌斯反演，上式可化简为： \\[ \\sum_{x = 1} ^ {[\\frac{m}{k}]} \\sum_{y = 1} ^ {[\\frac{n}{k}]} \\sum_{d | gcd(x, y)} \\mu(d) = \\sum_{x = 1} ^ {[\\frac{m}{k}]} \\sum_{y = 1} ^ {[\\frac{n}{k}]} \\sum_{d | x \\land d | y} \\mu(d) \\] 交换求和顺序，先枚举 \\(d\\) ，原式可进一步化简，最终可得： \\[ f(m, n) = \\sum_{d = 1} ^ {min\\{[\\frac{m}{k}], [\\frac{n}{k}]\\}} \\mu(d) [\\frac{m}{kd}][\\frac{n}{kd}] \\] 接下来使用分块除法即可在 \\(O(\\sqrt{min\\{[\\frac{m}{k}], [\\frac{n}{k}]\\}}\\) 的时间复杂度内求解答案。 参考代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;iostream&gt;#include &lt;vector&gt;const int MAX_N = 5e4 + 5;int mu[MAX_N];bool notPrime[MAX_N];void init() &#123; mu[1] = 1; std::vector&lt;int&gt; pri; for (int i = 2; i &lt; MAX_N; i++) &#123; if (!notPrime[i]) &#123; mu[i] = -1; pri.push_back(i); &#125; for (int p : pri) &#123; if (i * p &gt;= MAX_N) break; notPrime[i * p] = true; if (i % p == 0) &#123; mu[i * p] = 0; break; &#125; mu[i * p] = -mu[i]; &#125; &#125; for (int i = 1; i &lt; MAX_N; i++) mu[i] += mu[i - 1];&#125;int solve(int m, int n) &#123; int res = 0; for (int l = 1, r, b = std::min(m, n); l &lt;= b; l = r + 1) &#123; r = std::min(m / (m / l), n / (n / l)); res += (mu[r] - mu[l - 1]) * (m / l) * (n / l); &#125; return res;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); init(); int numTest; std::cin &gt;&gt; numTest; while (numTest--) &#123; int a, b, c, d, k; std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; k; int res = solve(b / k, d / k) - solve(b / k, (c - 1) / k) - solve((a - 1) / k, d / k) + solve((a - 1) / k, (c - 1) / k); std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"杜教筛","slug":"杜教筛","permalink":"http://example.com/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://example.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"}]},{"title":"Vim 编辑器入门","slug":"Vim 编辑器入门","date":"2023-08-15T16:51:02.000Z","updated":"2023-08-16T16:59:06.214Z","comments":true,"path":"2023/08/16/Vim 编辑器入门/","link":"","permalink":"http://example.com/2023/08/16/Vim%20%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/","excerpt":"","text":"简介 Vim（Vi IMproved）是一款强大、高度可定制且广泛使用的文本编辑器。它是 Unix 系统下的一个经典编辑器，也可以在其他操作系统上运行，包括 Linux、macOS 和 Windows。Vim 是从 Vi 编辑器发展而来的，但在功能和特性上进行了扩展和改进，成为了一个强大的文本编辑工具。尽管 Vim 具有很多功能，但它的学习曲线可能较陡峭，需要一些时间来适应和掌握。许多程序员选择学习和使用 Vim，因为一旦熟练掌握，它可以成为一个高效的文本编辑工具，适用于各种编程和文本处理任务。 基本使用 Vim 编辑器在使用的过程中有三种模式，即正常模式、编辑模式以及命令行模式，以下将一一介绍。 使用 Vim 编辑器打开或者新建文本文件 1vim filename 使用 vim 指令后会进入正常模式 ，此刻还不能编辑文本，只能预览文本。 进入编辑模式 此刻按下 i 键即可进入编辑模式。 此时终端下方会显示 -- INSERT -- ： 如何退出编辑模式进入正常模式呢？ 直接按下 esc 键即可。 进入命令行模式 在正常模式下，直接输入冒号 : ，则可进入命令行模式，此时可在底部输入命令： 一些常用命令： 保存退出： 1:wq 不保存退出： 1:q! 导航与编辑 KJHL 导航 在正常模式下，光标的移动由 4 个键组成，即： H ：左 L ：右 K ：上 J ：下 不同编辑方式 在将光标移动到合适的位置我们就可以开始编辑了，此时有几种选择： I ：如果键入 I ，表示插入，在光标的左边添加文本。 A ：如果键入 A ，表示追加，在光标的右边添加文本。 如果要在最前面添加文本，输入 Shift + I ，同理，若要在文本最后面添加文本，输入 Shift + A 。 O ：如果键入 O ，则向下另起一行，进入编辑模式。 键入 shift + O ，则增加上一行。 行数导航 如果想要让 Vim 编辑器显示文本行数，则需要我们自行在 .vimrc 文本中加入配置： 1set number 如何查找到 .vimrc 文本的位置呢？使用 vim --version 的指令即可显示其位置。 .vimrc 文本用于设置许多 Vim 编辑器的配置，后续还会经常提及。 如果想让 Vim 编辑器显示相对行数，则需要在 .vimrc 中添加配置： 1set relativenumber 行的跳转： 将光标跳转至第一行： 键入 Shift + G 。 将光标跳转至最后一行： 连续 2 次键入 G 。 向上跳转 n 行： 键入 数字 n + K 。 向下跳转 n 行： 键入 数字 n + J 。 复制行与删除行 连续两次键入 Y ，即可复制当前行，然后再键入 P ，就可以将复制的文本进行粘贴。 如果想复制 n 行，可以键入数字 n + P 。 如若想删除行，可以连续两次键入 D ，则可将该行删除。 重复最近操作和撤销操作 键入 . ，则可重复最近一次的操作。 键入 U ，则可撤销最近一次操作。 键入 crtl + r ，恢复前一次操作。 修改单词 键入 W ，光标跳转到下一个字母的首部。 键入 E ，光标跳转到下一个字母的尾部。 键入 B ，光标移动到上一个字母的首部。 键入 D + W ，可删除单词。 键入 C + W ，可改变单词。 键入 Y + W ，可复制单词。 删除括号内的内容 键入 C + I + 括号（&#123; 、[ 、(）即可删除光标所在括号的内容。 搜索与替换 搜索 进入命令行模式，输入 / + 变量名或函数名，即可将光标跳转到该函数。 命名全局替换 在命令行模式下输入 %s/旧命名/新命名/g ，可将所有旧命名全局替换。 可视化块和可视化行 键入 ctrl + V 可进入可视化块，可自己选择代码块进行相应的操作。 键入 shift + V 可进入可视化行，可自己选择代码行进行相应的操作。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"http://example.com/tags/Vim/"}]},{"title":"暑假集训 杭电多校 Round 6","slug":"暑假集训 杭电多校 Round 6","date":"2023-08-03T14:06:42.000Z","updated":"2023-08-14T02:48:14.265Z","comments":true,"path":"2023/08/03/暑假集训 杭电多校 Round 6/","link":"","permalink":"http://example.com/2023/08/03/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%206/","excerpt":"","text":"比赛链接 补题链接 「1004」 Count 签到题，\\(n \\not= k\\) 时答案为 \\(m ^ {n - k}\\) ，\\(n = k\\) 时答案为 \\(m ^ n\\)。 时间复杂度：\\(O(logn)\\) 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223242526#include &lt;iostream&gt;const int mod = 998244353;using i64 = long long;void solve() &#123; i64 n, m, k; std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; i64 t = n - k ? n - k : n; i64 res = 1; while (t) &#123; if (t &amp; 1) res = (__int128_t)res * m % mod; m = (__int128_t)m * m % mod; t &gt;&gt;= 1; &#125; std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; 「1002」 Pair Sum and Perfect Square 先枚举所有满足题意的 \\(i、j\\) 使得 \\(p_i + p_j\\) 为完全平方数，由于 \\(P\\) 在这里是 \\(1\\) 到 \\(n\\) 的排列，所以合法的 \\((i, j)\\) 只有 \\(O(n ^ {\\frac{3}{2}})\\) 种可能，接下来就是一个二维数点的问题了，即对于每次查询的区间 \\((L, R)\\) ，需找到多少点 \\((i, j)\\) 落在 \\((L, L)\\) 和 \\((R, R)\\) 组成的正方形内。 时间复杂度：\\(O(n ^ {\\frac{3}{2}} + q(logq + logn))\\) 空间复杂度：\\(O(n + k)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;const int MAX_N = 5e5 + 5;const int MAX_Q = 5e5 + 5;int n;int per[MAX_N];int id[MAX_N];int q;struct Query &#123; int x; int y; int id;&#125; query[4 * MAX_Q];int res[4 * MAX_Q];namespace __BIT &#123; int tree[MAX_N]; inline int lowbit(int x) &#123; return x &amp; -x; &#125; int prefix(int idx) &#123; int res = 0; while (idx) &#123; res += tree[idx]; idx -= lowbit(idx); &#125; return res; &#125; void add(int idx, int val = 1) &#123; while (idx &lt;= n) &#123; tree[idx] += val; idx += lowbit(idx); &#125; &#125;&#125;using namespace __BIT;void solve() &#123; std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; std::cin &gt;&gt; per[i]; id[per[i]] = i; &#125; std::cin &gt;&gt; q; int all = 4 * q; for (int i = 0, l, r; i &lt; all; i += 4) &#123; std::cin &gt;&gt; l &gt;&gt; r; query[i] = &#123;r, r, i&#125;; query[i + 1] = &#123;l - 1, r, i + 1&#125;; query[i + 2] = &#123;r, l - 1, i + 2&#125;; query[i + 3] = &#123;l - 1, l - 1, i + 3&#125;; &#125; std::sort(query, query + all, [](const Query&amp; q1, const Query&amp; q2) &#123; return q1.x &lt; q2.x; &#125;); int j = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int t = 2; ; t++) &#123; int pf = t * t - per[i]; if (pf &lt;= 0) continue; if (pf &gt;= per[i]) break; while (j &lt; all &amp;&amp; i &gt; query[j].x) &#123; // 当前区间已经统计完成 res[query[j].id] = prefix(query[j].y); j++; &#125; add(id[pf]); &#125; &#125; while (j &lt; all) &#123; res[query[j].id] = prefix(query[j].y); j++; &#125; for (int i = 0; i &lt; all; i += 4) &#123; std::cout &lt;&lt; res[i] - res[i + 1] - res[i + 2] + res[i + 3] &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; 「1006」 Perfect square number 使用一个数组动态维护所有跨越 \\(a_i\\) 的序列中增加 \\(k \\ (-300 \\leq k \\leq 300)\\) 后序列和为完全平方数的个数。当迭代次数从 \\(i - 1\\) 转移到 \\(i\\) 时，我们只需要考虑更新以 \\(a_i\\) 开头的序列，同时减去以 \\(a_{i - 1}\\) 结尾的序列中计算过的冗余即可。 时间复杂度：\\(O(n ^ 2 \\sqrt{k})\\) 空间复杂度：\\(O(n + k)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;const int MAX_N = 300, MAX_K = 300;int a[MAX_N + 5];int s[MAX_N + 5];inline int sum(int l, int r) &#123; return s[r] - s[l - 1];&#125;int lp[MAX_N + 5], rp[MAX_N + 5];int plus[2 * MAX_K + 5];inline int&amp; get_plus(int k) &#123; // 记录跨越当前 a[i] 的序列中有多少个序列增加 k 后为完全平方数 return plus[k + MAX_K];&#125;int ub(int x) &#123; int t = std::sqrt(x); while (t * t &lt; x) t++; return t;&#125;bool check(int s) &#123; int b = ub(s); return b * b == s;&#125;void solve() &#123; memset(plus, 0x00, sizeof(plus)); memset(lp, 0x00, sizeof(lp)); memset(rp, 0x00, sizeof(rp)); int n; std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) std::cin &gt;&gt; a[i]; for (int i = 1; i &lt;= n; i++) s[i] = s[i - 1] + a[i]; for (int i = 1; i &lt;= n; i++) &#123; lp[i] += lp[i - 1]; for (int j = 1; j &lt;= i; j++) &#123; if (check(sum(j, i))) lp[i]++; &#125; &#125; for (int i = n; i &gt;= 1; i--) &#123; rp[i] += rp[i + 1]; for (int j = i; j &lt;= n; j++) &#123; if (check(sum(i, j))) rp[i]++; &#125; &#125; int res = 0; for (int i = 1; i &lt;= n; i++) &#123; for (int j = i; j &lt;= n; j++) &#123; int ds = sum(i, j); int b = ub(ds); for (int ib = b; ib * ib - ds &lt;= MAX_K; ib++) &#123; get_plus(ib * ib - ds)++; &#125; for (int ib = b - 1; ib &gt; 0 &amp;&amp; ib * ib - ds &gt;= -MAX_K; ib--) &#123; get_plus(ib * ib - ds)++; &#125; &#125; for (int j = i - 1; j &gt;= 1; j--) &#123; int ds = sum(j, i - 1); int b = ub(ds); for (int ib = b; ib * ib - ds &lt;= MAX_K; ib++) &#123; get_plus(ib * ib - ds)--; &#125; for (int ib = b - 1; ib &gt; 0 &amp;&amp; ib * ib - ds &gt;= -MAX_K; ib--) &#123; get_plus(ib * ib - ds)--; &#125; &#125; int p = 0; for (int k = -a[i] + 1; k &lt;= MAX_K - a[i]; k++) p = std::max(p, get_plus(k)); res = std::max(res, p + lp[i - 1] + rp[i + 1]); &#125; std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; 「1003」 Vector 若三个向量线性无关，则只需要判断 \\(A_4\\) 是否落在向量 \\(A_1\\) ，\\(A_2\\) ，\\(A_3\\) 的张集里面即可（由于相关系数只能是非负数，所以这里的张集是一个无穷大的三棱锥）；若三个向量线性相关，则其张集一定可以在一个平面内表示，此时用类似的方式判断 \\(A_4\\) 是否属于该集合即可。 这里要注意零向量的情况。 时间复杂度：\\(O(1)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include &lt;iostream&gt;namespace __3dvector &#123; using i64 = long long; struct Vec &#123; i64 x, y, z; Vec(i64 _x = 0, i64 _y = 0, i64 _z = 0): x(_x), y(_y), z(_z) &#123;&#125; &#125;; Vec zero(0, 0, 0); bool operator==(const Vec&amp; v1, const Vec&amp; v2) &#123; return v1.x == v2.x &amp;&amp; v1.y == v2.y &amp;&amp; v1.z == v2.z; &#125; bool operator!=(const Vec&amp; v1, const Vec&amp; v2) &#123; return v1.x != v2.x || v1.y != v2.y || v1.z != v2.z; &#125; Vec operator+(const Vec&amp; v1, const Vec&amp; v2) &#123; return Vec(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z); &#125; i64 dot(const Vec&amp; v1, const Vec&amp; v2) &#123; return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z; &#125; Vec cross(const Vec&amp; v1, const Vec&amp; v2) &#123; return Vec( v1.y * v2.z - v1.z * v2.y, - v1.x * v2.z + v1.z * v2.x, v1.x * v2.y - v1.y * v2.x ); &#125;&#125;using namespace __3dvector;inline int sgn(i64 x) &#123; return (x &gt; 0) - (x &lt; 0);&#125;bool judge(const Vec&amp; v1, const Vec&amp; v2) &#123; return sgn(v1.x) * sgn(v2.x) &gt;= 0 &amp;&amp; sgn(v1.y) * sgn(v2.y) &gt;= 0 &amp;&amp; sgn(v1.z) * sgn(v2.z) &gt;= 0;&#125;void solve() &#123; Vec v[4]; for (int i = 0; i &lt; 4; i++) std::cin &gt;&gt; v[i].x &gt;&gt; v[i].y &gt;&gt; v[i].z; i64 x1 = v[0].x, x2 = v[1].x, x3 = v[2].x; i64 y1 = v[0].y, y2 = v[1].y, y3 = v[2].y; i64 z1 = v[0].z, z2 = v[1].z, z3 = v[2].z; i64 det = x1 * y2 * z3 + x2 * y3 * z1 + x3 * y1 * z2 - x3 * y2 * z1 - x2 * y1 * z3 - x1 * y3 * z2; // 计算行列式 if (det) &#123; Vec cr1 = cross(v[0], v[1]), cr2 = cross(v[1], v[2]), cr3 = cross(v[2], v[0]); // 3 个平面的法向量 Vec vt = v[0] + v[1] + v[2]; i64 dt1 = dot(vt, cr1); i64 d1 = dot(v[3], cr1), d2 = dot(v[3], cr2), d3 = dot(v[3], cr3); if (sgn(d1) * sgn(dt1) &gt;= 0 &amp;&amp; sgn(d2) * sgn(dt1) &gt;= 0 &amp;&amp; sgn(d3) * sgn(dt1) &gt;= 0) &#123; std::cout &lt;&lt; &quot;YES\\n&quot;; return; &#125; &#125; else &#123; // rank &lt;= 2 for (int i = 0; i &lt; 3; i++) &#123; for (int j = i + 1; j &lt; 3; j++) &#123; Vec cr = cross(v[i], v[j]); if (cr == zero) &#123; // v[i] 与 v[j] 平行 if (cross(v[3], v[i]) == zero &amp;&amp; cross(v[3], v[j]) == zero &amp;&amp; (v[i] != zero &amp;&amp; judge(v[3], v[i]) || v[j] != zero &amp;&amp; judge(v[3], v[j]))) &#123; std::cout &lt;&lt; &quot;YES\\n&quot;; return; &#125; else if (v[i] == zero &amp;&amp; v[j] == zero) &#123; if (v[3] == zero) &#123; std::cout &lt;&lt; &quot;YES\\n&quot;; return; &#125; &#125; &#125; else &#123; // v[i] 与 v[j] 不平行 if (dot(v[3], cr) == 0) &#123; // 则 v[3] 必须与两个向量共面 Vec cri = cross(v[3], v[i]), crj = cross(v[3], v[j]); Vec vt = v[i] + v[j]; Vec crit = cross(vt, v[i]), crjt = cross(vt, v[j]); if (judge(cri, crit) &amp;&amp; judge(crj, crjt)) &#123; std::cout &lt;&lt; &quot;YES\\n&quot;; return; &#125; &#125; &#125; &#125; &#125; &#125; std::cout &lt;&lt; &quot;NO\\n&quot;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"杭电多校","slug":"杭电多校","permalink":"http://example.com/tags/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"}]},{"title":"暑假集训 杭电多校 Round 5","slug":"暑假集训 杭电多校 Round 5","date":"2023-08-01T11:49:00.000Z","updated":"2023-09-01T16:21:23.858Z","comments":true,"path":"2023/08/01/暑假集训 杭电多校 Round 5/","link":"","permalink":"http://example.com/2023/08/01/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%205/","excerpt":"","text":"题目链接 补题链接 「1001」 Typhoon 签到题，遍历每条线段到每个点的最小距离即可。 时间复杂度：\\(O(mn)\\) 空间复杂度：\\(O(m)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;struct Point &#123; double x, y;&#125;;inline double dist2(const Point&amp; p1, const Point&amp; p2) &#123; double dx = (p1.x - p2.x); double dy = (p1.y - p2.y); return dx * dx + dy * dy;&#125;double dist2line(const Point&amp; p0, const Point&amp; p1, const Point&amp; p2) &#123; double vx = p2.x - p1.x, vy = p2.y - p1.y; double d1 = vx * (p1.x - p0.x) + vy * (p1.y - p0.y); double d2 = vx * (p2.x - p0.x) + vy * (p2.y - p0.y); if (d1 * d2 &lt; 0) &#123; double f1 = (p2.x - p1.x) * (p0.y - p1.y) - (p2.y - p1.y) * (p0.x - p1.x); double f2 = (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y); return f1 * f1 / f2; &#125; else &#123; return std::min(dist2(p0, p1), dist2(p0, p2)); &#125;&#125;#define MAX_N 10005Point pos[MAX_N];void solve() &#123; int m, n; std::cin &gt;&gt; m &gt;&gt; n; for (int i = 0; i &lt; m; i++) &#123; std::cin &gt;&gt; pos[i].x &gt;&gt; pos[i].y; &#125; Point p0; // 庇护所 for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; p0.x &gt;&gt; p0.y; double res = INFINITY; for (int i = 1; i &lt; m; i++) &#123; res = std::min(res, dist2line(p0, pos[i - 1], pos[i])); &#125; printf(&quot;%.4lf\\n&quot;, std::sqrt(res)); &#125;&#125;int main() &#123; solve(); return 0;&#125; 「1002」 GCD Magic 首先，显然有 \\(gcd(2 ^ i - 1, 2 ^ j - 1)\\) = \\(2 ^ {gcd(i, j)} - 1\\) ，所以原表达式只与 \\(gcd(i, j)\\) 有关，所以我们只用枚举全部 \\(i\\) 和 \\(j\\) 的最大公约数的数量即可。 对于 \\(i、j\\) 满足 \\(1 \\leq i、j \\leq n\\) 而言，满足 \\(gcd(i, j) = t\\) 的数量为： \\[ \\begin{array}{} \\sum_{i = 1} ^ n \\sum_{j = 1} ^ n [gcd(i, j) = t] \\\\ = \\sum_{i = 1} ^ {[\\frac{n}{t}]} \\sum_{j = 1} ^ {[\\frac{n}{t}]} [gcd(i, j) = 1] \\\\ = \\sum_{i = 1} ^ {[\\frac{n}{t}]} \\sum_{j = 1} ^ {[\\frac{n}{t}]} \\sum_{d | gcd(i, j)} \\mu(d) \\\\ = \\sum_{d = 1} ^ {[\\frac{n}{t}]} \\mu(d) \\sum_{i = 1} ^ {[\\frac{n}{t}]} \\sum_{j = 1} ^ {[\\frac{n}{t}]} [d | gcd(i, j)] \\\\ = \\sum_{d = 1} ^ {[\\frac{n}{t}]} \\mu(d) [\\frac{n}{td}] ^ 2 \\end{array} \\] 要计算的表达式可化为 \\(f(t) = (2 ^ t - 1) ^ k\\) ，因此最终要求的表达式如下所示： \\[ \\sum_{t = 1} ^ n f(t) \\sum_{d = 1} ^ {[\\frac{n}{t}]} \\mu(d) [\\frac{n}{td}] ^ 2 \\] 令 \\(T = dt\\) ，交换求和顺序，先枚举 \\(T\\) ，上式可转化为： \\[ \\sum_{T = 1} ^ n [\\frac{n}{T}] ^ 2 \\sum_{d | T} f(d) \\mu(\\frac{T}{d}) \\] 由于题目中的 \\(n\\) 很大，所以这里考虑使用杜教筛来计算 \\(\\sum_{d | T} f(d)\\mu(\\frac{T}{d})\\) 的前缀和，然后使用分块除法来快速求出上式的值。 考虑狄利克雷卷积，\\(f * \\mu * 1 = f * \\epsilon = f(T)\\) ，设 \\(S(n) = \\sum_{T = 1} ^ n \\sum_{d | T} f(d) \\mu(\\frac{T}{d})\\) 则有： \\[ S(n) = \\sum_{T = 1} ^ n f(T) - \\sum_{d = 2} ^ n S([\\frac{n}{d}]) \\] \\[ f(T) = (2 ^ T - 1) ^ K = \\sum_{i = 0} ^ K C_{K} ^ i 2 ^ {Ti} (-1) ^ {K - i} \\] 此处就是一个等比数列求和。 时间复杂度：\\(O(K \\sqrt n)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include &lt;cmath&gt;#include &lt;cstdio&gt;#include &lt;unordered_map&gt;using namespace std;using LL = long long;const int maxs = 1000001, maxk = 10, MOD = 998244353;int te, K;LL n;int u[maxs + 5], p[maxs + 5];bool pri[maxs + 5];int C[maxk + 5][maxk + 5], val[maxk + 5];int lim, G[maxs + 5];unordered_map&lt;LL, int&gt; f;int ans;inline int ADD(int x, int y) &#123; return x + y &gt;= MOD ? x + y - MOD : x + y; &#125;inline int MUL(int x, int y) &#123; return (LL)x * y % MOD; &#125;int Pow(int w, int b) &#123; int s; for (s = 1; b; b &gt;&gt;= 1, w = MUL(w, w)) if (b &amp; 1) s = MUL(s, w); return s;&#125;void Make() &#123; for (int i = 0; i &lt;= maxk; i++) &#123; C[i][0] = 1; for (int j = 1; j &lt;= i; j++) C[i][j] = ADD(C[i - 1][j - 1], C[i - 1][j]); &#125; for (int i = 1; i &lt;= maxk; i++) val[i] = MUL(1 &lt;&lt; i, Pow((1 &lt;&lt; i) - 1, MOD - 2)); u[1] = 1; for (int i = 2; i &lt;= maxs; i++) &#123; if (!pri[i]) p[++p[0]] = i, u[i] = MOD - 1; for (int j = 1, t; j &lt;= p[0] &amp;&amp; (t = i * p[j]) &lt;= maxs; j++) &#123; pri[t] = true; if (i % p[j]) u[t] = (MOD - u[i]) % MOD; else &#123; u[t] = 0; break; &#125; &#125; &#125;&#125;int SumF(LL n) &#123; int ans = MUL(K &amp; 1 ? MOD - 1 : 1, n % MOD); int BA = Pow(2, n % (MOD - 1)), pw = BA; for (int j = 1; j &lt;= K; j++) &#123; int now = MUL(C[K][j], K - j &amp; 1 ? MOD - 1 : 1); now = MUL(now, MUL(val[j], ADD(pw, MOD - 1))); ans = ADD(ans, now); pw = MUL(pw, BA); &#125; return ans;&#125;int Sum(LL n) &#123; if (n &lt;= lim) return G[n]; if (f.count(n)) return f[n]; int ans = SumF(n); for (LL l = 2, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); ans = ADD(ans, MOD - MUL(Sum(n / l), (r - l + 1) % MOD)); &#125; return f[n] = ans;&#125;int main() &#123; Make(); for (scanf(&quot;%d&quot;, &amp;te); te; te--) &#123; scanf(&quot;%lld%d&quot;, &amp;n, &amp;K); lim = pow(n, 2.0 / 3) + 1; for (int i = 1; i &lt;= lim; i++) G[i] = 0; for (int i = 1, pw = 2; i &lt;= lim; i++, pw = MUL(pw, 2)) &#123; int F = Pow(pw - 1, K); for (int j = i, k = 1; j &lt;= lim; j += i, k++) G[j] = ADD(G[j], MUL(u[k], F)); &#125; for (int i = 1; i &lt;= lim; i++) G[i] = ADD(G[i], G[i - 1]); f.clear(); ans = 0; for (LL l = 1, r; l &lt;= n; l = r + 1) &#123; r = n / (n / l); ans = ADD(ans, MUL(ADD(Sum(r), MOD - Sum(l - 1)), MUL(n / l % MOD, n / l % MOD))); &#125; printf(&quot;%d\\n&quot;, ans); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"杭电多校","slug":"杭电多校","permalink":"http://example.com/tags/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"}]},{"title":"暑假集训 Nowcoder 多校 Round 4","slug":"暑假集训 Nowcoder 多校 Round 4","date":"2023-07-28T13:17:47.000Z","updated":"2023-07-29T14:07:17.245Z","comments":true,"path":"2023/07/28/暑假集训 Nowcoder 多校 Round 4/","link":"","permalink":"http://example.com/2023/07/28/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20Nowcoder%20%E5%A4%9A%E6%A0%A1%20Round%204/","excerpt":"","text":"比赛链接 F 「Election of the King」 签到题，每次淘汰的候选人要么是最左的，要么是最右的，因此用两个变量维护两端的索引，逐步向中间移动。 每一轮选举使用二分查找来得到两人的票数，将得票高的一方淘汰即可。 时间复杂度：\\(O(nlogn)\\) 空间复杂度：\\(O(n)\\) 每一轮循环也可以只看中间的人来判断谁被淘汰，可以将时间复杂度优化到 \\(O(n)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include &lt;algorithm&gt;#define MAX_N 1000005using i64 = long long;struct &#123; i64 v; int idx;&#125; a[MAX_N];void solve() &#123; int n; std::cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; a[i].v; a[i].idx = i; &#125; std::sort(a, a + n, [](auto&amp; a1, auto&amp; a2) &#123; return a1.v &lt; a2.v; &#125;); int left = 0, right = n - 1; while (left &lt; right) &#123; int l = left, r = right; // 2 * a[l].v &lt;= a[left].v + a[right].v // 2 * a[r].v &gt; a[left].v + a[right].v i64 x = a[left].v + a[right].v; if (2 * a[r].v &lt;= x) &#123; right--; continue; &#125; while (r - l &gt; 1) &#123; int mid = (l + r) / 2; if (2 * a[mid].v &lt;= x) &#123; l = mid; &#125; else &#123; r = mid; &#125; &#125; if (right - r + 1 &gt; r - left) &#123; left++; &#125; else &#123; right--; &#125; &#125; std::cout &lt;&lt; a[left].idx + 1 &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); solve(); return 0;&#125; L 「We are the Lights」 因为后续的操作会覆盖之前的操作，所以从后往前遍历所有操作，操作过的行和列会被锁住且后续无法再修改，同时用两个变量 r 、c 分别维护未被锁住的行数和列数，若当前操作为 row x on 且 x 行未上锁，则当前开灯总数增加 c ，r 自减 1，对于其他三种情况，同理分析即可。 时间复杂度：\\(O(q)\\) 空间复杂度：\\(O(m + n + q)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#define MAX_NUM 1000005using i64 = long long;struct &#123; std::string pos; int val; std::string kind;&#125; op[MAX_NUM];bool lockRow[MAX_NUM];bool lockCol[MAX_NUM];void solve() &#123; int n, m, q; std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; for (int i = 0; i &lt; q; i++) &#123; std::cin &gt;&gt; op[i].pos &gt;&gt; op[i].val &gt;&gt; op[i].kind; &#125; int r = n, c = m; // 未被锁住的行列数 i64 res = 0; for (int i = q - 1; i &gt;= 0; i--) &#123; if (op[i].kind == &quot;on&quot;) &#123; if (op[i].pos == &quot;row&quot;) &#123; if (lockRow[op[i].val]) continue; res += c; r--; lockRow[op[i].val] = true; &#125; else &#123; if (lockCol[op[i].val]) continue; res += r; c--; lockCol[op[i].val] = true; &#125; &#125; else &#123; if (op[i].pos == &quot;row&quot;) &#123; if (lockRow[op[i].val]) continue; r--; lockRow[op[i].val] = true; &#125; else &#123; if (lockCol[op[i].val]) continue; c--; lockCol[op[i].val] = true; &#125; &#125; &#125; std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); solve(); return 0;&#125; J 「Qu'est-ce Que C'est?」 假设 \\(dp[i][s]\\) 表示 \\([0, i]\\) 序列中最小后缀和为 \\(s\\) 的合法情况有多少种，可以得到状态转移方程： \\[ \\begin{equation} dp[i][s] = \\begin{cases} \\ \\sum_{k = s - m} ^ m dp[i - 1][k] &amp; s \\geq 0 \\\\ \\\\ \\ \\sum_{k = - s} ^ m dp[i - 1][k] &amp; s &lt; 0 \\end{cases} \\end{equation} \\] 根据状态转移方程，我们需要定义一个后缀数组来维护后缀和来优化时间，同时注意到 \\(dp[i]\\) 只与 \\(dp[i - 1]\\) 有关，所以可以使用滚动数组优化空间。 时间复杂度：\\(O(nm)\\) 空间复杂度：\\(O(m)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#define MAX_M 5005using i64 = long long;const int mod = 998244353;i64 dp[2][2 * MAX_M];i64 sum[2][2 * MAX_M];void solve() &#123; int n, m; std::cin &gt;&gt; n &gt;&gt; m; for (int s = m; s &gt;= -m; s--) &#123; dp[0][m + s] = 1; sum[0][m + s] = (sum[0][m + s + 1] + dp[0][m + s]) % mod; &#125; for (int i = 1; i &lt; n; i++) &#123; for (int s = m; s &gt;= -m; s--) &#123; if (s &gt;= 0) &#123; dp[i &amp; 1][m + s] = sum[(i - 1) &amp; 1][m + s - m]; &#125; else &#123; dp[i &amp; 1][m + s] = sum[(i - 1) &amp; 1][m - s]; &#125; sum[i &amp; 1][m + s] = (sum[i &amp; 1][m + s + 1] + dp[i &amp; 1][m + s]) % mod; &#125; &#125; std::cout &lt;&lt; sum[(n - 1) &amp; 1][0] &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); solve(); return 0;&#125; H 「Merge the squares!」 对于任意一个 \\(n \\times n\\) 的正方形，如果 \\(n &lt; 8\\) ，则可以一次性合并，若 \\(n \\geq 8\\) ，我们考虑如下分割方式： 即将一个正方形分割为两个正方形与两个矩形，两个正方形的边长分别为 \\(j\\) 和 \\(n - j\\) ，通过枚举 \\(j\\) ，若两个 \\((n - j) \\times j\\) 的矩形可以分割为不超过 24 个正方形，则总的正方形合并数不超过 50。经计算，发现对任意 \\(n\\) 满足 \\(8 \\leq n \\leq 1000\\) 都可以找到合法的 \\(j\\) 满足题意。 我们使用一个数组来维护每一个 \\(n\\) 的合法分割方案，然后使用递归来记录答案即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;#include &lt;functional&gt;#include &lt;vector&gt;#include &lt;array&gt;int splitGrid[1001];void init() &#123; // 得到所有可行的分割方案 for (int i = 8; i &lt;= 1000; i++) &#123; for (int j = (i + 1) / 2; j &lt; i; j++) &#123; int a = j, b = i - j; int cnt = 0; while (b) &#123; cnt += (a / b); a %= b; std::swap(a, b); &#125; if (cnt &lt;= 24) &#123; splitGrid[i] = j; break; &#125; &#125; assert(splitGrid[i] &gt; 0); &#125;&#125;void solve() &#123; int n; std::cin &gt;&gt; n; std::vector&lt;std::array&lt;int, 3&gt;&gt; ans; std::function&lt;void(int, int, int, int)&gt; merge = [&amp;merge, &amp;ans](int x1, int y1, int x2, int y2) -&gt; void &#123; if (x2 - x1 == y2 - y1) &#123; int len = x2 - x1 + 1; if (len == 1) return; if (len &lt;= 7) &#123; ans.push_back(&#123;x1, y1, len&#125;); return; &#125; int k = splitGrid[len]; merge(x1, y1, x1 + k - 1, y1 + k - 1); merge(x1 + k, y1 + k, x2, y2); merge(x1, y1 + k, x1 + k - 1, y2); merge(x1 + k, y1, x2, y1 + k - 1); ans.push_back(&#123;x1, y1, len&#125;); &#125; else &#123; int len1 = x2 - x1 + 1, len2 = y2 - y1 + 1; if (len1 &gt; len2) &#123; merge(x1, y1, x1 + len2 - 1, y1 + len2 - 1); x1 += len2; &#125; else &#123; merge(x1, y1, x1 + len1 - 1, y1 + len1 - 1); y1 += len1; &#125; merge(x1, y1, x2, y2); &#125; &#125;; merge(1, 1, n, n); std::cout &lt;&lt; ans.size() &lt;&lt; &#x27;\\n&#x27;; for (const auto&amp; [x, y, len] : ans) &#123; std::cout &lt;&lt; x &lt;&lt; &#x27; &#x27; &lt;&lt; y &lt;&lt; &#x27; &#x27; &lt;&lt; len &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); init(); solve(); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"}]},{"title":"暑假集训 杭电多校 Round 4","slug":"暑假集训 杭电多校 Round 4","date":"2023-07-28T02:56:11.000Z","updated":"2023-07-29T11:25:59.857Z","comments":true,"path":"2023/07/28/暑假集训 杭电多校 Round 4/","link":"","permalink":"http://example.com/2023/07/28/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%204/","excerpt":"","text":"补题链接 「1007」 Guess 结论题，证明得当 \\(n\\) 为素数的幂即 \\(n = p ^ c\\) 时 \\(S(n) = ln\\ \\!p\\) ，否则 \\(S(n) = 0\\) 。 然后使用 Pollard-Rho 算法进行质因数分解即可。 时间复杂度：\\(O(n ^ {\\frac{1}{4}})\\) 空间复杂度：\\(O(1)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;iostream&gt;#include &lt;unordered_map&gt;#include &lt;functional&gt;using i64 = long long;const int mod = 998244353;i64 quickPow(i64 x, i64 n, i64 mod) &#123; i64 res = 1; while (n) &#123; if (n &amp; 1) res = (__int128_t)res * x % mod; x = (__int128_t)x * x % mod; n &gt;&gt;= 1; &#125; return res;&#125;bool millerRabin(i64 n, int test_times = 8) &#123; if (n &lt; 3 || n % 2 == 0) return n == 2; i64 u = n - 1; int t = 0; while (!(u &amp; 1)) &#123; u &gt;&gt;= 1; t++; &#125; for (int i = 0; i &lt; test_times; i++) &#123; i64 a = std::rand() % (n - 2) + 2; i64 v = quickPow(a, u, n); if (v == 1) continue; int s; for (s = 0; s &lt; t; s++) &#123; if (v == n - 1) break; v = (__int128_t)v * v % n; &#125; if (s == t) return false; &#125; return true;&#125;i64 gcd(i64 x, i64 y) &#123; return y == 0 ? x : gcd(y, x % y);&#125;i64 Pollard_Rho(i64 x) &#123; i64 s = 0, t = 0; i64 c = (i64)std::rand() % (x - 1) + 1; int step = 0, goal = 1; i64 val = 1; for (goal = 1; ; goal &lt;&lt;= 1, s = t, val = 1) &#123; for (step = 1; step &lt;= goal; step++) &#123; t = ((__int128_t)t * t + c) % x; val = (__int128_t)val * std::abs(t - s) % x; if (step % 127 == 0) &#123; i64 d = gcd(val, x); if (d &gt; 1) return d; &#125; &#125; i64 d = gcd(val, x); if (d &gt; 1) return d; &#125;&#125;i64 solve() &#123; i64 x; std::cin &gt;&gt; x; std::unordered_map&lt;i64, int&gt; res; std::function&lt;void(i64)&gt; fac = [&amp;res, &amp;fac](i64 n) &#123; if (n &lt; 2) return; if (millerRabin(n)) &#123; res[n]++; return; &#125; i64 p = n; while (p &gt;= n) p = Pollard_Rho(n); fac(p), fac(n / p); &#125;; fac(x); if (res.size() == 1) &#123; return res.begin()-&gt;first; &#125; else &#123; return 1; &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; for (int i = 0; i &lt; numTest; i++) &#123; std::cout &lt;&lt; solve() % mod &lt;&lt; &quot; \\n&quot;[i == numTest - 1]; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"杭电多校","slug":"杭电多校","permalink":"http://example.com/tags/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"}]},{"title":"暑假集训 Nowcoder 多校 Round 2","slug":"暑假集训 Nowcoder 多校 Round 2","date":"2023-07-24T15:35:44.000Z","updated":"2023-07-29T06:28:31.930Z","comments":true,"path":"2023/07/24/暑假集训 Nowcoder 多校 Round 2/","link":"","permalink":"http://example.com/2023/07/24/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20Nowcoder%20%E5%A4%9A%E6%A0%A1%20Round%202/","excerpt":"","text":"比赛链接 E 「Square」 枚举 \\(k\\) ，然后二分查找即可。 时间复杂度：\\(O(logn)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using i64 = long long;i64 pow10[19];void init() &#123; pow10[0] = 1; for (int i = 1; i &lt; 19; i++) pow10[i] = 10ll * pow10[i - 1];&#125;void solve() &#123; i64 x; std::cin &gt;&gt; x; for (int k = 0; k &lt; 19; k++) &#123; i64 left = 0, right = 1000000000ll; while (left &lt;= right) &#123; i64 mid = (left + right) / 2; i64 prefix = mid * mid / pow10[k]; if (prefix &lt; x) &#123; left = mid + 1; &#125; else if (prefix &gt; x) &#123; right = mid - 1; &#125; else &#123; std::cout &lt;&lt; mid &lt;&lt; &#x27;\\n&#x27;; return; &#125; &#125; &#125; std::cout &lt;&lt; -1 &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); init(); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; F 「Link with Chess Game」 这是一道典型的二分图博弈问题，对于三元组 \\((r, b, g)\\) ，我们可以看成边长为 \\(n\\) 的立方体的坐标，对于 \\(n\\) 为偶数的情况，任意一个初始状态都是最大匹配的必要点，若 \\(n\\) 为奇数，则只要 \\(r_0 + b_0 + g_0\\) 为偶数，则该初始状态为最大匹配点必要点。 综上所示，\\(n\\) 为偶数或者 \\(r_0 + b_0 + g_0\\) 为偶数时，先手必胜。 时间复杂度：\\(O(1)\\) 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920#include &lt;iostream&gt;void solve() &#123; int n, r, b, g; std::cin &gt;&gt; n &gt;&gt; r &gt;&gt; b &gt;&gt; g; if (n % 2 == 0 || (r + b + g) % 2 == 0) &#123; std::cout &lt;&lt; &quot;Alice\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Bob\\n&quot;; &#125;&#125;int main() &#123; int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; G 「Link with Centrally Symmetric Strings」 这题需要一些前置知识：Manacher 算法","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"},{"name":"Manacher","slug":"Manacher","permalink":"http://example.com/tags/Manacher/"}]},{"title":"最优终止策略 —— 为什么是 37%？","slug":"最优终止策略","date":"2023-07-20T16:01:03.000Z","updated":"2023-07-22T08:48:05.022Z","comments":true,"path":"2023/07/21/最优终止策略/","link":"","permalink":"http://example.com/2023/07/21/%E6%9C%80%E4%BC%98%E7%BB%88%E6%AD%A2%E7%AD%96%E7%95%A5/","excerpt":"","text":"见好就收。 描述 考虑一个问题：假设现在有若干件同类型商品，每件商品的质量都不一样且商品质量等可能分布，我们在看到商品前不知道商品的质量，且在看商品时无法回退到上一个商品，接下来要从这些商品中挑选一件商品。现在考虑如下策略： 如果有 \\(n\\) 件商品，我们先依次看前 \\(k\\ (k \\leq n)\\) 件商品，不论商品质量如何，都将其舍弃，在随后的 \\(n - k\\) 件商品中如果出现了质量比前 \\(k\\) 件商品质量更好的商品，那就选择该商品，请问选择 \\(k\\) 为多少，可以最大化我们选择到质量最好的商品的概率呢？ 假设第 \\(i\\) 件商品的质量最高，则要选择该商品，则需要保证前 \\(i - 1\\) 个商品的质量最大值在前 \\(k\\) 件商品，所以若该商品被选中的概率为 \\(\\frac{k}{i - 1}\\)， 因此，第 \\(i\\) 件商品被选择的概率为 \\(\\frac{k}{i - 1}\\) ，又由于商品质量分布是均匀的，所有质量最高的商品等可能出现在每一个 \\(i\\ (1 \\leq i \\leq n)\\)。综上所述，选择到最高质量 \\(P_k\\) 的商品的概率为： \\[ P_k = \\sum_{i = k + 1} ^ n \\frac{k}{i - 1} \\frac{1}{n} \\] 当 \\(n\\) 足够大时，\\(\\sum_{i = k + 1} ^ n \\frac{1}{i - 1}\\) 可以近似看作 \\(ln(n) - ln(k)\\) ，所以有： \\[ P_k \\approx \\frac{k}{n} (ln(n) - ln(k)) \\] 对 \\(k\\) 求导，可得： \\[ \\frac{\\partial P_k}{\\partial k} = \\frac{ln(\\frac{n}{e}) - ln(k)}{n} \\] 可知，当 \\(k \\approx [\\frac{n}{e}]\\) 时，\\(P_k\\) 取得最大值。 换言之，当 \\(\\frac{k}{n}\\) 近似等于自然常数 \\(\\frac{1}{e}\\) 的时候 \\(P_k\\) 取得最大值。事实上，\\(\\frac{1}{e}\\) 在数值上约等于 0.36787944117144233，近似等于 0.37，这也是我们经常说的 37% 法则。 历史 这个问题可以追溯到到上世纪 60 年代，当时美国杂志《科学美国人》提出了几个趣味数学问题，其中之一是秘书问题。假如你需要聘请一个秘书，你依次面试多个候选人，每面试一个人后，你要立刻决定是否聘用她，如果放弃她，她就会去其他公司工作，可能她是最优人选，但是你错过了她，如果录用她，你就不会再面试后面的人选，可能会错过后面更好的人选。那么什么时候停止，才能选到最佳人选呢？ 目前已知的第一个提出 37% 法则的是数学家弗拉德。他发现 37% 是最佳选择的一个分割点，当有 N 个候选人时，前 37% 的人面试时，不做决策，找出最优的一位，后面每面试一位，就和前面最优的这位比较，如果劣于她，就面试下一位，如果优于，就选择当前人选，停止面试。 37% 法则在生活中十分常见，它经常出现在各式各样的统计学问题和决策问题上，其描述了一种选择策略上的最优化理论，可以帮我们解决一些日常的决策纠结，37% 法则让我们在面对不确定时，尽可能获取到一个较好的结果。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"概率论","slug":"概率论","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"37% 法则","slug":"37-法则","permalink":"http://example.com/tags/37-%E6%B3%95%E5%88%99/"}]},{"title":"暑假集训 杭电多校 Round 2","slug":"暑假集训 杭电多校 Round 2","date":"2023-07-20T11:30:32.000Z","updated":"2023-09-02T10:45:33.978Z","comments":true,"path":"2023/07/20/暑假集训 杭电多校 Round 2/","link":"","permalink":"http://example.com/2023/07/20/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%202/","excerpt":"","text":"比赛链接 补题链接 「1009」 String Problem 签到题，求出连续段字符的数量，字符串长度减去该数量就是答案。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 123456789101112131415161718192021222324#include &lt;iostream&gt;void solve() &#123; std::string str; std::cin &gt;&gt; str; int dn = 1; for (int i = 1, len = str.size(); i &lt; len; i++) &#123; if (str[i] != str[i - 1]) dn++; &#125; std::cout &lt;&lt; str.size() - dn &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; 「1002」 Binary Number 签到题，简单分类讨论即可。但要注意细节，各种情况都需要考虑到。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;using i64 = long long;void solve() &#123; int n; i64 k; std::string str; std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; str; int p = 0; i64 k0 = k; while (k) &#123; while (p &lt; n &amp;&amp; str[p] == &#x27;1&#x27;) p++; if (p == n) &#123; if (k &amp; 1) &#123; if ((n == 1 &amp;&amp; str[0] == &#x27;1&#x27;) || (k == k0 &amp;&amp; k == 1)) &#123; str[n - 1] = &#x27;0&#x27;; &#125; break; &#125; break; &#125; else &#123; int i; for (i = p; i &lt; n &amp;&amp; str[i] == &#x27;0&#x27;; i++) str[i] = &#x27;1&#x27;; // str[i] == &#x27;0&#x27; p = i; k--; &#125; &#125; std::cout &lt;&lt; str &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; 「1004」 Card Game 数学题，由题意可得 \\(f(n) = 2 f(n - 1) + 1\\) ，又因为 \\(f(1) = 0\\) ，所以有： \\[ f(n) = 2 ^ {n - 1} - 1 \\] 使用快速幂求出答案即可。 时间复杂度：\\(O(logn)\\) 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223242526272829303132#include &lt;iostream&gt;const int mod = 998244353;int quickPow(int x, int n) &#123; int res = 1; while (n) &#123; if (n &amp; 1) res = 1ll * res * x % mod; x = 1ll * x * x % mod; n &gt;&gt;= 1; &#125; return res;&#125;void solve() &#123; int n; std::cin &gt;&gt; n; std::cout &lt;&lt; quickPow(2, n - 1) - 1 &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; 「1007 」 foreverlasting and fried-chicken 有一说一，比赛的时候这题给我看饿了（正好碰上疯狂星期四）。 枚举全部不同的两个节点，一个作为炸鸡的头，一个作为炸鸡的尾，假设两个节点共同一步可达的节点数为 \\(cnt\\)，则炸鸡的躯干一共有 \\(C_{cnt} ^ 4\\) 种取法，对于炸鸡尾部的两个节点，将从与尾部节点相邻的其余节点中选取，一共 \\(C_{x - 4} ^ 2\\) 中取法（\\(x\\) 在这里表示与尾部节点相邻且不为头节点的节点数），最后枚举求和即可，时间复杂度为 \\(O(n ^ 3)\\) ，对于题目的数据量而言是会超时的，所以这里考虑 bitset 优化。 时间复杂度：\\(O(\\frac{n ^ 3}{w})\\) 空间复杂度：\\(O(n ^ 2)\\) bitset 讲解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;bitset&gt;#define MAX_N 1005using i64 = long long;const int mod = 1000000007;inline int c2(int n) &#123; if (n &lt; 2) return 0; return (i64)n * (n - 1) / 2 % mod;&#125;inline int c4(int n) &#123; if (n &lt; 4) return 0; return (i64)n * (n - 1) * (n - 2) * (n - 3) / 24 % mod;&#125;std::bitset&lt;MAX_N&gt; g[MAX_N];void solve() &#123; int n, m; std::cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) g[i].reset(); for (int i = 0, x, y; i &lt; m; i++) &#123; std::cin &gt;&gt; x &gt;&gt; y; x--, y--; g[x][y] = g[y][x] = 1; &#125; int res = 0; for (int i = 0; i &lt; n - 1; i++) &#123; for (int j = i + 1; j &lt; n; j++) &#123; int cnt_i = g[i].count(); int cnt_j = g[j].count(); int cnt_and = (g[i] &amp; g[j]).count(); if (g[i][j]) &#123; cnt_i--, cnt_j--; &#125; res = (res + (i64)c4(cnt_and) * (c2(cnt_i - 4) + c2(cnt_j - 4))) % mod; &#125; &#125; std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; 「1011」SPY finding NPY 典中典结论，若前 \\(k\\) 个不选择，则选择到 IQ 最高的对象的概率为 \\(\\sum_{i = k + 1} ^ n \\frac{1}{i - 1} \\frac{k}{n}\\) 。当 \\(n\\) 足够大的的时候，\\(k\\) 大概等于 \\([\\frac{n}{e}]\\) ，考虑到可能会存在误差，所以还需要在此基础上将 \\(k\\) 左右微调。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 在这里时间和空间的开销主要都在预处理上。 最优终止策略讲解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;#include &lt;cmath&gt;#define MAX_N 10005double div_num[MAX_N];const double e = exp(1);void preProcess() &#123; for (int i = 2; i &lt; MAX_N; i++) &#123; div_num[i] = 1.0 / (i - 1); &#125; for (int i = 1; i &lt; MAX_N - 1; i++) &#123; div_num[i] += div_num[i - 1]; &#125;&#125;inline double prob(int n, int k) &#123; if (k == 0) &#123; return 1.0 / n; &#125; return (div_num[n] - div_num[k]) * k / n;&#125;void solve() &#123; int n; std::cin &gt;&gt; n; int k = (int)((n + 0.5) / e); while (k &gt; 0 &amp;&amp; prob(n, k - 1) &gt; prob(n, k)) k--; while (k &lt; n &amp;&amp; prob(n, k + 1) &gt; prob(n, k)) k++; std::cout &lt;&lt; k &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); preProcess(); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; 「1001」Alice Game 我们假设一段长度为 \\(x\\) 的序列的 \\(SG\\) 值为 \\(sg(x)\\) ，若 \\(x &lt;= k\\) ，则先手可以且只能一次将序列全部删除，此时，\\(sg(x) = 1\\) ，若 \\(x &gt; k\\) ，删除长度为 \\(k\\) 的序列后还剩两段不相连的序列，且两段序列互不影响，这事实上就是一种 Nim 游戏，此时有 \\(sg(x) = \\underset{i &gt; 0\\ \\land\\ n - k - i &gt; 0}{mex} \\{ sg(i) \\oplus sg(n - k - i) \\}\\) ，这里的 \\(\\oplus\\) 表示异或。 这样我们就可以求出 \\(sg(n)\\) 的值来判断先手是必胜还是必败了，但对于每一个 \\(k\\) 和 \\(n\\) 都求一次 \\(sg(n)\\) 的话时间开销过大，所以我们考虑打表找规律： 123k = 2: 0 3 13 23 33 43 ...k = 3: 0 4 18 32 46 60 ...k = 4: 0 5 23 41 59 77 ... 以上为不同的 \\(k\\) 满足 \\(sg(n) = 0\\) 的 \\(n\\) 的取值。 不难发现，必败点 \\(n\\) 在 \\(n &gt; 0\\) 的时候构成首项为 \\(k + 1\\) ，公差为 \\(4k + 2\\) 的等差数列。 因此可以大胆估计，当且仅当 \\(n = 0\\) 或者 \\(n \\equiv k + 1\\ (mod\\ 4k + 2)\\) 的时候先手必败，否则先手必胜。 时间复杂度：\\(O(1)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415161718192021#include &lt;iostream&gt;void solve() &#123; int k, n; std::cin &gt;&gt; k &gt;&gt; n; bool ans = (n != 0 ? n % (4 * k + 2) != k + 1 : false); std::cout &lt;&lt; (ans ? &quot;Alice&quot; : &quot;Bob&quot;) &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; 至于这个结论怎么证明，就不得而知了（ACM 要什么证明）。 如果读者感兴趣可以自己试试。","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"杭电多校","slug":"杭电多校","permalink":"http://example.com/tags/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"},{"name":"bitset","slug":"bitset","permalink":"http://example.com/tags/bitset/"}]},{"title":"暑假集训 杭电多校 Round 1","slug":"暑假集训 杭电多校 Round 1","date":"2023-07-18T13:03:26.000Z","updated":"2023-07-26T15:18:10.514Z","comments":true,"path":"2023/07/18/暑假集训 杭电多校 Round 1/","link":"","permalink":"http://example.com/2023/07/18/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%201/","excerpt":"","text":"暑假集训第一次杭电多校。 题目链接 I 「Assertion」 签到题，知道抽屉原理就行了。 时间复杂度：\\(O(1)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415161718192021222324#include &lt;iostream&gt;void solve() &#123; int n, m, d; std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; d; if (d &lt;= (m + n - 1) / n) &#123; std::cout &lt;&lt; &quot;Yes\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;No\\n&quot;; &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; E 「Cyclically Isomorphic」 判断两个字符串 str1 和 str2 是否符合 \"Cyclically Isomarphic\" 的性质，只需要判断 str2 是否是 str1 + str1 的子串即可。 时间复杂度：\\(O(Qm)\\)（重复的查询不计入） 空间复杂度：\\(O(nm)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;void solve() &#123; int n, m, q; std::cin &gt;&gt; n &gt;&gt; m; std::vector&lt;std::string&gt; arr(n); std::vector&lt;std::string&gt; pat(n); for (int i = 0; i &lt; n; i++) &#123; std::string str; std::cin &gt;&gt; str; arr[i] = str; pat[i] = str + str; &#125; std::map&lt;std::pair&lt;int, int&gt;, bool&gt; res; std::cin &gt;&gt; q; for (int i = 0, x, y; i &lt; q; i++) &#123; std::cin &gt;&gt; x &gt;&gt; y; x--; y--; if (x &gt; y) &#123; int tmp = x; x = y; y = tmp; &#125; if (res.find(&#123;x, y&#125;) == res.end()) &#123; res[&#123;x, y&#125;] = pat[x].find(arr[y]) != std::string::npos; &#125; std::cout &lt;&lt; (res[&#123;x, y&#125;] ? &quot;Yes\\n&quot; : &quot;No\\n&quot;); &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; B 「City Upgrading」 树上 DP，选定一个根节点，从叶节点向上 DP，状态转移方程还是比较好想的，如果父节点没有被选取，则至少要有一个子节点被选取。 若父节点被选取，则子节点的子树必须都被覆盖。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using i64 = long long;const i64 inf = 0x7f7f7f7f7f7fll;class Solution &#123;private: std::vector&lt;int&gt; cost; std::vector&lt;std::vector&lt;int&gt;&gt; g; std::vector&lt;std::vector&lt;i64&gt;&gt; dp; // dp[i] 表示 i 以及其子树覆盖的最小花费 // dp[i][0] 表示不选择 i // dp[i][1] 表示选择 i void dfs(int x, int fa) &#123; dp[x][1] = cost[x]; for (int v : g[x]) &#123; if (v != fa) &#123; dfs(v, x); // 只需要一个子树选择父节点即可 dp[x][0] += std::min(dp[v][0], dp[v][1]); i64 res_1 = std::min(dp[v][0], dp[v][1]); // 选择儿子节点 i64 res_2 = 0; for (int sv : g[v]) &#123; if (sv != x) &#123; res_2 += std::min(dp[sv][0], dp[sv][1]); &#125; &#125; // 不选择儿子节点，则需要覆盖该儿子节点的所有孙子子树 dp[x][1] += std::min(res_1, res_2); &#125; &#125; i64 res = dp[x][0]; dp[x][0] = inf; for (int v : g[x]) &#123; // 至少一个子树选择父节点 if (v != fa) &#123; dp[x][0] = std::min(dp[x][0], res - std::min(dp[v][0], dp[v][1]) + dp[v][1]); &#125; &#125; &#125;public: void solve() &#123; int n; std::cin &gt;&gt; n; cost.resize(n); for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; cost[i]; g.resize(n); for (int i = 0, x, y; i &lt; n - 1; i++) &#123; std::cin &gt;&gt; x &gt;&gt; y; x--; y--; g[x].push_back(y); g[y].push_back(x); &#125; dp.resize(n, std::vector&lt;i64&gt;(2, 0)); dfs(0, -1); std::cout &lt;&lt; std::min(dp[0][0], dp[0][1]) &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) Solution().solve(); return 0;&#125; L 「Play on Tree」 给定一颗树，两人轮流删掉一个子树，删掉最后一个节点的人输掉比赛。则叶节点的 SG 值为 0，非叶节点的 SG 值为其所有子节点的 (SG 值 + 1) 的异或和。 对于不同的根节点，可以考虑换根 DP，从而得到每一个节点作为根节点的 SG 值。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstring&gt;using i64 = long long;const int MAX_N = 2e5 + 5;int first[MAX_N];struct &#123; int to; int next;&#125; edges[2 * MAX_N];int cnt = 0;void addEdge(int x, int y) &#123; edges[cnt] = &#123;y, first[x]&#125;; first[x] = cnt++;&#125;int sg1[MAX_N];int sg2[MAX_N];void dfs1(int v, int fa) &#123; sg1[v] = 0; for (int e = first[v]; e != -1; e = edges[e].next) &#123; int x = edges[e].to; if (x == fa) continue; dfs1(x, v); sg1[v] ^= (sg1[x] + 1); &#125;&#125;void dfs2(int v, int fa) &#123; // 换根 for (int e = first[v]; e != -1; e = edges[e].next) &#123; int x = edges[e].to; if (x == fa) continue; sg2[x] = ((sg2[v] ^ (sg1[x] + 1)) + 1) ^ sg1[x]; dfs2(x, v); &#125;&#125;const int mod = 1e9 + 7;int quickPow(int x, int n) &#123; int res = 1; while (n) &#123; if (n &amp; 1) res = (i64)res * x % mod; x = (i64)x * x % mod; n &gt;&gt;= 1; &#125; return res;&#125;void solve() &#123; cnt = 0; memset(first, 0xff, sizeof(first)); int n; std::cin &gt;&gt; n; for (int i = 0, x, y; i &lt; n - 1; i++) &#123; std::cin &gt;&gt; x &gt;&gt; y; x--, y--; addEdge(x, y); addEdge(y, x); &#125; dfs1(0, -1); sg2[0] = sg1[0]; dfs2(0, -1); int res = 0; for (int i = 0; i &lt; n; i++) res += sg2[i] != 0; std::cout &lt;&lt; (i64)res * quickPow(n, mod - 2) % mod &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"杭电多校","slug":"杭电多校","permalink":"http://example.com/tags/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"}]},{"title":"暑假集训 Nowcoder 多校 Round 1","slug":"暑假集训 Nowcoder 多校 Round 1","date":"2023-07-17T12:34:55.000Z","updated":"2023-07-26T15:16:19.325Z","comments":true,"path":"2023/07/17/暑假集训 Nowcoder 多校 Round 1/","link":"","permalink":"http://example.com/2023/07/17/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20Nowcoder%20%E5%A4%9A%E6%A0%A1%20Round%201/","excerpt":"","text":"第一次参加暑假集训的牛客多校，感觉还是挺难的。 比赛链接 D 「Chocolate」 签到题，只有 1 × 1 的时候 Walk Alone 会赢，其余情况均是 Kelin 赢。 时间复杂度：\\(O(1)\\) 空间复杂度：\\(O(1)\\) 12345678910111213141516171819#include &lt;iostream&gt;void solve() &#123; int n, m; std::cin &gt;&gt; n &gt;&gt; m; if (n == 1 &amp;&amp; m == 1) &#123; std::cout &lt;&lt; &quot;Walk Alone\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Kelin\\n&quot;; &#125;&#125;int main() &#123; solve(); return 0;&#125; J 「Roulette」 以 ”输-输-输-输-...-输-赢“ 为一个周期，Walk Alone 的钱只会增加 1 块，且接下来重新从 1 块开始下注。 假设有 x 块钱，且从 1 开始下注的胜率为 \\(p_x\\)，可得： \\[ p_x = (1 - \\frac{1}{2 ^ k}) p_{x + 1} \\] 其中 \\(k\\) 满足：\\(x \\in [2 ^ r - 1, 2 ^ {r + 1} - 1)\\)，接下来只要枚举区间然后使用快速幂即可。 时间复杂度：\\(O(log^2n)\\) 空间复杂度：\\(O(1)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;algorithm&gt;using i64 = long long;const i64 mod = 998244353ll;i64 quickPow(i64 x, i64 n) &#123; i64 res = 1; while (n) &#123; if (n &amp; 1) &#123; res = res * x % mod; &#125; x = x * x % mod; n &gt;&gt;= 1; &#125; return res;&#125;i64 inverse(i64 x) &#123; return quickPow(x, mod - 2);&#125;void solve() &#123; i64 n, m; std::cin &gt;&gt; n &gt;&gt; m; int k = 1; while (n &gt;= (1ll &lt;&lt; (k + 1)) - 1ll) k++; i64 res = 1ll; i64 l = n, r = std::min((1ll &lt;&lt; (k + 1)) - 1ll, n + m); i64 i2 = inverse(2); while (l &lt; n + m) &#123; i64 x = (1 - quickPow(i2, k) + mod) % mod; res = res * quickPow(x, r - l) % mod; l = r; r = std::min(((r + 1ll) &lt;&lt; 1) - 1, n + m); k++; &#125; std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; solve(); return 0;&#125; K 「Subdivision」 先从从顶点 1 出发构造 BFS 树（只延伸 k 步），接下来新增顶点无非有以下两种类型： 加在非树边上的点： 对于非树边而言，无论加多少点，都不会影响到最终结果，假设在非树边 \\(&lt;x, y&gt;\\) 上加入尽可能多的点，则新增到顶点 1 的距离不超过 k 的点有 \\(2 \\times k - dist[x] - dist[y]\\) ，其中 \\(dist[v]\\) 表示 \\(v\\) 到顶点 1 的距离。 加在树边上的点： 假设存在末端节点 \\(v\\) 不与其他非树边相连，则可以延长末端节点，可新增 \\(k - dist[v]\\) 个点。 时间复杂度：\\(O(n + m)\\) 空间复杂度：\\(O(n + m)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;vector&gt;using i64 = long long;void solve() &#123; int n, m, k; std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; std::vector&lt;std::vector&lt;int&gt;&gt; g(n); for (int i = 0, x, y; i &lt; m; i++) &#123; std::cin &gt;&gt; x &gt;&gt; y; x--; y--; g[x].push_back(y); g[y].push_back(x); &#125; std::vector&lt;int&gt; dist(n, -1); dist[0] = 0; std::queue&lt;int&gt; q; q.push(0); i64 cnt = 1ll; // 初始状态有多少距离不超过 k 的点数 std::vector&lt;int&gt; tree(n, -1); // 构造 BFS 树 tree[0] = 0; std::vector&lt;int&gt; endVertex; // BFS 树的末端节点 while (!q.empty()) &#123; int v = q.front(); q.pop(); int d = dist[v] + 1; if (d &gt; k) continue; bool tag = false; for (int x : g[v]) &#123; if (dist[x] == -1) &#123; // 未发现的点 dist[x] = d; q.push(x); cnt++; // d &lt;= k tree[x] = v; tag = true; &#125; &#125; if (!tag) endVertex.push_back(v); // 树的末端 &#125; // 加在非树边上的点 for (int i = 0; i &lt; n; i++) &#123; for (int j : g[i]) &#123; if (i &lt; j &amp;&amp; dist[i] != -1 &amp;&amp; dist[j] != -1 &amp;&amp; tree[i] != j &amp;&amp; tree[j] != i) &#123; cnt += 2ll * k - dist[i] - dist[j]; &#125; &#125; &#125; // 加在树边上的点（树的末端） for (int i : endVertex) &#123; bool tag = false; for (int j : g[i]) &#123; if (dist[i] != -1 &amp;&amp; tree[i] != j) &#123; tag = true; break; &#125; &#125; // 不存在非树边与末端连接 if (!tag &amp;&amp; i != 0) cnt += 1ll * k - dist[i]; &#125; std::cout &lt;&lt; cnt &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); solve(); return 0;&#125; H 「Matches」 假设交换两个下标 \\(i\\) 和 \\(j\\) ，则 \\(\\sum_{k = 1} ^ n |a_k - b_k|\\) 在原来的基础上减小 \\(|a_i - b_i| + |a_j - b_j| - |a_i - b_j| - |a_j - b_i|\\) ，换言之，我们只要能最大化 \\(|a_i - b_i| + |a_j - b_j| - |a_i - b_j| - |a_j - b_i|\\) 即可。 我们将每一对 \\((a_i， b_i)\\) 划分为两类区间： \\([a_i, b_i]\\)，\\((a_i \\leq b_i)\\) \\([b_i, a_i]\\)，\\((a_i &gt; b_i)\\) 问题就转化为我们要找到两个不同的区间，使得 \\(f(i, j) = |a_i - b_i| + |a_j - b_j| - |a_i - b_j| - |a_j - b_i|\\) 的值最大。 事实上，很容易证明当区间属于同一类的时候 \\(f(i, j) \\leq 0\\) ，因此选取的两个区间只能来自不同的类，简单计算可得 \\(f(i, j)\\) 就等于两个区间相交部分的值。 所以我们只需要找到两类区间相交部分的最大值即可。 具体算法实现时可以考虑先枚举两类区间，存储到两个数组，然后分别按照区间左端点大小进行排序，同时使用两个新数组维护两类区间右端点前缀最大值，然后对任意一个区间 \\(r = [x, y]\\) ，在另一类区间数组中使用二分查找找到左区间不超过 \\(x\\) 的最大区间下标，根据前面定义的前缀数组，于是我们就得到了左区间端点不超过 \\(x\\) 的区间里右区间的最大值，通过此方式，我们可以枚举所有可能的最大区间交集。 时间复杂度：\\(O(nlogn)\\) 空间复杂度：\\(O(n)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cmath&gt;using i64 = long long;int binary_search(const std::vector&lt;std::pair&lt;int, int&gt;&gt;&amp; r, int d) &#123; // 找到区间 r[i] 左端点不超过 d 最大 i if (r.empty()) return -1; int left = 0, right = r.size() - 1; // r[left].first &lt;= d &lt; r[right].first if (r[left].first &gt; d) return -1; if (r[right].second &lt;= d) return right; while (right - left &gt; 1) &#123; int mid = (left + right) / 2; if (r[mid].first &lt;= d) &#123; left = mid; &#125; else &#123; right = mid; &#125; &#125; return left;&#125;void solve() &#123; int n; std::cin &gt;&gt; n; std::vector&lt;int&gt; a(n); std::vector&lt;int&gt; b(n); for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; a[i]; &#125; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; b[i]; &#125; std::vector&lt;std::pair&lt;int, int&gt;&gt; r1; std::vector&lt;std::pair&lt;int, int&gt;&gt; r2; for (int i = 0; i &lt; n; i++) &#123; if (a[i] &lt;= b[i]) &#123; r1.push_back(std::make_pair(a[i], b[i])); &#125; else &#123; r2.push_back(std::make_pair(b[i], a[i])); &#125; &#125; int n1 = r1.size(), n2 = r2.size(); std::sort(r1.begin(), r1.end()); std::sort(r2.begin(), r2.end()); std::vector&lt;int&gt; maxrb_1(n1); if (n1 &gt; 0) maxrb_1[0] = r1[0].second; for (int i = 1; i &lt; n1; i++) &#123; maxrb_1[i] = std::max(maxrb_1[i - 1], r1[i].second); &#125; std::vector&lt;int&gt; maxrb_2(n2); if (n2 &gt; 0) maxrb_2[0] = r2[0].second; for (int i = 1; i &lt; n2; i++) &#123; maxrb_2[i] = std::max(maxrb_2[i - 1], r2[i].second); &#125; i64 res = 0; for (int i = 0; i &lt; n1; i++) &#123; int j = binary_search(r2, r1[i].first); if (j == -1) continue; int l = r1[i].first; int r = std::min(r1[i].second, maxrb_2[j]); if (r &gt; l) res = std::max(res, (i64)r - l); &#125; for (int i = 0; i &lt; n2; i++) &#123; int j = binary_search(r1, r2[i].first); if (j == -1) continue; int l = r2[i].first; int r = std::min(r2[i].second, maxrb_1[j]); if (r &gt; l) res = std::max(res, (i64)r - l); &#125; i64 sum = 0; for (int i = 0; i &lt; n; i++) &#123; sum += abs((i64)a[i] - b[i]); &#125; std::cout &lt;&lt; sum - 2 * res &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); solve(); return 0;&#125; M 「Water」 一个比较典型的问题，假设存在解（\\(r\\), \\(s\\)）使得 \\(rA + sB = x\\) 则可以实现 Walk Alone 的需求，使用 exgcd 判断即可。 若不定方程存在解 \\((r, s)\\)，则答案为：\\(max\\{2(r + s), 2|r - s| - 1\\}\\) 。只需要找到使得该式最小的整数解 \\((r, s)\\) 即可。 时间复杂度：\\(O(logn)\\) 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;climits&gt;#include &lt;cmath&gt;using i64 = long long;i64 exgcd(i64 a, i64 b, i64&amp; x, i64&amp; y) &#123; if (b == 0) &#123; x = 1, y = 0; return a; &#125; i64 g = exgcd(b, a % b, y, x); y -= (a / b) * x; return g;&#125;void solve() &#123; i64 a, b, x; std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; x; i64 r, s; i64 g = exgcd(a, b, r, s); if (x % g != 0) &#123; std::cout &lt;&lt; -1 &lt;&lt; &#x27;\\n&#x27;; return; &#125; i64 c = x / g; r *= c, s *= c; // ar + bs = x i64 k1 = b / g, k2 = - a / g; auto minOp = [r, s, k1, k2](i64 t) -&gt; i64 &#123; i64 r0 = r + k1 * t; i64 s0 = s + k2 * t; if (r0 &gt;= 0 &amp;&amp; s0 &gt;= 0) &#123; return 2 * (r0 + s0); &#125; else &#123; return 2 * std::abs(r0 - s0) - 1; &#125; &#125;; i64 res = INT64_MAX; const int ran = 3; for (i64 t0 : &#123;-r / k1, -s / k2&#125;) &#123; for (i64 t = t0 - ran; t &lt;= t0 + ran; t++) &#123; res = std::min(res, minOp(t)); &#125; &#125; std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"}]},{"title":"深度学习鱼书学习笔记","slug":"深度学习鱼书学习笔记","date":"2023-07-10T12:55:04.000Z","updated":"2023-10-12T03:07:55.185Z","comments":true,"path":"2023/07/10/深度学习鱼书学习笔记/","link":"","permalink":"http://example.com/2023/07/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%B1%BC%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"如题，主要记录笔者有关于 Deep Learning 的学习笔记。","text":"神经网络介绍 从感知机到神经网络 感知机（perceptron）是美国学者 Frank Rosenblatt 在 1957 年提出的概念。 感知机可以理解成某个节点，接受一个或者多个信号，输出一个信号。在数字电路中常讨论的各种逻辑门，都可以看成感知机。 以下就是一个简单的感知机的例子： \\[ \\begin{equation} y = \\begin{cases} 0 &amp; (w_1 x_1 + w_2 x_2 \\leq 0) \\\\ 1 &amp; (w_1 x_1 + w_2 x_2 &gt; 0) \\end{cases} \\end{equation} \\] 而神经网络就是由很多层复杂的感知机组合而成的。 一般而言，神经网络由三个主要部分组成： 输入层（Input Layer） 隐藏层（Hidden Layer） 输出层（Output Layer） 一般而言，一个 \\(k\\) 层神经网络有 \\(k - 1\\) 个隐藏层。 Affine 函数 Affine 函数即对上一层节点传输数值作仿射变换，一般是所有数值的线性组合加上一个常量。 \\[ y_i = \\sum_{k = 1} ^ m w_{k, i} x_k + b_i \\] 矩阵乘法表示为： \\[ y = X W + b \\] 激活函数 激活函数（activation function）就是将输入信号转化为输出信号的函数。激活函数的作用在于决定如何来激活输入信号的总和。 下面是几种常见的激活函数： 阶跃函数 \\[ \\begin{equation} h(x) = \\begin{cases} 1 &amp; (x &gt; 0) \\\\ 0 &amp; (x \\leq 0) \\end{cases} \\end{equation} \\] 跃阶函数非常简单，输入值大于 0 时输出 1，否则输出 0。 代码实现： 123def step_function(x): return (x &gt; 0).astype(np.int) Sigmoid 函数 \\[ h(x) = \\frac{1}{1 + exp(-x)} \\] Sigmoid 函数可以将全体实数平滑映射到 \\((0, 1)\\)，在神经网络中被广泛使用。 代码实现： 123def sigmoid(x): return 1 / (1 + np.exp(-x)) 以上提及的两种激活函数都属于非线性函数，神经网络的激活函数必须使用非线性函数，如果激活函数都是线性的，那么不论神经网络有多少层，最后的激活值都是输入值的线性组合，无法发挥神经网络的作用。 ReLU 函数 \\[ \\begin{equation} h(x) = \\begin{cases} x &amp; (x &gt; 0) \\\\ 0 &amp; (x \\leq 0) \\end{cases} \\end{equation} \\] ReLU（Rectified Linear Unit）函数，即线性修正单元函数，当输入值大于 0 时输出输入值本身，否则输出 0。 代码实现： 123def relu(x): return np.maximum(0, x) 输出层设计 神经网络可以用在预测问题和分类问题上，根据我们要解决的问题可以改变输出层的激活函数。 一般而言，预测问题用恒等函数，分类问题用 Softmax 函数。 恒等函数 恒等函数会原样输出信息，不加以任何改动。一般用于像回归这样的预测问题上。 Softmax 函数 \\[ y_k = \\frac{exp(x_k)}{\\sum_{i = 1}^n exp(x_i)} \\] 不难发现，Softmax 函数处理后的向量元素和为 1，由于指数函数爆炸式增长的性质，不同元素的差异会被放大。一般用于分类问题上，使用 Softmax 函数激活输出节点后某个节点的值越大，说明输入输入该类的可能性越大。 代码实现： 1234def softmax(x): exp_x = np.exp(x) return exp_x / np.sum(exp_x) 神经网络代码实现 综上，以下给出一个简单的二层神经网络的实现： 12345678910111213141516class TwoLayersNetWork: def __init__(self, input_size, hidden_size, output_size, init_std = 0.01): self.params = &#123;&#125; self.params[&#x27;W1&#x27;] = init_std * np.random.randn(input_size, hidden_size) self.params[&#x27;b1&#x27;] = init_std * np.random.randn(hidden_size) self.params[&#x27;W2&#x27;] = init_std * np.random.randn(hidden_size, output_size) self.params[&#x27;b2&#x27;] = init_std * np.random.randn(output_size) def forward(self, x): x1 = np.dot(x, self.params[&#x27;W1&#x27;]) + self.params[&#x27;b1&#x27;] x1 = sigmoid(x1) x2 = np.dot(x1, self.params[&#x27;W2&#x27;]) + self.params[&#x27;b2&#x27;] x2 = softmax(x2) return x2 神经网络的学习 神经网络的特征就是可以从数据中学习。所谓从数据中学习，就是根据数据自动决定权重参数的值。 机器学习中，一般将数据分为训练数据和测试数据两部分来进行学习和实验，训练数据也称为监督数据，用来评价模型的泛化能力。 损失函数 损失函数（Loss Function）是用来评判神经网络性能的指标，损失函数可以使用任意函数，但一般用均方误差和交叉熵误差等。 均方误差 均方误差（Mean Squared Error）是非常著名的损失函数，其表达式如下： \\[ E = \\frac{1}{2}\\sum_{k = 1} ^ m (y_k - t_k) ^ 2 \\] 这里 \\(y_k\\) 和 \\(t_k\\) 分别表示神经网络的输出以及正确数据，\\(m\\) 表示数据的维度。 代码实现： 123def mean_squared_error(y, t): return 1 / 2 * np.sum((y - t) ** 2) 交叉熵误差 除了均方误差之外，交叉熵误差（Cross Entropy Error）也经常被用作损失函数。交叉熵误差如下式所示： \\[ E = -\\sum_{k = 1} ^ m t_k\\ ln\\ y_k \\] 这里 \\(y_k\\) 和 \\(t_k\\) 分别表示神经网络的输出以及正确解标签，\\(m\\) 表示数据的维度。对于 \\(t_k\\) 而言，只有正确索引的值为 1，其余都为 0。交叉熵误差一般用作分类问题的损失函数。 代码实现： 1234def cross_entropy_error(y, t): delta = 1e-7 return -np.sum(t * np.log(y + delta)) 这里 delta 是一个微小量，防止出现 log(0) 的情况发生。 Mini-batch 学习 机器学习使用训练数据进行学习，其目标就是找出参数使得损失函数的值尽可能地小。因此，计算损失函数时必须把所有的训练数据作为对象。 假设有 \\(N\\) 个数据数据，那么我们就要求所有训练的损失函数的平均值： \\[ E = \\frac{1}{N} \\sum_{i = 1} ^ N loss(y ^ {(i)}, t ^ {(i)}) \\] 但如果数据量过大，会导致每轮学习的时间开销过大。所以我们考虑 mini-batch 学习，即每次从所有数据集中随机选取批量数据进行学习，每次计算该批次的数据的损失函数的平均值即可。 在具体的代码实现中，我们可以使用 NumPy 中的 np.random.choice() 来随机选取下标。 123batch_mask = np.random.choice(train_size, batch_size)x_batch = x_train[batch_mask]t_batch = t_train[batch_mask] np.random.choice(train_size, batch_size) 返回一个长度为 batch_size ，数据取值范围为 [0, train_size) 的随机正整数数组。 梯度下降法 机器学习的主要任务是在学习时寻找能使损失函数值最小的最优参数。一般而言，损失函数很复杂，参数空间庞大，很难用常规方式求解最小值。 这里我们给出梯度下降法（Gradient Descent Method）： 从数学的角度出发，函数的梯度的方向代表函数增加最快的方向，其反方向就是函数减小的最快方向，极值点梯度为 0，所以我们可以在每一轮迭代中让参数往梯度方向减小，从而找到极小值点。 123456789101112131415def numerical_gradient(f, x): &#x27;&#x27;&#x27; 数值法求解梯度下降法 &#x27;&#x27;&#x27; delta = 1e-5 grads = np.zeros_like(x) for idx, val in np.ndenumerate(x): x[idx] = val + delta f1 = f(x) x[idx] = val - delta f2 = f(x) grads[idx] = (f1 - f2) / (2 * delta) x[idx] = val return grads 每轮迭代的数学表示如下： \\[ x_i := x_i - \\eta \\frac{\\partial f}{\\partial x_i} \\] 其中，\\(\\eta\\) 称为学习率（Learning Rate），学习率决定在一次学习中，在多大程度更新参数。 如果我们采用 mini-batch 学习法每次随机选取一批次数据量，并对其损失函数平均值采用梯度下降法，这样的梯度下降我们就称为随机梯度下降（Stochastic Gradient Descent），简称 SGD。 误差反向传播法 数值法求解梯度是严格按照偏导数的定义来的，这样求解固然正确，但对于参数很大的情况下效率过低。其实有一种高效的梯度求解方法，就是误差反向传播法。 计算图 书上花了很多篇幅去讲解什么是计算图以及起作用，笔者认为计算图就是将求导的链式法则进行了一个可视化。 计算图就是通过节点和箭头表示计算过程，如下图： 链式法则和反向传播 以上面的图为例，假设我们知道了 \\(\\frac{\\partial L}{\\partial z}\\) ，根据链式法则可知： \\[ \\begin{array}{} \\frac{\\partial L}{\\partial x} = \\frac{\\partial L}{\\partial z} \\frac{\\partial z}{\\partial x} \\\\ \\frac{\\partial L}{\\partial y} = \\frac{\\partial L}{\\partial z} \\frac{\\partial z}{\\partial y} \\end{array} \\] 不难发现，对于一个计算图而言，其数值是正向传播的，而其导数则是反向传播的。 而神经网络不就恰好是一个这样层层传递的计算图吗？ 所以我们可以利用链式法则的性质快速计算梯度。 各种层的实现 下面给出各种层的反向传播的实现。 ReLU 层 通过 ReLU 激活函数的表达式，不难得出： \\[ \\begin{equation} \\frac{\\partial y}{\\partial x} = \\begin{cases} 1 &amp; (x &gt; 0) \\\\ 0 &amp; (x \\leq 0) \\end{cases} \\end{equation} \\] 代码实现： 12345678910111213141516class Relu: def __init__(self): self.mask = None def forward(self, x): self.mask = (x &lt;= 0) out = x.copy() out[self.mask] = 0 return out def backward(self, dout): dout[self.mask] = 0 dx = dout return dx Sigmoid 层 同理，我们对原式求导： \\[ \\begin{array}{} y = \\frac{1}{1 + exp(-x)} \\\\ \\frac{\\partial y}{\\partial x} = \\frac{exp(x)}{(exp(x) + 1) ^ 2} = y (1 - y) \\end{array} \\] 代码实现： 12345678910111213class Sigmoid: def __init__(self): self.out = None def forward(self, x): out = sigmoid(x) self.out = out return out def backward(self, dout): dx = dout * (1.0 - self.out) * self.out return dx Affine 层 \\[ y = XW + b \\] 这里涉及到矩阵求导，采用分子布局，若已知 \\(\\frac{\\partial L}{\\partial y}\\)，根据链式求导法则，有： \\[ \\frac{\\partial L}{\\partial w_{i, j}} = \\sum_k \\frac{\\partial L}{\\partial y_{k, j}} \\frac{\\partial y_{k, j}}{\\partial w_{i, j}} \\] 代入： \\[ y_{k, j} = \\sum_{t} w_{t, j} x_{k, t} + b_j \\] 可得： \\[ \\frac{\\partial L}{\\partial w_{i, j}} = \\sum_k \\frac{\\partial L}{\\partial y_{k, j}} x_{k, i} \\] \\[ \\implies \\frac{\\partial L}{\\partial W} = X ^ T \\frac{\\partial L}{\\partial y} \\] 同理，有：\\(\\frac{\\partial L}{\\partial X} = \\frac{\\partial L}{\\partial y} W ^ T\\) 而对于 \\(b\\) 而言，我们采取同样的方法： \\[ \\frac{\\partial L}{\\partial b_i} = \\sum_k \\frac{\\partial L}{\\partial y_{k, i}} \\frac{\\partial y_{k, i}}{\\partial b_i} = \\sum_k \\frac{\\partial L}{\\partial y_{k, i}} \\] 这说明 \\(\\frac{\\partial L}{\\partial b}\\) 就等于 \\(\\frac{\\partial L}{\\partial y}\\) 对列求和。 基于以上的数学证明，我们不难写出 Affine 层的代码实现： 1234567891011121314151617181920212223242526class Affine: def __init__(self, W, b): self.W = W self.b = b self.x = None self.dW = None self.db = None def forward(self, x): if x.ndim == 1: self.x = x.reshape((1, x.size)) else: self.x = x out = np.dot(self.x, self.W) + self.b return out def backward(self, dout): if dout.ndim == 1: dout = dout.reshape((1, dout.size)) dx = np.dot(dout, self.W.T) self.dW = np.dot(self.x.T, dout) self.db = np.sum(dout, axis = 0) return dx Softmax-with-Loss 层 顾名思义，Softmax-with-Loss 层就是将 Softmax 层和 Loss 函数层结合在一起，以交叉熵分析为例： 事实上，对于一个用于分类的神经网络，softmax 函数只有在学习的过程中会使用，如果只用于判断某个数据的类别，只需要找到最后一层输出层的最大值即可。而如果是在学习的过程中使用了 softmax 函数，那就意味着马上需要计算其损失函数，于是在这里我们直接将 Softmax 层和 Lost 层看成一个整体。 有意思的是将两层看做一个整体后，其偏导数相当简洁： \\[ \\frac{\\partial E}{\\partial x_i} = - \\frac{\\partial}{\\partial x_i} \\sum_k t_k\\ ln\\ \\frac{exp(x_i)}{\\sum_j exp(x_j)} = \\frac{exp(x_i)}{\\sum_j exp(x_j)} \\sum_k t_k - t_i = y_i - t_i \\] 代码实现： 1234567891011121314151617class SoftmaxWithLoss: def __init__ (self): self.y = None self.t = None def forward(self, x, t): self.t = t self.y = softmax(x) out = cross_entropy_error(self.y, t) return out def backward(self, dout = 1): batch_size = self.t.shape[0] dx = (self.y - self.t) / batch_size return dx MNIST 示例 接下来我们以 MNIST 数据集为例，展示一次完整的机器学习过程。 MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology（NIST）。训练集（training set）由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局的工作人员。测试集（test set）也是同样比例的手写数字数据。 下载 MNIST 训练集与数据预处理 123456789101112131415161718from keras.datasets import mnistfrom PIL import Imageimport numpy as npdef show_img(img): pil_img = Image.fromarray(np.uint8(img)) pil_img.show()def main(): (x_train, t_train), (x_test, t_test) = mnist.load_data() idx = 0 # 打印第一个数据的图形 show_img(x_train[idx]) print(t_train[idx]) # 5if __name__ == &#x27;__main__&#x27;: main() 直接下载的训练数据 x_train 是 (60000, 28, 28) 的三维数组，且元素是 [0, 256) 的正整数，我们要将其降维以及正规化，同时还要将监督数据转化为 one-hot 形式，因此在训练前要对数据进行预处理： 12345678def pre_process(x, t): shape = x.shape x_pro = x.reshape(shape[0], shape[1] * shape[2]) / float(255) t_pro = np.zeros((t.size, 10), dtype = np.float64) for i in range(t.size): t_pro[i, t[i]] = 1 return x_pro, t_pro 1234567(x_train, t_train), (x_test, t_test) = mnist.load_data()# 数据预处理x_train, t_train = pre_process(x_train, t_train)x_test, t_test = pre_process(x_test, t_test)print(x_train.shape) # (60000, 784)print(t_train.shape) # (60000, 10) 基于反向传播的二层神经网络实现 基于先前得到的理论，我们在此处实现一个简单的神经网络： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class TwoLayerNetWork: def __init__(self, input_size, hidden_size, output_size, init_std = 0.01): self.params = &#123;&#125; self.params[&#x27;W1&#x27;] = init_std * np.random.randn(input_size, hidden_size) self.params[&#x27;b1&#x27;] = init_std * np.random.randn(hidden_size) self.params[&#x27;W2&#x27;] = init_std * np.random.randn(hidden_size, output_size) self.params[&#x27;b2&#x27;] = init_std * np.random.randn(output_size) self.layers = OrderedDict() self.layers[&#x27;Affine1&#x27;] = Affine(self.params[&#x27;W1&#x27;], self.params[&#x27;b1&#x27;]) self.layers[&#x27;Relu1&#x27;] = Relu() self.layers[&#x27;Affine2&#x27;] = Affine(self.params[&#x27;W2&#x27;], self.params[&#x27;b2&#x27;]) self.last_layer = SoftmaxWithLoss() def predict(self, x): for layer in self.layers.values(): x = layer.forward(x) return x def loss(self, x, t): y = self.predict(x) return self.last_layer.forward(y, t) def accuracy(self, x, t): y = self.predict(x) y = np.argmax(y, axis = 1 if y.ndim == 2 else 0) t = np.argmax(t, axis = 1 if t.ndim == 2 else 0) return np.sum(y == t) / float(y.size) def numerical_gradient(self, x, t): grads = &#123;&#125; f = lambda w : self.loss(x, t) for key in (&#x27;W1&#x27;, &#x27;b1&#x27;, &#x27;W2&#x27;, &#x27;b2&#x27;): grads[key] = numerical_gradient(f, self.params[key]) return grads def gradient(self, x, t): # forward self.loss(x, t) # backward dout = self.last_layer.backward(1) layers = list(self.layers.values()) layers.reverse() for layer in layers: dout = layer.backward(dout) grads = &#123;&#125; grads[&#x27;W1&#x27;] = self.layers[&#x27;Affine1&#x27;].dW grads[&#x27;b1&#x27;] = self.layers[&#x27;Affine1&#x27;].db grads[&#x27;W2&#x27;] = self.layers[&#x27;Affine2&#x27;].dW grads[&#x27;b2&#x27;] = self.layers[&#x27;Affine2&#x27;].db return grads 这里保留了 numerical_gradient() 方法，主要用于在训练前检测反向传播所求解的梯度是否足够准确。 以 MNIST 数据集为例，我们取前 10 个数据，计算两种梯度求法结果的平均差值： 1234567891011# gradient checkingbatch_size = 10x_batch = x_train[: batch_size]t_batch = t_train[: batch_size]nw = TwoLayerNetWork(input_size = 784, hidden_size = 50, output_size = 10)g1 = nw.gradient(x_batch, t_batch)g2 = nw.numerical_gradient(x_batch, t_batch)for key in g1.keys(): diff = np.average(np.abs(g1[key] - g2[key])) print(key + &#x27;:&#x27; + str(diff)) 控制台输出： 1234W1:3.0029986781580274e-10b1:1.889068461072459e-09W2:3.764107002402314e-09b2:6.041247907677899e-08 误差很小，说明反向传播求解梯度是可行的。 神经网络的学习与测试 我们采取 SGD 对神经网络进行训练，batch_size 设置为 100，迭代数设置为 10000，学习率设置为 0.1，同时我们记录每轮学习的损失函数以及对测试数据预测的准确率。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738def train(x_train, t_train, x_test, t_test): nw = TwoLayerNetWork(input_size = 784, hidden_size = 50, output_size = 10) train_size = x_train.shape[0] batch_size = 100 iter_num = 10000 lr = 0.1 loss_list = [] acc_list = [] for i in range(iter_num): batch_mask = np.random.choice(train_size, batch_size) x_batch = x_train[batch_mask] t_batch = t_train[batch_mask] grads = nw.gradient(x_batch, t_batch) for key in nw.params.keys(): nw.params[key] -= lr * grads[key] loss = nw.loss(x_batch, t_batch) acc = nw.accuracy(x_test, t_test) print(&#x27;iter %d, loss = %lf, acc = %lf&#x27; % (i, loss, acc)) loss_list.append(loss) acc_list.append(acc) plt.subplot(121) plt.xlabel(&#x27;iter_num&#x27;) plt.ylabel(&#x27;loss&#x27;) plt.title(&#x27;iter_num-loss&#x27;) plt.plot(np.arange(0, len(loss_list)), loss_list) plt.subplot(122) plt.xlabel(&#x27;iter_num&#x27;) plt.ylabel(&#x27;acc&#x27;) plt.title(&#x27;iter_num-acc&#x27;) plt.plot(np.arange(0, len(acc_list)), acc_list) plt.show() 结果如下图： 学习的效果总体呈现为先快后慢的趋势，损失函数逐渐趋于 0，预测准确率逐渐趋于 1。在一万次迭代后，预测准确率可以达到约 \\(97 \\%\\) 。这样，我们就完成了 MINIST 数据集的学习过程了。 神经网络学习技巧 更优的梯度下降策略 神经网络的学习目的可以概括为找到使损失函数的值尽可能小的参数。这个过程被称为最优化（Optimization）。 前几章我们讨论了随机梯度下降法（Stochastic Gradient Descent），即 SGD。 本章我们将讨论其他优化的梯度下降法。 SGD 的缺点 如果函数的形状非均向（anisotropic），收敛会很慢。 以函数 \\(f(x, y) = \\frac{1}{100} x^2 + y^2\\) 为例子，我们采取 SGD 方法求其最小值，假设初始值为 \\((-5, 2)\\)。 1234dat = np.array([-5, 2], dtype = np.float64)fun = lambda dat : 1 / 100 * dat[0] ** 2 + dat[1] ** 2for i in range(iter_num): dat -= lr * numerical_grad(fun, dat) 结果如下： 如上图所示，在 100 次迭代后仍然离极小值点 \\((0, 0)\\) 有一定距离，最后参数的移动路径近似于 Z 字形，收敛十分缓慢。 可见，随机梯度下降在本例中效率很低。从数学的层面理解，可以认为是 x 的梯度分量过小导致的。 Momentum Momentum，即动量，相当于我们给梯度下降引入了物理规则，具体算法如下： \\[ \\begin{array}{} v := \\alpha v - \\eta \\frac{\\partial L}{\\partial W} \\\\ W := W + v \\end{array} \\] \\(W\\) 表示参数，\\(v\\) 在这里是一个新的变量，用于表示速度。 \\(\\eta\\) 表示学习率，\\(\\alpha\\) 表示衰减率。不同于常规的梯度下降，动量梯度下降使用速度对参数进行更新，可以使得目标更快朝极小值点移动。 还是以刚才我们讨论的函数为例： 1234567891011121314151617class Momentum: def __init__(self, lr = 0.1, mom = 0.9): self.lr = lr self.mom = mom self.v = None def update(self, params, grads): if self.v is None: self.v = np.zeros_like(params) self.v = self.mom * self.v - self.lr * grads params += self.vfun = lambda dat : 1 / 100 * dat[0] ** 2 + dat[1] ** 2momen = Momentum(lr = 0.2)for i in range(iter_num): momen.update(dat, numerical_grad(fun, dat)) 可见，动量梯度下降路径更为平缓，且在有限次迭代中更快收敛至极小值点。 相较于 SGD，动量梯度下降为何能做到更快收敛呢？ 笔者对此是这样理解的，动量梯度下降是有记忆性的，其引入了一个变量记录参数更新速度，即使函数某个点的梯度在 x 分量上的值很小，但其在 x 分量上的速度始终是增加的，也就是在最后其依然能在 x 分量上快速收敛。而 SGD 是无记忆的，这也就意味着其更新速度只取决于当前的梯度，就容易导致收敛过慢的情况。 AdaGrad 在神经网络的学习中，学习率的选取非常重要。学习率过小，可能导致学习花费时长过多，学习率过大，可能导致学习过程无法收敛。所以我们给出 AdaGrad，即适应性调整学习率的梯度下降。 我们引入学习衰减率（Learning Rate Decay）\\(h\\) ，使得随着学习进行，学习率逐渐减小。 数学表示如下： \\[ \\begin{array}{} h := h + \\frac{\\partial L}{\\partial W} \\odot \\frac{\\partial L}{\\partial W} \\\\ W := W - \\eta \\frac{1}{\\sqrt h} \\frac{\\partial L}{\\partial W} \\end{array} \\] 还是以上述函数为例： 1234567891011121314151617class AdaGrad: def __init__(self, lr = 0.1): self.lr = lr self.h = None def update(self, params, grads): if self.h is None: self.h = np.zeros_like(params) delta = 1e-7 self.h = self.h + grads * grads params -= self.lr / np.sqrt(self.h + delta) * gradsfun = lambda dat : 1 / 100 * dat[0] ** 2 + dat[1] ** 2ada = AdaGrad(lr = 1)for i in range(iter_num): ada.update(dat, numerical_grad(fun, dat)) AdaGrad 的思路其实就是将更新过程中变化较大的参数的学习率降低，从而调整学习的尺寸。整体而言都是先快后慢，但如果无止境地学习，更新速度就会变成 0。为了改善这个问题，可以使用 RMSProp 方法。 关于权重的初始值 权重初始值是否可以设置为 0 ？ 答案是否定的，假设初始状态权重为 0，则第二层神经元会被传递相同的值，第二层神经元全部输入相同的值，这意味着反向传播时第二层的权重会进行相同的更新。这样一来，权重将会维持均一化，为了防止这种情况发生，必须随机生成初始值。 卷积神经网络 整体结构 卷积神经网络（Convolutional Nerual Network），简称 CNN 神经网络，相比于全连接神经网络，CNN 神经网络新出现了卷积（Convolution）层和池化（Pooling）层。 卷积层 卷积运算 卷积层进行的处理就是卷积运算。卷积运算相当于图像处理中的 “滤波器运算”。 如上图，卷积运算以一定间隔滑动滤波器的窗口，每次将滤波器的元素和输入的对应元素相乘然后求和，将这个结果保存到输出的对应位置，就可以得到卷积的结果。 对于 CNN 神经网络而言，卷积运算结束后一般会加上一个偏置，如下图： 填充 在进行卷积运算的处理之前，有时要向输入数据的周围填入固定的数据，比如 0 等，这就称为填充（padding）。通过合适的填充，可以保证卷积运算后的结果相对于输入空间大小不变。 步幅 应用滤波器的位置间隔称为步幅（stride），前面的例子中，滤波器的步幅都为 1，若步幅设置为 2，则滤波器每次移动 2 个像素。 假设输入大小为 \\((H, W)\\)，填充为 \\(P\\) ，步幅为 \\(S\\) ，滤波器大小为 \\((FH, FW)\\) 。 设输出大小为 \\((OH, OW)\\) ，则有： \\[ OH = \\frac{H + 2P - FH}{S} + 1 \\] \\[ OW = \\frac{W + 2P - FW}{S} + 1 \\] 三维数据的卷积运算 相对于二维数据的卷积运算，三维卷积运算除了处理长、宽之外还要处理通道方向。通道方向有多个特征图时，会按照通道进行数据和滤波器的卷积运算，然后相加。 输入数据和滤波器的通道数必须相等，输出数据会得到一张特征图，即通道数为 1 的输出数据。如果要在通道方向也拥有多个卷积运算的输出，就需要多个滤波器。 假设输入数据大小为 \\((C, H, W)\\) ，即通道数为 \\(C\\) ，高为 \\(H\\) ，宽为 \\(W\\) ；滤波器数据大小为 \\((FN, C, FH, FW)\\) ，即滤波器个数为 \\(FN\\) 个，通道数为 \\(C\\) ，高为 \\(FH\\) ，宽为 \\(FW\\) ；则输出数据的大小可以表示为 \\((FN, OH, OW)\\) ，即输出数据的通道数为滤波器的数量 \\(FN\\) 。 池化层 池化是缩小高、宽方向上空间的操作。常见的池化有 Max 池化和 Average 池化。 对于一个 \\(n \\times n\\) 的 Max 池化操作，每次选取一个 \\(n \\times n\\) 的区域，从该区域中取出最大值并记录到最终答案。一般而言，步幅和池化窗口大小会设置为同样的值。 下图演示了一个 \\(2 \\times 2\\) 的池化操作： 池化层具有以下特征： 没有需要学习的参数； 通道数不发生变化； 对微小的位置变化具有鲁棒性。 若输入数据发生微小变化时，池化仍然会返回相同的结果。例如 Max 池化，只要在池化区域内的最大值不发生变化，那么池化就可以吸收数据的偏差，仍然返回相同的结果。 卷积层和池化层的代码实现 4 维数组 由于 CNN 各层间传递的是 4 维数据，所以我们需要用 4 维数组来存储参数： 12x = np.random,rand(n, c, h, w)# 生成 n * c * h * w 的 4 维数组 im2col 技巧 如果只是按照平常的卷积运算，则会出现好几层 for 循环，十分不利于代码的书写，我们可以考虑 im2col 技巧，把输入数据按照滤波器的作用区域进行展开： 此后就可以将卷积运算汇总为一个大的矩阵乘积，而在 Numpy 库中，矩阵计算都进行过高度优化，因此我们可以实现更高效的计算。 代码实现： 1234567891011121314151617181920212223242526272829def im2col(input_data, filter_h, filter_w, stride = 1, pad = 0): &quot;&quot;&quot; Parameters ---------- input_data : 由(数据量, 通道, 高, 长)的4维数组构成的输入数据 filter_h : 滤波器的高 filter_w : 滤波器的长 stride : 步幅 pad : 填充 Returns ------- col : 2维数组 &quot;&quot;&quot; N, C, H, W = input_data.shape out_h = (H + 2 * pad - filter_h) // stride + 1 out_w = (W + 2 * pad - filter_w) // stride + 1 img = np.pad(input_data, [(0, 0), (0, 0), (pad, pad), (pad, pad)], &quot;constant&quot;) col = np.zeros((N, C, filter_h, filter_w, out_h, out_w)) for y in range(filter_h): y_max = y + stride * out_h for x in range(filter_w): x_max = x + stride * out_w col[:, :, y, x, :, :] = img[:, :, y : y_max : stride, x : x_max : stride] col = col.transpose(0, 4, 5, 1, 2, 3).reshape(N * out_h * out_w, -1) return col 卷积层实现 利用上述 im2col 技巧，我们就可以实现卷积层了： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Convolution: def __init__(self, W, b, stride = 1, pad = 0): self.W = W self.b = b self.stride = stride self.pad = pad # 中间数据（backward时使用） self.x = None self.col = None self.col_W = None # 权重和偏置参数的梯度 self.dW = None self.db = None def forward(self, x): FN, C, FH, FW = self.W.shape N, C, H, W = x.shape out_h = 1 + int((H + 2 * self.pad - FH) / self.stride) out_w = 1 + int((W + 2 * self.pad - FW) / self.stride) col = im2col(x, FH, FW, self.stride, self.pad) col_W = self.W.reshape(FN, -1).T out = np.dot(col, col_W) + self.b out = out.reshape(N, out_h, out_w, -1).transpose(0, 3, 1, 2) self.x = x self.col = col self.col_W = col_W return out def backward(self, dout): FN, C, FH, FW = self.W.shape dout = dout.transpose(0, 2, 3, 1).reshape(-1, FN) self.db = np.sum(dout, axis=0) self.dW = np.dot(self.col.T, dout) self.dW = self.dW.transpose(1, 0).reshape(FN, C, FH, FW) dcol = np.dot(dout, self.col_W.T) dx = col2im(dcol, self.x.shape, FH, FW, self.stride, self.pad) return dx 事实上使用 im2col 后的卷积层与 Affine 层的实现是差不多的，这里在反向传播的时候需要使用 im2col 的逆操作 col2im 来恢复数组。 池化层实现 123456789101112131415161718192021222324252627282930313233343536373839class Pooling: def __init__(self, pool_h, pool_w, stride = 1, pad = 0): self.pool_h = pool_h self.pool_w = pool_w self.stride = stride self.pad = pad self.x = None self.arg_max = None def forward(self, x): N, C, H, W = x.shape out_h = int(1 + (H - self.pool_h) / self.stride) out_w = int(1 + (W - self.pool_w) / self.stride) col = im2col(x, self.pool_h, self.pool_w, self.stride, self.pad) col = col.reshape(-1, self.pool_h * self.pool_w) arg_max = np.argmax(col, axis=1) out = np.max(col, axis=1) out = out.reshape(N, out_h, out_w, C).transpose(0, 3, 1, 2) self.x = x self.arg_max = arg_max return out def backward(self, dout): dout = dout.transpose(0, 2, 3, 1) pool_size = self.pool_h * self.pool_w dmax = np.zeros((dout.size, pool_size)) dmax[np.arange(self.arg_max.size), self.arg_max.flatten()] = dout.flatten() dmax = dmax.reshape(dout.shape + (pool_size, )) dcol = dmax.reshape(dmax.shape[0] * dmax.shape[1] * dmax.shape[2], -1) dx = col2im(dcol, self.x.shape, self.pool_h, self.pool_w, self.stride, self.pad) return dx CNN 的代码实现 基于上述讨论，我们就可以实现一个完整的 CNN 神经网络了： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170class SimpleConvNet: &quot;&quot;&quot;简单的ConvNet conv - relu - pool - affine - relu - affine - softmax Parameters ---------- input_size : 输入大小（MNIST的情况下为784） hidden_size_list : 隐藏层的神经元数量的列表（e.g. [100, 100, 100]） output_size : 输出大小（MNIST的情况下为10） activation : &#x27;relu&#x27; or &#x27;sigmoid&#x27; weight_init_std : 指定权重的标准差（e.g. 0.01） 指定&#x27;relu&#x27;或&#x27;he&#x27;的情况下设定“He的初始值” 指定&#x27;sigmoid&#x27;或&#x27;xavier&#x27;的情况下设定“Xavier的初始值” &quot;&quot;&quot; def __init__( self, input_dim=(1, 28, 28), conv_param=&#123;&quot;filter_num&quot;: 30, &quot;filter_size&quot;: 5, &quot;pad&quot;: 0, &quot;stride&quot;: 1&#125;, hidden_size=100, output_size=10, weight_init_std=0.01, ): filter_num = conv_param[&quot;filter_num&quot;] filter_size = conv_param[&quot;filter_size&quot;] filter_pad = conv_param[&quot;pad&quot;] filter_stride = conv_param[&quot;stride&quot;] input_size = input_dim[1] conv_output_size = ( input_size - filter_size + 2 * filter_pad ) / filter_stride + 1 pool_output_size = int( filter_num * (conv_output_size / 2) * (conv_output_size / 2) ) # 初始化权重 self.params = &#123;&#125; self.params[&quot;W1&quot;] = weight_init_std * np.random.randn( filter_num, input_dim[0], filter_size, filter_size ) self.params[&quot;b1&quot;] = np.zeros(filter_num) self.params[&quot;W2&quot;] = weight_init_std * np.random.randn( pool_output_size, hidden_size ) self.params[&quot;b2&quot;] = np.zeros(hidden_size) self.params[&quot;W3&quot;] = weight_init_std * np.random.randn(hidden_size, output_size) self.params[&quot;b3&quot;] = np.zeros(output_size) # 生成层 self.layers = OrderedDict() self.layers[&quot;Conv1&quot;] = Convolution( self.params[&quot;W1&quot;], self.params[&quot;b1&quot;], conv_param[&quot;stride&quot;], conv_param[&quot;pad&quot;], ) self.layers[&quot;Relu1&quot;] = Relu() self.layers[&quot;Pool1&quot;] = Pooling(pool_h = 2, pool_w = 2, stride = 2) self.layers[&quot;Affine1&quot;] = Affine(self.params[&quot;W2&quot;], self.params[&quot;b2&quot;]) self.layers[&quot;Relu2&quot;] = Relu() self.layers[&quot;Affine2&quot;] = Affine(self.params[&quot;W3&quot;], self.params[&quot;b3&quot;]) self.last_layer = SoftmaxWithLoss() def predict(self, x): for layer in self.layers.values(): x = layer.forward(x) return x def loss(self, x, t): &quot;&quot;&quot;求损失函数 参数x是输入数据、t是教师标签 &quot;&quot;&quot; y = self.predict(x) return self.last_layer.forward(y, t) def accuracy(self, x, t, batch_size = 100): if t.ndim != 1: t = np.argmax(t, axis=1) acc = 0.0 for i in range(int(x.shape[0] / batch_size)): tx = x[i * batch_size : (i + 1) * batch_size] tt = t[i * batch_size : (i + 1) * batch_size] y = self.predict(tx) y = np.argmax(y, axis=1) acc += np.sum(y == tt) return acc / x.shape[0] def numerical_gradient(self, x, t): &quot;&quot;&quot;求梯度（数值微分） Parameters ---------- x : 输入数据 t : 教师标签 Returns ------- 具有各层的梯度的字典变量 grads[&#x27;W1&#x27;]、grads[&#x27;W2&#x27;]、...是各层的权重 grads[&#x27;b1&#x27;]、grads[&#x27;b2&#x27;]、...是各层的偏置 &quot;&quot;&quot; loss_w = lambda w: self.loss(x, t) grads = &#123;&#125; for idx in (1, 2, 3): grads[&quot;W&quot; + str(idx)] = numerical_gradient( loss_w, self.params[&quot;W&quot; + str(idx)] ) grads[&quot;b&quot; + str(idx)] = numerical_gradient( loss_w, self.params[&quot;b&quot; + str(idx)] ) return grads def gradient(self, x, t): &quot;&quot;&quot;求梯度（误差反向传播法） Parameters ---------- x : 输入数据 t : 教师标签 Returns ------- 具有各层的梯度的字典变量 grads[&#x27;W1&#x27;]、grads[&#x27;W2&#x27;]、...是各层的权重 grads[&#x27;b1&#x27;]、grads[&#x27;b2&#x27;]、...是各层的偏置 &quot;&quot;&quot; # forward self.loss(x, t) # backward dout = 1 dout = self.last_layer.backward(dout) layers = list(self.layers.values()) layers.reverse() for layer in layers: dout = layer.backward(dout) # 设定 grads = &#123;&#125; grads[&quot;W1&quot;], grads[&quot;b1&quot;] = self.layers[&quot;Conv1&quot;].dW, self.layers[&quot;Conv1&quot;].db grads[&quot;W2&quot;], grads[&quot;b2&quot;] = self.layers[&quot;Affine1&quot;].dW, self.layers[&quot;Affine1&quot;].db grads[&quot;W3&quot;], grads[&quot;b3&quot;] = self.layers[&quot;Affine2&quot;].dW, self.layers[&quot;Affine2&quot;].db return grads def save_params(self, file_name = &quot;params.pkl&quot;): params = &#123;&#125; for key, val in self.params.items(): params[key] = val with open(file_name, &quot;wb&quot;) as f: pickle.dump(params, f) def load_params(self, file_name=&quot;params.pkl&quot;): with open(file_name, &quot;rb&quot;) as f: params = pickle.load(f) for key, val in params.items(): self.params[key] = val for i, key in enumerate([&quot;Conv1&quot;, &quot;Affine1&quot;, &quot;Affine2&quot;]): self.layers[key].W = self.params[&quot;W&quot; + str(i + 1)] self.layers[key].b = self.params[&quot;b&quot; + str(i + 1)]","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"NumPy","slug":"NumPy","permalink":"http://example.com/tags/NumPy/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"}]},{"title":"Div.2 Round 882 总结","slug":"Div.2 Round 882 总结","date":"2023-07-09T07:10:00.000Z","updated":"2023-07-17T11:38:12.032Z","comments":true,"path":"2023/07/09/Div.2 Round 882 总结/","link":"","permalink":"http://example.com/2023/07/09/Div.2%20Round%20882%20%E6%80%BB%E7%BB%93/","excerpt":"","text":"比赛链接 这一场整体下来感觉难度适中，对位运算性质的考查较多，个人感觉 A、B、C 比较简单。 A 「The Man who became a God」 我们不妨假设起初所有村庄都是一个整体，那么 suspicion 的值就是所有相邻村庄的怀疑值差值的绝对值总和，Kars 对村庄进行 \\(k - 1\\) 次分割将其划分为 \\(k\\) 个部分，假设分割村庄 \\((i, i + 1)\\) ，那 suspicion 就在原来的基础上减去一个 \\(|a_i - a_{i +1}|\\) ，要得到最小的 suspicion ，换言之我们只需要找到最大的 \\(k - 1\\) 个相邻元素差值的绝对值即可。 时间复杂度：\\(O(nlogn)\\) 空间复杂度：\\(O(n)\\) 12345678910111213141516171819202122232425262728293031323334#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;numeric&gt;#include &lt;cmath&gt;#define MAX_N 105int arr[MAX_N];int diff[MAX_N];void solve() &#123; int n, k; std::cin &gt;&gt; n &gt;&gt; k; for (int i = 0; i &lt; n; i++) std::cin &gt;&gt; arr[i]; for (int i = 1; i &lt; n; i++) diff[i] = abs(arr[i] - arr[i - 1]); std::sort(diff + 1, diff + n, std::greater&lt;int&gt;()); int s1 = std::accumulate(diff + 1, diff + n, 0); int s2 = std::accumulate(diff + 1, diff + k, 0); std::cout &lt;&lt; s1 - s2 &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; B 「Hamon Odyssey」 注意到，对于正整数 \\(x\\)、\\(y\\) 而言，一定有 \\(x + y \\geq x\\ \\&amp;\\ y\\)，\\((x, y) = (0, 0)\\) 时取等，因此如果合并后的有两个相邻的数不全为 0，则可以继续合并使结果严格减小。 综上所述，我们可以得到： 若所有数的数位与不为 0，那将所有数字合并为一个整体一定最小，且只能将所有数合并为一个整体时取最小值。 若所有数的数位与为 0，则考虑将数组分割为尽可能多的片段，每个片段的所有数的数位与为 0。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;void solve() &#123; int n; std::cin &gt;&gt; n; int res = 0; for (int i = 0, s = 0xffffffff, x; i &lt; n; i++) &#123; std::cin &gt;&gt; x; s &amp;= x; if (!s) &#123; s = 0xffffffff; res++; &#125; &#125; std::cout &lt;&lt; (res == 0 ? 1 : res) &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; C 「Vampiric Powers, anyone?」 不难证明每一次操作得到的数都是某段连续序列的异或值。因此本题只需要找到最大的连续异或值即可。暴力求解显然会超时，所以最开始我想的是怎么用 DP，后面发现 \\((0 \\leq a_i &lt; 2 ^ 8)\\)，也就是说所有数字只有 256 种取值，因此我们使用一个哈希表维护前缀异或即可。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;unordered_set&gt;void solve() &#123; int n; std::cin &gt;&gt; n; std::unordered_set&lt;int&gt; s; s.insert(0); for (int i = 0, r = 0, x; i &lt; n; i++) &#123; std::cin &gt;&gt; x; r ^= x; s.insert(r); &#125; int res = 0; for (int x : s) &#123; for (int y : s) &#123; res = std::max(res, x ^ y); &#125; &#125; std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) solve(); return 0;&#125; D 「Professor Higashikata」 贪心策略，我们假设 \\(f(i)\\) 表示 \\(t(s)[i]\\) 对应原字符串的下标，那么最右策略就是最大化 \\(k\\) 使得 \\(s_{f(0)} = 1、s_{f(1)} = 1, ..., s_{f(k)} = 1\\)。事实上，若存在 \\(i\\) 和 \\(j\\) 满足 \\(f(i) = f(j) \\ (i &lt; j)\\) ，则可以不考虑 \\(f(j)\\) ，因为 \\(s_{f(i)}\\) 和 \\(s_{f(j)}\\) 是一样的，且下标 \\(i\\) 更靠前，若 \\(s_{f(i)} = 1\\) 则必然有 \\(s_{f(j)} = 1\\) ，所以我们只要求每个下标第一次出现的时间顺序即可，然后将其按照从早到晚进行排序，以题目的第二个输入为例： 1234567891011121314151617188 6 10100110105 62 36 85 75 86 83562525841 根据题目依次输入的区间，每个下标的出现时间顺序为 5, 6, 2, 3, 7, 8。 假设原字符串为 \\(str\\)，接下来我们只需要最大化 \\(pat = [str[5]、str[6]、str[2]、str[3]、str[7]、str[8]]\\) 的字典序，即最大化其前缀 1 的数量，其初始状态为 100010，第一次翻转了下标为 3 的字符，\\(str\\) 更新为 10111010，\\(pat\\) 更新为 100110，只需要分别将 \\(str[1]\\)、\\(str[4]\\) 和 \\(str[6]\\)、\\(str[2]\\) 交换位置即可使得 \\(pat\\) 字典序最大，共需要两次操作，不难发现，每次的最小操作数量都等于 \\(pat\\) 在 区间 \\([1, min\\{num\\_of\\_ones,\\ pat.size\\}]\\)（\\(num\\_of\\_ones\\) 表示 \\(str\\) 中有多少个 1）中 0 的个数。 综上所述，完成本题需要两个步骤： 求出每个字符串下标的出现次序。 根据出现次序构造新字符串 \\(pat\\)，每一轮更新后区间 \\([1, min\\{num\\_of\\_ones, pat.size\\}]\\) 中 0 的个数即最小操作数。这一步涉及单点修改和区间查询，可以考虑使用线段树。 时间复杂度：\\(O((n + m + q)logn)\\) 空间复杂度：\\(O(n + m)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;set&gt;class SegTree &#123;private: int n; std::vector&lt;int&gt; tree; void update(int idx, int val, int node, int start, int end) &#123; if (start == end) &#123; tree[node] = val; return; &#125; int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; if (idx &lt;= mid) &#123; update(idx, val, leftNode, start, mid); &#125; else &#123; update(idx, val, rightNode, mid + 1, end); &#125; tree[node] = tree[leftNode] + tree[rightNode]; &#125; int query(int left, int right, int node, int start, int end) &#123; if (start &gt; right || end &lt; left) return 0; if (start &gt;= left &amp;&amp; end &lt;= right) return tree[node]; int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; return query(left, right, leftNode, start, mid) + query(left, right, rightNode, mid + 1, end); &#125;public: SegTree(int _n): n(_n), tree(4 * _n) &#123;&#125; void update(int idx, int val) &#123; update(idx, val, 0, 0, n - 1); &#125; int query(int left, int right) &#123; return query(left, right, 0, 0, n - 1); &#125;&#125;;void solve() &#123; int n, m, q; std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q; std::string str; std::cin &gt;&gt; str; std::vector&lt;int&gt; pat; // 记录在区间内出现过的数，按照第一次出现的时间排序 std::vector&lt;int&gt; pos(n, -1); // 原字符串在 pat 串的索引，-1 表示不存在 std::vector&lt;std::pair&lt;int, int&gt;&gt; ranges; for (int i = 0, l, r; i &lt; m; i++) &#123; std::cin &gt;&gt; l &gt;&gt; r; ranges.push_back(std::make_pair(l - 1, r - 1)); &#125; std::set&lt;int&gt; s; for (int i = 0; i &lt; n; i++) s.insert(i); // s 存储没有目前出现过的数字 for (const auto&amp; r : ranges) &#123; auto iter = s.lower_bound(r.first); // *iter &gt;= r.first std::vector&lt;int&gt; toErase; // 将要删除的数字 while (iter != s.end() &amp;&amp; *iter &lt;= r.second) &#123; toErase.push_back(*iter); pat.push_back(*iter); pos[*iter] = pat.size() - 1; iter++; &#125; for (int x : toErase) &#123; s.erase(x); &#125; &#125; int np = pat.size(); SegTree st(np); for (int i = 0; i &lt; np; i++) st.update(i, str[pat[i]] == &#x27;1&#x27;); int cntOne = 0; // 1 的数量 for (char ch : str) cntOne += ch == &#x27;1&#x27;; for (int i = 0, p; i &lt; q; i++) &#123; std::cin &gt;&gt; p; int idx = pos[p - 1]; // 对应的 pat 串下标 if (str[p - 1] == &#x27;1&#x27;) &#123; str[p - 1] = &#x27;0&#x27;; cntOne--; if (idx != -1) st.update(idx, 0); &#125; else &#123; str[p - 1] = &#x27;1&#x27;; cntOne++; if (idx != -1) st.update(idx, 1); &#125; int d = std::min(np, cntOne); std::cout &lt;&lt; d - st.query(0, d - 1) &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); solve(); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"},{"name":"Div.2","slug":"Div-2","permalink":"http://example.com/tags/Div-2/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"前缀异或","slug":"前缀异或","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%BC%82%E6%88%96/"},{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"哈尔滨避暑记","slug":"哈尔滨避暑记","date":"2023-07-05T15:38:31.000Z","updated":"2023-09-06T17:24:50.979Z","comments":true,"path":"2023/07/05/哈尔滨避暑记/","link":"","permalink":"http://example.com/2023/07/05/%E5%93%88%E5%B0%94%E6%BB%A8%E9%81%BF%E6%9A%91%E8%AE%B0/","excerpt":"","text":"4 号晚上到哈尔滨的火车，本想着睡一觉起来就到了，奈何卧铺实在是睡得不舒服，又挤又热，半夜还有个哥们抖音外放，显然晚上是睡不着了，就这样熬了一晚上，次日凌晨终于到了哈尔滨站。 中央大街 我们的酒店离中央大街只有不到两百米的距离，而许多景区又都是辐射性分布在中央大街附近的，故颇为便利。 中央大街街景，一股浓浓的俄式风格 工艺品商店一角的俄罗斯套娃 中央大街有一处很显眼的拜占庭风建筑，那便是坐落于索菲亚广场的圣 · 索菲亚教堂，现在已经完全对游客开放了。 再来说下这个俄餐，都是硬菜，量还不小，只能说很符合我对战斗民族的想象。😆 然后就是推荐品尝一下这里的鲜酿格瓦斯（到处都有），有一股独特的清香和甘甜，毕竟离原产地更近，那肯定也更正宗一些。 沿江夜骑 731 罪证陈列馆","categories":[{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"}],"tags":[{"name":"哈尔滨","slug":"哈尔滨","permalink":"http://example.com/tags/%E5%93%88%E5%B0%94%E6%BB%A8/"}]},{"title":"Educational Div.2 Round 151 总结","slug":"Educational Div.2 Round 151 总结","date":"2023-07-01T03:08:48.000Z","updated":"2023-07-10T08:11:07.990Z","comments":true,"path":"2023/07/01/Educational Div.2 Round 151 总结/","link":"","permalink":"http://example.com/2023/07/01/Educational%20Div.2%20Round%20151%20%E6%80%BB%E7%BB%93/","excerpt":"","text":"比赛链接 A 「Forbidden Integer」 这个没啥好说的，分类讨论一下就行。 时间复杂度：\\(O(1)\\) 空间复杂度：\\(O(1)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;void solve() &#123; int n, k, x; std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x; if (x != 1) &#123; std::cout &lt;&lt; &quot;YES\\n&quot; &lt;&lt; n &lt;&lt; &#x27;\\n&#x27;; for (int i = 0; i &lt; n; i++) std::cout &lt;&lt; 1 &lt;&lt; &quot; \\n&quot;[i == n - 1]; return; &#125; // x == 1 if (k == 1) &#123; std::cout &lt;&lt; &quot;NO\\n&quot;; return; &#125; if (k == 2) &#123; if (n &amp; 1) &#123; std::cout &lt;&lt; &quot;NO\\n&quot;; return; &#125; else &#123; std::cout &lt;&lt; &quot;YES\\n&quot; &lt;&lt; n / 2 &lt;&lt; &#x27;\\n&#x27;; for (int i = 0; i &lt; n; i += 2) &#123; std::cout &lt;&lt; 2 &lt;&lt; &quot; \\n&quot;[i == n - 2]; &#125; return; &#125; &#125; // k &gt;= 3 if (n == 1) &#123; std::cout &lt;&lt; &quot;NO\\n&quot;; return; &#125; // n &gt;= 2 std::cout &lt;&lt; &quot;YES\\n&quot; &lt;&lt; n / 2 &lt;&lt; &#x27;\\n&#x27;; while (n) &#123; if (n &amp; 1) &#123; n -= 3; std::cout &lt;&lt; 3 &lt;&lt; &quot; \\n&quot;[n == 0]; &#125; else &#123; n -= 2; std::cout &lt;&lt; 2 &lt;&lt; &quot; \\n&quot;[n == 0]; &#125; &#125;&#125;int main() &#123; int numTest; std::cin &gt;&gt; numTest; while (numTest--) &#123; solve(); &#125; return 0;&#125; B 「Come Together」 这个也没啥好说的，只需要看 B、C 和 A 的相对位置然后分类讨论一下即可。 时间复杂度：\\(O(1)\\) 空间复杂度：\\(O(1)\\) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;iostream&gt;#include &lt;cmath&gt;using i64 = long long;void solve() &#123; int xa, ya, xb, yb, xc, yc; std::cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb &gt;&gt; xc &gt;&gt; yc; xb -= xa, xc -= xa; yb -= ya, yc -= ya; int res = 1; bool same_x = (i64)xb * xc &gt;= 0; bool same_y = (i64)yb * yc &gt;= 0; if (same_x) &#123; // xb xc 同号 if (same_y) &#123; res += std::min(abs(xb), abs(xc)) + std::min(abs(yb), abs(yc)); &#125; else &#123; res += std::min(abs(xb), abs(xc)); &#125; &#125; else &#123; // xb xc 异号 if (same_y) &#123; res += std::min(abs(yb), abs(yc)); &#125; &#125; std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) &#123; solve(); &#125; return 0;&#125; C 「Strong Password」 考虑贪心策略，每一次从限定条件中选取最晚在 database string 中出现的字符，这样可以尽可能快地消耗掉 database string 的前缀，如果中途出现了后缀中不存在的限定条件内的字符，则说明存在答案，反之说明不存在。 为了记录 database string 所有后缀中字符的出现时间，我们需要一个数组来维护每个后缀所有字符出现的最小索引。 时间复杂度：\\(O(nm)\\) 空间复杂度：\\(O(nm)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;#define INF 0x7f7f7f7fvoid solve() &#123; std::string dat; std::cin &gt;&gt; dat; int n; std::cin &gt;&gt; n; std::string l, r; std::cin &gt;&gt; l &gt;&gt; r; int len = dat.size(); // 记录区间 [i, len - 1] 中每个数出现的最早下标 std::vector&lt;std::vector&lt;int&gt;&gt; nextIdx(len + 1); nextIdx.back() = std::vector&lt;int&gt;(10, INF); for (int i = len - 1; i &gt;= 0; i--) &#123; nextIdx[i] = nextIdx[i + 1]; nextIdx[i][dat[i] - &#x27;0&#x27;] = i; &#125; int p = 0; for (int i = 0; i &lt; n; i++) &#123; p = *std::max_element(nextIdx[p].begin() + l[i] - &#x27;0&#x27;, nextIdx[p].begin() + r[i] - &#x27;0&#x27; + 1) + 1; // 找到最晚出现的数字 if (p &gt;= INF) &#123; // 出现无法找到的数字 std::cout &lt;&lt; &quot;YES\\n&quot;; return; &#125; &#125; std::cout &lt;&lt; &quot;NO\\n&quot;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) &#123; solve(); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"},{"name":"Div.2","slug":"Div-2","permalink":"http://example.com/tags/Div-2/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"分类讨论","slug":"分类讨论","permalink":"http://example.com/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"}]},{"title":"CodeTon Round 5 总结","slug":"CodeTon Round 5 总结","date":"2023-06-28T13:08:28.000Z","updated":"2023-07-10T08:11:25.574Z","comments":true,"path":"2023/06/28/CodeTon Round 5 总结/","link":"","permalink":"http://example.com/2023/06/28/CodeTon%20Round%205%20%E6%80%BB%E7%BB%93/","excerpt":"","text":"比赛链接 这一场打得一般，因为太困了。😢 A 「Tenzing and Tsondu」 水题，易证总和高的人必胜，总和相等则平局。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(1)\\) 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using i64 = long long;void solve() &#123; int n, m; std::cin &gt;&gt; n &gt;&gt; m; i64 sum_1 = 0, sum_2 = 0; for (int i = 0, x; i &lt; n; i++) &#123; std::cin &gt;&gt; x; sum_1 += x; &#125; for (int i = 0, x; i &lt; m; i++) &#123; std::cin &gt;&gt; x; sum_2 += x; &#125; if (sum_1 &gt; sum_2) &#123; std::cout &lt;&lt; &quot;Tsondu\\n&quot;; &#125; else if (sum_1 &lt; sum_2) &#123; std::cout &lt;&lt; &quot;Tenzing\\n&quot;; &#125; else &#123; std::cout &lt;&lt; &quot;Draw\\n&quot;; &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) &#123; solve(); &#125; return 0;&#125; B 「Tenzing and Books」 根据题意，如果某本书的 knowledge 某个 bit 位为 1 而 x 在该位为 0，即满足 knowledge &amp; ~x 非 0，则该书一定不能选取，根据栈的性质，该书以下的书也不能选取。 而或运算对于 3 个栈的操作顺序本身而言没有影响，所以我们依次遍历每个栈即可，如果遍历过程中出现不能选择的书，那么就结束该轮循环，进入下一个栈，3 轮循环中如果出现某个状态等于 x ，则说明可以使得 knowledge 的值等于 x ，若 3 轮循环结束后都没有得到目标答案，则说明无法使得 knowledge 的值等于 x 。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#define MAX_N 100005int stk[3][MAX_N];void solve() &#123; int n, x; std::cin &gt;&gt; n &gt;&gt; x; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; std::cin &gt;&gt; stk[i][j]; &#125; &#125; int mask = ~x, ans = 0; if (x == 0) &#123; std::cout &lt;&lt; &quot;Yes\\n&quot;; return; &#125; for (int i = 0; i &lt; 3; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (stk[i][j] &amp; mask) break; ans |= stk[i][j]; if (ans == x) &#123; std::cout &lt;&lt; &quot;Yes\\n&quot;; return; &#125; &#125; &#125; std::cout &lt;&lt; &quot;No\\n&quot;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) &#123; solve(); &#125; return 0;&#125; C 「Tenzing and Balls」 若存在 \\(i、 j、 m、 n\\) 使得 \\(a_i = a_j\\) 且 \\(a_m = a_n\\) ，则考虑区间 \\([i, j]\\) 和 \\([m, n]\\) ： 若两个区间无交集，则两个区间都可以删除且互不影响； 若两个区间是包含关系，不妨设 \\([i, j] \\subsetneq [m, n]\\)，则 \\([i, j]\\) 只能在 \\([m, n]\\) 之前删除，而删除 \\([i, j]\\) 再删除 \\([m, n]\\) 与直接删除 \\([m, n]\\) 的效果是一样的； 若两个区间相交且不为包含关系，则只能删除其中一个区间。 综上所述，问题就变成了如何选取不相交的区间，使得选取的区间总长度最长。 我们假设 \\(dp[i]\\) 表示区间 \\([0, i]\\) 删除完后剩下来的数的最小值，\\(dp[0]\\) 初始化为 1，我们可以得到以下关系： 若不删除 \\(a_i\\) ，则 \\(dp[i] = dp[i - 1] + 1\\) 若能删除 \\(a_i\\) ，则 \\(dp[i] = \\underset{j}{min}\\ \\{dp[j]\\ |\\ j &lt; i - 1 \\land a_{j + 1} = a_i \\}\\) 于是，我们就得到了状态转移方程：\\(dp[i] = min\\{dp[i - 1] + 1,\\ \\underset{j}{min}\\ \\{dp[j]\\ |\\ j &lt; i - 1 \\land a_{j + 1} = a_i \\}\\) 而对于 \\(\\underset{j}{min}\\ \\{dp[j]\\ |\\ j &lt; i - 1 \\land a_{j + 1} = a_i \\}\\) 这一项，我们考虑使用一个数组更新每轮迭代后满足 \\(a_{j + 1} = a_i\\) 的最小 \\(dp[j]\\) 的值即可。迭代完后 \\(n - dp[n - 1]\\) 即为可删除的最大数量。 时间复杂度：\\(O(n)\\) 空间复杂度：\\(O(n)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;cstring&gt;#define MAX_N 200005int arr[MAX_N];int dp[MAX_N]; // 最少剩多少个int memo[MAX_N]; // memo[t] 表示满足 arr[j + 1] == t 的所有数里面 dp[j] 的最小值void solve() &#123; int n; std::cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; arr[i]; dp[i] = i + 1; &#125; memset(memo + 1, 0x7f, n * sizeof(int)); memo[arr[0]] = 0; for (int i = 1; i &lt; n; i++) &#123; dp[i] = std::min(dp[i - 1] + 1, memo[arr[i]]); memo[arr[i]] = std::min(memo[arr[i]], dp[i - 1]); &#125; std::cout &lt;&lt; n - dp[n - 1] &lt;&lt; &#x27;\\n&#x27;;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); int numTest; std::cin &gt;&gt; numTest; while (numTest--) &#123; solve(); &#125; return 0;&#125; D 「Tenzing and His Animal Friends」 题目有点抽象，大概就是说全部轮游戏中 \\(u_i\\) 和 \\(v_i\\) 的分开游戏时间总和均不超过 \\(y_i\\)，即 \\(u_i\\) 不和 \\(v_i\\) 玩的游玩时间不超过 \\(y_i\\) ，对 \\(v_i\\) 也是同理。于此同时，顶点 1 每轮游戏都要参加，顶点 n 每轮游戏都不能参加。 我们接下来将所有的限制看成一个无向图，若存在限制 \\((u_i, v_i, y_i)\\)，那么就在顶点 \\(u_i\\) 和 \\(v_i\\) 之间连接一条权重为 \\(y_i\\) 的边。 考虑以下两种情况： 若顶点 1 无法在有限步内到顶点 n，就说明顶点 1 和顶点 n 属于不同的分支，那我们每次可以和顶点 1 所在分支全部顶点一起玩，且没有时间限制。此时答案为 inf 。 若顶点 1 可以到达顶点 n，我们假设其中一条路径为 \\(&lt;1, k_1, k_2, ..., k_m, n&gt;\\) ，每个顶点的游玩时间为 \\(t_1, t_{k_1}, t_{k_2}, ..., t_{k_m}, t_n\\)。 因为顶点 1 每轮游戏都参与，所以顶点 1 游玩的时间就是总的游戏时间，因此我们只要求出 \\(t_1\\) 的最小值即可。 由于一对顶点 \\((x, y)\\) 分开的时间不超过 \\(d(x, y)\\)，我们可以得到：\\(t_x - t_y \\leq d(x, y)\\)。 所以有： \\[ \\begin{array}{} t_1 - t_{k_1} \\leq d(1, k_1) \\\\ t_{k_1} - t_{k_2} \\leq d(k_1, k_2) \\\\ ... \\\\ t_{k_m} - t_{n} \\leq d(k_m, n) \\end{array} \\] 将上式求和： \\[ \\implies t_1 - t_n \\leq d(1, k_1) + d(k_1, k_2) + ... + d(k_m, n) \\] 又因为顶点 n 不参与游戏，所以 \\(t_n = 0\\)，综上所述： \\[ t_1 \\leq d(1, k_1) + d(k_1, k_2) + ... + d(k_m, n) \\] 右式其实就是顶点 1 到顶点 n 的路径长度，换言之，游戏的时长必须小于等于所有顶点 1 到顶点 n 的路径长度。所以我们只要求出顶点 1 到顶点 n 到最短路径即可，考虑最小堆优化的 Dijkstra 算法，并用一个数组记录每次出队列的顶点。 时间复杂度：\\(O(mlog(m + n))\\) 空间复杂度：\\(O(n + m)\\) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;queue&gt;using i64 = long long;void solve() &#123; int n, m; std::cin &gt;&gt; n &gt;&gt; m; std::vector&lt;std::vector&lt;std::pair&lt;int, int&gt;&gt;&gt; g(n); for (int i = 0, u, v, y; i &lt; m; i++) &#123; std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; y; u--; v--; g[u].push_back(&#123;v, y&#125;); g[v].push_back(&#123;u, y&#125;); &#125; std::vector&lt;i64&gt; dist(n, -1); std::priority_queue&lt;std::pair&lt;i64, int&gt;, std::vector&lt;std::pair&lt;i64, int&gt;&gt;, std::greater&lt;&gt;&gt; q; q.push(&#123;0, 0&#125;); std::vector&lt;i64&gt; ans; while (!q.empty()) &#123; auto [d, to] = q.top(); q.pop(); if (dist[to] != -1) continue; dist[to] = d; ans.push_back(to); if (to == n - 1) break; for (auto [nxt, w] : g[to]) &#123; q.push(&#123;d + w, nxt&#125;); &#125; &#125; if (dist[n - 1] == -1) &#123; std::cout &lt;&lt; &quot;inf\\n&quot;; return; &#125; std::cout &lt;&lt; dist[n - 1] &lt;&lt; &#x27; &#x27; &lt;&lt; ans.size() - 1 &lt;&lt; &#x27;\\n&#x27;; std::string s(n, &#x27;0&#x27;); for (int i = 1, len = ans.size(); i &lt; len; i++) &#123; s[ans[i - 1]] = &#x27;1&#x27;; std::cout &lt;&lt; s &lt;&lt; &#x27; &#x27; &lt;&lt; dist[ans[i]] - dist[ans[i - 1]] &lt;&lt; &#x27;\\n&#x27;; &#125;&#125;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); solve(); return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"},{"name":"Div.1","slug":"Div-1","permalink":"http://example.com/tags/Div-1/"},{"name":"Div.2","slug":"Div-2","permalink":"http://example.com/tags/Div-2/"},{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://example.com/tags/Dijkstra/"}]},{"title":"二进制集合与状压 DP","slug":"二进制集合与状压 DP","date":"2023-06-28T03:55:33.000Z","updated":"2023-07-10T08:16:24.756Z","comments":true,"path":"2023/06/28/二进制集合与状压 DP/","link":"","permalink":"http://example.com/2023/06/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%9B%86%E5%90%88%E4%B8%8E%E7%8A%B6%E5%8E%8B%20DP/","excerpt":"","text":"二进制集合 二进制集合介绍 利用计算机存储数据的特点，我们可以用二进制数来表示集合。 设一个集合有 n 个元素，则可以使用一个 n bit 的数来表示该集合的所有子集，若该数字第 k 个 bit 位为 1，表示存在该元素，为 0 则说明不存在该元素。 例如，有集合：\\(U = \\{0, 1, 2, 3\\}\\)，则 1111 表示全集 \\(U\\)，0000 表示空集 \\(\\emptyset\\)，1010 表示子集 \\(\\{1, 3\\}\\)。 一般情况下，若要表示的集合元素数量较少，可以直接使用 int 或者 long long 整数来表示，若集合元素的数量大于 64，则可以考虑使用 C++ 中的 std::bitset 来表示，可以参考笔者之前的文章：std::bitset 讲解 。 二进制集合的运算 设有集合 \\(A\\) 和 \\(B\\) ，它们的二进制表示分别为 a 和 b ，则常见的集合运算规则如下： 一元运算 数学表示 二进制集合表示 集合的阶 \\(|A|\\) __builtin_popcount(a)（a 为 int 类）__builtin_popcount(a) （a 为 long long 类）a.count() （a 为 std::bitset 类） 补集 \\(\\overline{A}\\) ~a 二元运算 数学表示 二进制集合表示 集合并 \\(A \\cup B\\) a | b 集合交 \\(A \\cap B\\) a &amp; b 集合差 \\(A - B\\) a &amp; ~b 二进制集合子集的遍历 若集合 \\(X\\) 的二进制表示为 x ，则逆序遍历 \\(X\\) 的非空子集的代码如下： 123for (auto sub = x; sub; sub = (sub - 1) &amp; x) &#123; // s 为 x 的子集&#125; 状态压缩 DP 状态压缩 DP 是一种在动态规划算法中使用的优化技巧。它主要应用于具有指数级别状态数的问题，通过将状态用一个整数表示，从而减少内存空间的使用和提高计算效率。这里所说的用一个整数表示状态，也就是上文提到的二进制集合。 示例 连通两组点的最小成本 123456789101112131415161718192021222324252627class Solution &#123;public: int connectTwoGroups(vector&lt;vector&lt;int&gt;&gt;&amp; cost) &#123; const int inf = 0x3f3f3f3f; int size_1 = cost.size(), size_2 = cost[0].size(); int stateNumber = 1 &lt;&lt; size_2; vector&lt;vector&lt;int&gt;&gt; dp(size_1 + 1, vector&lt;int&gt;(stateNumber, inf)); dp[0][0] = 0; for (int i = 1; i &lt;= size_1; i++) &#123; // 前 i 个点 for (int s = 1; s &lt; stateNumber; s++) &#123; // s 表示状态 for (int k = 0; k &lt; size_2; k++) &#123; if ((s &amp; (1 &lt;&lt; k)) == 0) &#123; // k 不属于 s continue; &#125; dp[i][s] = min(dp[i][s], dp[i][s ^ (1 &lt;&lt; k)] + cost[i - 1][k]); dp[i][s] = min(dp[i][s], dp[i - 1][s] + cost[i - 1][k]); dp[i][s] = min(dp[i][s], dp[i - 1][s ^ (1 &lt;&lt; k)] + cost[i - 1][k]); &#125; &#125; &#125; return dp[size_1][stateNumber - 1]; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"}]},{"title":"NumPy 入门","slug":"NumPy 入门","date":"2023-06-25T11:44:47.000Z","updated":"2023-07-16T02:08:09.337Z","comments":true,"path":"2023/06/25/NumPy 入门/","link":"","permalink":"http://example.com/2023/06/25/NumPy%20%E5%85%A5%E9%97%A8/","excerpt":"","text":"NumPy（Numerical Python）是一个用于科学计算的 Python 库。它提供了高性能的多维数组对象（ndarray），以及处理这些数组的工具。NumPy 是 Python 科学计算生态系统中的核心库，被广泛用于数据分析、统计建模、图像处理、机器学习等领域。 由于 NumPy 的高性能和丰富的功能，它成为了许多科学计算和数据处理的基础库。许多其他的 Python 科学计算库，如 SciPy、 Pandas和 Scikit-learn 等，都建立在 NumPy 的基础上，并通过 NumPy 的 ndarray 对象进行数据交换和共享。 NumPy 官网 导包： 1import numpy 多维数组 NumPy 所有的计算都是围绕着数组进行的，因此在运算之前我们需要将数据转化为数组的形式。这一点与 MATLAB 十分相似，我们可以结合 Octave 的语法来理解 NumPy。 数组的定义 示例： 1234567891011121314151617181920import numpy as npdef main(): arr1 = np.array([1, 2, 3, 4, 5]) arr2 = np.zeros((4, 3)) # 4 行 3 列的全 0 数组 arr3 = np.ones((4, 3)) # 4 行 3 列的全 1 数组 print(arr3.shape) # 得到数组的尺寸，返回一个元组 # 输出：(4, 3) arr4 = np.arange(1, 10) # 得到一个 1 到 10 的递增数组 # arr4 == [1 2 3 4 5 6 7 8 9] arr5 = np.linspace(0, 1, 11) # 得到 0 ～ 1 等间距分布的数组 # arr5 == [0. 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ] arr6 = np.random.rand(2, 2) # 生成一个 2 行 2 列的随机数组，每个元素服从 0 ~ 1 的均匀分布if __name__ == &quot;__main__&quot;: main() 对于 NumPy 而言，数组元素默认是 np.float64 类型，我们也可以指定 dtype 参数来选择数组的类型： 1arr = np.array([1, 2, 3, 4], dtype = np.int64) # 指定数组元素类型为 64 位整数 也可以通过 astype() 函数转化类型： 123arr1 = np.array([1.5, 2.5, 3.2, 4.7])arr2 = arr1.astype(np.int32)# arr2 = [1 2 3 4] 数组的运算 同尺寸的数组可以直接作对应元素的基本运算 123456789arr1 = np.array([1, 2, 3, 4])arr2 = np.array([2, 3, 4, 5])print(arr1 + arr2)print(arr2 - arr1)print(arr1 * arr2)print(arr1 ** arr2)print(arr1 / arr2)print(arr2 // arr1) 控制台输出： 123456[3 5 7 9][1 1 1 1][ 2 6 12 20][ 1 8 81 1024][0.5 0.66666667 0.75 0.8 ][2 1 1 1] 其他运算 123456789101112131415print(np.dot(arr1, arr2)) # 点乘# 输出：40a = np.array([[1, 2],[3, 4]])b = np.array([[1], [3]])print(a @ b) # 矩阵乘法，等同于 np.matmul() 函数# 输出：# [[ 7]# [15]]# NumPy 中的数组也可以像 MATLAB 那样直接做函数的参数，返回同尺寸的矩阵，矩阵所有元素是原先元素在该函数下的返回值print(np.sqrt(a))# 输出：# [[1. 1.41421356]# [1.73205081 2. ]] 注意： 对于 dot() 函数而言，如果两个参数是一维数组，那就会计算两个数组的点积；如果是两个二维数组，那就会计算矩阵的乘积；如果第一个参数是多维数组，第二个参数是一维数组，则会利用广播操作来计算点积。 广播 广播（broadcasting），指 NumPy 可以对不同形状的数组进行运算，通过广播机制，使得形状不同的数组可以进行逐元素的操作，而无需显式循环。 获取数组元素 对于 2 维数组 arr 而言，获取 i 行 j 列的元素的语法如下： 1arr[i, j] 也可以按条件查找： 1arr[arr &gt; 0] # 列举所有大于 0 的元素 注意： 条件语句中的与用 &amp; 表示，或用 | 表示。 数组切片 123arr = np.array([[1, 2],[3, 4]])print(arr[0, 0 : 2])# [1 2] start : end : step 启始索引：终止索引：步长 步长在这里可以为负数 : 单个 : 表示全部元素 数组压缩 在 NumPy 中，可以使用 flatten() 或 ravel() 函数将多维数组压缩成一维数组。 1234567891011121314import numpy as np# 创建一个多维数组arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])# 使用 flatten() 函数压缩成一维数组arr_flattened = arr.flatten()print(arr_flattened)# 输出: [1 2 3 4 5 6 7 8 9]# 使用 ravel() 函数压缩成一维数组arr_raveled = arr.ravel()print(arr_raveled)# 输出: [1 2 3 4 5 6 7 8 9] 或者使用 reshape() 函数： 12345678910111213141516171819202122import numpy as np# 三维数组arr = np.array([ [[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]])# 获取数组的形状shape = arr.shapeprint(shape)# 输出: (2, 2, 3)# 将三维数组转换成二维数组arr_reshaped = arr.reshape((shape[0], shape[1] * shape[2]))print(arr_reshaped)# 输出:# [[ 1 2 3 4 5 6]# [ 7 8 9 10 11 12]] 数组拼接 在 NumPy 中，你可以使用 numpy.concatenate() 函数来实现两个矩阵的左右或上下拼接。 下面是两种常用的方法示例： 左右拼接（水平拼接）： 1234567891011import numpy as npmatrix1 = np.array([[1, 2], [3, 4]])matrix2 = np.array([[5, 6], [7, 8]])result = np.concatenate((matrix1, matrix2), axis = 1)print(result) 在这个示例中，我们有两个矩阵 matrix1 和 matrix2。通过使用 np.concatenate() 函数，并将 axis = 1 参数传递给它，我们可以将这两个矩阵在水平方向上拼接起来。输出结果如下： 12[[1 2 5 6] [3 4 7 8]] 上下拼接（垂直拼接）： 1234567891011import numpy as npmatrix1 = np.array([[1, 2], [3, 4]])matrix2 = np.array([[5, 6], [7, 8]])result = np.concatenate((matrix1, matrix2), axis = 0)print(result) 在这个示例中，我们仍然有两个矩阵 matrix1 和 matrix2。通过使用 np.concatenate() 函数，并将 axis = 0 参数传递给它，我们可以将这两个矩阵在垂直方向上拼接起来。输出结果如下： 1234[[1 2] [3 4] [5 6] [7 8]] 无论是左右拼接还是上下拼接，都可以使用 np.concatenate() 函数，并指定合适的 axis 参数来实现。注意，两个矩阵在除了指定拼接方向的轴以外的其他轴上的维度必须是一致的，这样才能成功进行拼接。 综合案例（实现一个简单的三层神经网络）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import numpy as npdef sigmoid(x): return 1 / (1 + np.exp(-x))def softmax(x): exp_x = np.exp(x) return exp_x / np.sum(exp_x)class NetWork: &#x27;&#x27;&#x27; 三层神经网络: - 输入层有 3 个神经元 - 第 1 个隐藏层有 3 个神经元 - 第 2 个隐藏层有 3 个神经元 - 输出层有 2 个神经元 &#x27;&#x27;&#x27; def __init__(self): self.__net = &#123;&#125; self.__net[&#x27;W1&#x27;] = np.array([[0.3, 0.4, 0.5], [0.2, 0.4, 0.6], [0.2, 0.95, 0.7]]) self.__net[&#x27;B1&#x27;] = np.array([0.5, 0.6, 0.4]) self.__net[&#x27;W2&#x27;] = np.array([[0.2, 0.7, 0.6], [0.4, 0.35, 0.6], [0.3, 0.5, 0.45]]) self.__net[&#x27;B2&#x27;] = np.array([0.35, 0.4, 0.9]) self.__net[&#x27;W3&#x27;] = np.array([[0.45, 0.75, 0.15], [0.5, 0.1, 0.2]]) self.__net[&#x27;B3&#x27;] = np.array([1.5, 3]) def forward(self, x: np.array) -&gt; np.float64: w1, w2, w3 = self.__net[&#x27;W1&#x27;], self.__net[&#x27;W2&#x27;], self.__net[&#x27;W3&#x27;] b1, b2, b3 = self.__net[&#x27;B1&#x27;], self.__net[&#x27;B2&#x27;], self.__net[&#x27;B3&#x27;] x1 = np.dot(w1, x) + b1 x2 = np.dot(w2, sigmoid(x1)) + b2 x3 = np.dot(w3, sigmoid(x2)) + b3 return softmax(x3)def main(): n = NetWork() print(n.forward([12, 34, 17])) # [0.2622667 0.7377333] if __name__ == &#x27;__main__&#x27;: main()","categories":[{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"}],"tags":[{"name":"NumPy","slug":"NumPy","permalink":"http://example.com/tags/NumPy/"},{"name":"数值运算","slug":"数值运算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97/"}]},{"title":"CMake 介绍","slug":"CMake 介绍","date":"2023-06-17T02:30:57.000Z","updated":"2023-07-10T08:07:50.846Z","comments":true,"path":"2023/06/17/CMake 介绍/","link":"","permalink":"http://example.com/2023/06/17/CMake%20%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"CMake 简介 CMake 是一个跨平台的构建工具，用于管理和构建 C++ 项目。它的设计目标是提供一种简化的构建过程，使开发人员能够在不同的操作系统和编译器上轻松地生成可执行文件、库和其他构建目标。 CMake 的主要思想是通过描述项目的构建过程来生成构建系统所需的构建脚本。它使用一种称为 CMakeLists.txt 的文本文件来定义项目的目录结构、源文件、编译选项、依赖项和构建规则。CMake 具有很好的跨平台性，可以在多种操作系统上使用，包括 Windows、Linux、macOS 等。它可以生成不同的构建系统文件，如 Makefile、Ninja、Visual Studio 解决方案等，从而使开发人员能够在不同的开发环境中使用适合的构建系统。 总而言之，CMake 简化了跨平台 C++ 项目的构建过程，使开发人员能够更轻松地管理项目的编译和构建，同时提供了灵活性和可扩展性来处理复杂的项目结构和依赖关系。 学习 CMake 的目的，是为将来处理大型的 C / C++ / Java 项目做准备。 CMake 安装 绝大多数 Linux 系统已经安装了 CMake，没有安装的话可以去 CMake 官网 进行安装。 MacOS 也可以用 Homebrew 进行快速安装： 1brew install cmake 构建 CMake 项目 构建 CMake 项目，大致分为 3 个步骤： 创建 CMakeLists.txt 文件 使用 CMake 指令生成 Makefile 文件 使用 make 指令进行编译 一个简单示例 创建一个 demo.cpp ： 12345678#include &lt;iostream&gt;int main() &#123; std::cout &lt;&lt; &quot;Hello world!\\n&quot;; return 0;&#125; 同级目录下创建一个 CMakeLists.txt 文件，输入以下文本： 1234567PROJECT(HELLO)SET(SRC_LIST demo.cpp)MESSAGE(STUTAS &quot;Configuring project...&quot;)ADD_EXECUTABLE(Demo $&#123;SRC_LIST&#125;) 终端下使用 cmake 指令生成 Makefile 文件： 1cmake . 若运行成功，则目录下会生成 Makefile 文件。 使用 make 指令进行编译： 1make 编译成功，则会生成可执行文件 Demo 。 运行 Demo 即可： 1./Demo CMakeLists.txt 基本语法介绍 PROJECT 关键字 PROJECT 关键字用于定义和配置项目。它用于指定项目的名称、版本号和语言。。 PROJECT关键字的基本语法如下： 1PROJECT(&lt;project_name&gt; [VERSION &lt;version&gt;] [LANGUAGES &lt;languages&gt;]) 其中，&lt;project_name&gt; 是要定义的项目名称。&lt;version&gt; 是可选的，用于指定项目的版本号。 &lt;languages&gt; 也是可选的，用于指定项目所使用的编程语言。 以下是一些 PROJECT 关键字的示例用法： 定义一个简单的项目： 1PROJECT(MyProject) 定义一个带有版本号的项目： 1PROJECT(MyProject VERSION 1.0) 定义一个使用多种编程语言的项目： 1PROJECT(MyProject LANGUAGES CXX C) SET 关键字 SET 关键字用于设置变量的值。语法如下： 1SET(&lt;variable&gt; &lt;value&gt; [CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]]) 其中，&lt;variable&gt; 是要设置的变量名，&lt;value&gt; 是要为变量设置的值。&lt;value&gt; 可以是一个字符串、一个列表、一个布尔值或一个数值。SET关键字还支持一些其他选项： CACHE ：指定变量为缓存变量，即用户可以通过CMake的缓存机制进行设置或修改该变量的值。缓存变量的值可以在CMake运行期间持久保存，并在下一次运行时保持不变。 &lt;type&gt; ：指定缓存变量的类型。可以是BOOL、STRING、PATH等类型。 &lt;docstring&gt; ：可选项，用于提供变量的描述文本。 FORCE ：可选项，强制设置变量的值，即使它已经被缓存。 以下是一些 SET 关键字的示例用法： 设置一个字符串变量： 1SET(my_string &quot;Hello, World!&quot;) 设置一个列表变量： 1SET(my_list 1 2 3 4) 设置一个缓存变量： 1SET(my_variable &quot;default value&quot; CACHE STRING &quot;Description of my variable&quot;) 强制设置一个缓存变量的值： 1SET(my_variable &quot;new value&quot; CACHE STRING &quot;Description of my variable&quot; FORCE) 通过 SET 关键字，你可以在 CMake 脚本中设置变量的值，并根据需要使用它们来控制构建过程、传递参数或处理其他逻辑。 变量取值：使用 $&#123;&#125; ，但是在 IF 控制语句中直接使用变量名。 MESSAGE 关键字 在 CMake 中，MESSAGE 是一个用于输出消息的关键字。它允许你在 CMake 脚本中打印信息，以便在构建过程中向用户提供有用的反馈或调试信息。 MESSAGE关键字的语法如下： 1MESSAGE([&lt;mode&gt;] &quot;&lt;message&gt;&quot;) 其中，&lt;mode&gt; 是可选的，用于指定消息的模式。常用的消息模式有以下几种： STATUS ：以普通状态的形式输出消息。 WARNING ：以警告的形式输出消息。 AUTHOR_WARNING ：以作者警告的形式输出消息。 SEND_ERROR ：以错误的形式输出消息，并终止 CMake 的配置过程。 FATAL_ERROR ：以致命错误的形式输出消息，并终止 CMake 的配置过程。 &lt;message&gt; 是要输出的消息内容，可以是一个字符串或一个变量。 以下是一些MESSAGE关键字的示例用法： 输出普通状态消息： 1MESSAGE(STATUS &quot;Configuring project...&quot;) 输出警告消息： 1MESSAGE(WARNING &quot;Warning: Invalid configuration detected.&quot;) 输出错误消息并终止配置过程： 1MESSAGE(SEND_ERROR &quot;Error: Required library not found.&quot;) ADD_EXECUTABLE 关键字 在 CMake 中，ADD_EXECUTABLE 是一个用于添加可执行文件的关键字。它用于指定要构建的可执行文件的名称和源代码文件。 ADD_EXECUTABLE 关键字的语法如下： 1ADD_EXECUTABLE(&lt;executable_name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...]) 其中，&lt;executable_name&gt; 是要生成的可执行文件的名称。[WIN32] 和 [MACOSX_BUNDLE] 是可选的标志，用于指定在 Windows 上构建一个 GUI 应用程序或在 macOS 上构建一个应用程序捆绑包。[EXCLUDE_FROM_ALL] 也是可选的标志，表示该目标不会被默认构建，除非明确要求。 source1 [source2 ...] 是要包含在可执行文件中的源代码文件的列表。可以通过相对或绝对路径指定这些源文件。 以下是 ADD_EXECUTABLE 关键字的示例用法： 1ADD_EXECUTABLE(MyApp main.cpp utils.cpp) 上述示例将创建一个名为 MyApp 的可执行文件，并将 main.cpp 和 utils.cpp 作为源代码文件包含在可执行文件中。 使用 ADD_EXECUTABLE 关键字时，CMake 会自动检测源代码文件的编程语言，并相应地设置编译器和编译选项。 ADD_EXECUTABLE 关键字允许你定义项目中的可执行文件，并指定与之相关的源代码文件。通过 ADD_EXECUTABLE，你可以将源代码文件与特定的可执行文件关联起来，以便在构建过程中生成所需的可执行文件。 ADD_SUBDIRECTORY 关键字 ADD_SUBDIRECTORY 是用于向 CMake 构建系统添加子目录的关键字。它的作用是告诉 CMake 在当前项目中包含另一个目录，并在该子目录中查找并处理另一个 CMakeLists.txt 文件。 ADD_SUBDIRECTORY 的语法如下： 1ADD_SUBDIRECTORY(directory [binary_dir] [EXCLUDE_FROM_ALL]) directory ：要添加的子目录的路径。这个路径可以是相对于当前 CMakeLists.txt 文件的相对路径，也可以是绝对路径。 binary_dir（可选）：指定生成的二进制文件的输出目录。如果不提供，则使用默认值（通常是当前构建目录）。 EXCLUDE_FROM_ALL（可选）：如果指定了这个选项，将会在构建目标时排除这个子目录。这对于包含一些可选的或不常用的子项目很有用。 使用 ADD_SUBDIRECTORY 时，CMake 会进入子目录并处理对应的 CMakeLists.txt 文件。这意味着子目录中可以有自己的构建规则、目标等。通过使用 ADD_SUBDIRECTORY，可以将复杂的项目划分为多个子项目，并使用各自的 CMakeLists.txt 文件进行管理，从而提高项目的组织性和可维护性。 请注意，在使用 ADD_SUBDIRECTORY 之前，通常需要在子目录中准备一个有效的 CMakeLists.txt 文件，以定义子项目的构建规则、目标等。 以下是一个示例，展示如何使用 ADD_SUBDIRECTORY： 1234567# 主项目的 CMakeLists.txt# 添加子目录ADD_SUBDIRECTORY(subdir)# 主项目的构建规则和目标# ... 1234# 子目录的 CMakeLists.txt# 子目录的构建规则和目标# ... 上述示例中，主项目的 CMakeLists.txt 文件使用 ADD_SUBDIRECTORY 添加了一个名为 \"subdir\" 的子目录。然后，CMake 进入子目录并处理对应的 CMakeLists.txt 文件，执行子目录的构建规则和目标的设置。 通过使用 ADD_SUBDIRECTORY ，你可以将项目组织成多个子目录，每个子目录都可以有自己的 CMakeLists.txt 文件，方便地管理和构建大型项目。 INSTALL 关键字 INSTALL 用于定义要安装的文件、目录和相关设置。它用于在构建过程中指定将生成的文件复制到特定位置的规则。 INSTALL 关键字的基本语法如下： 1234567891011121314INSTALL([CODE &lt;code&gt;] [SCRIPT &lt;file&gt;] [SCRIPTS &lt;files&gt;...] [FILES &lt;files&gt;...] [PROGRAMS &lt;files&gt;...] [DIRECTORY &lt;dir&gt;...] [TARGETS &lt;targets&gt;...] [EXPORT &lt;export-name&gt;] [ALIAS &lt;target&gt;] [FILES_MATCHING] [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;] [EXCLUDE] [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]]]... [...]) 下面是 INSTALL 关键字的一些常用选项： CODE &lt;code&gt; ：指定自定义安装逻辑的 CMake 代码。 SCRIPT &lt;file&gt; ：指定一个脚本文件，该脚本文件包含安装逻辑。 SCRIPTS &lt;files&gt;... ：指定多个脚本文件，这些脚本文件包含安装逻辑。 FILES &lt;files&gt;... ：指定要安装的普通文件。 PROGRAMS &lt;files&gt;... ：指定要安装的可执行文件。 DIRECTORY &lt;dir&gt;... ：指定要安装的目录。 TARGETS &lt;targets&gt;... ：指定要安装的构建目标（可执行文件、静态库、共享库等）。 EXPORT &lt;export-name&gt; ：指定要安装的导出目标。 ALIAS &lt;target&gt; ：指定要安装的构建目标的别名。 FILES_MATCHING ：指定在安装文件时进行匹配的模式。 PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt; ：指定文件匹配的模式或正则表达式。 EXCLUDE ：排除匹配的文件。 PERMISSIONS permissions... ：指定安装文件的权限。 CONFIGURATIONS [Debug|Release|...] ：指定仅在特定构建配置下安装文件。 INSTALL 关键字允许您以灵活的方式定义文件和目录的安装规则。可以使用多个 INSTALL 关键字来安装多个文件和目录。例如： 1234567891011121314# CMakeLists.txt# 安装脚本文件和目录INSTALL(SCRIPT my_script.cmake)INSTALL(DIRECTORY my_directory DESTINATION /path/to/destination)# 安装文件INSTALL(FILES file1.txt file2.txt DESTINATION /path/to/destination)# 安装可执行文件INSTALL(PROGRAMS my_program DESTINATION /path/to/destination)# 安装构建目标INSTALL(TARGETS my_target RUNTIME DESTINATION /path/to/destination) 上述示例演示了如何使用 INSTALL 关键字来指定不同类型的文件和目录的安装位置。 cmake 指令 cmake 基本语法： 1cmake [options] &lt;path-to-source&gt; options ：CMake的选项，用于配置生成过程的行为和参数。 &lt;path-to-source&gt; ：CMakeLists.txt 所在的源代码目录路径。 常用选项： -G &lt;generator&gt; ：指定生成器，用于生成特定构建系统的文件（如 Makefile 或 Visual Studio 解决方案）。例如，-G \"Unix Makefiles\" 表示生成 Unix 系统下的 Makefile 文件。 -D &lt;var&gt;=&lt;value&gt; ：设置 CMake 变量的值。例如，-D CMAKE_BUILD_TYPE=Release 设置 CMake 变量 CMAKE_BUILD_TYPE 的值为 Release。 -B &lt;path-to-build&gt; ：指定构建目录的路径。生成的构建系统文件将存储在该目录中。 -S &lt;path-to-source&gt; ：指定源代码目录的路径。 示例用法： 在源代码目录中直接运行CMake（in-source build）： 1cd /path/to/source &amp;&amp; cmake . 在指定的构建目录中运行CMake（out-of-source build）： 1cd /path/to/build &amp;&amp; cmake /path/to/source 指定生成器和构建类型： 1cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release /path/to/source make 指令 Make 是一个常用的构建工具，用于自动化软件项目的编译和构建过程。它使用一个名为Makefile 的文件来定义构建规则和依赖关系，以确定如何生成目标文件（例如可执行文件、库文件等）。 以下是 make 指令的基本语法： 1make [options] [target] 其中，options 是可选的命令行选项，用于控制 make 的行为。target 是要构建的目标，通常是在 Makefile 中定义的一个规则。 常用的 make 选项包括： -f &lt;filename&gt;：指定要使用的 Makefile 文件的名称。如果未指定，则默认使用当前目录下的 Makefile 文件。 -C &lt;dir&gt;：在指定的目录下执行 make 命令。这可以用于指定 Makefile 文件所在的目录。 -j &lt;num&gt;：指定并行构建的作业数，加快构建速度。 在 Makefile 文件中，你可以定义多个目标和规则，每个规则描述了如何根据依赖关系生成目标文件。一个基本的规则结构如下： 1234target: dependencies command1 command2 ... 其中，target 是目标文件的名称，dependencies 是生成目标文件所依赖的文件或目标，commandX 是用于生成目标文件的命令。 以下是一个简单的示例 Makefile 文件的内容： 12hello: main.c hello.c gcc -o hello main.c hello.c 上述示例中，我们定义了一个目标 hello，它依赖于 main.c 和 hello.c 这两个源代码文件。make 指令会检查依赖关系，并在需要时执行相应的命令来生成目标文件。 要使用 make 指令进行构建，只需在终端中进入包含 Makefile 文件的目录，并运行 make 命令。如果没有指定目标，默认会构建第一个目标。 Make 工具基于目标文件和规则之间的依赖关系，通过增量构建的方式进行构建，只重新构建已修改的文件和受其影响的文件，从而提高构建效率。Make 是一个强大而灵活的构建工具，它在软件开发中广泛应用。通过定义适当的规则和依赖关系，可以自动化构建过程，简化项目的管理和部署。 CMake 与 Make 之间的关系可以简述如下： CMake 负责生成适合不同平台和编译器的构建系统文件（如Makefile）。 Make 负责根据 Makefile 中的规则和依赖关系来执行实际的编译和构建操作。 make install 指令 make install 用于将构建生成的文件复制到指定位置，完成软件的安装过程。这个指令通常与 Makefile 文件一起使用，用于定义安装规则。 在 Makefile 中，可以定义一个名为 install 的目标规则，该规则包含安装过程的指令。安装指令通常使用系统的 cp 命令或类似的工具来复制文件或目录到目标位置。 以下是一个示例 Makefile 文件中的 install 规则： 123install: cp myapp /usr/local/bin cp -r resources /usr/local/share/myapp 在上述示例中，install 规则中定义了两个命令。第一个命令使用 cp 命令将 myapp 可执行文件复制到 /usr/local/bin 目录下，第二个命令将 resources 目录递归复制到 /usr/local/share/myapp 目录下。 要执行安装过程，可以在命令行中运行 make install 命令。Make 将读取 Makefile 文件，并根据 install 目标规则中定义的指令来执行安装操作。 需要注意的是，make install 命令通常需要使用超级用户权限（sudo）来执行，因为将文件复制到系统目录通常需要管理员权限。如果没有权限，可以尝试将文件复制到用户的个人目录或其他有权限的目录。 使用 make install 指令可以方便地自动化软件的安装过程，将生成的文件复制到指定位置，使用户可以直接使用已安装的软件。 工程化目录结构 基本目录结构： 12345678910.├─CMakeLists.txt├─README.md├─bulid├─runhello.sh├─doc├─COPYRIGHT├─src├───CMakeLists.txt└───demo.cpp 每个目录下都有一个 CMakeLists.txt ，用于实现 CMake 嵌套。 外层 CMakeLists.txt ： 123PROJECT(HELLO) # 指定项目名称ADD_SUBDIRECTORY(src bin) # 将 src 子目录加入工程并指定编译输出路径为 bin 目录 内层 CMakeLists.txt ： 12345SET(SRC_LIST demo.cpp)MESSAGE(STUTAS &quot;Configuring project...&quot;)ADD_EXECUTABLE(Demo $&#123;SRC_LIST&#125;) # 添加可执行项目 bulid 文件夹：用于存储构建过程中生成的中间文件和最终的构建结果。 src 文件夹：用于存放源代码 doc 文件夹：用于存放文档 COPYRIGHT ：版权 runhello.sh ：安装脚本 构建库 ADD_LIBRARY 关键字 ADD_LIBRARY 是一个用于定义和构建库（Library）目标的关键字。它用于创建静态库（Static Library）、共享库（Shared Library）或模块库（Module Library）的规则，并将源代码文件编译成库文件。 ADD_LIBRARY 关键字的基本语法如下： 123ADD_LIBRARY(&lt;name&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [source1] [source2 ...]) 其中，&lt;name&gt; 指定要创建的库的名称。可以使用自定义名称或者 CMake 的变量作为库的名称。 选项 [STATIC | SHARED | MODULE] 指定库的类型。可以选择其中一种类型： - STATIC：创建静态库。静态库在链接时被静态地链接到可执行文件中。 - SHARED：创建共享库（也称为动态库）。共享库在运行时被动态地加载。 - MODULE：创建模块库（适用于像 Apple 的 macOS 平台）。模块库是一种特殊的共享库类型。 可选项 [EXCLUDE_FROM_ALL] 表示将该库目标从生成的默认目标中排除。 后续的参数 source1、source2 等指定库的源代码文件，可以是单个源文件，也可以是一个文件列表。CMake 将编译这些源代码文件，并生成库文件。 以下是一个示例： 1234567# CMakeLists.txt# 创建静态库ADD_LIBRARY(my_static_lib STATIC source1.cpp source2.cpp)# 创建共享库ADD_LIBRARY(my_shared_lib SHARED source3.cpp source4.cpp) INCLUDE_DIRECTORIES 关键字 INCLUDE_DIRECTORIES 是一个用于指定包含目录的关键字。它用于将一个目录添加到编译器的包含路径中，以使编译器能够找到所需的头文件。 INCLUDE_DIRECTORIES 关键字的基本语法如下： 1INCLUDE_DIRECTORIES([AFTER|BEFORE] directory1 [directory2 ...]) 其中，directory1、directory2 等参数指定要添加到包含路径中的目录。可以指定一个或多个目录。 选项 [AFTER|BEFORE] 控制新目录的添加顺序。默认情况下，新目录会添加到已有包含目录列表的末尾，即在已有包含目录之后。如果指定了 AFTER 选项，新目录将添加到列表的末尾。如果指定了 BEFORE 选项，新目录将添加到列表的开头。 以下是一个示例： 1234567# CMakeLists.txt# 添加包含目录INCLUDE_DIRECTORIES(include_dir1 include_dir2)# 添加包含目录，并将其放置在列表的开头INCLUDE_DIRECTORIES(BEFORE include_dir3)","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"CMake","slug":"CMake","permalink":"http://example.com/tags/CMake/"},{"name":"跨平台项目构建","slug":"跨平台项目构建","permalink":"http://example.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"}]},{"title":"字典树","slug":"字典树","date":"2023-05-16T16:22:35.000Z","updated":"2023-07-24T17:47:36.715Z","comments":true,"path":"2023/05/17/字典树/","link":"","permalink":"http://example.com/2023/05/17/%E5%AD%97%E5%85%B8%E6%A0%91/","excerpt":"","text":"介绍 字典树（Trie），就是像字典一样的树，可用于插入和检索字符串。 假设某字典树只需要存储单词，所有单词均由 26 个小写字母组合而成，那么对于该字典树而言，每个节点都有 27 个域，分别为 26 个子节点（可以为 nullptr ）以及一个布尔标识符，表示是否存在某个单词以该字母结尾。 以下图为例： 该字典树一共存储了 dog、dot、dig、tea、tease、tease 六个单词，其中黄色的节点表示结束节点。 代码实现 在这里还是以 26 个字母组成的单词为例，给出字典树的代码实现。 使用链式节点的字典树模版 123456789101112131415161718192021222324252627282930313233343536373839404142class Trie &#123;private: std::vector&lt;Trie*&gt; child; bool isEnd; Trie* searchPrefix(const std::string&amp; prefix) &#123; Trie* p = this; for (char ch : prefix) &#123; p = p-&gt;child[ch - &#x27;a&#x27;]; if (p == nullptr) return nullptr; &#125; return p; &#125;public: Trie(): child(26, nullptr), isEnd(false) &#123;&#125; ~Trie() &#123; for (Trie* ct : child) &#123; if (ct != nullptr) &#123; delete ct; ct = nullptr; &#125; &#125; &#125; void insert(const std::string&amp; word) &#123; Trie* p = this; for (char ch : word) &#123; if (p-&gt;child[ch - &#x27;a&#x27;] == nullptr) &#123; p-&gt;child[ch - &#x27;a&#x27;] = new Trie(); &#125; p = p-&gt;child[ch - &#x27;a&#x27;]; &#125; p-&gt;isEnd = true; &#125; bool search(const std::string&amp; word) &#123; Trie* p = searchPrefix(word); return p &amp;&amp; p-&gt;isEnd; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"字典树","slug":"字典树","permalink":"http://example.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"}]},{"title":"数据库规范化理论","slug":"数据库规范化理论","date":"2023-05-15T12:45:27.000Z","updated":"2023-07-10T08:17:52.909Z","comments":true,"path":"2023/05/15/数据库规范化理论/","link":"","permalink":"http://example.com/2023/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA/","excerpt":"","text":"什么是数据库规范化？ 数据库规范化（Normalization）是一种数据库设计技术，其旨在实现以下两个主要目标： 减少数据冗余（Redundancy）。 确保数据的依赖性是有意义的，即数据存储是有逻辑的。 函数依赖 基本定义 函数依赖（Functional Dependncy）是规范化中的重要概念，简而言之，函数依赖用于描述属性（Attributes）之间的关系。 概念： 若 \\(A\\) 和 \\(B\\) 是关系模式 \\(R\\) 中的两个属性集合，对于给定的 \\(A\\) 值，都有唯一的 \\(B\\) 值与其对应，我们就称 \\(A\\) 函数决定 \\(B\\)，\\(B\\) 函数依赖于 \\(A\\)，记作：\\(A \\to B\\)，其中 \\(A\\) 称为决定因子（Determinant） 若 \\(A\\) 和 \\(B\\) 相互依赖，即二者一一对应，则记为：\\(A\\) \\(\\leftrightarrow B\\) 例如： 在一个学生信息的关系模型 \\(Student(\\underline{s\\_id}, name, gender, age)\\) 中，我们假设学号 \\(s\\_id\\) 是关系模型中的主键，则有： \\[ s\\_id \\to name \\] 即：唯一的学号对应唯一的姓名，因此姓名在这里是函数依赖于学号的。 平凡函数依赖和非平凡函数依赖 我们从决定因子和被决定因子的集合关系角度出发可以将函数依赖分为两类： 平凡函数依赖（Trivial Functional Dependency）： 若 \\(A \\to B\\) ，且 \\(B \\subseteq A\\) ，则称该依赖为平凡依赖。 非平凡函数依赖（Nontrivial Functional Dependency）： 若 \\(A \\to B\\) ，且 \\(B \\not\\subseteq A\\) ，则称该依赖为非平凡依赖。 部分函数依赖和完全函数依赖 同时，我们从决定因子属性的必要性又可以将函数依赖分为两类： 部分函数依赖（Partial Functional Dependency）： 若 \\(A \\to B\\) ，且存在 \\(A\\) 的真子集 \\(X\\) ，使得 \\(X \\to B\\) ，我们就称 \\(B\\) 部分函数依赖于 \\(A\\) 。 完全函数依赖（Full Functional Dependency）： 若 \\(A \\to B\\) ，且不存在 \\(A\\) 的真子集 \\(X\\) ，使得 \\(X \\to B\\)，我们就称 \\(B\\) 完全函数依赖于 \\(A\\) 。 即 \\(A\\) 中删去任意一个属性都无法满足 \\(A \\to B\\) 。 例如，在上述例子中，显然有 \\((s\\_id, name) \\to gender\\)， 但其决定因子的一个真子集 \\(s\\_id\\) 也满足被 \\(gender\\) 函数依赖，因此该函数依赖是一个部分函数依赖。相反，\\(s\\_id \\to gender\\) 就是一个完全函数依赖。 注意到，一般只有在 \\(A\\) 是多个特征的集合时才会考虑此分类，若 \\(A\\) 为单属性，且 \\(A \\to B\\) ，则一定构成完全函数依赖。 传递函数依赖 函数依赖具有传递性，传递函数依赖（Transitive Functional Dependency）描述如下： 若 \\(A\\) ，\\(B\\) ，\\(C\\) 是关系模型 \\(R\\) 中的三个特征集合，且满足： \\(A \\to B\\) 且 \\(B \\not\\to A\\) \\(B \\to C\\) 则称 \\(C\\) 通过 \\(B\\) 函数依赖于 \\(A\\) 。 多值依赖 设 \\(R(U)\\) 是属性集 \\(U\\) 上的一个关系模式。\\(X\\)、\\(Y\\)、\\(Z\\) 是 \\(U\\) 的子集，若对 \\(U\\) 的任意一对关系而言，给定一对 \\((X, Z)\\) 的值，都有若干组 \\(Y\\) 值与之对应，而 \\(Y\\) 的取值仅仅与 \\(X\\) 相关而与 \\(Z\\) 无关，这就是多值依赖（Multi-valued Dependency）。记作：\\(X \\to\\!\\!\\!\\to Y\\)。 我们也可以这样描述：给定 \\(X\\) 的值，有多组 \\((Y, Z)\\) 的值与之对应，且 \\(Y\\) 与 \\(Z\\) 的取值相互独立。 例如： 我们给定关系 \\(subject(subject\\_name, teacher, text\\_book)\\) 来描述学科、老师和学科教材的关系，在该关系模型中，一门学科对应多组老师和教材，而老师和教材又是相互独立的，即老师和学科教材分别只决定于学科，所以我们有： \\[ \\begin{array}{} subject\\_name \\to\\!\\!\\!\\to teacher \\\\ subject\\_name \\to\\!\\!\\!\\to text\\_book \\end{array} \\] 平凡多值依赖和非平凡多值依赖 进一步，我们又可以将多值依赖分为平凡多值依赖和非平凡多值依赖： 平凡多值依赖（Trivial Multi-valued Dependency）： 在关系模型 \\(R\\) 的属性集为 \\(U\\)，属性 \\(A\\) 和 \\(B\\) 满足 \\(A \\to\\!\\!\\!\\to B\\) 且满足以下两个条件之一： \\(A \\subseteq B\\) \\(A \\cup B = R\\) 我们就称该多值依赖是平凡的。 非平凡多值依赖（Nontrivial Multi-valued Dependency）： 若 \\(A \\to\\!\\!\\!\\to B\\) 且不满足以上任意一个条件，我们就称该多值依赖是非平凡的。 范式 范式（Normal Form），简称 NF，是一种数据库规范化评级标准，范式越高，数据模型越规范。 数据库规范化技术，就是不断提高数据模型的范式等级。 UNF UNF（Unormalized Form），即无范式，是一种未规范化的表格，表格中的数据可能包括一个或多个值。 示例： 1NF 1NF（First Normal Form），即第一范式。指在一张表格中给定行和列，对应唯一的数据，且一个关系模型中的所有的属性都是不可分的基本数据项。1NF 是关系型数据库的基本要求。 示例： UNF \\(\\to\\) 1NF 将缺省单元格的数据进行拷贝，然后对无范式表格重新划分，即可得到每个单元格仅有一个值的第一范式表格。 2NF 2NF（Second Normal Form），即第二范式。指在 1NF 的基础上，满足所有非主属性完全依赖于候选键（Candidate key）。 1NF \\(\\to\\) 2NF 确定主键：确定 1NF 关系中的主键 确定函数依赖：分析非主键列对主键的完全依赖关系。也就是说，找出哪些非主键列的值是由主键决定的，而不是由主键的一部分决定的 创建新表：对于那些非主键列存在部分依赖的情况，将其分离出来，创建一个新的表 调整关系：在新的表中，将非主键列和相应的主键列作为新表的列 示例： 上述关系中存在如下函数依赖： 不难发现，我们可以指定 \\((clinetNo, PropertyNo)\\) 作为该关系中的主键，而函数依赖 fd2 和 fd3 的决定因子是主键的真子集，因此其被决定因子（图中下画线部分的属性）是部分依赖于主键的，因此我们要将其从当前关系中抽离出来： 最终建立的关系模型的 Schema 如下： 该关系模型的三张表都不存在非主属性对主键的部分依赖，各自满足第二范式。 3NF 3NF（Third Normal Form），即第三范式。指在 2NF 的基础上，不存在非主属性传递依赖于候选键。 2NF \\(\\to\\) 3NF 确定主键 确定函数依赖 找到依赖于主键的传递函数依赖，并将其分离出来 示例： 在上述建立的 2NF 关系模型中的第二张表 \\(PropertyOwner\\) 中，存在函数依赖关系 \\(propertyNo \\to ownerNo\\)（\\(ownerNo \\not\\to propertyNo\\)）和 $ ownerNo oName$ ，因此 \\(oName\\) 传递依赖于主键，所以我们要将其从当前关系中分离出来。 满足 3NF 的关系模型 Schema 如下所示： 该关系模型中的 4 张表都不存在非主属性对主键的传递依赖，各自满足第三范式。 BCNF BCNF（Boyce-Codd Normal Form），即巴斯-科德范式。指在 3NF 的基础上，清除了主属性对候选键的部分函数依赖。 即满足 BCNF 的充要条件是关系模型中所有函数依赖的决定因子都是候选键。 3NF \\(\\to\\) BCNF 确定主键和主属性 确定函数依赖 消除主属性对候选键的部分函数依赖 例如，有如下关系模型： \\[ studentGrade(\\underline{class\\_id}, \\underline{s\\_id}, t\\_id, grade) \\] 该关系模型用于储存学生某门课程的成绩，每门课有且仅有一名老师来教学，可以作为该表的候选键有 \\((class\\_id, s\\_id)\\) 或者 \\((t\\_id, s\\_id)\\) ，我们选取前者作为主键，那么此关系模型中唯一的非主属性就是 \\(grade\\) 。 该关系模型符合 3NF，但是我们不难发现，主属性 \\(t\\_id\\) 对主键构成部分依赖关系，因此该关系模型不符合 BCNF，因此我们将其拆分为两张表： \\[ \\begin{array}{} teacher(\\underline{class\\_id}, t\\_id) \\\\ studentGrade(\\underline{class\\_id}, \\underline{s\\_id}, grade) \\end{array} \\] 这样，我们就消除了主属性对候选键的部分依赖，上述两张表各自符合 BCNF。 4 NF 4 NF（Forth Normal Form），即第四范式，即在 BCNF 的基础上，消除了所有决定因子不为候选键的非平凡多值依赖。换言之，满足 4NF 的充要条件是对于关系 \\(R\\) 中的每一对非平凡多值依赖 \\(A \\to\\!\\!\\!\\to B\\) 而言，\\(A\\) 都是关系中的候选键。 BCNF \\(\\to\\) 4NF 确定主键和候选键 确定关系中的非平凡多值依赖 消除所有决定因子不为候选键的非平凡多值依赖 例如，现有如下关系： 在如上 \\(BranchStaffOwner(branchNo, sName, oName)\\) 关系中，一个 \\(branchNo\\) 可以对应多组 \\((sName, oName)\\) ，而 \\(sName\\) 和 \\(oName\\) 之间相互不影响，所以我们有： \\[ \\begin{array}{} branchNo \\to\\!\\!\\!\\to sName \\\\ branchNo \\to\\!\\!\\!\\to oName \\end{array} \\] 而 \\(branchNo\\) 在这里不是候选键，所以我们要消除消除这两对非平凡多值依赖，因此将该关系拆分为两张表： 这样我们就消除了上面提到的两对非平凡多值依赖，以上两张表 \\(Branch(branchNo, sName)\\)、\\(BranchOwner(BranchNo, oName)\\) 分别满足第四范式。 事实上第四范式之上还有第五范式（Fifth Normal Form），但第四范式已经是相当规范的等级了，因此第五范式笔者在此就不赘述了。😃","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"数据库系统","slug":"数据库系统","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"},{"name":"数据库规范化","slug":"数据库规范化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96/"}]},{"title":"如何在程序中计算定积分？—— Simpson 公式讲解","slug":"如何在程序中计算定积分？—— Simpson 公式讲解","date":"2023-04-30T06:04:03.000Z","updated":"2023-07-19T16:59:27.560Z","comments":true,"path":"2023/04/30/如何在程序中计算定积分？—— Simpson 公式讲解/","link":"","permalink":"http://example.com/2023/04/30/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%AE%9A%E7%A7%AF%E5%88%86%EF%BC%9F%E2%80%94%E2%80%94%20Simpson%20%E5%85%AC%E5%BC%8F%E8%AE%B2%E8%A7%A3/","excerpt":"","text":"Simpson 公式是一种用于求积分近似值的方法，相对于常规的矩形逼近和梯型逼近，其精度要高很多。 公式如下： \\[ \\int_a^b f(x)dx \\approx \\frac{b - a}{6n} (f(a) + f(b) + 2 \\sum_{i = 1} ^ {n - 1}f(x_i) + 4 \\sum_{i = 0}^{n - 1}f(x_{i + 0.5})) \\] 其中 \\(n\\) 是区间分隔的数量，\\(n\\) 越大，精度越高。 数学证明 Simpson 积分公式的原理就是采用二次函数逼近目标函数。 如上图所示，我们将函数区间 \\([x_1, x_2]\\) 近似看作是二次函数，\\(x_{1.5}\\) 是区间中点，我们规定： \\[ \\begin{array}{} f(x_1) = c_2 x_1^2 + c_1 x_1 + c_0 \\\\ f(x_2) = c_2 x_2^2 + c_1 x_2 + c_0 \\\\ f(x_{1.5}) = c_0 \\end{array} \\] 则积分面积 \\(S = \\int_{x_1}^{x_2} f(x)dx \\approx \\int_{x_1}^{x_2} (c_2 x^2 + c_1 x + c_0)dx\\) \\[ \\begin{array}{} \\implies S \\approx \\frac{c_2}{3}(x_2^3 - x_1^3) + \\frac{c1}{2}(x_2^2 - x_1^2) + c_0(x_2 - x_1) \\\\ = \\frac{x_2 - x_1}{6}(f(x_1) + f(x_2) + 4 f(x_{1.5})) \\end{array} \\] 现在我们将函数积分区域 \\([a, b]\\) 划分为 \\(n\\) 段，对每一段 \\([x_i, x_{i + 1}]\\) 采取同样的方式求定积分， 最后求和就可以得到我们的目标答案： \\[ \\begin{array}{} \\int_a^b f(x)dx \\approx \\frac{b - a}{6n} (f(a) + f(b) + 2 \\sum_{i = 1} ^ {n - 1}f(x_i) + 4 \\sum_{i = 0}^{n - 1}f(x_{i + 0.5})) \\\\ (x_0 = a, x_n = b) \\end{array} \\] 误差 最大误差为 \\(\\frac{(b - a)^5}{180 n^4} M\\)，其中 \\(M\\) 是函数在区间 \\([a, b]\\) 上四阶导的绝对值的最大值。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;cstdio&gt;#include &lt;cmath&gt;inline double fn(double x) &#123; return x * exp(-x);&#125;double solve_rect(double left, double right, int n) &#123; // 采用一般的矩形逼近法求定积分 double res = 0; double d = (right - left) / n; for (int i = 0; i &lt; n; i++) &#123; res += fn(left + i * d); &#125; return res * d;&#125;double solve_simpson(double left, double right, int n) &#123; // 采取辛普森公式求定积分 double res = -fn(left) + fn(right); double d = (right - left) / n; for (int i = 0; i &lt; n; i++) &#123; res += (2 * fn(left + i * d) + 4 * fn(left + (i + 0.5) * d)); &#125; return d * res / 6;&#125;int main() &#123; printf(&quot;%lf\\n&quot;, solve_rect(0, 1, 10)); // 0.245014 printf(&quot;%lf\\n&quot;, solve_rect(0, 1, 100)); // 0.262393 printf(&quot;%lf\\n&quot;, solve_rect(0, 1, 1000)); // 0.264057 printf(&quot;%lf\\n&quot;, solve_simpson(0, 1, 10)); // 0.264241 return 0;&#125; 实际答案 \\(\\int_0^1 x e^{-x}dx = 1 - \\frac{2}{e} \\approx 0.2642411176571\\)，可见上述积分采用 Simpson 公式计算时在 \\(n = 10\\) 时已经达到了一个较高的精度，远超常规的矩形逼近法。","categories":[{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"}],"tags":[{"name":"计算几何","slug":"计算几何","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"Simpson 公式","slug":"Simpson-公式","permalink":"http://example.com/tags/Simpson-%E5%85%AC%E5%BC%8F/"},{"name":"定积分","slug":"定积分","permalink":"http://example.com/tags/%E5%AE%9A%E7%A7%AF%E5%88%86/"}]},{"title":"MySQL 知识点总结","slug":"MySQL 知识点总结","date":"2023-04-10T14:58:57.000Z","updated":"2023-07-10T08:45:59.882Z","comments":true,"path":"2023/04/10/MySQL 知识点总结/","link":"","permalink":"http://example.com/2023/04/10/MySQL%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"","text":"MySQL 基本介绍 MySQL 是一种关系型数据库管理系统，由瑞典 MySQL AB 公司开发，属于 Oracle 旗下产品，由于其体积小、速度快、成本低、开源等优点，使其在 Web 开发中尤其受欢迎。 MySQL 官网 MySQL 客户端连接 1mysql -u [用户名] -p 示例： 以 root 用户登陆： 1mysql -u root -p MySQL Command 介绍 MySQL 所使用的 SQL 语言是用于访问数据库的最常用标准化语言。 SQL 语句分类 最常见的 SQL 语句包括以下 4 大类： DDL（Data Definition Language） 用途：对数据库对象（数据库、表、列、索引等）进行创建、删除、修改等。 常用关键字：create、drop、alter DML（Data Manipulation Language） 用途：用于添加、修改、删除和查询数据库记录，并检查数据完整性。 常用关键字：insert、update、delete DQL（Data Query Language） 用途：用于查询数据。 常用关键字：select DCL（Data Control Language） 用途：用于管理用户权限。 DDL 语句 数据库操作 查询所有数据库： 1show databases; 创建数据库： 123create database [数据库名称];create database if not exists [数据库名称];create database [数据库名称] default charset [字符集]; 删除数据库： 12drop database [数据库名称];drop database if exists [数据库名称]; 使用数据库： 1use [数据库名称]; 查询当前数据库： 1select database(); 表操作 查询当前数据库所有表： 1show tables; 查询表结构： 1desc [表名]; 查询指定表的创建语句： 1show create table [表名]; 创建表： 123456create table [表名]( 字段1 字段1类型 [约束] [comment], 字段2 字段2类型 [约束] [comment], # ... 字段n 字段n类型 [约束] [comment])comment 表注释; 例如： 1234567# 创建如下员工表create table demo( id int comment &#x27;编号&#x27;, name varchar(50) comment &#x27;姓名&#x27;, age int comment &#x27;年龄&#x27;, gender varchar(1) comment &#x27;性别&#x27;)comment &#x27;员工&#x27;; 修改表名： 1alter table [表名] rename to [新表名]; 删除表： 1drop table (if exists) [表名]; 删除指定表，并重新创建该表（即删除表中所有行）： 1truncate table [表名]; 字段操作 添加字段： 1alter table [表名] add [字段名] [类型(长度)] [约束] [comment]; 例如： 12alter table staff add gender varchar(10) default &#x27;undefined&#x27; not null comment &#x27;性别&#x27;; 如上，给 staff 表格添加 gender 字段 修改字段数据类型 1alter table [表名] modify [字段名] [新数据类型]; 修改字段名和字段数据类型： 1alter table [表名] change [旧字段名] [新字段名] [类型(长度)] [约束] [comment]; 例如： 12alter table staff change id s_id int not null comment &#x27;员工 ID&#x27;; 删除字段： 1alter table [表名] drop [字段名]; 补充 MySQL 表格字段数据类型 基本数据类型： 类型 大小 描述 tinyint 1 byte 整数 smallint 2 bytes 整数 mediumint 3 bytes 整数 int 或者 integer 4 bytes 整数 bigint 8 bytes 整数 float 4 bytes 单精度浮点数 double 8 bytes 双精度浮点数 decimal 依赖于精度和标度的值 小数值 字符串类型： 类型 大小 描述 char 0 ~ 255 bytes 定长字符串 varchar 0 ~ 65535 bytes 变长字符串 tinyblob 0 ~ 255 bytes 不超过 255 个字符的二进制数据 tinytext 0 ~ 255 bytes 短文本字符串 blob 0 ~ 65535 bytes 二进制形式的长文本数据 text 0 ~ 65535 bytes 长文本数据 日期类型： 类型 大小 格式 说明 date 3 bytes YYYY-MM-DD 日期值 time 3 bytes HH:MM:SS 持续时间值 year 1 bytes YYYY 年份值 datetime 8 bytes YYYY-MM-DD HH:MM:SS 混合日期和时间值 timestamp 4 bytes YYYY-MM-DD HH:MM:SS 混合日期和时间值，时间戳 枚举类型： 关键词：enum 枚举范围需要在创建表格时通过枚举的方式指定，最多允许有 65535 个成员。 例如： 12345create table stu( id int primary key auto_increment, name varchar(20) not null, gender enum(&#x27;男&#x27;, &#x27;女&#x27;) not null); 其中 gender 字段只能是「男」或者「女」 MySQL 约束 约束是作用于表中字段上的规则，用于限制存储在表中的数据。 分类： 约束 关键字 描述 非空约束 not null 字段不能为 NULL 唯一约束 unique 字段数据都是唯一的，不重复的 主键约束 primary key 主键是一行数据的唯一表示，要求非空唯一 默认约束 default 保存数据时，如果未指定该字段的值，则采用默认值 检查约束 check 保证字段满足某一个条件 外键约束 foreign key 用来建立两张表的数据之间的联系，保证数据的一致性和完整性 案例： 根据以下需求完成表的创建： 字段名 字段含义 字段类型 约束条件 约束关键词 id ID 唯一标识 int 主键，并且自动增长 primary key, auto_increment name 姓名 varchar(10) 非空唯一 not null, unique age 年龄 int 大于 0，不大于 120 check status 状态 char(1) 默认为 1 default gender 性别 char(1) 无 1234567create table stu( id int primary key auto_increment comment &#x27;ID&#x27;, name varchar(10) not null unique comment &#x27;姓名&#x27;, age int check ( age &gt; 0 and age &lt;= 120 ) comment &#x27;年龄&#x27;, status char(1) default &#x27;1&#x27; comment &#x27;状态&#x27;, gender char(1) comment &#x27;性别&#x27;)comment &#x27;学生&#x27;; 外键约束 让多个表的数据产生连接，子表的外键是父表的一个候选键，如下图： 管理外键关联： 创建表时添加外键关联： 1[外键名称] foreign key [外键字段名] references [主表(主表列名)] [指定行为]; 创建表后添加外键关系： 1alter table [表名] add constraint [外键名称] foreign key [外键字段名] references [主表(主表列名)] [指定行为]; 删除外键关联： 1alter table [表名] drop foreign key [外键名称]; 外键删除和更新行为： 行为 说明 no action 当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则不允许删除或更新（默认） restrict 当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则不允许删除或更新（与 no action 一致） cascade 当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则也删除或者更新外键在子表中的记录 set null 当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则设置子表的外键值为 NULL set default 当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则设置子表的外键值为默认值（Innodb 不支持） 案例： 1234# 给 staff 表的 dept_id 属性添加关联 dept 表的 id 属性的外键关系，并且将更新行为和删除行为设置为级联alter table staff add constraint fk_staff_dept_id foreign key (dept_id) references dept(id) on update cascade on delete cascade; DML 语句 添加数据： 给指定字段添加数据： 1insert into [表名(字段名1, 字段名2, ...)] values(值1, 值2, ...); 给全部字段添加数据： 1insert into [表名] values(值1, 值2, ...); 批量添加： 1insert into [表名] values(值1, 值2, ...), (值1, 值2, ...), ...; 示例： 123insert into staff (s_id, name, age, gender)values (1002, &#x27;Tom&#x27;, 24, &#x27;男&#x27;), (1003, &#x27;Frank&#x27;, 25, &#x27;男&#x27;); 修改数据： 1update [表名] set 字段名1 = 值1， 字段名2 = 值2, ... [where 条件]; 删除数据： 1delete from [表名] [where 条件]; DQL 语句 语法： 1234567891011121314select [字段列表]from [表名列表]where [条件列表]group by [分组字段列表]having [分组后条件列表]order by [排序字段列表]limit [分页参数]; select 之后添加 distinct 可以消除重复元组 查询多个字段： 12345select [字段1, 字段2, ...] from [表名];select * from [表名]; # 查询所有字段（不推荐）select [字段] as [别名] from [表名]; 条件查询： 1select [字段列表] from [表名] where [条件列表]; 条件： 比较运算符 功能 &gt; 大于 &gt;= 大于等于 &lt; 小于 &lt;= 小于等于 = 等于 &lt;&gt; 或者 != 不等于 between ... and ... 在某个范围之内（含最小、最大值） in(...) 在 in 之后的列表中的值 like 占位符 模糊匹配，_ 匹配单个字符，% 匹配任意个字符 is null 是 NULL 逻辑运算符 功能 and 或 &amp;&amp; 并且 or 或 || 或者 not 或 ! 非 几个案例： 1234567891011121314select name, s_id from staff where age &gt;= 25;# 查找年龄不小于 25 的员工姓名和 IDselect name, s_id from staff where age between 20 and 30;# 查找年龄在 20 和 30 岁之间的员工姓名和年龄select name, s_id from staff where gender is null;# 查找 gender 为 null 的员工姓名和 IDselect name, s_id from staff where age &gt;= 25 and gender = &#x27;女&#x27;;# 查找年龄不小于 25 的女员工姓名和 IDselect name from staff like &#x27;李%&#x27;;# 查找姓李的员工 聚合函数 聚合函数是指将一列数据作为一个整体，进行纵向计算。 函数 功能 count() 统计数量 max() 最大值 min() 最小值 avg() 平均值 sum() 求和 注：NULL 值不参与除 count() 之外的聚合函数的运算 语法： 1select 聚合函数(字段列表) from [表名]; 几个案例： 12345select count(s_id) from staff;# s_id 数量，NULL 值不参与聚合函数计算select max(age) from staff;# 查找员工年龄最大值 分组查询 语法： 1select [字段列表] from [表名] where [条件列表] group by [分组字段名] having [分组后过滤条件]; ‼️ where 和 having 的区别： 执行时机不同：where 是分组之前进行过滤，不满足 where 条件，不参与分组；而 having 是分组之后对结果进行过滤。 判断条件不同，where 不能对聚合函数进行判断，而 having 可以。 几个案例： 12select gender, count(*) as numebr from staff group by gender;# 查询男性员工和女性员工的数量 结果： 12select address, count(*) as address_count from emp where age &lt;= 35 group by address having address_count &gt;= 5;# 查询不同地区年龄小于等于 35 岁的员工且人数不小于 5 的地区及其员工数量 ‼️ 执行顺序： where 聚合函数 having 排序查询 语法： 12select [字段列表] from [表名] order by [字段1] [排序方案1], [字段2] [排序方案2] ...;# 多个字段时先看前面的字段，若前面的字段值相同，则看后面的字段规则 排序方案： asc ：升序排序 desc ：降序排序 几个案例： 12select name, s_id from staff order by age asc;# 将员工姓名和 ID 按照年龄升序排列 分页查询 关键词：limit 语法： 1select [字段列表] from [表名] limit [起始索引], [查询记录数]; 注：起始索引从 0 开始，若索引为 0，则 0 可以省略 几个案例： 12select * from emp limit 0, 10;# 展示从索引 0 开始的 10 条记录 ‼️ 多表查询 直接使用 select 语句： 1select [字段列表] from [表1], [表2]; 以上语句会直接得到 表1 和 表2 的笛卡尔积的投影字段。 自然连接： 1select [字段列表] from [表1], [表2] where [表1.key] = [表2.key]; key 在这里为主表的外键 JOIN 语句 cross join ：笛卡尔积 1select [字段列表] from [表1] cross join [表2]; on 关键字：在 join 语句后添加 on [条件列表] 可以筛选特定条件的元组 内连接 natural join ：自然连接 1select [字段列表] from [表1] natural join [表2]; inner join ：内连接，join 不加修饰的默认连接，显示左表和右表符合条件的记录 1select [字段列表] from [表1] (inner) join [表2] on [条件列表]; 上图使用 where 语句的等价连接方式叫做隐式内连接。 外连接 left join ：左连接，即保留左表所有元组，右表无法匹配的属性用 NULL 取代 1select [字段列表] from [表1] left join [表2] on [条件列表]; right join ：右连接，即保留右表所有元组，左表无法匹配的属性用 NULL 取代 1select [字段列表] from [表1] right join [表2] on [条件列表]; full join ：全连接，即保留两张表所有元组，无法匹配的属性用 NULL 取代 1select [字段列表] from [表1] full join [表2] on [条件列表]; ‼️ 子查询 在 SQL 语句中嵌套 select 语句，称为嵌套查询，又称子查询。 标量子查询：子查询的结果为单个值 列子查询：子查询的结果为一列 常用操作符：in、not in、any、some、all 行子查询：子查询的结果为一行 常用操作符：=、!=、in、not in、exists、not exists exists (select ...) 用来判断是否有后面的 select 语句是否有返回值。若至少返回一行，则返回 true ，否则返回 false 表子查询：子查询的结果为多行多列 常用操作符：in 根据子查询的位置，又可以分为： where 之后 from 之后 select 之后 DCL 语句 DCL（Data Control Language）用来管理数据库用户控制数据库的访问权限。 管理用户： 查询用户： 12use mysql;select * from user; 创建用户： 1create user [&#x27;用户名&#x27;@&#x27;主机名&#x27;] identified by [&#x27;密码&#x27;]; 示例： 12345# 创建用户 Jack，只能在当前主机 localhost 访问，密码 123456create user &#x27;Jack&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;# 创建用户 Tina，可以在任意主机访问该数据库，密码 123456create user &#x27;Tina&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;; 修改用户密码： 1alter user [&#x27;用户名&#x27;@&#x27;主机名&#x27;] identified with mysql_native_password by [&#x27;新密码&#x27;]; 删除用户： 1drop user [&#x27;用户名&#x27;@&#x27;主机名&#x27;]; 权限控制： 权限 说明 all, all privileges 所有权限 select 查询数据 insert 插入数据 update 修改数据 delete 删除数据 alter 修改表 drop 删除数据库 / 表 / 视图 create 创建数据库 / 表 查询权限： 1show grants for [&#x27;用户名&#x27;@&#x27;主机名&#x27;]; 授予权限： 1grant [权限列表] on [数据库名.表名] to [&#x27;用户名&#x27;@&#x27;主机名&#x27;]; 撤销权限： 1revoke [权限列表] on [数据库名.表名] to [&#x27;用户名&#x27;@&#x27;主机名&#x27;]; 多个权限之间，采取逗号分隔 授权时，数据库和表名可以使用 * 进行通配 MySQL 函数 函数是指一段可以直接被另一段程序调用的程序或代码。 字符串函数 函数 功能 length(s) 返回字符串的长度 concat(s1, s2, ...) 字符串拼接 lower(str) 将字符串全部小写 upper(str) 将字符串全部大写 lpad(str, n, pad) 左填充 rpad(str, n, pad) 右填充 trim(str) 去掉字符串头部和尾部的空格 substring(str, start, len) 返回字符串从 start 位置起的 len 个长度的子字符串 数据函数 函数 说明 ceil(x) 向上取整 floor(x) 向下取整 mod(x, y) 返回 x mod y 的值 rand() 返回 0 ~ 1 之间的随机数 round(x, y) 求参数 x 的四舍五入的值，保留 y 位小数 日期函数 函数 说明 curdate() 返回当前日期 curtime() 返回当前时间 now() 返回当前日期和时间 year(date) 获取指定 date 的年份 month(date) 获取指定 date 的月份 day(date) 获取指定 date 的日期 date_add(date, interval expr type) 返回一个日期 / 时间值加上一个时间间隔 expr 后的时间值 datediff(date1, date2) 返回结束时间 date1 和起始时间 date2 之间的天数 date_format(date, format) date_format(date, format) ：用于以不同的格式显示日期 / 时间数据。date 参数是合法的日期，format 规定日期/时间的输出格式。例如，将 2023-03-14 转化为 2023-03 （即年 - 月）输出，则为： date_format(target_date, '%Y-%m') 流程函数 流程函数也是很常用的一类函数，可以在 SQL 语句中实现条件筛选，从而提高语句效率。 函数 功能 if(value, t, f) value 为 true 返回 t ，否则返回 f ifnull(value1, value2) 如果 value1 不为空，返回 value1 ，否则返回 value2 case when [val1] then [res1] ... else [default] end 如果 val1 为 true ，返回 res1 ，...，default 为默认值 case [expr] when [val1] then [res1] ... else [default] end 同上，若 expr 的值等于 val1 ，则返回 res1， ...，default 为默认值 MySQL 事务操作 事务（Transaction）是一组操作的集合，它是一个不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。 事务 4 大特性（ACID）： 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的 事务操作 查看 / 设置事务提交方式 12select @@autocommit;set @@autocommit = 0; # 将事务设置为手动提交 开启事务 1start transaction; # 我们也可以不更改 @@autocommit 参数 提交事务 1commit; # 设置为手动提交后必须要手动提交才能更新数据 回滚事务 1rollback; # 回滚 / 撤销事务","categories":[{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"}]},{"title":"素数筛","slug":"素数筛","date":"2023-04-02T05:23:45.000Z","updated":"2023-07-10T08:22:04.009Z","comments":true,"path":"2023/04/02/素数筛/","link":"","permalink":"http://example.com/2023/04/02/%E7%B4%A0%E6%95%B0%E7%AD%9B/","excerpt":"","text":"引入 如果我们想要求出小于 n 的所有素数，一个很自然的想法就是从 1 到 n 进行遍历，然后对素数进行记录，但这样的话时间复杂度为 \\(O(n^{\\frac{3}{2}})\\) ，当 n 足够大的时候这个算法是较慢的，有没有更高效的算法呢？ 接下来我们介绍最常见的两种素数筛，以 Leetcode 模版题为例：计数质数 埃氏筛 埃氏筛也叫埃拉托斯特尼筛法，考虑任意素数 x ，则 x 的所有倍数都是合数。 12345678910111213141516171819class Solution &#123;public: int countPrimes(int n) &#123; // 埃式筛 bool* notPrime = new bool[n](); int res = 0; for (int i = 2; i &lt; n; i++) &#123; if (!notPrime[i]) &#123; res++; for (long long k = (long long)i * i; k &lt; n; k += i) &#123; // 若 j &lt; i，则 j * i 一定已经被筛过 notPrime[k] = true; &#125; &#125; &#125; return res; &#125;&#125;; 时间复杂度：\\(O(n\\ loglogn)\\) 如果想了解其证明，读者可以自行去 OI Wiki 上看。 尽管埃氏筛法已经有较高的效率，但其仍然无法达到线性时间复杂度，因为有些数存在重复筛除的情况，例如 12，其会被 2，3 分别筛除一次，有没有办法可以避免重复筛除呢？ 欧式筛（线性筛） 欧式筛，即 Euler 筛法，其避免了上述的重复筛而造成的时间浪费，真正意义上实现了线性时间复杂度。对于特别大的数据量（\\(n &gt; 10^8\\)）时适用。 1234567891011121314151617181920212223class Solution &#123;public: int countPrimes(int n) &#123; if (n &lt; 2) return 0; int* primeNum = new int[(int)(1.5 * n / log(n)) + 1]; // π(n) &lt; 1.5 * n / ln(n) 素数数目的一个粗糙上界 bool* notPrime = new bool[n](); int res = 0; for (int i = 2; i &lt; n; i++) &#123; if (!notPrime[i]) &#123; primeNum[res++] = i; &#125; for (int j = 0; j &lt; res &amp;&amp; i * primeNum[j] &lt; n; j++) &#123; notPrime[i * primeNum[j]] = true; if (i % primeNum[j] == 0) break; // 如果 i 能被 primeNum[j] 整除，则 i 的倍数一定会被 primeNum[j] 的倍数筛除 // 故此刻不需要继续再筛除，退出循环 &#125; &#125; return res; &#125;&#125;; 时间复杂度：\\(O(n)\\) 注意到，欧式筛中被筛除的合数都是被当前记录的最小素数筛除的，所以我们我们也可以同时得到每个数的最小质因数。 案例 HDU - 6954 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;#include &lt;cmath&gt;#define MAX_NUM 10000005using i64 = long long;bool notPrime[MAX_NUM];i64 ans[MAX_NUM];int primeNum[MAX_NUM];int cnt = 0;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(0); std::cout.tie(0); for (int i = 2; i &lt; MAX_NUM; i++) &#123; if (!notPrime[i]) &#123; ans[i] = ans[i - 1] + 2ll * i; primeNum[cnt++] = i; &#125; else &#123; ans[i] = ans[i - 1] + i; &#125; for (int j = 0; j &lt; cnt &amp;&amp; (i64)i * primeNum[j] &lt; MAX_NUM; j++) &#123; notPrime[i * primeNum[j]] = true; if (i % primeNum[j] == 0) break; &#125; &#125; int numTest; std::cin &gt;&gt; numTest; int n; while (numTest--) &#123; std::cin &gt;&gt; n; std::cout &lt;&lt; ans[n] - 4 &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"素数","slug":"素数","permalink":"http://example.com/tags/%E7%B4%A0%E6%95%B0/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"素数筛","slug":"素数筛","permalink":"http://example.com/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"},{"name":"埃氏筛","slug":"埃氏筛","permalink":"http://example.com/tags/%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"name":"欧式筛","slug":"欧式筛","permalink":"http://example.com/tags/%E6%AC%A7%E5%BC%8F%E7%AD%9B/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2023-04-01T02:54:12.000Z","updated":"2023-07-10T08:23:40.818Z","comments":true,"path":"2023/04/01/正则表达式/","link":"","permalink":"http://example.com/2023/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"什么是正则表达式？ 正则表达式（regular expression），又称为规则表达式，是一种文本模式，其拥有独特的语法和独立的处理引擎，可以帮助我们实现文本匹配，特别是当匹配模式比较复杂时，正则表达式有相当大的优势。 构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。 正则表达式基本语法 字符类 表达式 说明 [abc] 只能是 a, b, c [^abc] 除了 a, b, c 之外的任何字符 [a-zA-Z] a 到 z，A 到 Z 的所有字符 [a-d[m-p]] a 到 d，m 到 p [a-z&amp;&amp;[def]] a-z 和 def 到交集，在这里相当于 [def] [a-z&amp;&amp;[^bc]] a-z 和非 bc 的交集 [a-z&amp;&amp;[^m-p]] a-z 和除了 m 到 p 的交集 预定义字符 表达式 说明 . 任何字符 \\d 一个数字（[0-9]） \\D 非数字（[^0-9]） \\s 一个空白字符（[\\t\\n\\x0B\\f\\r]） \\S 非空白字符（[^\\t\\n\\x0B\\f\\r]） \\w 英文、数字、下划线（[a-zA-Z0-9_]） \\W 一个非单词字符（[^a-zA-Z0-9_]） 数量词 表达式 说明 X? X， 一次或者零次 X* X ，零次或者多次 X+ X ，一次或者多次 X&#123;n&#125; X ，正好 n 次 X&#123;n,&#125; X ，至少 n 次 X&#123;n,m&#125; X ，至少 n 次，不超过 m 次 特殊字符 表达式 说明 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 \\n 或 \\r。要匹配 $ 字符本身，请使用 \\$ 。 () 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\) 。 | 指明两项之间的一个选择。要匹配 | ，请使用 \\| 。 典型案例 匹配网址 URL：[a-zA-z]+://[^\\s]* 匹配中国邮编编码：[1-9]\\d&#123;5&#125;(?!\\d) 匹配 18 位身份证：^(\\d&#123;6&#125;)(\\d&#123;4&#125;)(\\d&#123;2&#125;)(\\d&#123;2&#125;)(\\d&#123;3&#125;)([0-9]|X)$ 正则表达式在线测试工具 实际运用 当前大多数流行语言都有自己的正则表达式库，例如 C++11 更新的 Regex 库 。 今天我们以 Java 为例，讲解正则表达式的一些实际运用。 Java 中的 String 内置正则匹配方法 matches() 方法： boolean matches(String regex) ，根据正则表达式，判断字符串是否能匹配成功，返回对应的布尔值 12345678910111213// 匹配手机号码// 以 1 开头// 第二位只能是 3 到 9// 任意数字 9 位String regex_1 = &quot;1[3-9]\\\\d&#123;9&#125;&quot;;System.out.println(&quot;13170488669&quot;.matches(regex_1)); // true// 匹配座机号码// 区号 以 0 开头// 中间可能有 -// 号码总长度 5 到 10 位String regex_2 = &quot;0\\\\d&#123;2,3&#125;-?[1-9]\\\\d&#123;4,9&#125;&quot;;System.out.println(&quot;027-142424&quot;.matches(regex_2)); // true replaceFirst() 方法和 replaceAll() 方法： String replaceFirst(String regex, String replacement) ，将字符串匹配到的第一个子串进行替换，返回新字符串。 String replaceAll(String regex, String replacement) ，将字符串所有匹配成功的子串进行替换，返回新字符串。 1234567String name = &quot;Isaac Newton&quot;;// 隐藏姓名System.out.println(name.replaceFirst(&quot;[a-zA-Z]+&quot;, &quot;*****&quot;)); // ***** NewtonString number = &quot;12-(900)84632&quot;;// 删除所有非数字字符System.out.println(number.replaceAll(&quot;[^0-9]&quot;, &quot;&quot;)); // 1290084632 split() 方法： String[] split(String regex) String[] split(String regex, int limit) 根据正则表达式对字符串进行分割，返回分割后的字符串数组。 这里 limit 参数用来控制分割次数： 若 limit &gt; 0 ：字符串最多被分割 n - 1 次，返回长度为 n 的字符串数组 若 limit &lt;= 0 ：字符串被尽可能多次分割，返回尽可能长的字符串数组 12345String[] member = &quot;张三, 李四, 王五&quot;.split(&quot;, &quot;);for (var name : member) System.out.println(name);// 张三// 李四// 王五 练习 驼峰匹配 1234567891011121314class Solution &#123; public List&lt;Boolean&gt; camelMatch(String[] queries, String pattern) &#123; String regexModel = &quot;[a-z]*&quot;; for (int i = 0, len = pattern.length(); i &lt; len; i++) &#123; regexModel += (pattern.charAt(i) + &quot;[a-z]*&quot;); &#125; ArrayList&lt;Boolean&gt; ans = new ArrayList&lt;&gt;(); for (int i = 0, len = queries.length; i &lt; len; i++) &#123; ans.add(queries[i].matches(regexModel)); &#125; return ans; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"}]},{"title":"讲解 C++ 匿名函数","slug":"讲解 C++ 匿名函数","date":"2023-03-29T18:00:51.000Z","updated":"2023-07-10T08:08:08.374Z","comments":true,"path":"2023/03/30/讲解 C++ 匿名函数/","link":"","permalink":"http://example.com/2023/03/30/%E8%AE%B2%E8%A7%A3%20C++%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/","excerpt":"","text":"匿名函数，也叫 Lambda 表达式，是 C++ 11 提出的特性，匿名函数能使得我们的程序更加灵活轻便。 基本语法 1[capture](para) -&gt; returnType &#123; body &#125; capture ：闭包 para ：参数 returnType ：返回类型 body ：函数体 示例： 12auto fun = [](int x, int y) &#123; return x + y; &#125;;std::cout &lt;&lt; fun(1, 2) &lt;&lt; &#x27;\\n&#x27;; // 3 闭包 capture 称为闭包，作用是引用匿名函数体外的变量，其有如下格式： 12345678[] // 不引用外部变量，无法在函数体内使用外部变量[x, &amp;y] // x 按值捕获，y 按照引用捕获[&amp;] // 可以捕获所有外部变量，按照引用捕获[=] // 可以捕获所有外部变量，按照值捕获[&amp;, x] // x 按照值捕获，其余所有变量按照引用捕获[=, &amp;y] // y 按照引用捕获，其余所有变量按照值捕获[this] // 通过引用捕获当前对象[*this] // 通过传值的方式捕获当前对象 示例： 12345678910111213141516171819#include &lt;iostream&gt;#include &lt;vector&gt;int main() &#123; int sum = 0; std::vector&lt;int&gt; arr = &#123;1, 2, 3, 4, 5&#125;; auto fun = [&amp;sum](int x) &#123; sum += x; &#125;; // auto fun = [sum](int x) &#123; sum += x; &#125;; 报错，sum 必须是可修改的左值，故只能通过引用的方式捕获 for (int x : arr) &#123; fun(x); &#125; std::cout &lt;&lt; sum &lt;&lt; &#x27;\\n&#x27;; // 15 return 0;&#125; 运用 匿名函数的运用十分灵活，以下我们举几个常见的例子： 在 STL 的排序函数中自定义排序方式： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;struct Student &#123; std::string name; int grade;&#125;;int main() &#123; std::vector&lt;Student&gt; s_arr = &#123;&#123;&quot;Jack&quot;, 99&#125;, &#123;&quot;Alice&quot;, 97&#125;, &#123;&quot;Bob&quot;, 83&#125;, &#123;&quot;Carl&quot;, 100&#125;, &#123;&quot;Clara&quot;, 66&#125;&#125;; std::sort(s_arr.begin(), s_arr.end(), [](const Student&amp; s1, const Student&amp; s2) &#123; return s1.grade &gt; s2.grade; &#125;); // 自定义学生成绩按照降序排序 for (const auto&amp; s : s_arr) &#123; std::cout &lt;&lt; s.name &lt;&lt; &#x27; &#x27; &lt;&lt; s.grade &lt;&lt; &#x27;\\n&#x27;; &#125; // Carl 100 // Jack 99 // Alice 97 // Bob 83 // Clara 66 return 0;&#125; 定义一个匿名函数作为参数的函数： 12345678910111213141516171819#include &lt;iostream&gt;double solve(std::function&lt;double(double)&gt; fn, double left, double right, int n) &#123; // 求一元函数在区间 [left, right] 的定积分 double res = -fn(left) + fn(right); double d = (right - left) / n; for (int i = 0; i &lt; n; i++) &#123; res += 2 * fn(left + i * d) + 4 * fn(left + (i + 0.5) * d); &#125; return d * res / 6;&#125;int main() &#123; std::cout &lt;&lt; solve([](double x) &#123; return x * x * x; &#125;, 0, 1, 10) &lt;&lt; &#x27;\\n&#x27;; // 0.25 return 0;&#125;","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"匿名函数","slug":"匿名函数","permalink":"http://example.com/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"}]},{"title":"树状数组和线段树","slug":"树状数组和线段树","date":"2023-03-29T17:50:01.000Z","updated":"2023-09-10T07:06:00.631Z","comments":true,"path":"2023/03/30/树状数组和线段树/","link":"","permalink":"http://example.com/2023/03/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/","excerpt":"","text":"树状数组和线段树是两种常用的数据结构，其可以大大提升数组的区间查询的效率，同时也保证了数据修改的灵活度。 一般数组 前缀和数组 树状数组 线段树 单点查询 \\(O(1)\\) \\(O(1)\\) \\(O(logn)\\) \\(O(logn)\\) 区间查询 \\(O(n)\\) \\(O(1)\\) \\(O(logn)\\) \\(O(logn)\\) 单点修改 \\(O(1)\\) \\(O(n)\\) \\(O(logn)\\) \\(O(logn)\\) 区间修改 \\(O(n)\\) \\(O(n^2)\\) \\(O(nlogn)\\) \\(O(logn)\\) 树状数组 树状数组的原理讲解可以参考视频：五分钟丝滑动画讲解 | 树状数组 用于区间求和和单点修改的树状数组模版 123456789101112131415161718192021222324252627282930313233343536class BIT &#123;private: int n; std::vector&lt;int&gt; tree; inline int lowbit(int x) &#123; // 数状数组第 i 项的区间长度为 lowbit(i) return x &amp; -x; &#125; int count(int m) &#123; // 求前 m 项的和 int res = 0; while (m) &#123; res += tree[m]; m -= lowbit(m); &#125; return res; &#125;public: BIT(int _n): n(_n), tree(_n + 1, 0) &#123;&#125; void add(int idx, int val) &#123; // 单点修改 while (idx &lt;= n) &#123; tree[idx] += val; idx += lowbit(idx); &#125; &#125; int rangeSum(int left, int right) &#123; // 区间求和 return count(right) - count(left - 1); &#125;&#125;; 树状数组的核心就是 lowbit() 函数，数状数组第 i 项代表的区间长度为 lowbit(i) 树状数组的下标只能从 1 开始，不能从 0 开始 用于求前缀最大值的树状数组模版 12345678910111213141516171819202122232425class BIT &#123;private: int n; std::vector&lt;int&gt; tree;public: BIT(int _n): n(_n), tree(_n + 1) &#123;&#125; int query(int idx) &#123; int res = 0; while (idx) &#123; res = std::max(res, tree[idx]); idx &amp;= idx - 1; &#125; return res; &#125; void update(int idx, int val) &#123; while (idx &lt;= n) &#123; tree[idx] = std::max(tree[idx], val); idx += idx &amp; -idx; &#125; &#125;&#125;; 线段树 线段树相对于树状数组而言则更为灵活，其可以实现高效区间修改。 线段树的原理就是将数组的区间储存在二叉树的节点中，[left, right] 区间对应的左右节点分别为 [left, mid] 和 [mid + 1, right]（mid = (left + right) / 2)。 ‼️注：线段树的数组长度要开到原数组长度的 4 倍 用于区间求和的线段树模版 单点更新 区间求和 1234567891011121314151617181920212223242526272829303132333435363738394041424344class SegmentTree &#123;private: int n; std::vector&lt;int&gt; tree; void update(int idx, int val, int node, int start, int end) &#123; // 单点更新 if (start == end) &#123; tree[node] = val; return; &#125; int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; if (idx &lt;= mid) &#123; update(idx, val, leftNode, start, mid); &#125; else &#123; update(idx, val, rightNode, mid + 1, end); &#125; tree[node] = tree[leftNode] + tree[rightNode]; &#125; int rangeSum(int left, int right, int node, int start, int end) &#123; // 区间求和 if (start &gt; right || end &lt; left) return 0; if (start &gt;= left &amp;&amp; end &lt;= right) return tree[node]; int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; return rangeSum(left, right, leftNode, start, mid) + rangeSum(left, right, rightNode, mid + 1, end); &#125;public: SegmentTree(int _n): n(_n), tree(4 * _n, 0) &#123;&#125; void update(int idx, int val) &#123; update(idx, val, 0, 0, n - 1); &#125; int rangeSum(int left, int right) &#123; return rangeSum(left, right, 0, 0, n - 1); &#125;&#125;; 用于求区间极值的线段树模版 单点更新 区间求极值 1234567891011121314151617181920212223242526272829303132333435363738394041424344class SegmentTree &#123;private: int n; std::vector&lt;int&gt; tree; void update(int idx, int val, int node, int start, int end) &#123; // 单点更新 if (start == end) &#123; tree[node] = val; return; &#125; int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; if (idx &lt;= mid) &#123; update(idx, val, leftNode, start, mid); &#125; else &#123; update(idx, val, rightNode, mid + 1, end); &#125; tree[node] = std::max(tree[leftNode], tree[rightNode]); &#125; int maxVal(int left, int right, int node, int start, int end) &#123; // 求区间极大值 if (start &gt; right || end &lt; left) return INT_MIN; if (start &gt;= left &amp;&amp; end &lt;= right) return tree[node]; int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; return std::max(maxVal(left, right, leftNode, start, mid), maxVal(left, right, rightNode, mid + 1, end)); &#125;public: SegmentTree(int _n): n(_n), tree(4 * _n, 0) &#123;&#125; void update(int idx, int val) &#123; update(idx, val, 0, 0, n - 1); &#125; int maxVal(int left, int right) &#123; return maxVal(left, right, 0, 0, n - 1); &#125;&#125;; 有时候我们可能会遇到这样的需求：要多次将数组中一个区间内的每个元素都添加一个固定的值，如果逐一修改，则会消耗大量的时间，这个时候我们就可以使用带延迟标记的线段树。 什么是延迟标记？ —— 即对线段树的某个节点的数据更新完后不急于对其子节点进行更新，而是将更新信息存储下来，而当必须更新的时候再将信息传递给子节点。 使用延迟标记进行区间修改的线段树模版 区间修改 区间求和 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class SegmentTree &#123;private: int n; std::vector&lt;int&gt; tree; std::vector&lt;int&gt; lazy; inline void maintain(int node, int start, int end) &#123; // 传递 lazy 标签 int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; tree[leftNode] += (mid - start + 1) * lazy[node]; lazy[leftNode] += lazy[node]; tree[rightNode] += (end - mid) * lazy[node]; lazy[rightNode] += lazy[node]; lazy[node] = 0; &#125; void add(int left, int right, int val, int node, int start, int end) &#123; // 给区间 [left, right] 的所有数添加 val if (start &gt; right || end &lt; left) return; if (start &gt;= left &amp;&amp; end &lt;= right) &#123; tree[node] += (end - start + 1) * val; lazy[node] += val; return; &#125; if (lazy[node]) maintain(node, start, end); int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; add(left, right, val, leftNode, start, mid); add(left, right, val, rightNode, mid + 1, end); tree[node] = tree[leftNode] + tree[rightNode]; &#125; int rangeSum(int left, int right, int node, int start, int end) &#123; // 区间求和 if (start &gt; right || end &lt; left) return 0; if (start &gt;= left &amp;&amp; end &lt;= right) return tree[node]; if (lazy[node]) maintain(node, start, end); int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; return rangeSum(left, right, leftNode, start, mid) + rangeSum(left, right, rightNode, mid + 1, end); &#125;public: SegmentTree(int _n): n(_n), tree(4 * _n), lazy(4 * _n) &#123;&#125; void add(int left, int right, int val) &#123; add(left, right, val, 0, 0, n - 1); &#125; int rangeSum(int left, int right) &#123; return rangeSum(left, right, 0, 0, n - 1); &#125;&#125;; 案例 逆序对记数 题目链接 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;iostream&gt;#include &lt;algorithm&gt;const int MAX_N = 5e5 + 5;struct &#123; int val; int id;&#125; arr[MAX_N];int rank[MAX_N];namespace __BIT &#123; int bit[MAX_N]; int n; inline int lowbit(int x) &#123; return x &amp; -x; &#125; int query(int idx) &#123; int res = 0; while (idx) &#123; res += bit[idx]; idx -= lowbit(idx); &#125; return res; &#125; void add(int idx, int val) &#123; while (idx &lt;= n) &#123; bit[idx] += val; idx += lowbit(idx); &#125; &#125;&#125;using namespace __BIT;using i64 = long long;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n; for (int i = 1; i &lt;= n; i++) &#123; std::cin &gt;&gt; arr[i].val; arr[i].id = i; &#125; std::sort(arr + 1, arr + n + 1, [](const auto&amp; a1, const auto&amp; a2) &#123; return a1.val != a2.val ? a1.val &lt; a2.val : a1.id &lt; a2.id; &#125;); for (int i = 1; i &lt;= n; i++) rank[arr[i].id] = i; i64 res = 0; for (int i = 1; i &lt;= n; i++) &#123; res += i - 1 - query(rank[i]); add(rank[i], 1); &#125; std::cout &lt;&lt; res &lt;&lt; &#x27;\\n&#x27;; return 0;&#125; 二维数点 题目链接 二维数点是树状数组的一个典型应用，本题的 AC 代码如下： 注：需要开启 O2 优化 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include &lt;iostream&gt;#include &lt;algorithm&gt;const int MAX_N = 5e5 + 5, MAX_M = 5e5 + 5;int n, m;struct Tree &#123; int x; int y;&#125; tree[MAX_N];struct Query &#123; int x; int y; int id; int res;&#125; q[4 * MAX_M];const int MAX_Y = 1e7 + 7;namespace __BIT &#123; int bit[MAX_Y]; int len; inline int lowbit(int x) &#123; return x &amp; -x; &#125; int query(int idx) &#123; idx = idx &lt;= len ? idx : len; int res = 0; for (int i = idx; i; i -= lowbit(i)) res += bit[i]; return res; &#125; void add(int idx, int val) &#123; for (int i = idx; i &lt;= len; i += lowbit(i)) bit[i] += val; &#125;&#125;using namespace __BIT;int main() &#123; std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr); std::cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; std::cin &gt;&gt; tree[i].x &gt;&gt; tree[i].y; tree[i].x++, tree[i].y++; len = std::max(len, tree[i].y); &#125; std::sort(tree, tree + n, [](const Tree&amp; t1, const Tree&amp; t2) &#123; return t1.x &lt; t2.x; &#125;); int all = 4 * m; for (int i = 0, a, b, c, d; i &lt; all; i += 4) &#123; std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d; a++, b++, c++, d++; q[i] = &#123;c, d, i&#125;; q[i + 1] = &#123;a - 1, d, i + 1&#125;; q[i + 2] = &#123;c, b - 1, i + 2&#125;; q[i + 3] = &#123;a - 1, b - 1, i + 3&#125;; &#125; std::sort(q, q + all, [](const Query&amp; q1, const Query&amp; q2) &#123; return q1.x &lt; q2.x; &#125;); int j = 0; for (int i = 0; i &lt; n; i++) &#123; while (j &lt; all &amp;&amp; tree[i].x &gt; q[j].x) &#123; // 当前范围已经统计结束 q[j].res = query(q[j].y); j++; &#125; add(tree[i].y, 1); &#125; while (j &lt; all) &#123; q[j].res = query(q[j].y); j++; &#125; std::sort(q, q + all, [](const Query&amp; q1, const Query&amp; q2) &#123; return q1.id &lt; q2.id; &#125;); for (int i = 0; i &lt; all; i += 4) &#123; std::cout &lt;&lt; q[i].res - q[i + 1].res - q[i + 2].res + q[i + 3].res &lt;&lt; &#x27;\\n&#x27;; &#125; return 0;&#125; 统计最长递增子序列 题目链接 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123;private: int n; std::vector&lt;int&gt; tree; int query(int idx) &#123; int res = 0; while (idx) &#123; res = std::max(res, tree[idx]); idx &amp;= idx - 1; &#125; return res; &#125; void update(int idx, int val) &#123; while (idx &lt;= n) &#123; tree[idx] = std::max(tree[idx], val); idx += idx &amp; -idx; &#125; &#125;public: int lengthOfLIS(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); this-&gt;n = n; tree.resize(n + 1); std::vector&lt;std::pair&lt;int, int&gt;&gt; p(n); for (int i = 0; i &lt; n; i++) &#123; p[i].first = nums[i]; p[i].second = i + 1; &#125; std::sort(p.begin(), p.end(), [](const std::pair&lt;int, int&gt;&amp; p1, const std::pair&lt;int, int&gt;&amp; p2) &#123; return p1.first != p2.first ? p1.first &lt; p2.first : p1.second &gt; p2.second; &#125;); for (const auto&amp; [_, idx] : p) &#123; update(idx, query(idx) + 1); &#125; return query(n); &#125;&#125;; 其他 网格图中最少访问的格子数（线段树 单点修改 + 区间查询） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class SegTree &#123;// 单点修改 + 区间查询private: int n; vector&lt;int&gt; tree; void update(int idx, int val, int node, int start, int end) &#123; if (start == end) &#123; tree[node] = val; return; &#125; int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; if (idx &lt;= mid) &#123; update(idx, val, leftNode, start, mid); &#125; else &#123; update(idx, val, rightNode, mid + 1, end); &#125; tree[node] = min(tree[leftNode], tree[rightNode]); &#125; int query(int left, int right, int node, int start, int end) &#123; if (start &gt; right || end &lt; left) return INT_MAX; if (start &gt;= left &amp;&amp; end &lt;= right) return tree[node]; int leftNode = 2 * node + 1, rightNode = 2 * node + 2; int mid = (start + end) / 2; return min(query(left, right, leftNode, start, mid), query(left, right, rightNode, mid + 1, end)); &#125;public: SegTree(int _n): n(_n), tree(4 * _n, INT_MAX) &#123;&#125; void update(int idx, int val) &#123; update(idx, val, 0, 0, n - 1); &#125; int query(int left, int right) &#123; return query(left, right, 0, 0, n - 1); &#125;&#125;;class Solution &#123;public: int minimumVisitedCells(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int m = grid.size(), n = grid[0].size(); SegTree trRow(m * n); SegTree trCol(n * m); trRow.update(m * n - 1, 0); trCol.update(n * m - 1, 0); for (int i = m - 1; i &gt;= 0; i--) &#123; for (int j = n - 1; j &gt;= 0; j--) &#123; int resRow = trRow.query(n * i + j, n * i + min(j + grid[i][j], n - 1)); // (i, j) ~ (i, j + grid[i][j]) 中的最小值 int resCol = trCol.query(m * j + i, m * j + min(i + grid[i][j], m - 1)); // (i, j) ~ (i + grid[i][j], j) 中的最小值 int res = min(resRow, resCol); if (res != INT_MAX) &#123; trRow.update(n * i + j, res + 1); trCol.update(m * j + i, res + 1); &#125; &#125; &#125; int ans = trRow.query(0, 0); return ans != INT_MAX ? ans : -1; &#125;&#125;;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"区间查询","slug":"区间查询","permalink":"http://example.com/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/"},{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"std::bitset 讲解","slug":"std-bitset 详解","date":"2023-03-08T08:46:06.000Z","updated":"2023-07-10T08:08:19.964Z","comments":true,"path":"2023/03/08/std-bitset 详解/","link":"","permalink":"http://example.com/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"介绍 std::bitset 是 C++ 提供的一种 n-bit 固定大小序列的模版，可以用于标准逻辑运算，并且可以与字符串和整数相互转换，还可以使用标准流输出。 12template&lt; std::size_t N &gt;class bitset; 模版形参 N ：要为 bitset 分配储存的 bit 位数 头文件：&lt;bitset&gt; 构造方法 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;#include &lt;bitset&gt;int main() &#123; // 1. 无参构造 std::bitset&lt;5&gt; testCase_1; std::cout &lt;&lt; testCase_1 &lt;&lt; std::endl; // 00000 // 2. 传入整数 std::bitset&lt;4&gt; testCase_2&#123;0xb&#125;; std::cout &lt;&lt; testCase_2 &lt;&lt; std::endl; // 1011 std::bitset&lt;4&gt; testCase_3&#123;0x10&#125;; // 溢出位自动截断 std::cout &lt;&lt; testCase_3 &lt;&lt; std::endl; // 0000 // 3. 传入字符串 std::bitset&lt;8&gt; testCase_4&#123;&quot;10010101&quot;&#125;; // 传入 0-1 字符串 std::cout &lt;&lt; testCase_4 &lt;&lt; std::endl; // 10010101 std::bitset&lt;4&gt; testCase_5&#123;&quot;10010101&quot;&#125;; // 溢出位截断，只取前 4 位 std::cout &lt;&lt; testCase_5 &lt;&lt; std::endl; // 1001 std::bitset&lt;8&gt; testCase_6&#123;&quot;ABABA&quot;, /* 读取长度 */4, /* 代表 0 的字符 */&#x27;A&#x27;, /* 代表 1 的字符 */&#x27;B&#x27;&#125;; // 00000101 std::cout &lt;&lt; testCase_6 &lt;&lt; std::endl; // 4. 支持赋值构造以及整数和字符串到 bitset 的强制类型转化 std::bitset&lt;8&gt; testCase_7 = testCase_6; std::cout &lt;&lt; testCase_7 &lt;&lt; std::endl; // 00000101 std::cout &lt;&lt; (std::bitset&lt;8&gt;)0xf &lt;&lt; std::endl; // 00001111 std::cout &lt;&lt; (std::bitset&lt;8&gt;)&quot;1111&quot; &lt;&lt; std::endl; // 00001111 std::bitset&lt;10&gt; testCase_8 = 0x7f; std::cout &lt;&lt; testCase_8 &lt;&lt; std::endl; // 0001111111 return 0;&#125; 成员方法 支持下标 operator[] 123std::bitset&lt;10&gt; num = (std::bitset&lt;10&gt;)&quot;111011&quot;;std::cout &lt;&lt; num[2] &lt;&lt; std::endl; // 0// 从低位开始 bitset 支持所有常规位运算操作 123456789101112std::bitset&lt;10&gt; num = 0xf;std::cout &lt;&lt; (num &amp; (std::bitset&lt;10&gt;)0x12) &lt;&lt; std::endl; // 0000000010std::cout &lt;&lt; (num | (std::bitset&lt;10&gt;)0x12) &lt;&lt; std::endl; // 0000011111std::cout &lt;&lt; (num ^ (std::bitset&lt;10&gt;)0x12) &lt;&lt; std::endl; // 0000011101std::cout &lt;&lt; (num &lt;&lt; 2) &lt;&lt; std::endl; // 0000111100std::cout &lt;&lt; (num &gt;&gt; 2) &lt;&lt; std::endl; // 0000000011num = -1;std::cout &lt;&lt; num &lt;&lt; std::endl; // 1111111111std::cout &lt;&lt; (num &gt;&gt; 2) &lt;&lt; std::endl; // 0011111111// 对 bitset 的右移都是逻辑右移 set() ：设置单独位的值 123std::bitset&lt;10&gt; num = -1;num.set(0, false); // 将下标为 0 的位设置为 0std::cout &lt;&lt; num &lt;&lt; std::endl; // 1111111110 flip() ：取反，无参数时默认对全部位 12345std::bitset&lt;10&gt; num = 0xf;num.flip();std::cout &lt;&lt; num &lt;&lt; std::endl; // 1111110000num.flip(1);std::cout &lt;&lt; num &lt;&lt; std::endl; // 1111110010 检查位 all() ：判断是否所有位都为 1 any() ：判断是否有任意一位为 1 none() ：判断是否所有位为 0 12345std::bitset&lt;4&gt; num = 0x7;std::cout &lt;&lt; num.all() &lt;&lt; std::endl; // 0std::cout &lt;&lt; num.any() &lt;&lt; std::endl; // 1std::cout &lt;&lt; num.none() &lt;&lt; std::endl; // 0 count() ：返回 1 的数量 123std::bitset&lt;4&gt; num = 0x7;std::cout &lt;&lt; num.count() &lt;&lt; std::endl; // 3 size() ：返回位数 12std::bitset&lt;10&gt; num;std::cout &lt;&lt; num.size() &lt;&lt; std::endl; // 10 转换： to_string() ：返回数据的字符串类型 to_ulong ：返回数据的 unsigned long 整数表示 to_ullong ：返回数据的 unsigned long long 整数表示 12345678std::bitset&lt;8&gt; num_bit = 0xf;unsigned long num_1 = num_bit.to_ulong();unsigned long long num_2 = num_bit.to_ullong();std::string str = num_bit.to_string();std::cout &lt;&lt; num_1 &lt;&lt; std::endl; // 15std::cout &lt;&lt; num_2 &lt;&lt; std::endl; // 15std::cout &lt;&lt; str &lt;&lt; std::endl; // 00001111 ​","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"}]},{"title":"链式前向星介绍","slug":"链式前向星介绍","date":"2023-03-06T08:42:40.000Z","updated":"2023-07-10T08:24:40.172Z","comments":true,"path":"2023/03/06/链式前向星介绍/","link":"","permalink":"http://example.com/2023/03/06/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"什么是链式前向星？ 链式前向星是一种常用的图存储结构，其思路类似于邻接链表法，只是实现方式有所不同，链式向前星更像是用数组模拟链表。 与一般的邻接链表法不同，链式向前星储存的图的每条边都有编号。 以下是链式前向星的存储结构： cnt ：用来记录当前所有边的数量 first 数组：用来存储从某个节点出发的第一条边，例如 first[0] == 3 可以得出从 0 号节点出发的第一条边的编号为 3 edges 数组：用来记录每条边的信息，对于每个 edges[i] 都有 3 个域： to ：记录边的终点 weight ：记录边的权重 next ：记录从当前起点出发下一条边的编号，例如：若 edges[i] 的起点为 j 号节点，则 edges[i].next 表示从 j 出发的下一条边 示例： 如上图，这就是链式向前星存储图的方式了，其中编号为 -1 的边表示不存在，即没有其他的出边。 若我们需要新增一条从 i 到 j 的边，只需更新在 edges 数组内增加元素并且使其新增边的 next 等于 first[i] ，然后更新 first[i] 为新增的边的编号即可。 代码 12345678910111213141516171819202122232425262728293031#define MAX_VERTEX 100000#define MAX_EDGE 100000int cnt; // 边的数量int first[MAX_VERTEX]; // first 数组struct &#123; int to; int weight; int next;&#125; edges[MAX_EDGE]; // 记录边void initEdge() &#123; cnt = 0; // 初始化，将 first 数组全初始化为 -1 memset(first, 0xff, sizeof(first));&#125;void addEdge(int from, int to, int weight) &#123; edges[cnt] = &#123;to, weight, first[from]&#125;; // 新增边 first[from] = cnt; // 更新 first 数组 cnt++; // 边数增加&#125;void traverseEdgeFrom(int v) &#123; // 遍历从 v 出发的所有边 for (int p = first[v]; p != -1; p = edges[p].next) &#123; std::cout &lt;&lt; &quot;eNo: &quot; &lt;&lt; p &lt;&lt; &quot; to: &quot; &lt;&lt; edges[p].to &lt;&lt; &quot; weight: &quot; &lt;&lt; edges[p].weight &lt;&lt; std::endl; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"图论","slug":"图论","permalink":"http://example.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"链式前向星","slug":"链式前向星","permalink":"http://example.com/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"}]},{"title":"ICG 游戏博弈问题与 SG 定理","slug":"ICG 游戏博弈问题与 SG 定理","date":"2023-03-02T05:07:17.000Z","updated":"2023-07-10T08:25:45.820Z","comments":true,"path":"2023/03/02/ICG 游戏博弈问题与 SG 定理/","link":"","permalink":"http://example.com/2023/03/02/ICG%20%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98%E4%B8%8E%20SG%20%E5%AE%9A%E7%90%86/","excerpt":"","text":"ICG 游戏 定义 ICG 游戏是博弈游戏的一种，其定义如下： 游戏由两人参加，两人轮流做出决策 当有一人无法决策即无论如何都必败时对手胜出，且 ICG 游戏一定会在有限步内完成，游戏没有平局 游戏的状态转移是单向的，同一个状态只能达到一次 必胜点和必败点 必胜点 N ( Next ) 和必败点 P ( Previous ) 描述的是某个游戏状态当前的胜负。 若当前状态为必胜点 N ，则先手必胜，反之，若当前状态为必败点 P ，则先手必败。 可能到这里为止大家还是会觉得比较抽象，所以我们给出一个实际例子： 假设有一堆石头，两人轮流从这堆石头中取走 1 ~ 5 块石头，初始状态下有 n 块石头，问 n 为何值时先手必胜？ 先说结论：n % 6 != 0 时先手必胜。 原因十分简单，若 n 不是 6 的倍数，则先手一定可以取走 1 ～ 5 块内的石头使得取走石头后这堆石头的数量能被 6 整除，此后，对手只要取走 m 块石头，我们就取走 6 - m 块石头，可以保证我们每次取完后石头的数量都是 6 的倍数。如此一来，最后的石头一定是被我们取走。 于是，我们可以得到石头数量 n 对应的 NP 状态： n 0 1 2 3 4 5 6 7 8 9 ... state P N N N N N P N N N ... 在这里，我们不难得出结论： 所有必胜点必然可以在一步操作内转移到必败点 所有必败点无论如何操作只能转移到必胜点 SG 定理 SG 是 Sprague-Grundy 的缩写，SG 定理是处理 ICG 博弈问题的重要方法，在讲解其使用之前，我们先简要介绍一下 SG 函数的定义。 SG 函数 首先我们定义 \\(mex\\) ( minimal excludant ) 运算，\\(mex(F)\\) 即表示不属于非负整数集 \\(F\\) 中最小的元素： 例如： \\[ \\begin{array}{} mex(\\{1, 2, 3\\}) = 0 \\\\ mex(\\{0, 1, 3, 4\\}) = 2 \\\\ mex(\\emptyset) = 0 \\end{array} \\] 什么是 SG 值？ SG 值是一种通过递归定义的值，它一般情况下是一个非负整数，可以用来描述游戏状态是必胜点还是必败点，假设游戏状态 \\(V_i\\) 的 SG 值为 \\(SG(V_i)\\) ，那么其状态转移方程如下： \\[ SG(V_i) = mex(\\{SG(V_j) \\ | \\ V_i \\rightarrow V_j \\}) \\] 其数值上等于与 \\(V_i\\) 所有后继状态的 SG 值不相等的最小非负整数。 基于此，我们得到一条重要结论：SG 值不为 0 的状态为必胜点，SG 值为 0 的状态为必败点。 这个结论很好证明：若 SG 值不为 0，说明该状态一定能一步转移到 SG 值为 0 的状态，即可以一步转移到必败点，所以该状态一定为必胜点；反之，若 SG 值为 0，则该状态无法一步转移到必败点，只能转移到必胜点或者无法决策，故该点一定为必败点。 我们还是用上述的取石头问题来举例说明，则不同石头数量 n 对应的 SG 值如下： n 0 1 2 3 4 5 6 7 8 9 10 SG(n) 0 1 2 3 4 5 0 1 2 3 4 \\[ \\begin{array}{} SG(0) = mex(\\emptyset) = 0 \\\\ SG(1) = mex(\\{0\\}) = 1 \\\\ SG(2) = mex(\\{0, 1\\}) = 2 \\\\ SG(3) = mex(\\{0, 1, 2\\}) = 3 \\\\ SG(4) = mex(\\{0, 1, 2, 3\\}) = 4 \\\\ SG(5) = mex(\\{0, 1, 2, 3, 4\\}) = 5 \\\\ SG(6) = mex(\\{1, 2, 3, 4, 5\\}) = 0 \\\\ ... \\newline SG(10) = mex(\\{5, 0, 1, 2, 3\\}) = 4 \\\\ ... \\end{array} \\] SG 定理详解 现在我们已经知道了 SG 函数的定义，那 SG 定理又是什么呢？ 什么是 SG 定理 ? SG 定理指的是若一个 ICG 博弈游戏的游戏状态可以分为多个子状态，且子状态互相独立，则该游戏状态下的 SG 值等于所有子状态的 SG 值的异或值。 这又是什么意思呢？别急，我们还是用取石头的例子来说明： 假设现在有 \\(k\\) 堆石头，每堆石头有 \\(n_i(i = 1, 2, ...,k)\\) 块石头 ，两个人轮流从每一堆石头中取走 \\([1, m]\\) 块石头，先取完所有石头的一方获胜。我们设此刻游戏状态的 SG 值为 \\(SG((n_1, n_2, ..., n_k))\\) ，由 SG 定理可得： \\[ SG((n_1, n_2, ..., n_k)) = SG(n_1) \\oplus SG(n_2) \\oplus ... \\oplus SG(n_k) \\] \\(SG((n_1, n_2, ..., n_k)) \\neq 0\\) ：先手胜 \\(SG((n_1, n_2, ..., n_k)) = 0\\) ：先手败 以上就是完整的 SG 定理了。 SG 定理的合理性 为什么 SG 定理会与位运算的异或有关呢？它们是如何联系上的？为什么这种计算是合理的呢？ 以下我们给出简要的证明： 根据 SG 值的定义，必败点的 SG 值一定为 0，对于此题而言，游戏的终点就是所有的石头被取完，此时 SG 值是 k 个 0 的异或值，显然为 0。 若当前的 SG 值不为 0，我们假设： \\[ SG((n_1, n_2, ..., n_k)) = {001010..}_2 \\] 我们找到该 SG 值数值为 1 的最高位，由异或运算符的性质，必然存在奇数个子状态的 SG 值该位为 1，我们不妨假设其中一个子状态对应的 SG 值为 \\(SG_0\\) ，由 SG 值的定义，该状态一定可以一步之内转变为任何 SG 值小于 \\(SG_0\\) 的状态，\\(SG_0\\) 对应母状态下数值为 1 的最高位的值也为 1，我们让其变为 0，然后从这一位开始之后全部位取反，则一定可以将母状态的 SG 值变为 0。 0 1 0 1 1 1 0 1 1 0 0 0 0 1 0 1 0 1 0 1 1 0 1 0 如上，我们将第二个子状态 的 SG 值转移到 0 0 0 1 1 1，就将母状态的 SG 值转化为 0 了 0 1 0 1 1 1 0 0 0 1 1 1 0 1 0 1 0 1 0 0 0 0 0 0 反之，如果母状态的 SG 值为 0，则改变任何一个子状态，由于异或运算的性质，母状态的 SG 值一定无法维持为 0。 而根据 ICG 博弈游戏的定义，游戏一定会在有限步内完成，故所有子状态 SG 值的异或运算不为 0 的母状态一定是必胜点。 实际应用 Fibonacci again and again Problem Description 任何一个大学生对菲波那契数列(Fibonacci numbers)应该都不会陌生，它是这样定义的： F(1) = 1； F(2) = 2； F(n) = F(n - 1) + F(n - 2) ( n &gt;= 3 )； 所以，1, 2, 3, 5, 8, 13, ... 就是菲波那契数列。 今天，又一个关于 Fibonacci 的题目出现了，它是一个小游戏，定义如下： 这是一个二人游戏； 一共有 3 堆石子，数量分别是 m, n, p 个； 两人轮流走； 每走一步可以选择任意一堆石子，然后取走f个； f 只能是菲波那契数列中的元素 ( 即每次只能取1，2，3，5，8 … 等数量 )； 最先取光所有石子的人为胜者； 假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。 Input 输入数据包含多个测试用例，每个测试用例占一行，包含 3 个整数 m, n, p ( 1 &lt;= m, n, p &lt;= 1000 )。 m = n = p = 0 则表示输入结束。 Output 如果先手的人能赢，请输出“Fibo”，否则请输出“Nacci”，每个实例的输出占一行。 输入样例 1231 1 11 4 10 0 0 输出样例 12FiboNacci 分析： 本题所描述的游戏就是一种 ICG 博弈，且三堆石头互不影响，所以我们可以直接使用 SG 定理求解，再加上记忆化 DFS 优化，很容易就能求解此问题。废话不多说，直接上代码😎。 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAX_FIB_NUM 50#define MAX_AMOUNT 1005int Fibonacci[MAX_FIB_NUM]; // 储存 Fibonacci 数列的值int SG[MAX_AMOUNT]; // 记录 SG 值，初始化为 -1// 记忆化搜索int fib(int n) &#123; if (Fibonacci[n]) &#123; return Fibonacci[n]; &#125; if (n == 0) &#123; Fibonacci[n] = 1; return 1; &#125; else if (n == 1) &#123; Fibonacci[n] = 2; return 2; &#125; Fibonacci[n] = fib(n - 1) + fib(n - 2); // 记忆 return Fibonacci[n];&#125;int sg(int n) &#123; // 返回 SG 值 if (SG[n] &gt;= 0) &#123; return SG[n]; &#125; if (n == 0) &#123; SG[n] = 0; return 0; &#125; bool vis[MAX_AMOUNT] = &#123;0&#125;; // 记录当前状态可达状态的 SG 值是否出现过 for (int i = 0; n - fib(i) &gt;= 0; i++) &#123; vis[sg(n - fib(i))] = true; // 记录已出现的 SG 值 &#125; for (int i = 0; i &lt; MAX_AMOUNT; i++) &#123; if (!vis[i]) &#123; SG[n] = i; break; &#125; &#125; return SG[n];&#125;int main() &#123; ios::sync_with_stdio(false); memset(SG, 0xff, sizeof(SG)); // 初始化 int m, n, p; while (cin &gt;&gt; m &gt;&gt; n &gt;&gt; p, m != 0 || n != 0 || p != 0) &#123; if (sg(m) ^ sg(n) ^ sg(p)) &#123; // SG 定理 cout &lt;&lt; &quot;Fibo&quot; &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; &quot;Nacci&quot; &lt;&lt; endl; &#125; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"SG 定理","slug":"SG-定理","permalink":"http://example.com/tags/SG-%E5%AE%9A%E7%90%86/"},{"name":"SG 函数","slug":"SG-函数","permalink":"http://example.com/tags/SG-%E5%87%BD%E6%95%B0/"},{"name":"组合博弈","slug":"组合博弈","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88%E5%8D%9A%E5%BC%88/"},{"name":"组合数学","slug":"组合数学","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"}]},{"title":"记忆化 DFS","slug":"记忆化 DFS","date":"2023-02-26T15:47:02.000Z","updated":"2023-07-10T08:27:12.697Z","comments":true,"path":"2023/02/26/记忆化 DFS/","link":"","permalink":"http://example.com/2023/02/26/%E8%AE%B0%E5%BF%86%E5%8C%96%20DFS/","excerpt":"","text":"引入 记忆化 DFS，顾名思义，就是带有记忆的深度优先搜索。 总所周知，用程序实现 Fibonacci 数列求值有两种常见方式： 通过迭代即非递归的方式： 12345678910111213int Fibonacci(int n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; int pre = 1, next = 1, sum = 0; while (n-- &gt; 2) &#123; sum = pre + next; pre = next; next = sum; &#125; return sum;&#125; 通过递归方式： 123456int Fibonacci(int n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 上述两种方式各有优缺点，迭代方式效率更高，但是写起来比较麻烦；递归方式运行效率低，但是代码实现容易。 有没有一种方式可以结合两者的优点呢？ 对于第二种递归方式，其主要的时间开销在于计算了许多重复内容，我们是否可以使用一个数组来维护已经计算过的值呢？ 答案是显然的，于是我们就有了 —— 记忆化 DFS： 123456789101112131415int fib[MAX_NUM]; // 记忆数组int Fibonacci(int n) &#123; if (fib[n]) &#123; return fib[n]; // 已经计算过的值直接返回 &#125; if (n == 1 || n == 2) &#123; fib[n] = 1; &#125; else &#123; fib[n] = Fibonacci(n - 1) + Fibonacci(n - 2); &#125; return fib[n];&#125; 以上代码以递归的方式实现，但是时间复杂度可以降到线性，和迭代形式一样，不同的地方在于我们需要额外的空间开销来记录已经计算过的值。 可能有同学就有疑问了： 上述例子很容易用 DP 来实现，为什么还需要记忆化 DFS 呢？ 接下来我们将给出几个实际例子加以说明。 实例分析 案例一 猫和老鼠 Problem Description 有个小老鼠在校园里收藏了一些它最爱吃的奶酪。 校园可以看成一个长度为n的正方形网格，每个网格可以标记为 (p, q) ，其中，0 &lt;= p , q &lt; n。每个网格都有一个洞，里面储存了 k（0 &lt;= k &lt;= 100）块奶酪。 现在，小老鼠准备享用这些美味啦。 开始的时候，他在 (0, 0) 这个位置，每到一个地方，它都会吃光这个地方的奶酪，然后沿着水平或者垂直的方向到达另外一个地方。麻烦的是，有个很凶的猫总是在它的洞口附近，所以他每次最多移动 k 个位置，否则就会被这只猫吃掉。更糟糕的是，每在一个地方吃过奶酪，小老鼠都会变胖，所以，为了获得足够下一次逃跑的能量，它每次只能去比当前位置的奶酪更多的格子。 现在已知 n 和 k ，以及在每个网格的洞中小老鼠储存的奶酪的数量，请计算小老鼠在无法移动之前，一共最多能吃到多少块奶酪。 Input 题目包含多组测试数据。 每组测试数据组成如下： 首先一行包含2个不超过100的正整数 n 和 k ; 接下来 n 行，每行包含n个数： 第一行 n 个数分别表示 (0, 0), (0, 1), … (0, n - 1) 这些位置储存的奶酪数量； 第二行 n 个数分别表示 (1, 0), (1, 1), … (1, n - 1) 这些位置储存的奶酪数量； 以此类推... 输入数据以两个 -1 结束。 Output 请输出小老鼠最多 能够吃到的奶酪数量，每组数据输出一行。 输入案例： 123453 11 2 510 11 612 12 7-1 -1 输出案例： 137 分析： 根据题意，我们假设从 \\((x, y)\\) 出发的老鼠可以吃到的最大奶酪数量为 \\(ans(x, y)\\)，\\((x, y)\\) 处的芝士储量为 \\(cheese(x, y)\\)，老鼠可以从 \\((x, y)\\) 出发在一次 \\(k\\) 步以内的移动中到达的坐标的集合为 \\(S = \\{(x_1, y_1), (x_2, y_2), (x_3, y_3), ...\\}\\)，不难得出状态转移方程： \\[ ans(x, y) = max_{(x_n, y_n) \\in S} ans(x_n, y_n) \\ + \\ cheese(x, y) \\] 如果直接用动态规划求解，这个问题的处理会相当复杂，因为我们难以从该状态转移方程中确定 DP 的起点和 DP 的方向，所以直接采用迭代的方式恐怕不现实。 于是我们便考虑到可以使用记忆化 DFS，既保证了效率，又降低了编码难度。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;array&gt;using namespace std;#define MAX_LENG 105int cheese[MAX_LENG][MAX_LENG];int ans[MAX_LENG][MAX_LENG]; // 储存结果，初始化为 -1int n, k;const vector&lt;array&lt;int, 2&gt;&gt; dirs = &#123; &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;; // 运动方向int dfs(int x, int y) &#123; // 记忆化 DFS // 返回以 (x, y) 为起点可以吃到最多的奶酪 if (ans[x][y] &gt;= 0) &#123; // 已经计算过的值 return ans[x][y]; &#125; ans[x][y] = cheese[x][y]; int plusCheese = 0; for (auto&amp; dir :dirs) &#123; for (int s = 1; s &lt;= k; s++) &#123; int nx = x + s * dir[0]; int ny = y + s * dir[1]; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; cheese[nx][ny] &gt; cheese[x][y]) &#123; plusCheese = max(plusCheese, dfs(nx, ny)); &#125; &#125; &#125; ans[x][y] += plusCheese; return ans[x][y];&#125;int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; k, n != -1 || k != -1) &#123; memset(ans, 0xff, sizeof(ans)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; cheese[i][j]; &#125; &#125; cout &lt;&lt; dfs(0, 0) &lt;&lt; endl; &#125; return 0;&#125; 案例二 How many ways Problem Description 这是一个简单的生存游戏，你控制一个机器人从一个棋盘的起始点 (1, 1) 走到棋盘的终点 (n, m)。游戏的规则描述如下： 机器人一开始在棋盘的起始点并有起始点所标有的能量。 机器人只能向右或者向下走，并且每走一步消耗一单位能量。 机器人不能在原地停留。 当机器人选择了一条可行路径后，当他走到这条路径的终点时，他将只有终点所标记的能量。 img 如上图，机器人一开始在 (1, 1) 点，并拥有4单位能量，蓝色方块表示他所能到达的点，如果他在这次路径选择中选择的终点是 (2, 4) ，当他到达 (2, 4) 点时将拥有1单位的能量，并开始下一次路径选择，直到到达 (6, 6) 点。 我们的问题是机器人有多少种方式从起点走到终点。这可能是一个很大的数，输出的结果对 10000 取模。 Input 第一行输入一个整数T,表示数据的组数。 对于每一组数据第一行输入两个整数 n, m (1 &lt;= n, m &lt;= 100)。表示棋盘的大小。接下来输入 n 行,每行 m 个整数 e (0 &lt;= e &lt; 20)。 Output 对于每一组数据输出方式总数对10000取模的结果。 输入案例： 1234567816 64 5 6 6 4 32 2 3 1 7 21 1 4 6 2 75 8 4 3 9 57 6 6 2 1 53 1 1 3 7 2 输出案例： 13948 分析： 同案例一，我们只需找到状态转移方程后使用记忆化 DFS 即可，这里不再赘述。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int T; // 数据组数int n, m;#define MAX_LENG 105#define MAX_NUM 10000int energy[MAX_LENG][MAX_LENG]; // 记录每个格点点能量int ans[MAX_LENG][MAX_LENG]; // 记录答案，初始化为 -1int dfs(int x, int y) &#123; // 表示从 (x, y) 出发到终点又多少种走法 if (ans[x][y] &gt;= 0) &#123; return ans[x][y]; &#125; if (x == n - 1 &amp;&amp; y == m - 1) &#123; ans[x][y] = 1; return ans[x][y]; &#125; int power = energy[x][y]; // 能量 ans[x][y] = 0; for (int i = 0; i &lt;= power; i++) &#123; for (int j = 0; j &lt;= power - i; j++) &#123; // 遍历所有可能位置 int nx = x + i, ny = y + j; if (nx != x || ny != y) &#123; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m) &#123; ans[x][y] = (ans[x][y] + dfs(nx, ny)) % MAX_NUM; &#125; &#125; &#125; &#125; return ans[x][y];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; energy[i][j]; &#125; &#125; memset(ans, 0xff, sizeof(ans)); cout &lt;&lt; dfs(0, 0) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://example.com/tags/DFS/"}]},{"title":"二分匹配问题 —— 匈牙利算法","slug":"二分匹配算法详解","date":"2023-02-24T17:21:01.000Z","updated":"2023-07-26T17:39:24.427Z","comments":true,"path":"2023/02/25/二分匹配算法详解/","link":"","permalink":"http://example.com/2023/02/25/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"问题介绍 什么是二分图？ 对于图 \\(G(V,E)\\) 而言，若 \\(G\\) 中的所有点可以划分为两个子集 \\(G_1\\)、\\(G_2\\) ，且图中每条边 \\(e\\) 关联的两个顶点都属于不同的顶点子集，这样的图我们称为二分图（ Bipartite Graph ），或者二部图。 最大匹配问题和最小点覆盖问题 什么是最大匹配问题？给定一个二分图 \\(G(V,E)\\)，若 \\((a_i,b_j) \\in E\\) ，我们就称 \\(a_i\\) 和 \\(b_j\\) 是可配对的，已知该图中任意顶点至多匹配一个顶点，求最大匹配数。如下图，不难看出该图的最大匹配数为 2。其中一种匹配方式为 \\((a_1, b_1)\\)、\\((a_3, b_4)\\) 。 什么又是最小点覆盖问题呢？即从二分图中删除最少的顶点，使得图 \\(G\\) 中任何一对点都无法匹配。删除顶点的最小数量称为最小点覆盖数。如下图，不难看出最小覆盖数也是 2。我们可以删去 \\(a_3\\) 和 \\(b_1\\) 使得图中任何一对点都无法匹配。 这两个问题看似不一样，实际上实际上是处理一个相同的问题。为什么这么说呢？因为我们可以证明一条重要性质： 最大匹配数 = 最小覆盖数 具体证明就不在这里说明了，笔者打算以后单独出一期文章来证明该性质。 那我们该如何给出二分匹配问题的一般解决方案呢？1955 年，库恩（ W.W.Kuhn ）利用一个匈牙利数学家康哥尼（ D.Kőnig ）的一个定理构造了一种二分匹配问题的解法，后人称之为匈牙利算法。 匈牙利算法 在介绍匈牙利算法之前，我们先介绍几个概念： 交替路： 从未匹配点出发，依次经过未匹配的边和已匹配的边的路径称为交替路。 增广路： 经过除出发点之外其他未匹配点的交替路称为增广路。 当且仅当不存在关于图 \\(G\\) 的增广路径时当前的匹配为图 \\(G\\) 的最大匹配。 算法讲解 如下图所示，我们接下来将使用匈牙利算法来计算该二分图的最大匹配数。 我们从 \\(a_1\\) 开始匹配，\\(a_1\\) 与 \\(b_1\\) 匹配成功，即当前匹配对数为 1。 然后再对 \\(a_2\\) 进行匹配，我们发现 \\(a_2\\) 只能匹配 \\(b_1\\) ，而 \\(b_1\\) 已经与 \\(a_1\\) 匹配成功了，此时我们发现 \\(a_1\\) 和 \\(b_3\\) 可以成功匹配，于是我们可以取消 \\(a_1\\) 和 \\(b_1\\) 的匹配，然后匹配 \\(a_1\\) 和 \\(b_3\\) ，这个时候 \\(a_2\\) 就可以匹配 \\(b_1\\) 了。匹配对数加一，当前匹配对数为 2。 其实这一步相当于找到了一条增广路 \\((a_2, b_1, a_1, b_3)\\) ，然后对该增广路取反。 接下来对 \\(a_3\\) 进行匹配，\\(a_3\\) 与 \\(b_2\\) 成功匹配，匹配对数加一，当前匹配对数为 3。 最后对 \\(a_4\\) 进行匹配，发现其只能与 \\(b_1\\) 匹配，而 \\(b_1\\) 已经与 \\(a_1\\) 匹配过了，而且无法从 \\(a_4\\) 出发构造一条增广路，因此 \\(a_4\\) 无法与任何一个顶点成功匹配。 综上所述，展示的二分图的最大匹配数为 3。 伪代码： 123456789// 判断 ai 是否能匹配成功for bj 与 ai 相连: if bj 未被访问: 更新 bj 访问状态; if bj 未被匹配或者 bj 的配对点可以出发找到增广路径: 将 bj 的配对点改为 ai; return true;return false; 时间复杂度：\\(O(VE)\\) 代码实现 123456789101112131415161718192021222324252627282930313233343536373839#define NOT_MATCH 0x3f3f3f3fclass Solution &#123;private: int numA, numB; // numA、numB 分别表示两个集合的元素个数 vector&lt;vector&lt;int&gt;&gt; G; // 假设这里用邻接链表储存图 G，G[i] 表示和 ai 相邻的所有 B 集合的顶点编号 int match[numB]; // 记录 B 集合的元素的匹配点在 A 集合的编号 bool vis[numB]; // 记录 B 集合的元素是否被访问过 // ... bool isMatch(int index) &#123; // 判断 A 集合中编号为 index 的顶点是否能匹配成功 for (int i = 0; i &lt; G[index].size(); i++) &#123; if (!vis[G[i]]) &#123; vis[G[i]] = true; if (match[G[i]] == NOT_MATCH || isMatch(match[[G[i]]])) &#123; // 该顶点未被匹配或着原来匹配该点的顶点可以匹配其他顶点 match[G[i]] = index; return true; &#125; &#125; &#125; return false; &#125; public: int hungarian() &#123; int cnt = 0; for (int i = 0; i &lt; numA; i++) &#123; memset(vis, 0x3f, sizeof(vis)); if (isMatch(i)) &#123; cnt++; &#125; &#125; return cnt; &#125;&#125; 实际应用 Machine Schedule Problem Description As we all know, machine scheduling is a very classical problem in computer science and has been studied for a very long history. Scheduling problems differ widely in the nature of the constraints that must be satisfied and the type of schedule desired. Here we consider a 2-machine scheduling problem. There are two machines A and B. Machine A has n kinds of working modes, which is called \\(mode_0\\) , \\(mode_1\\) , …, \\(mode_{n-1}\\) , likewise machine B has m kinds of working modes, \\(mode_0\\), \\(mode_1\\) , … , \\(mode_{m-1}\\) . At the beginning they are both work at \\(mode_0\\). For k jobs given, each of them can be processed in either one of the two machines in particular mode. For example, job 0 can either be processed in machine A at \\(mode_3\\) or in machine B at \\(mode_4\\) , job 1 can either be processed in machine A at \\(mode_2\\) or in machine B at \\(mode_4\\) , and so on. Thus, for job i, the constraint can be represent as a triple (i, x, y), which means it can be processed either in machine A at \\(mode_x\\), or in machine B at \\(mode_y\\) . Obviously, to accomplish all the jobs, we need to change the machine’s working mode from time to time, but unfortunately, the machine’s working mode can only be changed by restarting it manually. By changing the sequence of the jobs and assigning each job to a suitable machine, please write a program to minimize the times of restarting machines. Input The input file for this program consists of several configurations. The first line of one configuration contains three positive integers: n, m (n, m &lt; 100) and k (k &lt; 1000). The following k lines give the constrains of the k jobs, each line is a triple: i, x, y. The input will be terminated by a line containing a single zero. Output The output should be one integer per line, which means the minimal times of restarting machine. 输入案例： 1234567891011125 5 100 1 11 1 22 1 33 1 44 2 15 2 26 2 37 2 48 3 39 4 30 输出案例： 13 对于此题，我们可以将 A、B 机器的所有模式看成二部图看成两个子集，若某个工作需要机器 A 的 x 模式和机器 B 的 y 模式来完成，就将 \\((a_x, b_y)\\) 连接起来。最后我们的问题就变成了：应该如何找到该二部图的最小点覆盖数？ 而根据我们之前提到的结论可知，最小点覆盖数在数值上等于最大匹配数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAX_NUM 105#define NOT_FOUND 0x3f3f3f3fint G[MAX_NUM][MAX_NUM];bool vis[MAX_NUM];int match[MAX_NUM];int n, m, k;bool isMatch(int index) &#123; for (int i = 0; i &lt; m; i++) &#123; if (G[index][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (match[i] == NOT_FOUND || isMatch(match[i])) &#123; match[i] = index; return true; &#125; &#125; &#125; return false;&#125;int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; if (n == 0) &#123; break; &#125; cin &gt;&gt; m &gt;&gt; k; memset(G, 0, sizeof(G)); memset(match, 0x3f, sizeof(match)); // 初始化 int t, ax, by; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; t &gt;&gt; ax &gt;&gt; by; if (ax != 0 &amp;&amp; by != 0) &#123; // 0 号模式下可以完成的任务不用添加 G[ax][by] = 1; &#125; &#125; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; memset(vis, 0, sizeof(vis)); if (isMatch(i)) &#123; cnt++; &#125; &#125; // 求出最小点覆盖数 cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125; 二分图博弈问题 二分图博弈是一类博弈模型，他可以抽象为：给出一张二分图和起点 \\(S\\) ，两人轮流进行操作，每次操作只能选择与上一个被选的点相邻的点，且不能选择已经选择过的点，无法选点的人输掉。问先手是否必胜。 结论：考虑二分图的所有最大匹配，如果在所有的最大匹配的方案中都包含了起点 \\(S\\) ，那么先手必胜，否则先手必败。 证明： 若所有最大匹配方案包括了 \\(S\\) ，则先手可以走到一个匹配点 \\(p_1\\) ，每一步后手都会走到一个新匹配点。假设后手走到了未匹配点 \\(p_n\\) ，考虑当前所走步：\\(S \\to p_1 \\to p_2 \\to ... \\to p_{n - 1} \\to p_{n}\\) ，则 \\((p_1, p_2), (p_3, p_4), ... (p_{n - 1}, p_{n})\\) 以及其他匹配对构成了不包含 \\(S\\) 的最大匹配，矛盾。因此后手一定会走到一个匹配点，综上所述，先手一定会选择完最后一个匹配点，后手将无路可走，先手必胜。 若存在一种最大匹配不包含 \\(S\\) ，则先手每一步只能走到新匹配点，假设先手在某一步走到了非匹配点 \\(p_n\\) ，则当前路径为 \\(S \\to p_1 \\to p_2 \\to ... \\to p_{n - 1} \\to p_{n}\\) ，此时 \\((S, p_1), (p_1, p_2), ... , (p_{n - 1}, p_n)\\) 加上其他匹配对构成了更大的匹配对数，这与假设矛盾。因此每一步先手后会走到新匹配点，后手走与该点匹配的点即可，最终后手一定会选择完最后一个匹配点，先手将无路可走，后手必胜。 如何确定某个点 \\(S\\) 在最大匹配中不可或缺呢？ 考虑先求该二分图的最大匹配，然后删除 \\(S\\) 点，再算一次最大匹配，若二者相等说明 \\(S\\) 不是最大匹配中不可或缺的点，反之这说明所有的最大匹配方案中都有 \\(S\\) 。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://example.com/tags/DFS/"},{"name":"二分匹配","slug":"二分匹配","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/"},{"name":"匈牙利算法","slug":"匈牙利算法","permalink":"http://example.com/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"},{"name":"二分图博弈","slug":"二分图博弈","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8D%9A%E5%BC%88/"}]},{"title":"LLDB 快速入门","slug":"LLDB 快速入门","date":"2023-02-22T03:01:12.000Z","updated":"2023-07-10T08:05:54.880Z","comments":true,"path":"2023/02/22/LLDB 快速入门/","link":"","permalink":"http://example.com/2023/02/22/LLDB%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"如果调试是删除 bug 的过程，那么编程就是引入 bug 的过程。 —— Edsger W. Dijkstra LLDB 是什么？ LLDB（ Low level Debug ）是 MacOS 默认进行调试 C/C++ 程序的调试工具，能帮开发者进行更加丰富地流程控制和栈帧数据监测。 简言之，LLDB 是一个有着 REPL 的特性和 C++ 、Python 插件的开源调试器。 在此，我们以几个简单的程序为例子，对 LLDB 进行快速入门。 目录 启动 LLDB 断点操作 设置断点 查看断点 删除断点 分步调试 启动调试 进入，跳过和继续 跳出当前函数 查看变量 结束调试 启动 LLDB 1234567891011121314151617181920212223242526// demo.cpp#include &lt;iostream&gt;using namespace std;int fact(int n) &#123; if (n == 0) &#123; return 1; &#125; else &#123; return n * fact(n - 1); &#125;&#125;int main() &#123; int x = 2; int y = 3; int z = x + y; cout &lt;&lt; fact(z) &lt;&lt; endl; return 0;&#125; 编译 C/C++ 程序时使其可以被 LLDB 调试工具设置断点，需要添加 -g ，以 C++ 文件 demo.cpp 为例： 123clang++ -g demo.cpplldb a.out 断点操作 设置断点 12br s -f [文件名] -l [行号] # 在文件的某一行设置断点br s -n [函数名] # 给函数设置断点 查看断点 1br list # 显示所有断点和其序号 删除断点 12br del [断点序号]br del # 删除所有断点 示例： 1234567891011121314151617181920212223242526(lldb) br s -f demo.cpp -l 17Breakpoint 1: where = a.out`main + 28 at demo.cpp:17:9, address = 0x0000000100003d80(lldb) br s -f demo.cpp -l 21Breakpoint 2: where = a.out`main + 56 at demo.cpp:21:18, address = 0x0000000100003d9c(lldb) br s -n factBreakpoint 3: where = a.out`fact(int) + 16 at demo.cpp:6:9, address = 0x0000000100003d18(lldb) br listCurrent breakpoints:1: file = &#x27;demo.cpp&#x27;, line = 17, exact_match = 0, locations = 1 1.1: where = a.out`main + 28 at demo.cpp:17:9, address = a.out[0x0000000100003d80], unresolved, hit count = 0 2: file = &#x27;demo.cpp&#x27;, line = 21, exact_match = 0, locations = 1 2.1: where = a.out`main + 56 at demo.cpp:21:18, address = a.out[0x0000000100003d9c], unresolved, hit count = 0 3: name = &#x27;fact&#x27;, locations = 1 3.1: where = a.out`fact(int) + 16 at demo.cpp:6:9, address = a.out[0x0000000100003d18], unresolved, hit count = 0 (lldb) br del 31 breakpoints deleted; 0 breakpoint locations disabled.(lldb) br listCurrent breakpoints:1: file = &#x27;demo.cpp&#x27;, line = 17, exact_match = 0, locations = 1 1.1: where = a.out`main + 28 at demo.cpp:17:9, address = a.out[0x0000000100003d80], unresolved, hit count = 0 2: file = &#x27;demo.cpp&#x27;, line = 21, exact_match = 0, locations = 1 2.1: where = a.out`main + 56 at demo.cpp:21:18, address = a.out[0x0000000100003d9c], unresolved, hit count = 0 分步调试 启动调试 1r 输入 run 或者 r 后程序便会开始启动调试 进入，跳过和继续 12345678# 进入 单步执行，中间如果有函数调用会跳转到目标函数s# 跳过 单步执行，中间的函数执行过程会跳过n# 继续 跳转到下一个断点c 跳出当前函数 1finish 查看变量 123456789101112131415161718# 查看某个变量：p [变量名]# 查看当前栈帧所有变量fr v# 切换栈帧fr s [栈帧序号]# 打印当前线程的栈帧信息bt# 打印所有线程的栈帧信息bt all 综合案例：在 demo.cpp 的 17 行和 21 行设置断点，使用 r 开始调试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1 frame #0: 0x0000000100003d80 a.out`main at demo.cpp:17:9 14 15 int main() &#123; 16 -&gt; 17 int x = 2; 18 int y = 3; 19 int z = x + y; 20 Target 0: (a.out) stopped.(lldb) sProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step in frame #0: 0x0000000100003d88 a.out`main at demo.cpp:18:9 15 int main() &#123; 16 17 int x = 2;-&gt; 18 int y = 3; 19 int z = x + y; 20 21 cout &lt;&lt; fact(z) &lt;&lt; endl;Target 0: (a.out) stopped.(lldb) sProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step in frame #0: 0x0000000100003d8c a.out`main at demo.cpp:19:13 16 17 int x = 2; 18 int y = 3;-&gt; 19 int z = x + y; 20 21 cout &lt;&lt; fact(z) &lt;&lt; endl; 22 Target 0: (a.out) stopped.(lldb) sProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 2.1 frame #0: 0x0000000100003d9c a.out`main at demo.cpp:21:18 18 int y = 3; 19 int z = x + y; 20 -&gt; 21 cout &lt;&lt; fact(z) &lt;&lt; endl; 22 23 return 0; 24 &#125;Target 0: (a.out) stopped.(lldb) fr v(int) x = 2(int) y = 3(int) z = 5(lldb) sProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step in frame #0: 0x0000000100003d18 a.out`fact(n=5) at demo.cpp:6:9 3 using namespace std; 4 5 int fact(int n) &#123;-&gt; 6 if (n == 0) &#123; 7 return 1; 8 &#125; 9 else &#123;Target 0: (a.out) stopped.(lldb) finishProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step outReturn value: (int) $0 = 120 frame #0: 0x0000000100003da4 a.out`main at demo.cpp:21:13 18 int y = 3; 19 int z = x + y; 20 -&gt; 21 cout &lt;&lt; fact(z) &lt;&lt; endl; 22 23 return 0; 24 &#125;Target 0: (a.out) stopped.(lldb) cProcess 31435 resuming120Process 31435 exited with status = 0 (0x00000000) 结束调试 1q 输入 quit 或者 q 结束 LLDB 调试 以上就是对 LLDB 的一个简单介绍了，如果想了解更多 LLDB 指令，可以查看官网的 LLDB command map","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"调试器","slug":"调试器","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"},{"name":"LLDB","slug":"LLDB","permalink":"http://example.com/tags/LLDB/"}]},{"title":"React 脚手架配置代理的方法","slug":"React 脚手架配置代理的方法","date":"2023-02-07T14:42:07.000Z","updated":"2023-07-10T08:03:12.050Z","comments":true,"path":"2023/02/07/React 脚手架配置代理的方法/","link":"","permalink":"http://example.com/2023/02/07/React%20%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"方法一：直接在 package.json 中追加配置 例如，当前服务器端口为 3000，若要向端口 5000 的服务器发送请求，我们可以在 package.json 中添加如下配置： 1&quot;proxy&quot;: &quot;http://localhost:5000&quot; 此后，当请求了 3000 端口不存在的资源时，那么请求就会转发给 5000 端口。 示例： 例如一个 create-react-app 创建项目在 3001 端口运行，我们使用 json-server 模拟了一个 3000 端口的服务器，其中 JSON 数据如下： 1234567&#123; &quot;students&quot;: [ &#123;&quot;id&quot;: &quot;0001&quot;, &quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;id&quot;: &quot;0002&quot;, &quot;name&quot;: &quot;Jack&quot;, &quot;age&quot;: 19&#125;, &#123;&quot;id&quot;: &quot;0003&quot;, &quot;name&quot;: &quot;Frank&quot;, &quot;age&quot;: 20&#125; ]&#125; students 数据的 URL 为 http://localhost:3000/students，若我们要向 3001 端口发送 GET 请求来获取 students 的 JSON 数据，则可以在 package.json 中添加配置： 1&quot;proxy&quot;: &quot;http://localhost:3000&quot; 获取 3001 端口有的资源： 12345678910111213141516171819202122export default class App extends Component &#123; getInfo = () =&gt; &#123; axios.get(&quot;http://localhost:3001/index.html&quot;).then( response =&gt; &#123; console.log(response.data); &#125;, err =&gt; &#123; console.log(err); &#125; ); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.getInfo&#125;&gt;点击发送请求获取数据&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 此时控制台输出当前项目下的 index.html 文件： 获取 3001 端口没有而 3000 端口有的资源： 12345678910111213141516171819202122export default class App extends Component &#123; getInfo = () =&gt; &#123; axios.get(&quot;http://localhost:3001/students&quot;).then( response =&gt; &#123; console.log(response.data); &#125;, err =&gt; &#123; console.log(err); &#125; ); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.getInfo&#125;&gt;点击发送请求获取数据&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 此时控制台输出 3000 端口下的 students 数据： 若获取的资源 3001 端口和 3000 端口都没有，则控制台会报错。 方法一优缺点： 优点：配置简单，前端请求资源时可以不加任何前缀 缺点：不能配置多个代理 方法二：创建 setupProxy.js 文件 首先在 src 目录下创建 setupProxy.js 文件 编写 setupProxy.js 配置具体代码规范： 12345678910111213141516171819202122232425262728// 配置端口 8000 和端口 5001 的服务器代理// setupProxy.jsconst &#123; createProxyMiddleware &#125; = require(&#x27;http-proxy-middleware&#x27;);// 引入内置模块: HTTP 代理中间件module.exports = function(app) &#123; // app 为服务对象 app.use( createProxyMiddleware(&#x27;/api1&#x27;, &#123; // 遇见 /api1 前缀的请求，就会触发该代理 target: &#x27;http://localhost:8000&#x27;, // 请求转发的端口地址 changeOrigin: true, // 控制服务器收到响应头中 Host 字段的值 pathRewrite: &#123; &#x27;^/api1&#x27;: &#x27;&#x27; // 去除请求前缀，保证交给后台服务器的是正常请求地址 &#125; &#125;) ); app.use( createProxyMiddleware(&#x27;/api2&#x27;, &#123; target: &#x27;http://localhost:5001&#x27;, changeOrigin: true, pathRewrite: &#123; &#x27;^/api2&#x27;: &#x27;&#x27; &#125; &#125;) );&#125; http-proxy-middleware 1.x 版本后配置代理使用： 1const &#123; createProxyMiddleware &#125; = require(&#x27;http-proxy-middleware&#x27;); 此前使用： 1const proxy = require(&#x27;http-proxy-middleware&#x27;); 向不同端口发送请求的方法： 如果要向 8000 端口发送请求，例如： 123axios.get(&#x27;http://localhost:3000/api1/teachers&#x27;).then( // ...); 如果要向 5001 端口发送请求，同理： 123axios.get(&#x27;http://localhost:3000/api2/students&#x27;).then( // ...); 方法二优缺点： 优点：可以配置多个代理，可以更加灵活地控制是否走代理请求 缺点：配置繁琐，前端发送代理请求时必须加前缀","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]}],"categories":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Python","slug":"Python","permalink":"http://example.com/categories/Python/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"ACM","slug":"ACM","permalink":"http://example.com/categories/ACM/"},{"name":"数学","slug":"数学","permalink":"http://example.com/categories/%E6%95%B0%E5%AD%A6/"},{"name":"机器学习","slug":"机器学习","permalink":"http://example.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"日常","slug":"日常","permalink":"http://example.com/categories/%E6%97%A5%E5%B8%B8/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"数据库","slug":"数据库","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"文件系统","slug":"文件系统","permalink":"http://example.com/tags/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/tags/MySQL/"},{"name":"数据库系统","slug":"数据库系统","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F/"},{"name":"进程","slug":"进程","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B/"},{"name":"进程管理","slug":"进程管理","permalink":"http://example.com/tags/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"name":"shell","slug":"shell","permalink":"http://example.com/tags/shell/"},{"name":"表达式树","slug":"表达式树","permalink":"http://example.com/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"},{"name":"波兰记法","slug":"波兰记法","permalink":"http://example.com/tags/%E6%B3%A2%E5%85%B0%E8%AE%B0%E6%B3%95/"},{"name":"逆波兰记法","slug":"逆波兰记法","permalink":"http://example.com/tags/%E9%80%86%E6%B3%A2%E5%85%B0%E8%AE%B0%E6%B3%95/"},{"name":"Pandas","slug":"Pandas","permalink":"http://example.com/tags/Pandas/"},{"name":"数据科学","slug":"数据科学","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/"},{"name":"字符串","slug":"字符串","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数论","slug":"数论","permalink":"http://example.com/tags/%E6%95%B0%E8%AE%BA/"},{"name":"杜教筛","slug":"杜教筛","permalink":"http://example.com/tags/%E6%9D%9C%E6%95%99%E7%AD%9B/"},{"name":"莫比乌斯反演","slug":"莫比乌斯反演","permalink":"http://example.com/tags/%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"},{"name":"Vim","slug":"Vim","permalink":"http://example.com/tags/Vim/"},{"name":"杭电多校","slug":"杭电多校","permalink":"http://example.com/tags/%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1/"},{"name":"Nowcoder","slug":"Nowcoder","permalink":"http://example.com/tags/Nowcoder/"},{"name":"Manacher","slug":"Manacher","permalink":"http://example.com/tags/Manacher/"},{"name":"概率论","slug":"概率论","permalink":"http://example.com/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"37% 法则","slug":"37-法则","permalink":"http://example.com/tags/37-%E6%B3%95%E5%88%99/"},{"name":"bitset","slug":"bitset","permalink":"http://example.com/tags/bitset/"},{"name":"NumPy","slug":"NumPy","permalink":"http://example.com/tags/NumPy/"},{"name":"深度学习","slug":"深度学习","permalink":"http://example.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"Python","slug":"Python","permalink":"http://example.com/tags/Python/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://example.com/tags/Codeforces/"},{"name":"Div.2","slug":"Div-2","permalink":"http://example.com/tags/Div-2/"},{"name":"贪心算法","slug":"贪心算法","permalink":"http://example.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"},{"name":"哈希表","slug":"哈希表","permalink":"http://example.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"前缀异或","slug":"前缀异或","permalink":"http://example.com/tags/%E5%89%8D%E7%BC%80%E5%BC%82%E6%88%96/"},{"name":"线段树","slug":"线段树","permalink":"http://example.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"},{"name":"哈尔滨","slug":"哈尔滨","permalink":"http://example.com/tags/%E5%93%88%E5%B0%94%E6%BB%A8/"},{"name":"分类讨论","slug":"分类讨论","permalink":"http://example.com/tags/%E5%88%86%E7%B1%BB%E8%AE%A8%E8%AE%BA/"},{"name":"Div.1","slug":"Div-1","permalink":"http://example.com/tags/Div-1/"},{"name":"DP","slug":"DP","permalink":"http://example.com/tags/DP/"},{"name":"Dijkstra","slug":"Dijkstra","permalink":"http://example.com/tags/Dijkstra/"},{"name":"C++","slug":"C","permalink":"http://example.com/tags/C/"},{"name":"位运算","slug":"位运算","permalink":"http://example.com/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"集合","slug":"集合","permalink":"http://example.com/tags/%E9%9B%86%E5%90%88/"},{"name":"数值运算","slug":"数值运算","permalink":"http://example.com/tags/%E6%95%B0%E5%80%BC%E8%BF%90%E7%AE%97/"},{"name":"CMake","slug":"CMake","permalink":"http://example.com/tags/CMake/"},{"name":"跨平台项目构建","slug":"跨平台项目构建","permalink":"http://example.com/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"},{"name":"字典树","slug":"字典树","permalink":"http://example.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"数据库规范化","slug":"数据库规范化","permalink":"http://example.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96/"},{"name":"计算几何","slug":"计算几何","permalink":"http://example.com/tags/%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95/"},{"name":"Simpson 公式","slug":"Simpson-公式","permalink":"http://example.com/tags/Simpson-%E5%85%AC%E5%BC%8F/"},{"name":"定积分","slug":"定积分","permalink":"http://example.com/tags/%E5%AE%9A%E7%A7%AF%E5%88%86/"},{"name":"SQL","slug":"SQL","permalink":"http://example.com/tags/SQL/"},{"name":"素数","slug":"素数","permalink":"http://example.com/tags/%E7%B4%A0%E6%95%B0/"},{"name":"素数筛","slug":"素数筛","permalink":"http://example.com/tags/%E7%B4%A0%E6%95%B0%E7%AD%9B/"},{"name":"埃氏筛","slug":"埃氏筛","permalink":"http://example.com/tags/%E5%9F%83%E6%B0%8F%E7%AD%9B/"},{"name":"欧式筛","slug":"欧式筛","permalink":"http://example.com/tags/%E6%AC%A7%E5%BC%8F%E7%AD%9B/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://example.com/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"Java","slug":"Java","permalink":"http://example.com/tags/Java/"},{"name":"匿名函数","slug":"匿名函数","permalink":"http://example.com/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"},{"name":"区间查询","slug":"区间查询","permalink":"http://example.com/tags/%E5%8C%BA%E9%97%B4%E6%9F%A5%E8%AF%A2/"},{"name":"树状数组","slug":"树状数组","permalink":"http://example.com/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"STL","slug":"STL","permalink":"http://example.com/tags/STL/"},{"name":"图论","slug":"图论","permalink":"http://example.com/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"链式前向星","slug":"链式前向星","permalink":"http://example.com/tags/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F/"},{"name":"SG 定理","slug":"SG-定理","permalink":"http://example.com/tags/SG-%E5%AE%9A%E7%90%86/"},{"name":"SG 函数","slug":"SG-函数","permalink":"http://example.com/tags/SG-%E5%87%BD%E6%95%B0/"},{"name":"组合博弈","slug":"组合博弈","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88%E5%8D%9A%E5%BC%88/"},{"name":"组合数学","slug":"组合数学","permalink":"http://example.com/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"记忆化搜索","slug":"记忆化搜索","permalink":"http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96%E6%90%9C%E7%B4%A2/"},{"name":"DFS","slug":"DFS","permalink":"http://example.com/tags/DFS/"},{"name":"二分匹配","slug":"二分匹配","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/"},{"name":"匈牙利算法","slug":"匈牙利算法","permalink":"http://example.com/tags/%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95/"},{"name":"二分图博弈","slug":"二分图博弈","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%9B%BE%E5%8D%9A%E5%BC%88/"},{"name":"调试器","slug":"调试器","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"},{"name":"LLDB","slug":"LLDB","permalink":"http://example.com/tags/LLDB/"},{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]}
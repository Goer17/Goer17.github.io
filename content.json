{"meta":{"title":"Yuanyang-Lee 的个人博客","subtitle":"","description":"","author":"Captain_Lee","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2023-02-08T17:20:04.000Z","updated":"2023-02-08T17:21:01.238Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标题","date":"2023-02-08T16:22:53.592Z","updated":"2023-02-08T16:22:53.588Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":""},{"title":"tags","date":"2023-02-08T17:23:44.000Z","updated":"2023-02-08T17:24:02.300Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"记忆化 DFS","slug":"记忆化 DFS","date":"2023-02-26T15:47:02.000Z","updated":"2023-02-28T05:47:07.712Z","comments":true,"path":"2023/02/26/记忆化 DFS/","link":"","permalink":"http://example.com/2023/02/26/%E8%AE%B0%E5%BF%86%E5%8C%96%20DFS/","excerpt":"","text":"引入 记忆化 DFS，顾名思义，就是带有记忆的深度优先搜索。 总所周知，用程序实现 Fibonacci 数列求值有两种常见方式： 通过迭代即非递归的方式： 12345678910111213int Fibonacci(int n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; int pre = 1, next = 1, sum = 0; while (n-- &gt; 2) &#123; sum = pre + next; pre = next; next = sum; &#125; return sum;&#125; 通过递归方式： 123456int Fibonacci(int n) &#123; if (n == 1 || n == 2) &#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125; 上述两种方式各有优缺点，迭代方式效率更高，但是写起来比较麻烦；递归方式运行效率低，但是代码实现容易。 有没有一种方式可以结合两者的优点呢？ 对于第二种递归方式，其主要的时间开销在于计算了许多重复内容，我们是否可以使用一个数组来维护已经计算过的值呢？ 答案是显然的，于是我们就有了 —— 记忆化 DFS： 123456789101112131415int fib[MAX_NUM]; // 记忆数组int Fibonacci(int n) &#123; if (fib[n]) &#123; return fib[n]; // 已经计算过的值直接返回 &#125; if (n == 1 || n == 2) &#123; fib[n] = 1; &#125; else &#123; fib[n] = Fibonacci(n - 1) + Fibonacci(n - 2); &#125; return fib[n];&#125; 以上代码以递归的方式实现，但是时间复杂度可以降到线性，和迭代形式一样，不同的地方在于我们需要额外的空间开销来记录已经计算过的值。 可能有同学就有疑问了： 上述例子很容易用 DP 来实现，为什么还需要记忆化 DFS 呢？ 接下来我们将给出几个实际例子加以说明。 实例分析 案例一 猫和老鼠 Problem Description 有个小老鼠在校园里收藏了一些它最爱吃的奶酪。 校园可以看成一个长度为n的正方形网格，每个网格可以标记为 (p, q) ，其中，0 &lt;= p , q &lt; n。每个网格都有一个洞，里面储存了 k（0 &lt;= k &lt;= 100）块奶酪。 现在，小老鼠准备享用这些美味啦。 开始的时候，他在 (0, 0) 这个位置，每到一个地方，它都会吃光这个地方的奶酪，然后沿着水平或者垂直的方向到达另外一个地方。麻烦的是，有个很凶的猫总是在它的洞口附近，所以他每次最多移动 k 个位置，否则就会被这只猫吃掉。更糟糕的是，每在一个地方吃过奶酪，小老鼠都会变胖，所以，为了获得足够下一次逃跑的能量，它每次只能去比当前位置的奶酪更多的格子。 现在已知 n 和 k ，以及在每个网格的洞中小老鼠储存的奶酪的数量，请计算小老鼠在无法移动之前，一共最多能吃到多少块奶酪。 Input 题目包含多组测试数据。 每组测试数据组成如下： 首先一行包含2个不超过100的正整数 n 和 k ; 接下来 n 行，每行包含n个数： 第一行 n 个数分别表示 (0, 0), (0, 1), … (0, n - 1) 这些位置储存的奶酪数量； 第二行 n 个数分别表示 (1, 0), (1, 1), … (1, n - 1) 这些位置储存的奶酪数量； 以此类推... 输入数据以两个 -1 结束。 Output 请输出小老鼠最多 能够吃到的奶酪数量，每组数据输出一行。 输入案例： 123453 11 2 510 11 612 12 7-1 -1 输出案例： 137 分析： 根据题意，我们假设从 \\((x, y)\\) 出发的老鼠可以吃到的最大奶酪数量为 \\(ans(x, y)\\)，\\((x, y)\\) 处的芝士储量为 \\(cheese(x, y)\\)，老鼠可以从 \\((x, y)\\) 出发在一次 \\(k\\) 步以内的移动中到达的坐标的集合为 \\(S = \\{(x_1, y_1), (x_2, y_2), (x_3, y_3), ...\\}\\)，不难得出状态转移方程： \\[ ans(x, y) = max_{(x_n, y_n) \\in S} ans(x_n, y_n) \\ + \\ cheese(x, y) \\] 如果直接用动态规划求解，这个问题的代码恐怕会相当复杂，因为我们难以确定 DP 的起点，而且该转移方程较为复杂，更是加大了其难度。 于是我们便考虑到可以使用记忆化 DFS，既保证了效率，又降低了编码难度。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;vector&gt;#include &lt;array&gt;using namespace std;#define MAX_LENG 105int cheese[MAX_LENG][MAX_LENG];int ans[MAX_LENG][MAX_LENG]; // 储存结果，初始化为 -1int n, k;const vector&lt;array&lt;int, 2&gt;&gt; dirs = &#123; &#123;1, 0&#125;, &#123;0, 1&#125;, &#123;-1, 0&#125;, &#123;0, -1&#125;&#125;; // 运动方向int dfs(int x, int y) &#123; // 记忆化 DFS // 返回以 (x, y) 为起点可以吃到最多的奶酪 if (ans[x][y] &gt;= 0) &#123; // 已经计算过的值 return ans[x][y]; &#125; ans[x][y] = cheese[x][y]; int plusCheese = 0; for (auto&amp; dir :dirs) &#123; for (int s = 1; s &lt;= k; s++) &#123; int nx = x + s * dir[0]; int ny = y + s * dir[1]; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; n &amp;&amp; cheese[nx][ny] &gt; cheese[x][y]) &#123; plusCheese = max(plusCheese, dfs(nx, ny)); &#125; &#125; &#125; ans[x][y] += plusCheese; return ans[x][y];&#125;int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; k, n != -1 || k != -1) &#123; memset(ans, 0xff, sizeof(ans)); for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; cin &gt;&gt; cheese[i][j]; &#125; &#125; cout &lt;&lt; dfs(0, 0) &lt;&lt; endl; &#125; return 0;&#125; 案例二 How many ways Problem Description 这是一个简单的生存游戏，你控制一个机器人从一个棋盘的起始点 (1, 1) 走到棋盘的终点 (n, m)。游戏的规则描述如下： 机器人一开始在棋盘的起始点并有起始点所标有的能量。 机器人只能向右或者向下走，并且每走一步消耗一单位能量。 机器人不能在原地停留。 当机器人选择了一条可行路径后，当他走到这条路径的终点时，他将只有终点所标记的能量。 img 如上图，机器人一开始在 (1, 1) 点，并拥有4单位能量，蓝色方块表示他所能到达的点，如果他在这次路径选择中选择的终点是 (2, 4) ，当他到达 (2, 4) 点时将拥有1单位的能量，并开始下一次路径选择，直到到达 (6, 6) 点。 我们的问题是机器人有多少种方式从起点走到终点。这可能是一个很大的数，输出的结果对 10000 取模。 Input 第一行输入一个整数T,表示数据的组数。 对于每一组数据第一行输入两个整数 n, m (1 &lt;= n, m &lt;= 100)。表示棋盘的大小。接下来输入 n 行,每行 m 个整数 e (0 &lt;= e &lt; 20)。 Output 对于每一组数据输出方式总数对10000取模的结果。 输入案例： 1234567816 64 5 6 6 4 32 2 3 1 7 21 1 4 6 2 75 8 4 3 9 57 6 6 2 1 53 1 1 3 7 2 输出案例： 13948 分析： 同案例一，我们只需找到状态转移方程后使用记忆化 DFS 即可，这里不再赘述。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int T; // 数据组数int n, m;#define MAX_LENG 105#define MAX_NUM 10000int energy[MAX_LENG][MAX_LENG]; // 记录每个格点点能量int ans[MAX_LENG][MAX_LENG]; // 记录答案，初始化为 -1int dfs(int x, int y) &#123; // 表示从 (x, y) 出发到终点又多少种走法 if (ans[x][y] &gt;= 0) &#123; return ans[x][y]; &#125; if (x == n - 1 &amp;&amp; y == m - 1) &#123; ans[x][y] = 1; return ans[x][y]; &#125; int power = energy[x][y]; // 能量 ans[x][y] = 0; for (int i = 0; i &lt;= power; i++) &#123; for (int j = 0; j &lt;= power - i; j++) &#123; // 遍历所有可能位置 int nx = x + i, ny = y + j; if (nx != x || ny != y) &#123; if (nx &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; m) &#123; ans[x][y] = (ans[x][y] + dfs(nx, ny)) % MAX_NUM; &#125; &#125; &#125; &#125; return ans[x][y];&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i++) &#123; for (int j = 0; j &lt; m; j++) &#123; cin &gt;&gt; energy[i][j]; &#125; &#125; memset(ans, 0xff, sizeof(ans)); cout &lt;&lt; dfs(0, 0) &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://example.com/tags/DFS/"},{"name":"记忆化 DFS","slug":"记忆化-DFS","permalink":"http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96-DFS/"}]},{"title":"二分匹配问题 —— 匈牙利算法","slug":"二分匹配算法详解","date":"2023-02-24T17:21:01.000Z","updated":"2023-02-26T10:28:50.149Z","comments":true,"path":"2023/02/25/二分匹配算法详解/","link":"","permalink":"http://example.com/2023/02/25/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"问题介绍 什么是二分图？ 对于图 \\(G(V,E)\\) 而言，若 \\(G\\) 中的所有点可以划分为两个子集 \\(G_1\\)、\\(G_2\\) ，且图中每条边 \\(e\\) 关联的两个顶点都属于不同的顶点子集，这样的图我们称为二分图（ Bipartite Graph ），或者二部图。 最大匹配问题和最小点覆盖问题 什么是最大匹配问题？给定一个二分图 \\(G(V,E)\\)，若 \\((a_i,b_j) \\in E\\) ，我们就称 \\(a_i\\) 和 \\(b_j\\) 是可配对的，已知该图中任意顶点至多匹配一个顶点，求最大匹配数。如下图，不难看出该图的最大匹配数为 2。其中一种匹配方式为 \\((a_1, b_1)\\)、\\((a_3, b_4)\\) 。 什么又是最小点覆盖问题呢？即从二分图中删除最少的顶点，使得图 \\(G\\) 中任何一对点都无法匹配。删除顶点的最小数量称为最小点覆盖数。如下图，不难看出最小覆盖数也是 2。我们可以删去 \\(a_3\\) 和 \\(b_1\\) 使得图中任何一对点都无法匹配。 这两个问题看似不一样，实际上实际上是处理一个相同的问题。为什么这么说呢？因为我们可以证明一条重要性质： 最大匹配数 = 最小覆盖数 具体证明就不在这里说明了，笔者打算以后单独出一期文章来证明该性质。 那我们该如何给出二分匹配问题的一般解决方案呢？1955 年，库恩（ W.W.Kuhn ）利用一个匈牙利数学家康哥尼（ D.Kőnig ）的一个定理构造了一种二分匹配问题的解法，后人称之为匈牙利算法。 匈牙利算法 在介绍匈牙利算法之前，我们先介绍几个概念： 交替路： 从未匹配点出发，依次经过未匹配的边和已匹配的边的路径称为交替路。 增广路： 经过除出发点之外其他未匹配点的交替路称为增广路。 当且仅当不存在关于图 \\(G\\) 的增广路径时当前的匹配为图 \\(G\\) 的最大匹配。 算法讲解 如下图所示，我们接下来将使用匈牙利算法来计算该二分图的最大匹配数。 我们从 \\(a_1\\) 开始匹配，\\(a_1\\) 与 \\(b_1\\) 匹配成功，即当前匹配对数为 1。 然后再对 \\(a_2\\) 进行匹配，我们发现 \\(a_2\\) 只能匹配 \\(b_1\\) ，而 \\(b_1\\) 已经与 \\(a_1\\) 匹配成功了，此时我们发现 \\(a_1\\) 和 \\(b_3\\) 可以成功匹配，于是我们可以取消 \\(a_1\\) 和 \\(b_1\\) 的匹配，然后匹配 \\(a_1\\) 和 \\(b_3\\) ，这个时候 \\(a_2\\) 就可以匹配 \\(b_1\\) 了。匹配对数加一，当前匹配对数为 2。 其实这一步相当于找到了一条增广路 \\((a_2, b_1, a_1, b_3)\\) ，然后对该增广路取反。 接下来对 \\(a_3\\) 进行匹配，\\(a_3\\) 与 \\(b_2\\) 成功匹配，匹配对数加一，当前匹配对数为 3。 最后对 \\(a_4\\) 进行匹配，发现其只能与 \\(b_1\\) 匹配，而 \\(b_1\\) 已经与 \\(a_1\\) 匹配过了，而且无法从 \\(a_4\\) 出发构造一条增广路，因此 \\(a_4\\) 无法与任何一个顶点成功匹配。 综上所述，展示的二分图的最大匹配数为 3。 伪代码： 123456789// 判断 ai 是否能匹配成功for bj 与 ai 相连: if bj 未被访问: 更新 bj 访问状态; if bj 未被匹配或者 bj 的配对点可以出发找到增广路径: 将 bj 的配对点改为 ai; return true;return false; 时间复杂度：\\(O(VE)\\) 代码实现 123456789101112131415161718192021222324252627282930313233343536373839#define NOT_MATCH 0x3f3f3f3fclass Solution &#123;private: int numA, numB; // numA、numB 分别表示两个集合的元素个数 vector&lt;vector&lt;int&gt;&gt; G; // 假设这里用邻接链表储存图 G，G[i] 表示和 ai 相邻的所有 B 集合的顶点编号 int match[numB]; // 记录 B 集合的元素的匹配点在 A 集合的编号 bool vis[numB]; // 记录 B 集合的元素是否被访问过 // ... bool isMatch(int index) &#123; // 判断 A 集合中编号为 index 的顶点是否能匹配成功 for (int i = 0; i &lt; G[index].size(); i++) &#123; if (!vis[G[i]]) &#123; vis[G[i]] = true; if (match[G[i]] == NOT_MATCH || isMatch(match[[G[i]]])) &#123; // 该顶点未被匹配或着原来匹配该点的顶点可以匹配其他顶点 match[G[i]] = index; return true; &#125; &#125; &#125; return false; &#125; public: int hungarian() &#123; int cnt = 0; for (int i = 0; i &lt; numA; i++) &#123; memset(vis, 0x3f, sizeof(vis)); if (isMatch(i)) &#123; cnt++; &#125; &#125; return cnt; &#125;&#125; 实际应用 Machine Schedule Problem Description As we all know, machine scheduling is a very classical problem in computer science and has been studied for a very long history. Scheduling problems differ widely in the nature of the constraints that must be satisfied and the type of schedule desired. Here we consider a 2-machine scheduling problem. There are two machines A and B. Machine A has n kinds of working modes, which is called \\(mode_0\\) , \\(mode_1\\) , …, \\(mode_{n-1}\\) , likewise machine B has m kinds of working modes, \\(mode_0\\), \\(mode_1\\) , … , \\(mode_{m-1}\\) . At the beginning they are both work at \\(mode_0\\). For k jobs given, each of them can be processed in either one of the two machines in particular mode. For example, job 0 can either be processed in machine A at \\(mode_3\\) or in machine B at \\(mode_4\\) , job 1 can either be processed in machine A at \\(mode_2\\) or in machine B at \\(mode_4\\) , and so on. Thus, for job i, the constraint can be represent as a triple (i, x, y), which means it can be processed either in machine A at \\(mode_x\\), or in machine B at \\(mode_y\\) . Obviously, to accomplish all the jobs, we need to change the machine’s working mode from time to time, but unfortunately, the machine’s working mode can only be changed by restarting it manually. By changing the sequence of the jobs and assigning each job to a suitable machine, please write a program to minimize the times of restarting machines. Input The input file for this program consists of several configurations. The first line of one configuration contains three positive integers: n, m (n, m &lt; 100) and k (k &lt; 1000). The following k lines give the constrains of the k jobs, each line is a triple: i, x, y. The input will be terminated by a line containing a single zero. Output The output should be one integer per line, which means the minimal times of restarting machine. 输入案例： 1234567891011125 5 100 1 11 1 22 1 33 1 44 2 15 2 26 2 37 2 48 3 39 4 30 输出案例： 13 对于此题，我们可以将 A、B 机器的所有模式看成二部图看成两个子集，若某个工作需要机器 A 的 x 模式和机器 B 的 y 模式来完成，就将 \\((a_x, b_y)\\) 连接起来。最后我们的问题就变成了：应该如何找到该二部图的最小点覆盖数？ 而根据我们之前提到的结论可知，最小点覆盖数在数值上等于最大匹配数。 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;#define MAX_NUM 105#define NOT_FOUND 0x3f3f3f3fint G[MAX_NUM][MAX_NUM];bool vis[MAX_NUM];int match[MAX_NUM];int n, m, k;bool isMatch(int index) &#123; for (int i = 0; i &lt; m; i++) &#123; if (G[index][i] &amp;&amp; !vis[i]) &#123; vis[i] = true; if (match[i] == NOT_FOUND || isMatch(match[i])) &#123; match[i] = index; return true; &#125; &#125; &#125; return false;&#125;int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n) &#123; if (n == 0) &#123; break; &#125; cin &gt;&gt; m &gt;&gt; k; memset(G, 0, sizeof(G)); memset(match, 0x3f, sizeof(match)); // 初始化 int t, ax, by; for (int i = 0; i &lt; k; i++) &#123; cin &gt;&gt; t &gt;&gt; ax &gt;&gt; by; if (ax != 0 &amp;&amp; by != 0) &#123; // 0 号模式下可以完成的任务不用添加 G[ax][by] = 1; &#125; &#125; int cnt = 0; for (int i = 0; i &lt; n; i++) &#123; memset(vis, 0, sizeof(vis)); if (isMatch(i)) &#123; cnt++; &#125; &#125; // 求出最小点覆盖数 cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://example.com/tags/DFS/"},{"name":"二分匹配","slug":"二分匹配","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/"}]},{"title":"LLDB 快速入门","slug":"LLDB 快速入门","date":"2023-02-22T03:01:12.000Z","updated":"2023-02-24T17:22:30.891Z","comments":true,"path":"2023/02/22/LLDB 快速入门/","link":"","permalink":"http://example.com/2023/02/22/LLDB%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","excerpt":"","text":"如果调试是删除 bug 的过程，那么编程就是引入 bug 的过程。 —— Edsger W. Dijkstra LLDB 是什么？ LLDB（ Low level Debug ）是 MacOS 默认进行调试 C/C++ 程序的调试工具，能帮开发者进行更加丰富地流程控制和栈帧数据监测。 简言之，LLDB 是一个有着 REPL 的特性和 C++ 、Python 插件的开源调试器。 在此，我们以几个简单的程序为例子，对 LLDB 进行快速入门。 目录 启动 LLDB 断点操作 设置断点 查看断点 删除断点 分步调试 启动调试 进入，跳过和继续 跳出当前函数 查看变量 结束调试 启动 LLDB 1234567891011121314151617181920212223242526// demo.cpp#include &lt;iostream&gt;using namespace std;int fact(int n) &#123; if (n == 0) &#123; return 1; &#125; else &#123; return n * fact(n - 1); &#125;&#125;int main() &#123; int x = 2; int y = 3; int z = x + y; cout &lt;&lt; fact(z) &lt;&lt; endl; return 0;&#125; 编译 C/C++ 程序时使其可以被 LLDB 调试工具设置断点，需要添加 -g ，以 C++ 文件 demo.cpp 为例： 123clang++ -g demo.cpplldb a.out 断点操作 设置断点 12br s -f [文件名] -l [行号] # 在文件的某一行设置断点br s -n [函数名] # 给函数设置断点 查看断点 1br list # 显示所有断点和其序号 删除断点 12br del [断点序号]br del # 删除所有断点 示例： 1234567891011121314151617181920212223242526(lldb) br s -f demo.cpp -l 17Breakpoint 1: where = a.out`main + 28 at demo.cpp:17:9, address = 0x0000000100003d80(lldb) br s -f demo.cpp -l 21Breakpoint 2: where = a.out`main + 56 at demo.cpp:21:18, address = 0x0000000100003d9c(lldb) br s -n factBreakpoint 3: where = a.out`fact(int) + 16 at demo.cpp:6:9, address = 0x0000000100003d18(lldb) br listCurrent breakpoints:1: file = &#x27;demo.cpp&#x27;, line = 17, exact_match = 0, locations = 1 1.1: where = a.out`main + 28 at demo.cpp:17:9, address = a.out[0x0000000100003d80], unresolved, hit count = 0 2: file = &#x27;demo.cpp&#x27;, line = 21, exact_match = 0, locations = 1 2.1: where = a.out`main + 56 at demo.cpp:21:18, address = a.out[0x0000000100003d9c], unresolved, hit count = 0 3: name = &#x27;fact&#x27;, locations = 1 3.1: where = a.out`fact(int) + 16 at demo.cpp:6:9, address = a.out[0x0000000100003d18], unresolved, hit count = 0 (lldb) br del 31 breakpoints deleted; 0 breakpoint locations disabled.(lldb) br listCurrent breakpoints:1: file = &#x27;demo.cpp&#x27;, line = 17, exact_match = 0, locations = 1 1.1: where = a.out`main + 28 at demo.cpp:17:9, address = a.out[0x0000000100003d80], unresolved, hit count = 0 2: file = &#x27;demo.cpp&#x27;, line = 21, exact_match = 0, locations = 1 2.1: where = a.out`main + 56 at demo.cpp:21:18, address = a.out[0x0000000100003d9c], unresolved, hit count = 0 分步调试 启动调试 1r 输入 run 或者 r 后程序便会开始启动调试 进入，跳过和继续 12345678# 进入 单步执行，中间如果有函数调用会跳转到目标函数s# 跳过 单步执行，中间的函数执行过程会跳过n# 继续 跳转到下一个断点c 跳出当前函数 1finish 查看变量 123456789101112131415161718# 查看某个变量：p [变量名]# 查看当前栈帧所有变量fr v# 切换栈帧fr s [栈帧序号]# 打印当前线程的栈帧信息bt# 打印所有线程的栈帧信息bt all 综合案例：在 demo.cpp 的 17 行和 21 行设置断点，使用 r 开始调试 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 1.1 frame #0: 0x0000000100003d80 a.out`main at demo.cpp:17:9 14 15 int main() &#123; 16 -&gt; 17 int x = 2; 18 int y = 3; 19 int z = x + y; 20 Target 0: (a.out) stopped.(lldb) sProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step in frame #0: 0x0000000100003d88 a.out`main at demo.cpp:18:9 15 int main() &#123; 16 17 int x = 2;-&gt; 18 int y = 3; 19 int z = x + y; 20 21 cout &lt;&lt; fact(z) &lt;&lt; endl;Target 0: (a.out) stopped.(lldb) sProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step in frame #0: 0x0000000100003d8c a.out`main at demo.cpp:19:13 16 17 int x = 2; 18 int y = 3;-&gt; 19 int z = x + y; 20 21 cout &lt;&lt; fact(z) &lt;&lt; endl; 22 Target 0: (a.out) stopped.(lldb) sProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint 2.1 frame #0: 0x0000000100003d9c a.out`main at demo.cpp:21:18 18 int y = 3; 19 int z = x + y; 20 -&gt; 21 cout &lt;&lt; fact(z) &lt;&lt; endl; 22 23 return 0; 24 &#125;Target 0: (a.out) stopped.(lldb) fr v(int) x = 2(int) y = 3(int) z = 5(lldb) sProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step in frame #0: 0x0000000100003d18 a.out`fact(n=5) at demo.cpp:6:9 3 using namespace std; 4 5 int fact(int n) &#123;-&gt; 6 if (n == 0) &#123; 7 return 1; 8 &#125; 9 else &#123;Target 0: (a.out) stopped.(lldb) finishProcess 31435 stopped* thread #1, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step outReturn value: (int) $0 = 120 frame #0: 0x0000000100003da4 a.out`main at demo.cpp:21:13 18 int y = 3; 19 int z = x + y; 20 -&gt; 21 cout &lt;&lt; fact(z) &lt;&lt; endl; 22 23 return 0; 24 &#125;Target 0: (a.out) stopped.(lldb) cProcess 31435 resuming120Process 31435 exited with status = 0 (0x00000000) 结束调试 1q 输入 quit 或者 q 结束 LLDB 调试 以上就是对 LLDB 的一个简单介绍了，如果想了解更多 LLDB 指令，可以查看官网的 LLDB command map","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"}],"tags":[{"name":"C++ 开发","slug":"C-开发","permalink":"http://example.com/tags/C-%E5%BC%80%E5%8F%91/"},{"name":"调试器","slug":"调试器","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"}]},{"title":"React 脚手架配置代理的方法","slug":"React 脚手架配置代理的方法","date":"2023-02-07T14:42:07.000Z","updated":"2023-02-08T17:22:52.385Z","comments":true,"path":"2023/02/07/React 脚手架配置代理的方法/","link":"","permalink":"http://example.com/2023/02/07/React%20%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"方法一：直接在 package.json 中追加配置 例如，当前服务器端口为 3000，若要向端口 5000 的服务器发送请求，我们可以在 package.json 中添加如下配置： 1&quot;proxy&quot;: &quot;http://localhost:5000&quot; 此后，当请求了 3000 端口不存在的资源时，那么请求就会转发给 5000 端口。 示例： 例如一个 create-react-app 创建项目在 3001 端口运行，我们使用 json-server 模拟了一个 3000 端口的服务器，其中 JSON 数据如下： 1234567&#123; &quot;students&quot;: [ &#123;&quot;id&quot;: &quot;0001&quot;, &quot;name&quot;: &quot;Tom&quot;, &quot;age&quot;: 18&#125;, &#123;&quot;id&quot;: &quot;0002&quot;, &quot;name&quot;: &quot;Jack&quot;, &quot;age&quot;: 19&#125;, &#123;&quot;id&quot;: &quot;0003&quot;, &quot;name&quot;: &quot;Frank&quot;, &quot;age&quot;: 20&#125; ]&#125; students 数据的 URL 为 http://localhost:3000/students，若我们要向 3001 端口发送 GET 请求来获取 students 的 JSON 数据，则可以在 package.json 中添加配置： 1&quot;proxy&quot;: &quot;http://localhost:3000&quot; 获取 3001 端口有的资源： 12345678910111213141516171819202122export default class App extends Component &#123; getInfo = () =&gt; &#123; axios.get(&quot;http://localhost:3001/index.html&quot;).then( response =&gt; &#123; console.log(response.data); &#125;, err =&gt; &#123; console.log(err); &#125; ); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.getInfo&#125;&gt;点击发送请求获取数据&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 此时控制台输出当前项目下的 index.html 文件： 获取 3001 端口没有而 3000 端口有的资源： 12345678910111213141516171819202122export default class App extends Component &#123; getInfo = () =&gt; &#123; axios.get(&quot;http://localhost:3001/students&quot;).then( response =&gt; &#123; console.log(response.data); &#125;, err =&gt; &#123; console.log(err); &#125; ); &#125; render() &#123; return ( &lt;div&gt; &lt;button onClick=&#123;this.getInfo&#125;&gt;点击发送请求获取数据&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; 此时控制台输出 3000 端口下的 students 数据： 若获取的资源 3001 端口和 3000 端口都没有，则控制台会报错。 方法一优缺点： 优点：配置简单，前端请求资源时可以不加任何前缀 缺点：不能配置多个代理 方法二：创建 setupProxy.js 文件 首先在 src 目录下创建 setupProxy.js 文件 编写 setupProxy.js 配置具体代码规范： 12345678910111213141516171819202122232425262728// 配置端口 8000 和端口 5001 的服务器代理// setupProxy.jsconst &#123; createProxyMiddleware &#125; = require(&#x27;http-proxy-middleware&#x27;);// 引入内置模块: HTTP 代理中间件module.exports = function(app) &#123; // app 为服务对象 app.use( createProxyMiddleware(&#x27;/api1&#x27;, &#123; // 遇见 /api1 前缀的请求，就会触发该代理 target: &#x27;http://localhost:8000&#x27;, // 请求转发的端口地址 changeOrigin: true, // 控制服务器收到响应头中 Host 字段的值 pathRewrite: &#123; &#x27;^/api1&#x27;: &#x27;&#x27; // 去除请求前缀，保证交给后台服务器的是正常请求地址 &#125; &#125;) ); app.use( createProxyMiddleware(&#x27;/api2&#x27;, &#123; target: &#x27;http://localhost:5001&#x27;, changeOrigin: true, pathRewrite: &#123; &#x27;^/api2&#x27;: &#x27;&#x27; &#125; &#125;) );&#125; http-proxy-middleware 1.x 版本后配置代理使用： 1const &#123; createProxyMiddleware &#125; = require(&#x27;http-proxy-middleware&#x27;); 此前使用： 1const proxy = require(&#x27;http-proxy-middleware&#x27;); 向不同端口发送请求的方法： 如果要向 8000 端口发送请求，例如： 123axios.get(&#x27;http://localhost:3000/api1/teachers&#x27;).then( // ...); 如果要向 5001 端口发送请求，同理： 123axios.get(&#x27;http://localhost:3000/api2/students&#x27;).then( // ...); 方法二优缺点： 优点：可以配置多个代理，可以更加灵活地控制是否走代理请求 缺点：配置繁琐，前端发送代理请求时必须加前缀","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]}],"categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"C/C++","slug":"C-C","permalink":"http://example.com/categories/C-C/"},{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"DFS","slug":"DFS","permalink":"http://example.com/tags/DFS/"},{"name":"记忆化 DFS","slug":"记忆化-DFS","permalink":"http://example.com/tags/%E8%AE%B0%E5%BF%86%E5%8C%96-DFS/"},{"name":"二分匹配","slug":"二分匹配","permalink":"http://example.com/tags/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D/"},{"name":"C++ 开发","slug":"C-开发","permalink":"http://example.com/tags/C-%E5%BC%80%E5%8F%91/"},{"name":"调试器","slug":"调试器","permalink":"http://example.com/tags/%E8%B0%83%E8%AF%95%E5%99%A8/"},{"name":"React","slug":"React","permalink":"http://example.com/tags/React/"}]}
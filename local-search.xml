<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>std::bitset 讲解</title>
    <link href="/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍">介绍</h4><p><code>std::bitset</code> 是 C++ 提供的一种 n-bit固定大小序列的模版，可以用于标准逻辑运算，并且可以与字符串和整数相互转换，还可以使用标准流输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; std::<span class="hljs-type">size_t</span> N &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bitset</span>;<br></code></pre></td></tr></table></figure><blockquote><p>模版形参 <code>N</code> ：要为 <code>bitset</code> 分配储存的 bit位数</p></blockquote><p><strong>头文件：<code>&lt;bitset&gt;</code></strong></p><h4 id="构造方法">构造方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 1. 无参构造</span><br>    std::bitset&lt;5&gt; testCase_1;<br>    std::cout &lt;&lt; testCase_1 &lt;&lt; std::endl; <span class="hljs-comment">// 00000</span><br><br>    <span class="hljs-comment">// 2. 传入整数</span><br>    std::bitset&lt;4&gt; testCase_2&#123;<span class="hljs-number">0xb</span>&#125;;<br>    std::cout &lt;&lt; testCase_2 &lt;&lt; std::endl; <span class="hljs-comment">// 1011</span><br><br>    std::bitset&lt;4&gt; testCase_3&#123;<span class="hljs-number">0x10</span>&#125;; <span class="hljs-comment">// 溢出位自动截断</span><br>    std::cout &lt;&lt; testCase_3 &lt;&lt; std::endl; <span class="hljs-comment">// 0000</span><br><br>    <span class="hljs-comment">// 3. 传入字符串</span><br>    std::bitset&lt;8&gt; testCase_4&#123;<span class="hljs-string">&quot;10010101&quot;</span>&#125;; <span class="hljs-comment">// 传入 0-1 字符串</span><br>    std::cout &lt;&lt; testCase_4 &lt;&lt; std::endl; <span class="hljs-comment">// 10010101</span><br><br>    std::bitset&lt;4&gt; testCase_5&#123;<span class="hljs-string">&quot;10010101&quot;</span>&#125;; <span class="hljs-comment">// 溢出位截断，只取前 4 位</span><br>    std::cout &lt;&lt; testCase_5 &lt;&lt; std::endl; <span class="hljs-comment">// 1001</span><br><br>    std::bitset&lt;8&gt; testCase_6&#123;<span class="hljs-string">&quot;ABABA&quot;</span>, <span class="hljs-comment">/* 读取长度 */</span><span class="hljs-number">4</span>, <span class="hljs-comment">/* 代表 0 的字符 */</span><span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-comment">/* 代表 1 的字符 */</span><span class="hljs-string">&#x27;B&#x27;</span>&#125;; <span class="hljs-comment">// 00000101</span><br>    std::cout &lt;&lt; testCase_6 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 4. 支持赋值构造以及整数和字符串到 bitset 的强制类型转化</span><br>    std::bitset&lt;8&gt; testCase_7 = testCase_6;<br>    std::cout &lt;&lt; testCase_7 &lt;&lt; std::endl; <span class="hljs-comment">// 00000101</span><br><br>    std::cout &lt;&lt; (std::bitset&lt;<span class="hljs-number">8</span>&gt;)<span class="hljs-number">0xf</span> &lt;&lt; std::endl; <span class="hljs-comment">// 00001111</span><br>    std::cout &lt;&lt; (std::bitset&lt;<span class="hljs-number">8</span>&gt;)<span class="hljs-string">&quot;1111&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 00001111</span><br><br>    std::bitset&lt;10&gt; testCase_8 = <span class="hljs-number">0x7f</span>;<br>    std::cout &lt;&lt; testCase_8 &lt;&lt; std::endl; <span class="hljs-comment">// 0001111111</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员方法">成员方法</h4><ul><li><p>支持下标 <code>operator[]</code></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-string">&quot;111011&quot;</span>;<br>std::cout &lt;&lt; num[<span class="hljs-number">2</span>] &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 从低位开始</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>bitset</code> 支持所有常规位运算操作</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = <span class="hljs-number">0xf</span>;<br><br>std::cout &lt;&lt; (num &amp; (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-number">0x12</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000000010</span><br>std::cout &lt;&lt; (num | (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-number">0x12</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000011111</span><br>std::cout &lt;&lt; (num ^ (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-number">0x12</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000011101</span><br>std::cout &lt;&lt; (num &lt;&lt; <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000111100</span><br>std::cout &lt;&lt; (num &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000000011</span><br><br>num = <span class="hljs-number">-1</span>;<br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111111111</span><br>std::cout &lt;&lt; (num &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0011111111</span><br><span class="hljs-comment">// 对 bitset 的右移都是逻辑右移</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>set()</code> ：设置单独位的值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = <span class="hljs-number">-1</span>;<br>num.<span class="hljs-built_in">set</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 将下标为 0 的位设置为 0</span><br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111111110</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>flip()</code> ：取反，无参数时默认对全部位</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = <span class="hljs-number">0xf</span>;<br>num.<span class="hljs-built_in">flip</span>();<br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111110000</span><br>num.<span class="hljs-built_in">flip</span>(<span class="hljs-number">1</span>);<br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111110010</span><br></code></pre></td></tr></table></figure></p></li><li><p>检查位</p><ul><li><code>all()</code> ：判断是否所有位都为 1</li><li><code>any()</code> ：判断是否有任意一位为 1</li><li><code>none()</code> ：判断是否所有位为 0</li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;4&gt; num = <span class="hljs-number">0x7</span>;<br><br>std::cout &lt;&lt; num.<span class="hljs-built_in">all</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br>std::cout &lt;&lt; num.<span class="hljs-built_in">any</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 1</span><br>std::cout &lt;&lt; num.<span class="hljs-built_in">none</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>count()</code> ：返回 1 的数量</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;4&gt; num = <span class="hljs-number">0x7</span>;<br><br>std::cout &lt;&lt; num.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>size()</code> ：返回位数</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num;<br>std::cout &lt;&lt; num.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></p></li><li><p>转换：</p><ul><li><code>to_string()</code> ：返回数据的字符串类型</li><li><code>to_ulong</code> ：返回数据的 <code>unsigned long</code>整数表示</li><li><code>to_ullong</code> ：返回数据的 <code>unsigned long long</code>整数表示</li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;8&gt; num_bit = <span class="hljs-number">0xf</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> num_1 = num_bit.<span class="hljs-built_in">to_ulong</span>();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> num_2 = num_bit.<span class="hljs-built_in">to_ullong</span>();<br>std::string str = num_bit.<span class="hljs-built_in">to_string</span>();<br><br>std::cout &lt;&lt; num_1 &lt;&lt; std::endl; <span class="hljs-comment">// 15</span><br>std::cout &lt;&lt; num_2 &lt;&lt; std::endl; <span class="hljs-comment">// 15</span><br>std::cout &lt;&lt; str &lt;&lt; std::endl; <span class="hljs-comment">// 00001111</span><br></code></pre></td></tr></table></figure></p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链式向前星介绍</title>
    <link href="/2023/03/06/%E9%93%BE%E5%BC%8F%E5%90%91%E5%89%8D%E6%98%9F%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/03/06/%E9%93%BE%E5%BC%8F%E5%90%91%E5%89%8D%E6%98%9F%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是链式向前星">什么是链式向前星？</h4><p><strong>链式向前星</strong>是一种常用的图存储结构，其思路类似于邻接链表法，只是实现方式有所不同，链式向前星更像是<strong>用数组模拟链表</strong>。</p><p>与一般的邻接链表法不同，链式向前星储存的图的<strong>每条边都有编号</strong>。</p><p>以下是链式向前星的存储结构：</p><ul><li><p><code>cnt</code> ：用来记录当前所有边的数量</p></li><li><p><code>first</code> 数组：用来存储从某个节点出发的第一条边，例如<code>first[0] == 3</code> 可以得出从 <code>0</code>号节点出发的第一条边的编号为 <code>3</code></p></li><li><p><code>edges</code> 数组：用来记录每条边的信息，对于每个<code>edges[i]</code> 都有 3 个域：</p><ul><li><code>to</code> ：记录边的终点</li><li><code>weight</code> ：记录边的权重</li><li><code>next</code> ：记录从当前起点出发下一条边的编号，例如：若<code>edges[i]</code> 的起点为 <code>j</code> 号节点，则<code>edges[i].next</code> 表示从 <code>j</code> 出发的下一条边</li></ul></li></ul><p>示例：</p><p><img src="https://p.ipic.vip/wvox68.png" alt="链式向前星存储图示例" style="zoom:67%;" /></p><blockquote><p>如上图，这就是链式向前星存储图的方式了，其中编号为 -1的边表示不存在，即没有其他的出边。</p><p>若我们需要新增一条从 <code>i</code> 到 <code>j</code>的边，只需更新在 <code>edges</code> 数组内增加元素并且使其新增边的<code>next</code> 等于 <code>first[i]</code> ，然后更新<code>first[i]</code> 为新增的边的编号即可。</p></blockquote><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX 100000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EDGE 100000</span><br><br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>; <span class="hljs-comment">// 边的数量</span><br><br><span class="hljs-type">int</span> first[MAX_VERTEX]; <span class="hljs-comment">// first 数组</span><br><br><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> next;<br>&#125; edges[MAX_EDGE]; <span class="hljs-comment">// 记录边</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initEdge</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 初始化，将 first 数组全初始化为 -1</span><br>    <span class="hljs-built_in">memset</span>(first, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(first));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> weight)</span> </span>&#123;<br>    edges[cnt] = &#123;to, weight, first[from]&#125;; <span class="hljs-comment">// 新增边</span><br>    first[from] = cnt; <span class="hljs-comment">// 更新 first 数组</span><br>    cnt++; <span class="hljs-comment">// 边数增加</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverseEdgeFrom</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历从 v 出发的所有边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = first[v]; p != <span class="hljs-number">-1</span>; p = edges[p].next) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;eNo: &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; to: &quot;</span> &lt;&lt; edges[p].to &lt;&lt; <span class="hljs-string">&quot; weight: &quot;</span> &lt;&lt; edges[p].weight &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>链式向前星</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICG 游戏博弈问题与 SG 定理</title>
    <link href="/2023/03/02/ICG%20%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98%E4%B8%8E%20SG%20%E5%AE%9A%E7%90%86/"/>
    <url>/2023/03/02/ICG%20%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98%E4%B8%8E%20SG%20%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="icg-游戏">ICG 游戏</h3><h4 id="定义">定义</h4><p><strong>ICG</strong> 游戏是博弈游戏的一种，其定义如下：</p><ol type="1"><li>游戏由两人参加，两人轮流做出决策</li><li>当有一人无法决策即无论如何都必败时对手胜出，且 ICG游戏一定会在有限步内完成，游戏没有平局</li><li>游戏的状态转移是单向的，同一个状态只能达到一次</li></ol><h4 id="必胜点和必败点">必胜点和必败点</h4><p>必胜点 N ( Next ) 和必败点 P ( Previous )描述的是某个游戏状态当前的胜负。</p><p>若当前状态为必胜点 N ，则先手必胜，反之，若当前状态为必败点 P，则先手必败。</p><p>可能到这里为止大家还是会觉得比较抽象，所以我们给出一个实际例子：</p><p>假设有一堆石头，两人轮流从这堆石头中取走 1 ~ 5 块石头，初始状态下有 n块石头，问 n 为何值时先手必胜？</p><p>先说结论：<code>n % 6 != 0</code> 时先手必胜。</p><p>原因十分简单，若 n 不是 6 的倍数，则先手一定可以取走 1 ～ 5块内的石头使得取走石头后这堆石头的数量能被 6 整除，此后，对手只要取走 m块石头，我们就取走 6 - m块石头，<strong>可以保证我们每次取完后石头的数量都是 6的倍数</strong>。如此一来，最后的石头一定是被我们取走。</p><p>于是，我们可以得到石头数量 n 对应的 NP 状态：</p><table style="width:100%;"><thead><tr class="header"><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>...</th></tr></thead><tbody><tr class="odd"><td><strong>state</strong></td><td><strong>P</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>P</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>...</strong></td></tr></tbody></table><p>在这里，我们不难得出结论：</p><ul><li><strong>所有必胜点必然可以在一步操作内转移到必败点</strong></li><li><strong>所有必败点无论如何操作只能转移到必胜点</strong></li></ul><h3 id="sg-定理">SG 定理</h3><p>SG 是 Sprague-Grundy 的缩写，SG 定理是处理 ICG博弈问题的重要方法，在讲解其使用之前，我们先简要介绍一下 SG函数的定义。</p><h4 id="sg-函数">SG 函数</h4><p>首先我们定义 <strong><span class="math inline">\(mex\)</span> (minimal excludant )</strong> 运算，<spanclass="math inline">\(mex(F)\)</span> 即表示不属于非负整数集 <spanclass="math inline">\(F\)</span> 中最小的元素：</p><p>例如： <span class="math display">\[\begin{array}{}mex(\{1, 2, 3\}) = 0 \\mex(\{0, 1, 3, 4\}) = 2 \\mex(\emptyset) = 0\end{array}\]</span> 什么是 SG 值？</p><p>SG值是一种通过递归定义的值，它一般情况下是一个非负整数，可以用来描述游戏状态是必胜点还是必败点，假设游戏状态<span class="math inline">\(V_i\)</span> 的 SG 值为 <spanclass="math inline">\(SG(V_i)\)</span> ，那么其状态转移方程如下： <spanclass="math display">\[SG(V_i) = mex(\{SG(V_j) \ | \ V_i \rightarrow V_j \})\]</span> 其数值上等于与 <span class="math inline">\(V_i\)</span>所有后继状态的 SG 值不相等的最小非负整数。</p><p>基于此，我们得到一条重要结论：<strong>SG 值不为 0 的状态为必胜点，SG值为 0 的状态为必败点</strong>。</p><p>这个结论很好证明：若 SG 值不为 0，说明该状态一定能一步转移到 SG 值为0 的状态，即可以一步转移到必败点，所以该状态一定为必胜点；反之，若 SG值为0，则该状态无法一步转移到必败点，只能转移到必胜点或者无法决策，故该点一定为必败点。</p><p>我们还是用上述的取石头问题来举例说明，则不同石头数量 n 对应的 SG值如下：</p><table style="width:100%;"><thead><tr class="header"><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr class="odd"><td><strong>SG(n)</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p><span class="math display">\[\begin{array}{}SG(0) = mex(\emptyset) = 0 \\SG(1) = mex(\{0\}) = 1 \\SG(2) = mex(\{0, 1\}) = 2 \\SG(3) = mex(\{0, 1, 2\}) = 3 \\SG(4) = mex(\{0, 1, 2, 3\}) = 4 \\SG(5) = mex(\{0, 1, 2, 3, 4\}) = 5 \\SG(6) = mex(\{1, 2, 3, 4, 5\}) = 0 \\... \newlineSG(10) = mex(\{5, 0, 1, 2, 3\}) = 4 \\...\end{array}\]</span></p><h4 id="sg-定理详解">SG 定理详解</h4><p>现在我们已经知道了 SG 函数的定义，那 SG 定理又是什么呢？</p><hr /><h5 id="什么是-sg-定理">什么是 SG 定理 ?</h5><p>SG 定理指的是<strong>若一个 ICG博弈游戏的游戏状态可以分为多个子状态，且子状态互相独立，则该游戏状态下的SG 值等于所有子状态的 SG 值的异或值</strong>。</p><p>这又是什么意思呢？别急，我们还是用取石头的例子来说明：</p><p>假设现在有 <span class="math inline">\(k\)</span> 堆石头，每堆石头有<span class="math inline">\(n_i(i = 1, 2, ...,k)\)</span> 块石头，两个人轮流从每一堆石头中取走 <span class="math inline">\([1,m]\)</span> 块石头，先取完所有石头的一方获胜。我们设此刻游戏状态的 SG值为 <span class="math inline">\(SG((n_1, n_2, ..., n_k))\)</span> ，由SG 定理可得： <span class="math display">\[SG((n_1, n_2, ..., n_k)) = SG(n_1) \oplus SG(n_2) \oplus ... \oplusSG(n_k)\]</span></p><ul><li><span class="math inline">\(SG((n_1, n_2, ..., n_k)) \neq 0\)</span>：先手胜</li><li><span class="math inline">\(SG((n_1, n_2, ..., n_k)) = 0\)</span>：先手败</li></ul><p>以上就是完整的 SG 定理了。</p><h5 id="sg-定理的合理性">SG 定理的合理性</h5><p>为什么 SG定理会与位运算的异或有关呢？它们是如何联系上的？为什么这种计算是合理的呢？</p><p>以下我们给出简要的证明：</p><p>根据 SG 值的定义，必败点的 SG 值一定为0，对于此题而言，游戏的终点就是所有的石头被取完，此时 SG 值是 k 个 0的异或值，显然为 0。</p><p>若当前的 SG 值不为 0，我们假设： <span class="math display">\[SG((n_1, n_2, ..., n_k)) = {001010..}_2\]</span> 我们找到该 SG 值数值为 1的最高位，由异或运算符的性质，必然存在奇数个子状态的 SG 值该位为1，我们不妨假设其中一个子状态对应的 SG 值为 <spanclass="math inline">\(SG_0\)</span> ，由 SG值的定义，该状态一定可以一步之内转变为任何 SG 值小于 <spanclass="math inline">\(SG_0\)</span> 的状态，<spanclass="math inline">\(SG_0\)</span> 对应母状态下数值为 1的最高位的值也为 1，我们让其变为0，然后从这一位开始之后全部位取反，则一定可以将母状态的 SG 值变为0。</p><center>0 1 0 1 1 1<br> <strong>0 1 1 0 0 0</strong><br> <ins>0 1 0 1 01</ins><br> 0 1 1 0 1 0<br> 如上，我们将第二个子状态 的 SG 值转移到 0 00 1 1 1，就将母状态的 SG 值转化为 0 了<br> 0 1 0 1 1 1<br> <strong>0 0 01 1 1</strong><br> <ins>0 1 0 1 0 1</ins><br> 0 0 0 0 0 0<br></center><p>反之，如果母状态的 SG 值为0，则改变任何一个子状态，由于异或运算的性质，母状态的 SG值一定无法维持为 0。</p><p>而根据 ICG 博弈游戏的定义，游戏一定会在有限步内完成，故所有子状态 SG值的异或运算不为 0 的母状态一定是必胜点。</p><h3 id="实际应用">实际应用</h3><blockquote><p><strong>Fibonacci again and again</strong></p><p>Problem Description 任何一个大学生对菲波那契数列(Fibonaccinumbers)应该都不会陌生，它是这样定义的： F(1) = 1； F(2) = 2； F(n) =F(n - 1) + F(n - 2) ( n &gt;= 3 )； 所以，1, 2, 3, 5, 8, 13, ...就是菲波那契数列。 今天，又一个关于 Fibonacci的题目出现了，它是一个小游戏，定义如下：</p><ol type="1"><li>这是一个二人游戏；</li><li>一共有 3 堆石子，数量分别是 m, n, p 个；</li><li>两人轮流走；</li><li>每走一步可以选择任意一堆石子，然后取走f个；</li><li>f 只能是菲波那契数列中的元素 ( 即每次只能取1，2，3，5，8 … 等数量)；</li><li>最先取光所有石子的人为胜者；</li></ol><p>假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。</p><p><strong>Input</strong>输入数据包含多个测试用例，每个测试用例占一行，包含 3 个整数 m, n, p ( 1&lt;= m, n, p &lt;= 1000 )。 m = n = p = 0 则表示输入结束。</p><p><strong>Output</strong>如果先手的人能赢，请输出“Fibo”，否则请输出“Nacci”，每个实例的输出占一行。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs input">1 1 1<br>1 4 1<br>0 0 0<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs output">Fibo<br>Nacci<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析</strong>：</p><p>本题所描述的游戏就是一种 ICG博弈，且三堆石头互不影响，所以我们可以直接使用 SG 定理求解，再加上记忆化DFS 优化，很容易就能求解此问题。废话不多说，直接上代码😎。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FIB_NUM 50</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_AMOUNT 1005</span><br><br><span class="hljs-type">int</span> Fibonacci[MAX_FIB_NUM]; <span class="hljs-comment">// 储存 Fibonacci 数列的值</span><br><span class="hljs-type">int</span> SG[MAX_AMOUNT]; <span class="hljs-comment">// 记录 SG 值，初始化为 -1</span><br><br><span class="hljs-comment">// 记忆化搜索</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Fibonacci[n]) &#123;<br>        <span class="hljs-keyword">return</span> Fibonacci[n];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        Fibonacci[n] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        Fibonacci[n] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    Fibonacci[n] = <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>); <span class="hljs-comment">// 记忆</span><br><br>    <span class="hljs-keyword">return</span> Fibonacci[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sg</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 返回 SG 值</span><br>    <span class="hljs-keyword">if</span> (SG[n] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> SG[n];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        SG[n] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> vis[MAX_AMOUNT] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 记录当前状态可达状态的 SG 值是否出现过</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; n - <span class="hljs-built_in">fib</span>(i) &gt;= <span class="hljs-number">0</span>; i++) &#123;<br>        vis[<span class="hljs-built_in">sg</span>(n - <span class="hljs-built_in">fib</span>(i))] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 记录已出现的 SG 值</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_AMOUNT; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>            SG[n] = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> SG[n];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-built_in">memset</span>(SG, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(SG)); <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-type">int</span> m, n, p;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; m &gt;&gt; n &gt;&gt; p, m != <span class="hljs-number">0</span> || n != <span class="hljs-number">0</span> || p != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sg</span>(m) ^ <span class="hljs-built_in">sg</span>(n) ^ <span class="hljs-built_in">sg</span>(p)) &#123;<br>            <span class="hljs-comment">// SG 定理</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;Fibo&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Nacci&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>SG 函数</tag>
      
      <tag>组合博弈</tag>
      
      <tag>组合数学</tag>
      
      <tag>位运算</tag>
      
      <tag>SG 定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化 DFS</title>
    <link href="/2023/02/26/%E8%AE%B0%E5%BF%86%E5%8C%96%20DFS/"/>
    <url>/2023/02/26/%E8%AE%B0%E5%BF%86%E5%8C%96%20DFS/</url>
    
    <content type="html"><![CDATA[<h4 id="引入">引入</h4><p>记忆化DFS，顾名思义，就是<strong>带有记忆的深度优先搜索</strong>。</p><p>总所周知，用程序实现 Fibonacci 数列求值有两种常见方式：</p><ul><li><p>通过迭代即非递归的方式：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">1</span>, next = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">2</span>) &#123;<br>        sum = pre + next;<br>        pre = next;<br>        next = sum;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>通过递归方式：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul><p>上述两种方式各有优缺点，迭代方式效率更高，但是写起来比较麻烦；递归方式运行效率低，但是代码实现容易。</p><p><em>有没有一种方式可以结合两者的优点呢？</em></p><p>对于第二种递归方式，其主要的时间开销在于计算了许多重复内容，我们是否可以使用一个数组来维护已经计算过的值呢？</p><p>答案是显然的，于是我们就有了 —— <strong>记忆化 DFS</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> fib[MAX_NUM]; <span class="hljs-comment">// 记忆数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (fib[n]) &#123;<br>        <span class="hljs-keyword">return</span> fib[n]; <span class="hljs-comment">// 已经计算过的值直接返回</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        fib[n] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        fib[n] = <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> fib[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码以递归的方式实现，但是时间复杂度可以降到线性，和迭代形式一样，不同的地方在于我们需要额外的空间开销来记录已经计算过的值。</p><p>可能有同学就有疑问了：</p><p><em>上述例子很容易用 DP 来实现，为什么还需要记忆化 DFS 呢？</em></p><p>接下来我们将给出几个实际例子加以说明。</p><h4 id="实例分析">实例分析</h4><h5 id="案例一">案例一</h5><blockquote><p><strong>猫和老鼠</strong></p><p>Problem Description 有个小老鼠在校园里收藏了一些它最爱吃的奶酪。校园可以看成一个长度为n的正方形网格，每个网格可以标记为 (p, q) ，其中，0&lt;= p , q &lt; n。每个网格都有一个洞，里面储存了 k（0 &lt;= k &lt;=100）块奶酪。</p><p>现在，小老鼠准备享用这些美味啦。</p><p>开始的时候，他在 (0, 0)这个位置，每到一个地方，它都会吃光这个地方的奶酪，然后沿着水平或者垂直的方向到达另外一个地方。麻烦的是，有个很凶的猫总是在它的洞口附近，所以他每次最多移动k个位置，否则就会被这只猫吃掉。更糟糕的是，每在一个地方吃过奶酪，小老鼠都会变胖，所以，为了获得足够下一次逃跑的能量，它每次只能去比当前位置的奶酪更多的格子。现在已知 n 和 k，以及在每个网格的洞中小老鼠储存的奶酪的数量，请计算小老鼠在无法移动之前，一共最多能吃到多少块奶酪。</p><p>Input 题目包含多组测试数据。</p><p>每组测试数据组成如下： 首先一行包含2个不超过100的正整数 n 和 k ;接下来 n 行，每行包含n个数： 第一行 n 个数分别表示 (0, 0), (0, 1), … (0,n - 1) 这些位置储存的奶酪数量； 第二行 n 个数分别表示 (1, 0), (1, 1), …(1, n - 1) 这些位置储存的奶酪数量； 以此类推...</p><p>输入数据以两个 -1 结束。</p><p>Output 请输出小老鼠最多 能够吃到的奶酪数量，每组数据输出一行。</p><p>输入案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs input">3 1<br>1 2 5<br>10 11 6<br>12 12 7<br>-1 -1<br></code></pre></td></tr></table></figure><p>输出案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">37<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析</strong>：</p><p>根据题意，我们假设从 <span class="math inline">\((x, y)\)</span>出发的老鼠可以吃到的最大奶酪数量为 <span class="math inline">\(ans(x,y)\)</span>，<span class="math inline">\((x, y)\)</span> 处的芝士储量为<span class="math inline">\(cheese(x, y)\)</span>，老鼠可以从 <spanclass="math inline">\((x, y)\)</span> 出发在一次 <spanclass="math inline">\(k\)</span> 步以内的移动中到达的坐标的集合为 <spanclass="math inline">\(S = \{(x_1, y_1), (x_2, y_2), (x_3, y_3),...\}\)</span>，不难得出状态转移方程： <span class="math display">\[ans(x, y) = max_{(x_n, y_n) \in S} ans(x_n, y_n) \ + \ cheese(x, y)\]</span>如果直接用动态规划求解，这个问题的处理会相当复杂，因为我们难以从该状态转移方程中确定DP 的起点和 DP 的方向，所以直接采用迭代的方式恐怕不现实。</p><p>于是我们便考虑到可以使用记忆化DFS，既保证了效率，又降低了编码难度。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENG 105</span><br><br><span class="hljs-type">int</span> cheese[MAX_LENG][MAX_LENG];<br><span class="hljs-type">int</span> ans[MAX_LENG][MAX_LENG]; <span class="hljs-comment">// 储存结果，初始化为 -1</span><br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">const</span> vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; dirs = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;<br>&#125;; <span class="hljs-comment">// 运动方向</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// 记忆化 DFS</span><br>    <span class="hljs-comment">// 返回以 (x, y) 为起点可以吃到最多的奶酪</span><br>    <span class="hljs-keyword">if</span> (ans[x][y] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 已经计算过的值</span><br>        <span class="hljs-keyword">return</span> ans[x][y];<br>    &#125;<br>    ans[x][y] = cheese[x][y];<br>    <span class="hljs-type">int</span> plusCheese = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dir :dirs) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>; s &lt;= k; s++) &#123;<br>            <span class="hljs-type">int</span> nx = x + s * dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ny = y + s * dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n &amp;&amp; cheese[nx][ny] &gt; cheese[x][y]) &#123;<br>                plusCheese = <span class="hljs-built_in">max</span>(plusCheese, <span class="hljs-built_in">dfs</span>(nx, ny));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ans[x][y] += plusCheese;<br>    <span class="hljs-keyword">return</span> ans[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; k, n != <span class="hljs-number">-1</span> || k != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(ans));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                cin &gt;&gt; cheese[i][j];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="案例二">案例二</h5><blockquote><p><strong>How many ways</strong></p><p>Problem Description这是一个简单的生存游戏，你控制一个机器人从一个棋盘的起始点 (1, 1)走到棋盘的终点 (n, m)。游戏的规则描述如下：</p><ol type="1"><li>机器人一开始在棋盘的起始点并有起始点所标有的能量。</li><li>机器人只能向右或者向下走，并且每走一步消耗一单位能量。</li><li>机器人不能在原地停留。</li><li>当机器人选择了一条可行路径后，当他走到这条路径的终点时，他将只有终点所标记的能量。</li></ol><figure><img src="http://acm.hdu.edu.cn/data/images/C113-1003-1.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如上图，机器人一开始在 (1, 1)点，并拥有4单位能量，蓝色方块表示他所能到达的点，如果他在这次路径选择中选择的终点是(2, 4) ，当他到达 (2, 4)点时将拥有1单位的能量，并开始下一次路径选择，直到到达 (6, 6) 点。我们的问题是机器人有多少种方式从起点走到终点。这可能是一个很大的数，输出的结果对10000 取模。</p><p>Input 第一行输入一个整数T,表示数据的组数。对于每一组数据第一行输入两个整数 n, m (1 &lt;= n, m &lt;=100)。表示棋盘的大小。接下来输入 n 行,每行 m 个整数 e (0 &lt;= e &lt;20)。</p><p>Output 对于每一组数据输出方式总数对10000取模的结果。</p><p>输入案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs input">1<br>6 6<br>4 5 6 6 4 3<br>2 2 3 1 7 2<br>1 1 4 6 2 7<br>5 8 4 3 9 5<br>7 6 6 2 1 5<br>3 1 1 3 7 2<br></code></pre></td></tr></table></figure><p>输出案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3948<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析</strong>：</p><p>同案例一，我们只需找到状态转移方程后使用记忆化 DFS即可，这里不再赘述。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> T; <span class="hljs-comment">// 数据组数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENG 105</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 10000</span><br><br><span class="hljs-type">int</span> energy[MAX_LENG][MAX_LENG]; <span class="hljs-comment">// 记录每个格点点能量</span><br><span class="hljs-type">int</span> ans[MAX_LENG][MAX_LENG]; <span class="hljs-comment">// 记录答案，初始化为 -1</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// 表示从 (x, y) 出发到终点又多少种走法</span><br>    <span class="hljs-keyword">if</span> (ans[x][y] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> ans[x][y];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) &#123;<br>        ans[x][y] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> ans[x][y];<br>    &#125;<br>    <span class="hljs-type">int</span> power = energy[x][y]; <span class="hljs-comment">// 能量</span><br>    ans[x][y] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= power; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= power - i; j++) &#123;<br>            <span class="hljs-comment">// 遍历所有可能位置</span><br>            <span class="hljs-type">int</span> nx = x + i, ny = y + j;<br>            <span class="hljs-keyword">if</span> (nx != x || ny != y) &#123;<br>                <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m) &#123;<br>                    ans[x][y] = (ans[x][y] + <span class="hljs-built_in">dfs</span>(nx, ny)) % MAX_NUM;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                cin &gt;&gt; energy[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(ans));<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>记忆化搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分匹配问题 —— 匈牙利算法</title>
    <link href="/2023/02/25/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/25/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="问题介绍">问题介绍</h3><p><strong>什么是二分图？</strong></p><p>对于图 <span class="math inline">\(G(V,E)\)</span> 而言，若 <spanclass="math inline">\(G\)</span> 中的所有点可以划分为两个子集 <spanclass="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span> ，且图中每条边 <spanclass="math inline">\(e\)</span>关联的两个顶点都属于不同的顶点子集，这样的图我们称为<strong>二分图（Bipartite Graph ）</strong>，或者二部图。</p><p><img src="https://p.ipic.vip/ueiehn.png" style="zoom:67%;" /></p><p><strong>最大匹配问题和最小点覆盖问题</strong></p><p>什么是<strong>最大匹配问题</strong>？给定一个二分图 <spanclass="math inline">\(G(V,E)\)</span>，若 <spanclass="math inline">\((a_i,b_j) \in E\)</span> ，我们就称 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(b_j\)</span>是可配对的，已知该图中任意顶点至多匹配一个顶点，求最大匹配数。如下图，不难看出该图的最大匹配数为2。其中一种匹配方式为 <span class="math inline">\((a_1,b_1)\)</span>、<span class="math inline">\((a_3, b_4)\)</span> 。</p><p>什么又是<strong>最小点覆盖问题</strong>呢？即从二分图中删除最少的顶点，使得图<span class="math inline">\(G\)</span>中任何一对点都无法匹配。删除顶点的最小数量称为最小点覆盖数。如下图，不难看出最小覆盖数也是2。我们可以删去 <span class="math inline">\(a_3\)</span> 和 <spanclass="math inline">\(b_1\)</span> 使得图中任何一对点都无法匹配。</p><p>这两个问题看似不一样，实际上实际上是处理一个相同的问题。为什么这么说呢？因为我们可以证明一条重要性质：</p><center><strong>最大匹配数 = 最小覆盖数</strong></center><p>具体证明就不在这里说明了，笔者打算以后单独出一期文章来证明该性质。</p><p><img src="https://p.ipic.vip/5pnk5n.png" style="zoom:45%;" /></p><p>那我们该如何给出二分匹配问题的一般解决方案呢？1955 年，库恩（W.W.Kuhn ）利用一个匈牙利数学家康哥尼（ D.Kőnig）的一个定理构造了一种二分匹配问题的解法，后人称之为<strong>匈牙利算法</strong>。</p><h3 id="匈牙利算法">匈牙利算法</h3><p>在介绍匈牙利算法之前，我们先介绍几个概念：</p><ul><li><p><strong>交替路</strong>：</p><p>从未匹配点出发，依次经过未匹配的边和已匹配的边的路径称为交替路。</p></li><li><p><strong>增广路</strong>：</p><p>经过除出发点之外其他未匹配点的交替路称为增广路。</p><p><strong>当且仅当不存在关于图 <span class="math inline">\(G\)</span>的增广路径时当前的匹配为图 <span class="math inline">\(G\)</span>的最大匹配。</strong></p></li></ul><h4 id="算法讲解">算法讲解</h4><p>如下图所示，我们接下来将使用匈牙利算法来计算该二分图的最大匹配数。</p><p>我们从 <span class="math inline">\(a_1\)</span> 开始匹配，<spanclass="math inline">\(a_1\)</span> 与 <spanclass="math inline">\(b_1\)</span> 匹配成功，即当前匹配对数为 1。</p><p><left><img src="https://p.ipic.vip/phzd9z.png" alt="(1)" style="zoom:100%; margin-right: 30px;" /><img src="https://p.ipic.vip/wfjof3.png" alt="(2)" style="zoom:100%; margin-right: 30px;" /></left></p><p>然后再对 <span class="math inline">\(a_2\)</span> 进行匹配，我们发现<span class="math inline">\(a_2\)</span> 只能匹配 <spanclass="math inline">\(b_1\)</span> ，而 <spanclass="math inline">\(b_1\)</span> 已经与 <spanclass="math inline">\(a_1\)</span> 匹配成功了，此时我们发现 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(b_3\)</span> 可以成功匹配，于是我们可以取消 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(b_1\)</span> 的匹配，然后匹配 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(b_3\)</span> ，这个时候 <spanclass="math inline">\(a_2\)</span> 就可以匹配 <spanclass="math inline">\(b_1\)</span> 了。匹配对数加一，当前匹配对数为2。</p><p>其实这一步相当于找到了一条增广路 <span class="math inline">\((a_2,b_1, a_1, b_3)\)</span> ，然后对该增广路取反。</p><p><left><img src="https://p.ipic.vip/0dm74v.png" alt="(3)" style="zoom:100%;" /></left></p><p>接下来对 <span class="math inline">\(a_3\)</span> 进行匹配，<spanclass="math inline">\(a_3\)</span> 与 <spanclass="math inline">\(b_2\)</span>成功匹配，匹配对数加一，当前匹配对数为 3。</p><p><left><img src="https://p.ipic.vip/zhjyss.png" alt="(4)" style="zoom:100%;" /></left></p><p>最后对 <span class="math inline">\(a_4\)</span>进行匹配，发现其只能与 <span class="math inline">\(b_1\)</span> 匹配，而<span class="math inline">\(b_1\)</span> 已经与 <spanclass="math inline">\(a_1\)</span> 匹配过了，而且无法从 <spanclass="math inline">\(a_4\)</span> 出发构造一条增广路，因此 <spanclass="math inline">\(a_4\)</span> 无法与任何一个顶点成功匹配。</p><p><strong>综上所述，展示的二分图的最大匹配数为 3</strong>。</p><p><strong>伪代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pseudo-code">// 判断 ai 是否能匹配成功<br>for bj 与 ai 相连:<br>if bj 未被访问:<br>更新 bj 访问状态;<br>        if bj 未被匹配或者 bj 的配对点可以出发找到增广路径:<br>        将 bj 的配对点改为 ai;<br>        return true;<br><br>return false;<br></code></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(VE)\)</span></p><h4 id="代码实现">代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NOT_MATCH 0x3f3f3f3f</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> numA, numB; <span class="hljs-comment">// numA、numB 分别表示两个集合的元素个数</span><br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; G; <span class="hljs-comment">// 假设这里用邻接链表储存图 G，G[i] 表示和 ai 相邻的所有 B 集合的顶点编号</span><br>  <span class="hljs-type">int</span> match[numB]; <span class="hljs-comment">// 记录 B 集合的元素的匹配点在 A 集合的编号</span><br>  <span class="hljs-type">bool</span> vis[numB]; <span class="hljs-comment">// 记录 B 集合的元素是否被访问过</span><br><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>      <span class="hljs-comment">// 判断 A 集合中编号为 index 的顶点是否能匹配成功</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[index].<span class="hljs-built_in">size</span>(); i++) &#123;<br>          <span class="hljs-keyword">if</span> (!vis[G[i]]) &#123;<br>              vis[G[i]] = <span class="hljs-literal">true</span>;<br>              <span class="hljs-keyword">if</span> (match[G[i]] == NOT_MATCH || <span class="hljs-built_in">isMatch</span>(match[[G[i]]])) &#123;<br>                <span class="hljs-comment">// 该顶点未被匹配或着原来匹配该点的顶点可以匹配其他顶点</span><br>                  match[G[i]] = index;<br>                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hungarian</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numA; i++) &#123;<br>          <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isMatch</span>(i)) &#123;<br>              cnt++;<br>            &#125;<br>        &#125;<br>      <br>      <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实际应用">实际应用</h4><blockquote><p><strong>Machine Schedule</strong></p><p>Problem Description As we all know, machine scheduling is a veryclassical problem in computer science and has been studied for a verylong history. Scheduling problems differ widely in the nature of theconstraints that must be satisfied and the type of schedule desired.Here we consider a 2-machine scheduling problem.</p><p>There are two machines A and B. Machine A has n kinds of workingmodes, which is called <span class="math inline">\(mode_0\)</span> ,<span class="math inline">\(mode_1\)</span> , …, <spanclass="math inline">\(mode_{n-1}\)</span> , likewise machine B has mkinds of working modes, <span class="math inline">\(mode_0\)</span>,<span class="math inline">\(mode_1\)</span> , … , <spanclass="math inline">\(mode_{m-1}\)</span> . At the beginning they areboth work at <span class="math inline">\(mode_0\)</span>.</p><p>For k jobs given, each of them can be processed in either one of thetwo machines in particular mode. For example, job 0 can either beprocessed in machine A at <span class="math inline">\(mode_3\)</span> orin machine B at <span class="math inline">\(mode_4\)</span> , job 1 caneither be processed in machine A at <spanclass="math inline">\(mode_2\)</span> or in machine B at <spanclass="math inline">\(mode_4\)</span> , and so on. Thus, for job i, theconstraint can be represent as a triple (i, x, y), which means it can beprocessed either in machine A at <spanclass="math inline">\(mode_x\)</span>, or in machine B at <spanclass="math inline">\(mode_y\)</span> .</p><p>Obviously, to accomplish all the jobs, we need to change themachine’s working mode from time to time, but unfortunately, themachine’s working mode can only be changed by restarting it manually. Bychanging the sequence of the jobs and assigning each job to a suitablemachine, please write a program to minimize the times of restartingmachines.</p><p>Input The input file for this program consists of severalconfigurations. The first line of one configuration contains threepositive integers: n, m (n, m &lt; 100) and k (k &lt; 1000). Thefollowing k lines give the constrains of the k jobs, each line is atriple: i, x, y.</p><p>The input will be terminated by a line containing a single zero.</p><p>Output The output should be one integer per line, which means theminimal times of restarting machine.</p><p>输入案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs input">5 5 10<br>0 1 1<br>1 1 2<br>2 1 3<br>3 1 4<br>4 2 1<br>5 2 2<br>6 2 3<br>7 2 4<br>8 3 3<br>9 4 3<br>0<br></code></pre></td></tr></table></figure><p>输出案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3<br></code></pre></td></tr></table></figure></blockquote><p>对于此题，我们可以将 A、B机器的所有模式看成二部图看成两个子集，若某个工作需要机器 A 的 x模式和机器 B 的 y 模式来完成，就将 <span class="math inline">\((a_x,b_y)\)</span>连接起来。最后我们的问题就变成了：<strong>应该如何找到该二部图的最小点覆盖数？</strong></p><p>而根据我们之前提到的结论可知，最小点覆盖数在数值上等于最大匹配数。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 105</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NOT_FOUND 0x3f3f3f3f</span><br><br><span class="hljs-type">int</span> G[MAX_NUM][MAX_NUM];<br><span class="hljs-type">bool</span> vis[MAX_NUM];<br><span class="hljs-type">int</span> match[MAX_NUM];<br><br><span class="hljs-type">int</span> n, m, k;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (G[index][i] &amp;&amp; !vis[i]) &#123;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[i] == NOT_FOUND || <span class="hljs-built_in">isMatch</span>(match[i])) &#123;<br>                match[i] = index;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cin &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-built_in">memset</span>(G, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G));<br>        <span class="hljs-built_in">memset</span>(match, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(match));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-type">int</span> t, ax, by;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            cin &gt;&gt; t &gt;&gt; ax &gt;&gt; by;<br>            <span class="hljs-keyword">if</span> (ax != <span class="hljs-number">0</span> &amp;&amp; by != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 0 号模式下可以完成的任务不用添加</span><br>                G[ax][by] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isMatch</span>(i)) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 求出最小点覆盖数</span><br><br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>二分匹配</tag>
      
      <tag>匈牙利算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLDB 快速入门</title>
    <link href="/2023/02/22/LLDB%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/22/LLDB%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><strong><em>如果调试是删除 bug 的过程，那么编程就是引入 bug的过程。</em></strong></p><p><strong>—— Edsger W. Dijkstra</strong></p><hr /><h4 id="lldb-是什么">LLDB 是什么？</h4><p>LLDB（ Low level Debug ）是 MacOS 默认进行调试 C/C++程序的调试工具，能帮开发者进行更加丰富地流程控制和栈帧数据监测。</p><p><strong>简言之，LLDB 是一个有着 REPL 的特性和 C++ 、Python插件的开源调试器。</strong></p><p>在此，我们以几个简单的程序为例子，对 LLDB 进行快速入门。</p><p><strong>目录</strong></p><ul><li><p>启动 LLDB</p></li><li><p>断点操作</p><ul><li>设置断点</li><li>查看断点</li><li>删除断点</li></ul></li><li><p>分步调试</p><ul><li>启动调试</li><li>进入，跳过和继续</li><li>跳出当前函数</li></ul></li><li><p>查看变量</p></li><li><p>结束调试</p></li></ul><h4 id="启动-lldb">启动 LLDB</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">fact</span>(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> z = x + y;<br><br>    cout &lt;&lt; <span class="hljs-built_in">fact</span>(z) &lt;&lt; endl;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译 C/C++ 程序时使其可以被 LLDB 调试工具设置断点，需要添加<code>-g</code> ，以 C++ 文件 <code>demo.cpp</code> 为例：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">clang++ -g demo.cpp<br><br>lldb a.out<br></code></pre></td></tr></table></figure><h4 id="断点操作">断点操作</h4><h6 id="设置断点">设置断点</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">br s -f [文件名] -l [行号]# 在文件的某一行设置断点<br>br s -n [函数名]# 给函数设置断点<br></code></pre></td></tr></table></figure><h6 id="查看断点">查看断点</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">br list# 显示所有断点和其序号<br></code></pre></td></tr></table></figure><h6 id="删除断点">删除断点</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">br <span class="hljs-built_in">del</span> [断点序号]<br>br <span class="hljs-built_in">del</span> # 删除所有断点<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cmd">(lldb) br s -f demo.cpp -l <span class="hljs-number">17</span><br>Breakpoint <span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">28</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span>, address = <span class="hljs-number">0</span>x0000000100003d80<br>(lldb) br s -f demo.cpp -l <span class="hljs-number">21</span><br>Breakpoint <span class="hljs-number">2</span>: where = a.out`main + <span class="hljs-number">56</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span>, address = <span class="hljs-number">0</span>x0000000100003d9c<br>(lldb) br s -n fact<br>Breakpoint <span class="hljs-number">3</span>: where = a.out`fact(int) + <span class="hljs-number">16</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">6</span>:<span class="hljs-number">9</span>, address = <span class="hljs-number">0</span>x0000000100003d18<br>(lldb) br list<br>Current breakpoints:<br><span class="hljs-number">1</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">17</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">1</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">28</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d80], unresolved, hit count = <span class="hljs-number">0</span> <br><br><span class="hljs-number">2</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">21</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">2</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">56</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d9c], unresolved, hit count = <span class="hljs-number">0</span> <br><br><span class="hljs-number">3</span>: name = &#x27;fact&#x27;, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">3</span>.<span class="hljs-number">1</span>: where = a.out`fact(int) + <span class="hljs-number">16</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">6</span>:<span class="hljs-number">9</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d18], unresolved, hit count = <span class="hljs-number">0</span> <br><br>(lldb) br <span class="hljs-built_in">del</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> breakpoints deleted; <span class="hljs-number">0</span> breakpoint locations disabled.<br>(lldb) br list<br>Current breakpoints:<br><span class="hljs-number">1</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">17</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">1</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">28</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d80], unresolved, hit count = <span class="hljs-number">0</span> <br><br><span class="hljs-number">2</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">21</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">2</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">56</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d9c], unresolved, hit count = <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><h4 id="分步调试">分步调试</h4><h6 id="启动调试">启动调试</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">r<br></code></pre></td></tr></table></figure><blockquote><p>输入 <code>run</code> 或者 <code>r</code> 后程序便会开始启动调试</p></blockquote><h6 id="进入跳过和继续">进入，跳过和继续</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 进入单步执行，中间如果有函数调用会跳转到目标函数<br>s<br><br># 跳过单步执行，中间的函数执行过程会跳过<br>n<br><br># 继续跳转到下一个断点<br>c<br></code></pre></td></tr></table></figure><h6 id="跳出当前函数">跳出当前函数</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">finish<br></code></pre></td></tr></table></figure><h4 id="查看变量">查看变量</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 查看某个变量：<br>p [变量名]<br><br><br># 查看当前栈帧所有变量<br>fr v<br><br><br># 切换栈帧<br>fr s [栈帧序号]<br><br><br># 打印当前线程的栈帧信息<br>bt<br><br><br># 打印所有线程的栈帧信息<br>bt all<br></code></pre></td></tr></table></figure><p>综合案例：在 <code>demo.cpp</code> 的 17 行和 21 行设置断点，使用<code>r</code> 开始调试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cmd">* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint <span class="hljs-number">1</span>.<span class="hljs-number">1</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d80 a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span><br>   <span class="hljs-number">14</span>  <br>   <span class="hljs-number">15</span>   int main() &#123;<br>   <span class="hljs-number">16</span>  <br>-&gt; <span class="hljs-number">17</span>       int x = <span class="hljs-number">2</span>;<br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step <span class="hljs-keyword">in</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d88 a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">18</span>:<span class="hljs-number">9</span><br>   <span class="hljs-number">15</span>   int main() &#123;<br>   <span class="hljs-number">16</span>  <br>   <span class="hljs-number">17</span>       int x = <span class="hljs-number">2</span>;<br>-&gt; <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>   <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step <span class="hljs-keyword">in</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d8c a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">19</span>:<span class="hljs-number">13</span><br>   <span class="hljs-number">16</span>  <br>   <span class="hljs-number">17</span>       int x = <span class="hljs-number">2</span>;<br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>-&gt; <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>   <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>   <span class="hljs-number">22</span>  <br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint <span class="hljs-number">2</span>.<span class="hljs-number">1</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d9c a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span><br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>-&gt; <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>   <span class="hljs-number">22</span>  <br>   <span class="hljs-number">23</span>       return <span class="hljs-number">0</span>;<br>   <span class="hljs-number">24</span>   &#125;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) fr v<br>(int) x = <span class="hljs-number">2</span><br>(int) y = <span class="hljs-number">3</span><br>(int) z = <span class="hljs-number">5</span><br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step <span class="hljs-keyword">in</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d18 a.out`fact(n=<span class="hljs-number">5</span>) <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">6</span>:<span class="hljs-number">9</span><br>   <span class="hljs-number">3</span>    using namespace std;<br>   <span class="hljs-number">4</span>   <br>   <span class="hljs-number">5</span>    int fact(int n) &#123;<br>-&gt; <span class="hljs-number">6</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-number">7</span>            return <span class="hljs-number">1</span>;<br>   <span class="hljs-number">8</span>        &#125;<br>   <span class="hljs-number">9</span>        <span class="hljs-keyword">else</span> &#123;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) finish<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step out<br>Return value: (int) $<span class="hljs-number">0</span> = <span class="hljs-number">120</span><br><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003da4 a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">13</span><br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>-&gt; <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>   <span class="hljs-number">22</span>  <br>   <span class="hljs-number">23</span>       return <span class="hljs-number">0</span>;<br>   <span class="hljs-number">24</span>   &#125;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) c<br>Process <span class="hljs-number">31435</span> resuming<br><span class="hljs-number">120</span><br>Process <span class="hljs-number">31435</span> exited with status = <span class="hljs-number">0</span> (<span class="hljs-number">0</span>x00000000)<br></code></pre></td></tr></table></figure><h4 id="结束调试">结束调试</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">q<br></code></pre></td></tr></table></figure><blockquote><p>输入 <code>quit</code> 或者 <code>q</code> 结束 LLDB 调试</p></blockquote><p><strong>以上就是对 LLDB 的一个简单介绍了，如果想了解更多 LLDB指令，可以查看官网的 <a href="https://lldb.llvm.org/use/map.html">LLDBcommand map</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>调试器</tag>
      
      <tag>C++</tag>
      
      <tag>LLDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 脚手架配置代理的方法</title>
    <link href="/2023/02/07/React%20%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/02/07/React%20%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="方法一直接在-package.json-中追加配置">方法一：直接在<code>package.json</code> 中追加配置</h4><p>例如，当前服务器端口为 3000，若要向端口 5000的服务器发送请求，我们可以在 <code>package.json</code>中添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:5000&quot;</span><br></code></pre></td></tr></table></figure><p>此后，当请求了 3000 端口不存在的资源时，那么请求就会转发给 5000端口。</p><p>示例：</p><p>例如一个 <code>create-react-app</code> 创建项目在 3001端口运行，我们使用 <code>json-server</code> 模拟了一个 3000端口的服务器，其中 JSON 数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;students&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0001&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Tom&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0002&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jack&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">19</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0003&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Frank&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>students</code> 数据的 URL 为<code>http://localhost:3000/students</code>，若我们要向 3001 端口发送GET 请求来获取 <code>students</code> 的 JSON 数据，则可以在<code>package.json</code> 中添加配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:3000&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>获取 3001 端口有的资源：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br><br>  getInfo = <span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:3001/index.html&quot;</span>).<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>      &#125;<br>    );<br>  &#125;<br><br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.getInfo&#125;</span>&gt;</span>点击发送请求获取数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时控制台输出当前项目下的 <code>index.html</code> 文件：</p><p><left><img src="https://p.ipic.vip/vyhdeu.png" alt="image-20230207230919387" style="zoom: 33%;" /></left></p></li><li><p>获取 3001 端口没有而 3000 端口有的资源：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br><br>  getInfo = <span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:3001/students&quot;</span>).<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>      &#125;<br>    );<br>  &#125;<br><br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.getInfo&#125;</span>&gt;</span>点击发送请求获取数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时控制台输出 3000 端口下的 <code>students</code> 数据：</p><p><left><img src="https://p.ipic.vip/hxjhru.png" alt="image-20230207231130393" style="zoom:50%;" /></left></p></li><li><p>若获取的资源 3001 端口和 3000端口都没有，则控制台会报错。</p></li></ul><blockquote><p>方法一优缺点：</p><ul><li>优点：配置简单，前端请求资源时可以不加任何前缀</li><li>缺点：不能配置多个代理</li></ul></blockquote><h4 id="方法二创建-setupproxy.js-文件">方法二：创建<code>setupProxy.js</code> 文件</h4><ol type="1"><li><p>首先在 src 目录下创建 <code>setupProxy.js</code> 文件</p></li><li><p>编写 <code>setupProxy.js</code> 配置具体代码规范：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 配置端口 8000 和端口 5001 的服务器代理</span><br><span class="hljs-comment">// setupProxy.js</span><br><br><span class="hljs-keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><span class="hljs-comment">// 引入内置模块: HTTP 代理中间件</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">app</span>) &#123;<br>    <span class="hljs-comment">// app 为服务对象</span><br>    app.<span class="hljs-title function_">use</span>(<br>        <span class="hljs-title function_">createProxyMiddleware</span>(<span class="hljs-string">&#x27;/api1&#x27;</span>, &#123;<span class="hljs-comment">// 遇见 /api1 前缀的请求，就会触发该代理</span><br>            <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8000&#x27;</span>,<span class="hljs-comment">// 请求转发的端口地址</span><br>            <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 控制服务器收到响应头中 Host 字段的值</span><br>            <span class="hljs-attr">pathRewrite</span>: &#123;<br>                <span class="hljs-string">&#x27;^/api1&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">// 去除请求前缀，保证交给后台服务器的是正常请求地址</span><br>            &#125;<br>        &#125;)<br>    );<br>    <br>    app.<span class="hljs-title function_">use</span>(<br>        <span class="hljs-title function_">createProxyMiddleware</span>(<span class="hljs-string">&#x27;/api2&#x27;</span>, &#123;<br>            <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>,<br>            <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">pathRewrite</span>: &#123;<br>                <span class="hljs-string">&#x27;^/api2&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>            &#125;<br>        &#125;)<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>http-proxy-middleware</code> 1.x 版本后配置代理使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br></code></pre></td></tr></table></figure><p>此前使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>向不同端口发送请求的方法：</p><ul><li><p>如果要向 8000 端口发送请求，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/api1/teachers&#x27;</span>).<span class="hljs-title function_">then</span>(<br>  <span class="hljs-comment">// ...</span><br>);<br></code></pre></td></tr></table></figure></li><li><p>如果要向 5001 端口发送请求，同理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/api2/students&#x27;</span>).<span class="hljs-title function_">then</span>(<br><span class="hljs-comment">// ...</span><br>);<br></code></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>方法二优缺点：</p><ul><li>优点：可以配置多个代理，可以更加灵活地控制是否走代理请求</li><li>缺点：配置繁琐，前端发送代理请求时必须加前缀</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

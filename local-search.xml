<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>脉冲神经网络 SNN</title>
    <link href="/2024/01/26/%E8%84%89%E5%86%B2%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-SNN/"/>
    <url>/2024/01/26/%E8%84%89%E5%86%B2%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C-SNN/</url>
    
    <content type="html"><![CDATA[<h4 id="第三代神经网络-snn">第三代神经网络 SNN</h4><p>尖峰神经网络（SNN，Spike NeuralNetwork）是一种神经网络模型，它在模拟人脑处理信息方式方面比传统的人工神经网络更为接近。SNN的独特之处在于其神经元之间的交流是通过<strong>“尖峰”（Spike）</strong>，即短暂的电信号脉冲来实现的，类似于生物神经元的通信方式。这种方式允许SNN以一种高效的时间编码方式处理信息，使得网络能够响应快速变化的输入信号并在更低的功耗下运行。</p><p>如下图，这项由 J. Krüger 和 F. Aiple 在 1988年进行的研究集中在猴子的视皮层下层的神经元之间的相互作用。研究通过使用多个紧密排列的微电极记录尖峰并分析交叉相关图，旨在理解这些皮层层次中神经元的交互作用及其相关结构。其中两条竖线标记了100ms 的间隔。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2024-01-29-032237.png" style="zoom:35%;" /></p><p>SNN通常被视为第三代神经网络模型，它在模拟神经元动态行为、处理时间序列数据以及学习时空模式方面表现出独特优势。由于其生物学上的真实性和能效高的特点，SNN在神经形态计算领域尤为受到关注。神经形态计算旨在模仿人脑的处理方式，开发出更高效的计算模型和硬件架构。</p><h4 id="神经元">神经元</h4><p>相比第二代神经网络，也就是基于传统的线性变换和非线性激活函数的 ANN而言，SNN将激活函数替换成了一种动态的时序敏感的<strong>神经元（Neuron）</strong>。</p><h5 id="基本特性">基本特性</h5><ol type="1"><li><strong>脉冲机制</strong>：SNN神经元通过尖峰进行通信。这些脉冲是离散的事件，通常在模拟神经元的<strong>电压达到某个阈值</strong>时发生。</li><li><strong>时间动力学</strong>：SNN神经元具有显著的时间动力学特性。它们的状态不仅取决于当前的输入，还取决于<strong>历史输入的积累效应</strong>，这是通过内部状态变量（例如<strong>膜电位</strong>）来实现的。</li><li><strong>生物学上的仿真性</strong>：SNN更贴近于模拟真实生物神经系统的方式。它们试图通过模拟生物神经元的动态特性（如脉冲编码和神经元的时变动态）来处理信息。</li></ol><p>接下来我们以两种神经元为例，讲解其工作原理。</p><h5 id="if-神经元">IF 神经元</h5><p>IF 神经元（Integrate-and-FireNeuron）是脉冲神经网络（SNNs）中最基本的神经元模型之一。它的设计模拟了生物神经元的基本行为，特别是如何积累输入信号，并在达到特定阈值时产生脉冲。</p><p><strong>积分（Integrate）</strong>：IF神经元首先会积累其输入信号。这些输入可能来自网络中的其他神经元，或者是外部的刺激。积分过程实际上是对输入信号（通常是电流）随时间的累加，这在生物学上对应于神经元膜电位的变化。<span class="math display">\[U_i^{(l)}(t) = U_i^{(l)}(t - 1) + RI_{i}^{(l)}(t)\]</span> 这里 <span class="math inline">\(U_i^{(l)}(t)\)</span> 表示<span class="math inline">\(t\)</span> 时刻神经元的膜电位，<spanclass="math inline">\(RI_i^{(l)}(t)\)</span> 表示 <spanclass="math inline">\(t\)</span> 时刻该神经元接收的输入信号的大小，其中<span class="math inline">\(I_i^{(l)}(t)\)</span> 表示输入电流，由 <spanclass="math inline">\(t\)</span> 时刻神经元接收到的尖峰累加而成，<spanclass="math inline">\(R\)</span> 在这里表示膜电阻。</p><p><strong>触发（Fire）</strong>：当积累的信号（即膜电位）达到特定的阈值时，<strong>神经元会发射一个脉冲</strong>，并且将这个信号传递给其它神经元。发射脉冲后，神经元的膜电位通常会被重置到一个较低的初始值，准备接受下一轮的信号积累。<span class="math display">\[S_i^{(l)}(t) = \Theta(U_i^{(l)}(t) - U_{\text{threshold}})\]</span></p><p><span class="math display">\[U_i^{(l)}(t) := U_{\text{rest}}\ \ \text{if}\ \ U_i^{(l)}(t) \geqU_{\text{threshold}}\]</span></p><p>这里 <span class="math inline">\(\Theta(\cdot)\)</span>表示阶跃函数，<span class="math inline">\(U_{\text{threshold}}\)</span>表示阈值电压，<span class="math inline">\(U_{\text{rest}}\)</span>表示静息电压。</p><p><strong>可视化</strong></p><p>如下图，假设 IF 神经元 15个时刻的输入信号大小为：<code>[0.2, 0, 0, 0, 0, 0.79, 0.02, 0, 0, 0, 0.9, 0, 0, 0, 0.09, 0.01]</code>：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2024-01-29-153442.png" style="zoom:50%;" /></p><p>膜电位在 <code>t = 6</code> 和 <code>t = 15</code>时达到阈值并迅速恢复到静息电位，同时神经元的后端突出释放尖峰。</p><h5 id="lif-神经元">LIF 神经元</h5><p>LIF（LeakyIntegrate-and-Fire）神经元是脉冲神经网络（SNNs）中的一个重要和常见的神经元模型。与最简单的IF（Integrate-and-Fire）神经元模型不同，LIF模型增加了对生物神经元电位衰减特性的模拟，使之更贴近真实的生物神经元行为。</p><p>其微分方程形式表示如下： <span class="math display">\[\tau_{\text{mem}} \frac{dU_{i}^{(l)}}{dt} = -(U_i^{(l)} -U_{\text{rest}}) + RI_{i}^{(l)}\]</span></p><p>其中 <span class="math inline">\(\tau_{\text{mem}}\)</span>是膜时间常数，它决定了膜电位因泄漏而衰减的速率。</p><p><strong>可视化</strong></p><p>如下图，假设 LIF 神经元 20个时刻的输入信号大小为：<code>[0.9, 0, 0, 0, 0.9, 0, 0, 0, 0.9, 0, 0.9, 0, 1.5, 0, 0, 0, 0, 0, 0, 1.5, 1.5]</code></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2024-01-29-154200.png" style="zoom:50%;" /></p><p>该 LIF 神经元在 <code>t = 20</code> 时被触发。</p><h4 id="前向传播">前向传播</h4><p>许多时序神经元在一起就组成了一个完整的 SNN网络模型，以尖峰组成的时序编码信息在不同神经元之间的<strong>突触（Synapse）</strong>上进行传播。如下图所示：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2024-01-29-155618.png" style="zoom:50%;" /></p><p>对于一个全连接网络而言，第 <span class="math inline">\(l + 1\)</span>层第 <span class="math inline">\(i\)</span> 个神经元而言，其 <spanclass="math inline">\(t\)</span> 时刻的输入电流大小满足： <spanclass="math display">\[I_i^{(l + 1)}(t) = \sum_j w_{ji} S_{j}^{(l)}(t) = \sum_{j \inE^{(l)}(t)} w_{ji}\]</span> 其中 <span class="math inline">\(w_{ji}\)</span>表示该神经元每个后突触的权重，<spanclass="math inline">\(E^{(l)}(t)\)</span> 表示 <spanclass="math inline">\(t\)</span> 时刻第 <spanclass="math inline">\(l\)</span> 层触发的神经元的集合。</p><h4 id="梯度替代">梯度替代</h4><p>在 SNN中，由于脉冲的二进制特性（神经元要么发射脉冲，要么不发射），这导致了神经元激活函数的不连续性，使得传统的梯度反向传播方法不适用。</p><p>为了解决这个问题，研究者们提出了<strong>“梯度替代”（SurrogateGradient）</strong>方法。这个方法的核心思想是用一个连续可微的函数来近似原本不连续的激活函数的导数。这个近似的函数被称为“替代梯度”或“伪梯度”。梯度替代的步骤通常包括：</p><ol type="1"><li><strong>前向传播</strong>：在网络的前向传播过程中，使用真实的脉冲激活函数。</li><li><strong>反向传播</strong>：在计算梯度并进行反向传播时，将不可微的激活函数替换为可微的替代梯度函数。</li><li><strong>参数更新</strong>：使用这些近似梯度来更新网络的参数。</li></ol><p>这种方法的一个常见例子是在 SNN 中使用 Heaviside阶跃函数作为激活函数，该函数在脉冲发射时是不可微的。为了进行梯度反向传播，研究者们可能会使用Sigmoid 函数或是带有平滑过渡的阶跃函数来近似 Heaviside 函数的导数。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2024-01-29-163009.png" style="zoom:67%;" /></p><h4 id="简单案例">简单案例</h4><p>接下来我们将使用 <ahref="https://spikingjelly.readthedocs.io/zh-cn/latest/#index-en">SpikingJelly框架</a> 实现一个 SNN 全连接识别 MNIST 手写数字的简单案例：</p><p><strong>导包</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn, optim<br><span class="hljs-keyword">from</span> torch.nn <span class="hljs-keyword">import</span> functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, transforms<br><span class="hljs-keyword">from</span> spikingjelly.activation_based <span class="hljs-keyword">import</span> neuron, encoding, surrogate, functional<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p><strong>模型定义</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">model = nn.Sequential(<br>    nn.Flatten(),<br>    nn.Linear(<span class="hljs-number">28</span> * <span class="hljs-number">28</span>, <span class="hljs-number">10</span>, bias=<span class="hljs-literal">False</span>),<br>    neuron.LIFNode(tau=<span class="hljs-number">2.0</span>, surrogate_function=surrogate.ATan())<br>)<br></code></pre></td></tr></table></figure><p>由于 SNN接收的信号是尖峰组成的时序编码，所以我们还需要一个编码器将静态的图片（<spanclass="math inline">\(C \times H \timesW\)</span>）转化为时序尖峰信号（<span class="math inline">\(T \times C\times H \times W\)</span>），这里我们使用<strong>泊松编码器（PoissonEncoder）</strong>。泊松编码器认为图像每个像素的尖峰发射事件服从泊松分布，其强度<span class="math inline">\(\lambda\)</span> 与像素强度相关。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">encoder = encoding.PoissonEncoder()<br></code></pre></td></tr></table></figure><p><strong>加载数据集</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">transform = transforms.Compose([transforms.ToTensor()])<br><br>train_set = datasets.MNIST(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transform)<br>val_set = datasets.MNIST(root=<span class="hljs-string">&#x27;./data&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=transform)<br><br>batch_size = <span class="hljs-number">64</span><br><br>train_loader = DataLoader(train_set, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>val_loader = DataLoader(val_set, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p><strong>训练</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs = <span class="hljs-number">16</span><br>T = <span class="hljs-number">32</span><br><br>device = <span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span><br>model.to(device=device)<br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">1e-3</span>)<br>criterion = nn.MSELoss()<br><br>train_loss_rec = []<br>train_acc_rec = []<br><br>val_loss_rec = []<br>val_acc_rec = []<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_epochs + <span class="hljs-number">1</span>):<br>    avg_loss = <span class="hljs-number">0</span><br>    avg_acc = <span class="hljs-number">0</span><br>    model.train()<br>    <span class="hljs-keyword">for</span> img, label <span class="hljs-keyword">in</span> tqdm(train_loader, desc=<span class="hljs-string">f&#x27;Training Epoch [<span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;num_epochs&#125;</span>]&#x27;</span>, unit=<span class="hljs-string">&#x27;batch&#x27;</span>):<br>        optimizer.zero_grad()<br>        img = img.to(device=device)<br>        label = label.to(device=device)<br>        fr_out = <span class="hljs-number">0.0</span><br>        <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):<br>            encoded_img = encoder(img)<br>            fr_out += model(encoded_img)<br>        fr_out /= T<br>        loss = criterion(fr_out, F.one_hot(label, <span class="hljs-number">10</span>).<span class="hljs-built_in">float</span>())<br>        loss.backward()<br>        optimizer.step()<br>        functional.reset_net(model)<br>        <br>        avg_loss += loss.data.item()<br>        acc = (torch.argmax(fr_out, dim=<span class="hljs-number">1</span>) == label).<span class="hljs-built_in">sum</span>() / label.size(<span class="hljs-number">0</span>)<br>        avg_acc += acc.data.item()    <br>    avg_loss /= <span class="hljs-built_in">len</span>(train_loader)<br>    avg_acc /= <span class="hljs-built_in">len</span>(train_loader)<br>    train_loss_rec.append(avg_loss)<br>    train_acc_rec.append(avg_acc)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Training Loss: <span class="hljs-subst">&#123;avg_loss :<span class="hljs-number">.4</span>&#125;</span>&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Training Accuracy: <span class="hljs-subst">&#123;avg_acc :<span class="hljs-number">.4</span>&#125;</span>&#x27;</span>)<br>    <br>    avg_loss = <span class="hljs-number">0</span><br>    avg_acc = <span class="hljs-number">0</span><br>    model.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> img, label <span class="hljs-keyword">in</span> val_loader:<br>            img = img.to(device=device)<br>            label = label.to(device=device)<br>            fr_out = <span class="hljs-number">0.0</span><br>            <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(T):<br>                encoded_img = encoder(img)<br>                fr_out += model(encoded_img)<br>            fr_out /= T<br>            functional.reset_net(model)<br>            loss = criterion(fr_out, F.one_hot(label, <span class="hljs-number">10</span>))<br>            avg_loss += loss.data.item()<br>            <br>            acc = (torch.argmax(fr_out, dim=<span class="hljs-number">1</span>) == label).<span class="hljs-built_in">sum</span>() / label.size(<span class="hljs-number">0</span>)<br>            avg_acc += acc.data.item()<br>        avg_loss /= <span class="hljs-built_in">len</span>(val_loader)<br>        avg_acc /= <span class="hljs-built_in">len</span>(val_loader)<br>        <br>        val_loss_rec.append(avg_loss)<br>        val_acc_rec.append(avg_acc)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Validation Loss: <span class="hljs-subst">&#123;avg_loss :<span class="hljs-number">.4</span>&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Validation Accuracy: <span class="hljs-subst">&#123;avg_acc :<span class="hljs-number">.4</span>&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>训练结果可视化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python">epoch_t = <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, num_epochs + <span class="hljs-number">1</span>)<br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>))<br>plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>plt.title(<span class="hljs-string">&#x27;Loss-Epoch&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Epoch&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Loss(MSE)&#x27;</span>)<br>plt.plot(epoch_t, train_loss_rec, label=<span class="hljs-string">&#x27;Training&#x27;</span>)<br>plt.plot(epoch_t, val_loss_rec, label=<span class="hljs-string">&#x27;Validation&#x27;</span>)<br>best_idx = torch.argmin(torch.tensor(val_loss_rec)).item()<br>plt.scatter(best_idx + <span class="hljs-number">1</span>, val_loss_rec[best_idx], color=<span class="hljs-string">&#x27;red&#x27;</span>, marker=<span class="hljs-string">&#x27;*&#x27;</span>)<br>plt.text(best_idx + <span class="hljs-number">1</span>, val_loss_rec[best_idx], <span class="hljs-string">f&#x27;epoch-<span class="hljs-subst">&#123;best_idx + <span class="hljs-number">1</span>&#125;</span>&#x27;</span>)<br>plt.legend()<br><br>plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>plt.title(<span class="hljs-string">&#x27;Accuracy-Epoch&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Epoch&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Accuracy&#x27;</span>)<br>plt.plot(epoch_t, train_acc_rec, label=<span class="hljs-string">&#x27;Training&#x27;</span>)<br>plt.plot(epoch_t, val_acc_rec, label=<span class="hljs-string">&#x27;Validation&#x27;</span>)<br>best_idx = torch.argmax(torch.tensor(val_acc_rec)).item()<br>plt.scatter(best_idx + <span class="hljs-number">1</span>, val_acc_rec[best_idx], color=<span class="hljs-string">&#x27;red&#x27;</span>, marker=<span class="hljs-string">&#x27;*&#x27;</span>)<br>plt.text(best_idx + <span class="hljs-number">1</span>, val_acc_rec[best_idx], <span class="hljs-string">f&#x27;epoch-<span class="hljs-subst">&#123;best_idx + <span class="hljs-number">1</span>&#125;</span>&#x27;</span>)<br>plt.legend()<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2024-01-29-165042.png" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>SNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层——MAC 子层</title>
    <link href="/2023/12/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94MAC-%E5%AD%90%E5%B1%82/"/>
    <url>/2023/12/11/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94MAC-%E5%AD%90%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h4 id="mac-子层">MAC 子层</h4><p><strong>什么是 MAC 子层？</strong></p><p><strong>MAC（Medium AccessControl）</strong>子层，是数据链路层的一部分，主要负责在物理介质上传输数据包。</p><p>在 OSI模型中，数据链路层被分为<strong>逻辑链路控制（LLC）子层</strong>和<strong>媒体访问控制（MAC）子层</strong>，其中：</p><p>LLC子层负责管理服务质量，例如<strong>流量控制</strong>和<strong>错误检测</strong>（不同于MAC层的错误检测）。这包括重发机制，以确保信息的正确传输等；而MAC 子层处理物理地址（MAC地址），用于在同一网络内识别设备，它负责封装数据，在数据包周围添加帧头和帧尾，包括源和目的地的物理地址。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-11-124316.png" style="zoom:50%;" /></p><p>总结来说，LLC 子层主要负责管理链路层与网络层之间的接口和服务质量，而MAC子层则集中于<strong>物理地址</strong>的处理、数据帧的封装和媒体访问控制。这种分层使得数据链路层可以灵活地支持多种不同类型的物理网络技术，同时为上层网络提供统一的接口和服务。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-054029.png" style="zoom:33%;" /></p><h3 id="媒体访问技术">媒体访问技术</h3><p>两类常见的媒体访问技术：</p><ul><li><p><strong>预约协议（Reservation Based Protocol）</strong></p><ul><li>需要知道网络的拓扑结构</li><li><strong>无冲突（Collision Free）</strong></li></ul><p>Eg：令牌环、TDMA</p></li><li><p><strong>争抢协议（Contension Based Protocol）</strong></p><ul><li>不需要知道网络的拓扑结构</li><li>各个节点会竞争资源，可能产生冲突</li></ul><p>Eg：ALOHA、CSMA</p></li></ul><h4 id="令牌环">令牌环</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-022815.png"  style="zoom:33%;" /></p><p>一种古老的技术，定义了一种短帧，称为<strong>令牌（Token）</strong>。令牌环网络的<strong>拓扑结构呈环状</strong>，所有计算机连接成一个闭合的环路。每台计算机都直接连接到环上，并通过物理介质（通常是双绞线或光纤）相互连接。在令牌环中令牌以固定速率在网络中沿着环路传递。只有拥有令牌的计算机才能发送数据，其他计算机必须等待令牌传递到它们之前才能发送。</p><ul><li>优点：不会产生冲突</li><li>缺点：一个节点失效会影响到整个信道</li></ul><h4 id="tdma">TDMA</h4><p>TDMA（Time Division MultipleAccess）技术将传输过程分成不同的<strong>时槽（TimeSlot）</strong>，每个时槽只允许一个用户传输信息。TDMA 在大多数 2G系统中使用。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-023632.png" style="zoom:50%;" /></p><ul><li><p>优点：和令牌环一样，TDMA 也能避免冲突</p></li><li><p>缺点：某个节点如果长期没有请求，则可能造成信道浪费</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-024129.png" style="zoom:50%;" /></p></li></ul><h4 id="aloha">ALOHA</h4><p>不同于令牌环和 TDMA，ALOHA 属于冲突协议，即每个节点会竞争资源。</p><h5 id="纯-aloha">纯 ALOHA</h5><p>纯 ALOHA 协议相当简单，它是一种<strong>无协商（Withoutcoordination）</strong>的协议，每个节点可以在任意时刻传输信息，如果在规定时间没有收到ACK，则重传该帧。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-025247.png" style="zoom:25%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-024716.png" style="zoom:33%;" /></p><p>想象一根总线拓扑结构，所有节点可以在任何时刻传输信息，则无可避免会产生冲突：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-024814.png" style="zoom:45%;" /></p><p>当两个不同的节点在同一时刻传输信息就会发生冲突，脆弱时间（VulnerableTime）等于 <span class="math inline">\(2 \times T_{fr}\)</span>，这里的<span class="math inline">\(T_{fr}\)</span> 指<strong>帧传递时间（Frametransmission time）</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-025130.png" style="zoom:45%;" /></p><h5 id="slotted-aloha">Slotted ALOHA</h5><p>时槽 ALOHA（Slotted ALOHA）就是在纯 ALOHA协议的基础上，把时间段分为许多等长的时槽，每一帧只允许在时槽的起始点开始传输，这么设计之后，所有的帧要么<strong>错开（Miss）</strong>，要么<strong>重合（Overlap）</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-025704.png" style="zoom:40%;" /></p><p>脆弱时间：<span class="math inline">\(T_0\)</span>，这里的 <spanclass="math inline">\(T_0\)</span> 指时槽的长度。</p><h4 id="csma">CSMA</h4><p>CSMA，全称 Carrier Sense Multiple Access，这里的 Carrir Sense指的就是监听信道，其基于一个假设，就是节点可以监听信道是否空闲。</p><h5 id="传统-csma">传统 CSMA</h5><ul><li>如果信道是<strong>空闲的（Idle）</strong>，节点会传输信息</li><li>如果信道是<strong>繁忙的（Busy）</strong>，节点则会一直等待直到信道空闲</li></ul><p>这是否意味着 CSMA就不会产生冲突呢？答案是否定的，如果两个节点恰巧在同一时刻传输帧，则会发生冲突：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-030457.png" style="zoom:50%;" /></p><p>和 ALOHA 一样，CSMA 通过 ACK确定是否发送冲突，如果节点在发送帧后未在指定时间内收到ACK，则确定为帧可能发生冲突或出错，则重传帧。</p><p>脆弱时间：<span class="math inline">\(\tau\)</span>，<spanclass="math inline">\(\tau\)</span> 在这里指传输时延。</p><p>CSMA 还可以分为两种类型：</p><ul><li><p><strong>非坚持 CSMA（Nonpersistant CSMA）</strong></p><p>在非坚持 CSMA中，如果节点检测到信道是繁忙的，则会<strong>随机等待</strong>一定的时间，然后重新监听信道。</p></li><li><p><strong>坚持 CSMA（Persistant CSMA）</strong></p><p>在坚持 CSMA中，如果节点检测到信道是繁忙的，则会一直监听信道直到信道变得空闲然后传输帧。</p><p>在坚持 CSMA 中，还可以细分两类：</p><ul><li><p><strong>1-坚持 CSMA（1-persistent CSMA）</strong></p><p>检测到信道空闲，则立马发送帧</p><blockquote><p>在<strong>低负载</strong>的情况下可以实现<strong>高吞吐量（Highthroughput）</strong>和<strong>低时延（Lowdelay）</strong>，而在高负载的情况下可能会造成低吞吐量，因为所有节点在信道空闲的时候都会争抢着发送帧，跟有可能造成冲突。</p></blockquote></li><li><p><strong>p-坚持 CSMA（p-persistant CSMA）</strong></p><p>检测到信道空闲，以概率 p（0 &lt; p &lt; 1）发送帧</p><blockquote><p>在高负载的情况下可以实现<strong>高吞吐量</strong>。但其在低时延的情况下可能会<strong>增大时延</strong>。</p></blockquote></li></ul></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-031427.png" style="zoom:40%;" /></p><h5 id="csmacd">CSMA/CD</h5><p>CSMA/CD（Carrier Sense Multiple Access with <strong>CollisionDetection</strong>），在 CSMA 的基础上添加了<strong>冲突检测（CollisionDetection）</strong>。</p><p>这是什么意思呢，就是说在 CSMA的基础上给了节点能够在传输过程中检测到冲突的能力，一旦检测到冲突，改节点会立刻舍弃此次传输。具体来说步骤如下：</p><ol type="1"><li>如果冲突被检测，则<strong>取消传输（Ceasetransmission）</strong>并且传输一个<strong>强化信号（Jamsignal）</strong>而不是传递完整个帧。</li><li>在发送强化信号之后，节点随机等待一段时间然后重新开始，这一步我们称为<strong>退避（Back-off）</strong>。</li><li>使用这个机制，可以节约时间和带宽。</li></ol><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-033702.png" style="zoom:33%;" /></p><p>CSMA/CD 最差情况下每个节点要多长时间检测到冲突：答案是 <spanclass="math inline">\(2 \times \tau\)</span>。</p><p>假设节点 A 和节点 B 是分布在总线上两端的两个节点，A在检测到信道空闲后发送帧，在即将到 B 时 B 也发送了一帧，此刻发送冲突，A需要两倍传输时延才能检测到冲突。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-033846.png" style="zoom:33%;" /></p><p><strong>指数退避（Exponential Back-off）</strong></p><p>在检测到冲突后，节点会退避并且重新等待一段随机时间。这里的随机时间是如何定义的呢？</p><p>我们定义 <span class="math inline">\(K = min\{10, \text{number ofattempt}\}\)</span>，每次退避时从区间 <span class="math inline">\([0, 2^ k)\)</span> 中随机选取一个整数作为退避系数 <spanclass="math inline">\(r\)</span>，退避时间 = <spanclass="math inline">\(r \hat t\)</span>，这里的 <spanclass="math inline">\(\hat t\)</span> 表示<strong>基本重传时间（Basicretransmission time）</strong>，一般是 51.2 <spanclass="math inline">\(\mu s\)</span>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-035337.png" style="zoom:45%;" /></p><p>在 16 次冲突后，改请求就会取消，这一帧会被舍弃。</p><p>完整流程：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-035445.png" style="zoom:33%;" /></p><h4 id="参考协议ieee-802">参考协议：IEEE 802</h4><p>IEEE 802 是一种包括了物理层和数据链路层的网络协议。不同的 IEEE 802子标准针对不同的局域网和城域网技术，如以太网、无线局域网（Wi-Fi）、WiMAX等，都基于这一模型进行规范和实现。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-053922.png" style="zoom:40%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-054244.png" alt="IEEE 802 Standards" style="zoom:33%;" /></p><h3 id="以太网">以太网</h3><p>以太网（Ethernet）是一种常见的局域网（LAN）技术，用于在计算机和网络设备之间进行数据通信。以太网起源于20 世纪 70 年代，是由 Xerox、Intel 和 Digital EquipmentCorporation（DEC）共同开发的，后来被广泛采用，并成为最常见的局域网技术之一。</p><p>以太网支持多种数据传输速度，包括10 Mbps（常称为10BASE-T）、100Mbps（100BASE-TX）、1 Gbps（1000BASE-T）和更高速度。IEEE802.3系列标准定义了以太网的规范，不同速度的以太网遵循不同的 IEEE 802.3子标准。</p><h4 id="nic">NIC</h4><p>网卡（Network InterfaceCard，NIC），是一种用于建立和管理计算机连接到设备，其包含了物理层和数据链路层（LLC与 MAC）的功能，每张网卡都有一个唯一的物理地址，称为 MAC 地址。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-063859.png" style="zoom:33%;" /></p><h5 id="mac-地址">MAC 地址</h5><p>每个 MAC 地址由 6 个字节组成，前 3 个字节表示供应商的标识符，后 3个字节表示供应商提供的序列号。</p><p>Eg：<code>1c:57:dc:68:23:0d</code></p><h4 id="传统以太网">传统以太网</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-064547.png" style="zoom:50%;" /></p><p><strong>拓扑结构</strong>：逻辑上都是总线型的。</p><p>传统以太网比如 10Base-T通过一个<strong>集线器（Hub）</strong>连接所有主机：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-064940.png" style="zoom:33%;" /></p><p>从上述结构可知，每一台主机发送的帧所有其他主机都可以接收，看上去拓扑结构是星型的，实际上还是总线型的。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-065428.png" style="zoom:50%;" /></p><p><strong>使用的媒体访问技术</strong>：CSMA/CD</p><p>传统以太网使用 CSMA/CD 作为媒体访问技术，更具体来说，使用的是1-persistent CSMA/CD 技术，这个前文已经说过，再次就不赘述了。</p><p><strong>以太网的数据帧</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-070426.png" style="zoom:67%;" /></p><ul><li><p>Preamble：前导码，用于<strong>时钟同步（Clocksynchronization）</strong>，SFD 用于标记帧的开始。</p></li><li><p>Address：包括目的地和出发地的 6 字节 MAC地址，由于以太网是广播链路传播，因此地址是必须的。</p><blockquote><p>如果 Destination address 的值为<code>FF:FF:FF:FF:FF:FF</code>，那就说明该帧是发送给全部节点的，所有计算机都会接收。</p></blockquote></li><li><p>Type：指定帧的类型，IPv4 或 IPv6。</p></li><li><p>Data and padding：数据和填充，这部分的大小在 46 字节到 1500字节。</p><blockquote><p>这部分至少 46 字节就是为了保证整个帧大小不小于64B，这么设计的目的就是让<strong>帧的传输时间不少于传输时延</strong>。否则CSMA/CD 有时候将无法检测到冲突。</p></blockquote></li><li><p>CRC：校错码。</p></li></ul><h4 id="交换以太网">交换以太网</h4><p>交换以太网在传统以太网的基础上将集线器改成了<strong>交换机（Switch）</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-071603.png" style="zoom:50%;" /></p><p>与传统的以太网集线器（Hub）不同，交换机能够根据数据帧中的目标 MAC地址，将数据帧有针对性地发送到正确的端口，而不是广播给所有连接设备。为了实现有针对性的数据帧交换，交换机维护一个MAC 地址表，记录了各个设备的 MAC地址与相应端口之间的映射关系。当数据帧到达交换机时，它会查找 MAC地址表以确定如何转发数据帧。</p><p>集线器（Hub）属于<strong>半双工通信</strong>，这是因为它在数据传输方面有一些限制和局限性。半双工通信意味着在同一时间内，设备只能进行单向的数据传输，要么发送数据，要么接收数据，而不能同时进行发送和接收。</p><p>相比之下，交换机（Switch）是一种支持<strong>全双工通信</strong>的设备，因为它具有智能的数据帧处理功能，可以在不同的端口之间建立虚拟电路，允许同时进行双向通信。交换机更高效、可靠，并且不容易发生碰撞，因此在现代网络中广泛使用，取代了集线器。集线器通常仅用于旧的网络中或特定的测试和诊断场景中。由于在交换机中不存在资源的争抢，也就<strong>不需要像CSMA/CD 这样的介质访问技术</strong>。</p><h4 id="快速以太网">快速以太网</h4><p>快速以太网（FastEthernet）是对传统以太网的升级，旨在提供更高的数据传输速度。</p><p>快速以太网支持 100 Mbps（兆位每秒）的数据传输速度，相对于传统以太网的10 Mbps 来说，它提供了更快的网络连接速度。因此，它通常被称为100BASE-T。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-072147.png" style="zoom:50%;" /></p><h4 id="gigabit-以太网">Gigabit 以太网</h4><p>Gigabit 以太网是一种高速的以太网技术，提供了 1 Gbps的传输速度，用于满足高带宽需求的各种应用，如企业网络、数据中心和多媒体传输。它是现代网络基础设施的关键组成部分，为快速和可靠的数据传输提供了支持。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-072747.png" style="zoom:55%;" /></p><h3 id="无线局域网">无线局域网</h3><p><strong>为什么 CSMA/CD 不适用于无线通信？</strong></p><p>CSMA/CD 不适用于无线通信是因为其可能产生两个问题：</p><ol type="1"><li><p><strong>隐藏基站问题（Hidden station problem）</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-050551.png" style="zoom:40%;" /></p><p>如上图所示，假设 A 要传输帧给 B，于此同时 C 也要传输帧给B，由于无线信号的范围覆盖问题，A 和 C 均不能接收到彼此的信号，因此 A 和C 都无法检测到 B 处发生了冲突。</p></li><li><p><strong>暴露基站问题（Exposed station problem）</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-050832.png" style="zoom:40%;" /></p><p>如上图所示，B 要传输帧给 A，C 要传输帧给 D，C 在发送帧时检测到与 B传输的帧发送冲突，于是便会立刻停止帧的传输。而事实上 C 传输帧给 D 不收到B 的影响，因为 B 的帧无法传输到 D，实际上不存在冲突问题。</p></li></ol><p>以上两种情况可以总结为在无线通信中<strong>检测不到冲突</strong>和<strong>错误判断了冲突</strong>。</p><h4 id="maca">MACA</h4><p>为了解决隐藏站的问题，人们提出了 MACA（Multiple Access<strong>CollisionAvoidance</strong>），不同于冲突检测，该技术强调冲突避免。</p><p>MACA 的具体是通过基站之间的握手机制实现的，步骤如下：</p><ol type="1"><li>若 S 要传递帧给 R，那么首先 S 会传输一个称为 RTS 的帧</li><li>终点 R 收到 RTS 后，会传输一个 CTS</li><li>S 接收到 CTS 后传输帧给 R</li><li>R 成功接受帧后返回 ACK 给 S</li></ol><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-053646.png" style="zoom:67%;" /></p><p><strong>具体流程</strong></p><ol type="1"><li>A 与 B 建立通信，发送 RTS，C 和 E 收到 RTS帧，接下来将保持沉默；</li><li>B 收到 A 传输的 RTS，返回一个 CTS，D 和 E 收到 CTS帧，接下来将保持沉默。</li></ol><p>MACA 为什么可以解决隐藏站的问题？</p><p>节点只收到 CTS，未收到 RTS：节点在接收节点 R 的范围内，不在发送节点 S的范围内，所以该节点是一个<strong>隐藏站</strong>，也就是说该节点在 S 到R 的传输过程将无法传输信息。如上图，D 是一个隐藏站，在 A 与 B通信的过程中会被沉默。</p><p>注意：MACA 无法解决暴露站的问题，如上图，C是一个暴露站，其通信是不受到影响的，但其错误判断可能会产生冲突从而造成信道浪费。</p><h4 id="lan-架构">LAN 架构</h4><p>LAN 架构主要可以分为以下两个部分：</p><ul><li><p><strong>接入点（Access Point，AP）</strong>：</p><p>AP是一种网络设备，通常是一个无线路由器或无线接入设备，用于创建一个无线局域网，比如<strong>基站</strong>。它允许无线设备（如笔记本电脑、智能手机、平板电脑）连接到有线局域网或互联网。AP负责将有线网络信号转换成无线信号，并为连接到它的无线设备提供网络连接。它通常有一个或多个无线接口（通常是Wi-Fi），以允许多个设备连接。</p></li><li><p><strong>基本服务集（Basic Service Set，BSS）</strong>：</p><p>BSS 是一个概念，用于描述一个无线局域网中的基本单元。每个 BSS 由一个AP（或无线路由器）和与之连接的无线设备组成。BSS通常包括一个无线网络的一个小覆盖区域，所有连接到同一个 AP的设备属于同一个 BSS。在同一个 BSS 内，设备可以相互通信。BSS还有一个唯一的标识符，称为 BSSID，通常是 AP 的 MAC地址，用于在网络中唯一标识一个 BSS。</p></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-123900.png" style="zoom:50%;" /></p><p><strong>Ad hoc</strong></p><p>Ad hoc，也就是自组织网络，是一种无线 LAN模式，其不依赖基站，这种网络只能通过节点的连接覆盖来将数据传输给其他节点，所有节点将自己组织成网络。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-124858.png" style="zoom:33%;" /></p><p><strong>寻找可用节点的两种方法</strong></p><ul><li><p><strong>被动扫描（Passive Scanning）</strong></p><p>被动扫描是一种相对较简单的方法，其中无线设备只是监听周围的 Wi-Fi信号，而不主动发送请求。它通常用于发现并显示附近可用的 Wi-Fi网络列表，以供用户选择连接。无线设备在特定时间间隔内监听 Wi-Fi信道上的信号帧，以检测是否有 AP 广播它们的<strong>信标帧（BeaconFrames）</strong>。这些信标帧包含有关 AP 的信息，如SSID（网络名称）、BSSID（AP的MAC地址）、信号强度等。一旦设备收到信标帧，它就可以在扫描结果中列出相应的Wi-Fi 网络，以便用户选择连接。</p></li><li><p><strong>主动扫描（Positive Scanning）</strong></p><p>主动扫描涉及到无线设备主动发送探测请求来查找附近的 Wi-Fi网络。这个请求通常是一个 802.11 探测请求帧（Probe RequestFrame），其中包含了设备想要连接的 SSID信息。接入点在收到探测请求后，可以响应并发送一个探测响应帧（ProbeResponseFrame），其中包含有关网络的信息，如支持的加密方法、信号强度、频道等。主动扫描允许设备更主动地发现附近的Wi-Fi网络，而不仅仅是等待信标帧的广播。这对于设备在新环境中快速连接到Wi-Fi 网络或在切换网络时非常有用。</p></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-19-004646.png" style="zoom:50%;" /></p><h4 id="csmaca">CSMA/CA</h4><p>CSMA/CA（Carrier Sense Multiple Access with <strong>CollisionAvoidance</strong>）是一种用于无线通信的可以避免冲突的载波监听多路访问技术。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-131413.png" style="zoom:50%;" /></p><p>工作流程：</p><ul><li><p>不同于 persistent CSMA，802.11 Sender不会在信道空闲的第一时刻发送数据，而是等待一个时间段 DIFS（DistributedInter-Frame Space）后发送数据。</p><p>如果检测到信道处于繁忙状态，则会随机等待一个退避时间。如果没有收到ACK应答，则认为产生了冲突或错误，此时会增大随机退避区间，这里的增加机制和CSMA/CD 是一样的。</p></li><li><p>同时，802.11 Receicer 在收到数据帧后会等待一个时间段 SIFS（ShortInter-Frame Space）后再传输 ACK。</p></li></ul><p>为了解决隐藏站和暴露站的问题，CSMA/CA 还可以使用 MACA 中的 RTS/CTS握手机制：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-132859.png" style="zoom:67%;" /></p><h4 id="帧结构">802.11 帧结构</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-16-133123.png" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据链路层</tag>
      
      <tag>媒体访问控制</tag>
      
      <tag>ALOHA</tag>
      
      <tag>CSMA</tag>
      
      <tag>以太网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程与并发</title>
    <link href="/2023/12/06/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/"/>
    <url>/2023/12/06/%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="线程">线程</h3><h4 id="线程与进程的关系">线程与进程的关系</h4><p><strong>回顾：什么是进程？</strong></p><p><strong>进程（Process）</strong>是程序运行的实例。一个进程由当前状态和<strong>系统资源</strong>组成。</p><ul><li><p><strong>当前状态（Current State）</strong></p><p>包括 CPU 寄存器、栈指针、PC 指针等。</p></li><li><p><strong>系统资源（System Resources）</strong></p><p>地址空间、I/O 状态等。</p></li></ul><p>每个进程的系统资源都是<strong>受到保护</strong>的。</p><p><strong>什么是线程？</strong></p><p><strong>线程（Thread）</strong>是进程中的<strong>顺序执行流（Sequentialexecutionstream）</strong>，进程的一组线程<strong>共用进程的系统资源</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-041608.png" alt="线程的生命周期" style="zoom:67%;" /></p><h4 id="多线程-tcb">多线程 &amp; TCB</h4><p><strong>多线程（Multithread）</strong>是一种技术，即一个程序的进程可以有多个不同的并发线程。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-033558.png" alt="单线程进程和多线程进程" style="zoom:67%;" /></p><p>就如进程会将其信息存储在 PCB中，每个线程也有一个维护自身信息的数据结构 —— <strong>TCB（ThreadControl Block）</strong></p><p>那些线程的私有状态会保存在 TCB 内，如：</p><ul><li><strong>CPU 寄存器（包括 PC 寄存器）</strong></li><li><strong>程序执行的栈指针（Execution stack pointer）</strong></li><li><strong>调度信息（包括状态、优先级、CPU 执行时间等）</strong></li><li>...</li></ul><p><strong>操作系统将 TCB存储在内核内存中</strong>，以便能够轻松地访问和管理所有线程的信息。这样，操作系统可以在需要时对线程进行调度、切换线程的上下文以及管理线程的状态等操作，而这些操作需要访问TCB 中存储的信息。</p><p>每个 PCB 都会指向多个 TCB：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-040955.png" style="zoom:50%;" /></p><p>线程切换可以分为两种：</p><ul><li><strong>在同一个 PCB 内（Within aPCB）</strong>，这种切换地址空间保持一致；</li><li><strong>在不同的 PCB 之间（AcrossPCBs）</strong>，这种切换需要改变地址空间。</li></ul><p><strong>多线程的优点</strong></p><ul><li>不同于进程的上下文切换，<strong>线程切换（ThreadSwitch）</strong>开销低很多；</li><li>线程的创建和取消都比进程快很多；</li><li>线程之间可以共享内存，更利于通信。</li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-042037.png" style="zoom:67%;" /></p><p><strong>多核操作系统中的线程</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-042159.png" style="zoom:55%;" /></p><p>多核操作系统中两种线程调度的方式：</p><ul><li><p>每个核维护自己的线程队列</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-042628.png" style="zoom:45%;" /></p><ul><li>需要更有效的高速缓存</li><li>需要平衡的调度策略</li></ul></li><li><p>所有线程都放置在一个单独的队列内</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-042702.png" alt="image-20231208122701523" style="zoom:50%;" /></p><ul><li>有可能会导致<strong>竞态条件</strong>，需要锁机制</li></ul></li></ul><blockquote><p><strong>处理器亲和性（ProcessorAffinity）</strong>是计算机操作系统中的一个概念，它用于指定一个进程或线程在多核处理器系统中执行时应该绑定到哪个特定的处理器核心上。<strong>处理器亲和性允许开发者或系统管理员控制进程或线程的执行位置</strong>，以优化性能、降低延迟或满足特定的系统需求。</p><p>亲和性有两种类型：<strong>软亲和性（SoftAffinity）</strong>和<strong>硬亲和性（Hard Affinity）</strong>。</p><ul><li>软亲和性是指系统<strong>尝试将进程/线程保持在同一个处理器上运行的策略</strong>，<strong>但不保证一定能够做到</strong>。例如，由于处理器之间的负载平衡，进程可能会迁移到其他处理器。</li><li>硬亲和性指的是某些系统提供的系统调用，<strong>允许进程指定一组处理器来运行</strong>。这意味着进程可以绑定在特定的处理器上，不会被系统迁移。</li></ul><p>许多系统同时提供这两种类型的亲和性设置。</p><ul><li><p>Linux系统中的 <code>sched_setaffinity()</code>是一个系统调用，用于实现硬亲和性。通过这个调用，进程可以指定一个或多个处理器，以便系统将其调度到这些处理器上运行。</p><p><code>sched_setaffinity()</code> 函数接受三个参数：</p><ol type="1"><li><code>pid_t pid</code> ：进程ID。如果该值为0，则表示当前进程。</li><li><code>size_t cpusetsize</code> ：<code>cpu_set_t</code>结构大小，通常为系统 CPU 数量的字节大小。</li><li><code>const cpu_set_t *mask</code> ：指向 <code>cpu_set_t</code>结构的指针，该结构定义了进程可以运行的 CPU 集合。使用 CPU集合，可以指定一个或多个 CPU 核心。</li></ol></li></ul></blockquote><h4 id="ult-klt">ULT &amp; KLT</h4><p>就像进程分为内核进程和用户进程一样，线程也有同样的分类：</p><ul><li><p><strong>内核级别线程（Kernel Level Thread，KLT）</strong></p><p>KLT是由操作系统内核管理和调度的线程。每个线程都有一个对应的内核线程。</p><ul><li>所有现代操作系统都支持 KLT</li><li>直接被内核控制</li><li><strong>每个 KLT 都能独立运行或者被阻塞</strong></li><li>一个进程可以有多个 KLT 在等待不同的事件</li><li>缺点<ul><li>相比于 ULT 更 “昂贵”，因为要经常和内核打交道</li></ul></li></ul></li><li><p><strong>用户级别线程（User Level Thread，ULT）</strong></p><p>ULT是在用户空间中由应用程序或线程库管理的线程。操作系统对它们一无所知，只会认为应用程序只有一个线程在运行。</p><ul><li><p>ULT 相比于 KLT 更加轻量级，用户的<strong>程序自身一般就能提供进ULT 的线程调度</strong>，由于不需要内核的参与，<strong>ULT的切换一般更快</strong></p></li><li><p>ULT在相对于彼此而言，可能会以<strong>非抢占（Non-preemptive）的方式</strong>进行调度</p></li><li><p>缺点：</p><ul><li><p>一个线程处于 I/O 阻断，所有线程都会被阻断（多对一模式）</p></li><li><p>内核无法干预 ULT 的调度，这意味着其不能利用多核处理器的优势</p><blockquote><p>由于操作系统对用户级线程一无所知，它无法将不同的 ULT分配给不同的处理器核心并进行并行执行。因此，无论多核处理器上有多少个核心，操作系统只会认为应用程序只有一个线程在运行。这限制了ULT 利用多核处理器的能力。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-045011.png" style="zoom:67%;" /></p></blockquote></li></ul></li></ul></li><li><p><strong>三种线程模式（Threading Model）</strong></p><ol type="1"><li><strong>一对一（One-to-One）</strong>：</li></ol><ul><li>在这个模型中，每个用户级线程都直接映射到一个内核级线程。</li><li>这种模型的优点是一个线程在执行系统调用或者进行阻塞操作时，不会影响到其他线程。</li><li>这是 Linux 和 Windows系统中常用的模型，它<strong>可以很好地利用多核处理器的并行处理能力</strong>。</li><li>但是，因为每个线程都需要内核级的结构，所以线程的数量<strong>可能受到系统资源的限制</strong>。</li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-31-035500.png" style="zoom:45%;" /></p><ol start="2" type="1"><li><strong>多对一（Many-to-One）</strong>：</li></ol><ul><li>在这个模型中，多个用户级线程映射到单个内核级线程。</li><li>优点是线程<strong>切换和管理的开销很小</strong>，因为这些操作都在用户空间完成。</li><li>缺点是<strong>如果任何一个线程执行阻塞系统调用，整个进程都会被阻塞</strong>，因为操作系统只看到一个线程。</li><li>这种模型不适合多核处理器，因为它无法同时在多个核心上并行执行多个线程。</li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-31-035404.png" style="zoom:45%;" /></p><ol start="3" type="1"><li><strong>多对多（Many-to-Many）</strong>：</li></ol><ul><li>这个模型结合了前两者的优点。</li><li>允许多个用户级线程映射到多个内核级线程，<strong>提供了很大的灵活性</strong>。</li><li>这种模型既可以防止一个线程的阻塞操作影响其他线程，也可以利用多核处理器的并行处理能力。</li><li>但是，这种<strong>模型的管理相对复杂</strong>，调度也更为困难，因为需要在用户和内核空间之间协调线程的管理。</li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-31-035524.png" style="zoom:45%;" /></p></li></ul><h4 id="线程交错">线程交错</h4><p><strong>线程交错（ThreadInterleaving）</strong>是指在多线程编程中，多个线程的执行在时间上交错进行的现象。当一个计算机系统具有多个处理核心（例如多核处理器）或者操作系统采用分时调度策略时，多个线程之间会竞争执行权，导致它们交替运行，这就是线程交错。</p><h3 id="并行与并发">并行与并发</h3><h4 id="二者区别">二者区别</h4><p><strong>并行（Parallelism）</strong>和<strong>并发（Concurrency）</strong>是两个在多任务处理领域常被讨论的概念，它们描述了系统处理多个任务的方式，但它们指的并不是相同的情形。</p><p><strong>并行（Parallelism）</strong>：</p><ul><li>并行处理指的是系统同时进行多个任务的能力。<strong>这通常涉及到多核或多处理器的系统</strong>，其中每个核或处理器可以同时执行不同的任务或同一个任务的不同部分。</li><li>并行性的关键在于性能的提升，因为它可以显著减少完成多个任务的总时间。</li><li>例如，在一个四核处理器上，四个独立的计算可以同时进行，每个核心处理一个计算。</li></ul><p><strong>并发（Concurrency）</strong>：</p><ul><li><strong>并发处理是指系统能够处理多个任务的能力，但不一定是同时进行的</strong>。在单核处理器上，操作系统可以通过任务切换，使得用户感觉到多个任务似乎是同时执行的。</li><li>并发性不一定提高性能（相对于单任务来说），而是关于多任务管理的效率。并发可以在单核或多核机器上实现。</li><li>例如，一个服务器运行多个进程，通过快速切换来服务多个客户端，即使在任何给定的微秒内，只有一个进程在执行。</li></ul><p>简而言之，<strong>并行</strong>是关于<strong>同时</strong>做多件事情（提高吞吐量），而<strong>并发</strong>是关于处理多件事情（管理共享资源的访问）。<strong>并行是并发的一个子集</strong>；所有并行系统都是并发的，但不是所有并发系统都是并行的。并发强调的是正确性和管理多个同时活动的任务，而并行强调的是性能和做相同的事情来加速计算。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-060714.png" style="zoom:67%;" /></p><h4 id="并发中的一些概念">并发中的一些概念</h4><h5 id="竞态条件">竞态条件</h5><p><strong>竞态条件（RaceCondition）</strong>是指一种在并发程序中的错误，它出现在当<strong>程序的结果依赖于线程的调度顺序的情况</strong>，其强调结果的不可预判性。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-061423.png" style="zoom:67%;" /></p><h5 id="互斥">互斥</h5><p><strong>互斥（MutualExclusion）</strong>指一个资源无法被多个线程共享，即一个线程在完成某个任务直到释放资源之前，其他进程都不能访问该资源。</p><h5 id="临界区">临界区</h5><p><strong>临界区（CriticalRegion）</strong>就是程序中需要<strong>互斥</strong>的部分。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-062041.png" style="zoom:50%;" /></p><p>为了实现临界区，操作系统会给一些资源分配<strong>锁（Lock）</strong>，当一个线程访问该资源时会拿到该资源的锁，此时其他线程均无法访问而被放置在一个<strong>入队列集合</strong>。</p><blockquote><p><strong>入队列集合（Entry SetQueue）</strong>是一个数据结构，用于存储等待获取锁的线程。每当一个线程尝试获取锁但锁已经被其他线程占用时，该线程会被加入到集合中，<strong>等待锁释放</strong>。</p></blockquote><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-062851.png" style="zoom:50%;" /></p><p>很多编程语言给了这个抽象概念的具体实现方式，比如 Java 中的<code>synchronized</code> 关键字。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-062935.png" style="zoom:67%;" /></p><h5 id="死锁">死锁</h5><p><strong>死锁（Deadlock）</strong>是指在多线程或多进程环境中，两个或多个线程（或进程）由于相互等待对方释放资源而陷入无法继续执行的状态。在死锁状态下，每个线程都在等待其他线程释放资源，但由于相互之间的依赖关系，它们都无法继续执行下去。死锁是一种常见的并发编程问题，可以导致系统停滞，无法正常运行。</p><p>死锁通常涉及以下几个<strong>关键要素</strong>：</p><ol type="1"><li><strong>互斥（MutualExclusion）</strong>：多个线程或进程竞争获取某个资源，但同一时刻只能有一个线程或进程占有资源。</li><li><strong>请求和保持（Hold andWait）</strong>：线程在持有某些资源的同时，又请求其他资源，但由于资源被其他线程占有，请求线程必须等待。</li><li><strong>不可抢占（NoPreemption）</strong>：资源只能由占有它的线程主动释放，而不能被强制抢占。</li><li><strong>循环等待（CircularWait）</strong>：多个线程之间形成了一个循环链，每个线程都在等待下一个线程释放资源，从而造成了死锁。</li></ol><p>以上四个条件是死锁的必要条件，缺一不可。</p><p><strong>分配图</strong></p><p><strong>分配图（AllocationGraph）</strong>是一种检测死锁的方式，分配图中一共有两类节点：一是线程，而是资源，如下图。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-084846.png" style="zoom:55%;" /></p><p>分配图中所有的边都是有向的：</p><ul><li>从线程指向资源的边称为<strong>请求边（RequestEdge）</strong>，表示线程正在请求某个资源。</li><li>从资源指向线程的边称为<strong>分配边（AssignmentEdge）</strong>，表示该资源正在被某个线程占有。</li></ul><p>再上图中，资源和线程形成了一个回环，产生了死锁，但并不是有回环就一定会有死锁。关于线程分配图中的回环与死锁之间的关系，有以下几点需要了解：</p><ul><li><p><strong>存在回环不一定意味着死锁</strong>：虽然死锁的一个典型特征是资源分配图中的回环，但并不是所有回环都表示死锁。关键在于这个回环是否包含了所有相关资源和线程。如果一个线程（或几个线程）在回环中，<strong>但是它们还可以访问其它资源来继续运行，那么这个回环就不一定代表死锁</strong>。</p><ul><li>如果都只有一个实例，那么回环意味着死锁</li><li>如果回环中的资源有很多个实例，那么就不意味着死锁</li></ul><p>如下图：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-090619.png" style="zoom:50%;" /></p><p>图中存在回环：<span class="math inline">\(T_1 \to R_1 \to T_3 \to R_2\to T_1\)</span>，但注意到 <span class="math inline">\(T_4\)</span>在这里没有请求，说明 <span class="math inline">\(T_4\)</span>可以正常运行，那么当 <span class="math inline">\(T_4\)</span> 运行结束后<span class="math inline">\(R_2\)</span> 会被释放，<spanclass="math inline">\(T_3\)</span> 便可以成功获得 <spanclass="math inline">\(R_2\)</span> 的请求，从而打破循环等待，所以不会产生死锁。</p></li><li><p><strong>没有回环通常意味着没有死锁</strong>：如果资源分配图中没有回环，那么一般可以认为系统中没有死锁。这是因为死锁的一个条件是循环等待，这在资源分配图中表现为回环。</p></li></ul><p>因此，线程资源分配图存在回环是产生死锁的<strong>必要不充分条件</strong>。</p><p><strong>如何避免死锁</strong></p><p>要避免死锁，就要从死锁产生的四个条件入手，只要破除四个条件中的任何一个就可以成功解决死锁的问题。</p><ul><li><p><strong>解决「互斥」</strong></p><p>一种解决方案是让资源可共享，这样就不会有互斥的需求。在某些情况下，这是可能的，例如，多个线程可以同时读取同一个只读文件，因为它们不会对文件内容进行修改，从而不会发生冲突。这个想法很理想，但多数时候不允许。</p></li><li><p><strong>解决「请求和保持」</strong></p><p>我们可以考虑一次性让一个线程拿到所有它请求的资源，阻断其他占取它资源的线程。这样也不现实，可能会导致每个线程在等待资源上浪费过多时间。</p></li><li><p><strong>解决「不可抢占」</strong></p><p>我们可以考虑运行线程抢占资源，从而打破循环请求。但这样又可能导致线程饥饿。</p></li><li><p><strong>解决「循环等待」</strong></p><p>我们可以定义一个严格的资源分配顺序，从而避免循环等待的情况。</p><p>例如我们可以给资源进行编号，要求每个线程以递增的枚举顺序请求资源来解决这个问题。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-08-092818.png" style="zoom:50%;" /></p><p>如上图所示，假如 <span class="math inline">\(i &lt;j\)</span>，那么线程 A 可以请求 <spanclass="math inline">\(j\)</span>，但线程 <spanclass="math inline">\(B\)</span> 无法请求 <spanclass="math inline">\(i\)</span>，从而避免了死锁。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>并发</tag>
      
      <tag>线程</tag>
      
      <tag>死锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于 Transfomer 的预训练模型 | GPT</title>
    <link href="/2023/12/03/Transfomer-%E5%AE%B6%E6%97%8F%E4%B9%8B-GPT/"/>
    <url>/2023/12/03/Transfomer-%E5%AE%B6%E6%97%8F%E4%B9%8B-GPT/</url>
    
    <content type="html"><![CDATA[<p>GPT（Generative Pre-trained Transformer）是一个由 OpenAI开发的先进的自然语言处理（NLP）模型，专门用于处理各种语言任务。它基于Transformer 架构，一种在 NLP 领域非常有效的深度学习模型结构。GPT模型在多种语言任务上表现出色，包括但不限于：文本生成、问答系统、机器翻译、文本摘要、感情分析等。</p><p>要注意的是，不同于 BERT，GPT是一个自回归模型，使用了监督学习的方式，进行从左到右的语言建模，因此 GPT在生成时只能查看之前的单词（单向上下文）。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-03-112129.png" style="zoom:40%;" /></p><h4 id="基本结构">基本结构</h4><p>由于 GPT 任务的特殊性，其只保留了 Transformer的解码器（Decoder），舍弃了编码器（Encoder）。所以如果能够理解Transformer，那么理解 GPT 模型自然也就不难了。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-03-114307.png" alt="GPT Decoder Layer 结构，删除了编码器-解码器注意力模块" style="zoom:35%;" /></p><p class="note note-info">Decoder层面的自注意力机制允许模型在生成每个新词时看到之前的所有词，这对于生成连贯的文本至关重要。而Encoder 部分是为了编码输入序列到一个固定长度的连续表征中，这在 GPT的预训练目标中并不是必要的。此外，省略 Encoder可以简化模型的结构，并专注于提高文本生成能力。</p><h4 id="两种文本生成策略">两种文本生成策略</h4><ol type="1"><li><strong>贪心解码</strong>：<ul><li>在每一步，模型选择概率最高的单词作为下一个单词。</li><li>这种方法<strong>速度快，计算成本低，但可能不是最佳选择</strong>，因为它不考虑整体句子的最佳组合，可能导致局部最优解。</li></ul></li><li><strong>集束搜索解码</strong>：<ul><li>在每一步保持多个可能的候选序列（称为 “集束” 或 “beam”）。</li><li>集束的宽度（Beam width）决定了在每一步有多少候选序列被考虑。</li><li><strong>集束搜索会在每个时间步骤考虑多个可能的继承候选，并在序列结束时选择整体得分最高的序列</strong>。</li><li>这种方法<strong>更能找到质量高的序列，但计算成本更高，速度也较慢</strong>。</li></ul></li></ol><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-03-120502.png" style="zoom:67%;" /></p><h4 id="代码实现">代码实现</h4><h5 id="gpt-decoder">GPT Decoder</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ...</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoderLayer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(DecoderLayer, self).__init__()<br>        self.self_attn = MultiHeadAttention()  <span class="hljs-comment"># 多头自注意力层</span><br>        self.feed_forward = FFN()  <span class="hljs-comment"># 位置前馈神经网络层</span><br>        self.norm1 = nn.LayerNorm(d_embedding)  <span class="hljs-comment"># 第一个层归一化</span><br>        self.norm2 = nn.LayerNorm(d_embedding)  <span class="hljs-comment"># 第二个层归一化</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, dec_inputs, attn_mask=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-comment"># 使用多头自注意力处理输入</span><br>        attn_output, _ = self.self_attn(dec_inputs, dec_inputs, dec_inputs, attn_mask)<br>        <span class="hljs-comment"># 将注意力输出与输入相加并进行第一个层归一化</span><br>        norm1_outputs = self.norm1(dec_inputs + attn_output)<br>        <span class="hljs-comment"># 将归一化后的输出输入到位置前馈神经网络</span><br>        ff_outputs = self.feed_forward(norm1_outputs)<br>        <span class="hljs-comment"># 将前馈神经网络输出与第一次归一化后的输出相加并进行第二个层归一化</span><br>        dec_outputs = self.norm2(norm1_outputs + ff_outputs)<br>        <span class="hljs-keyword">return</span> dec_outputs<br><br>n_layers = <span class="hljs-number">6</span>  <span class="hljs-comment"># 设置 Decoder 的层数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decoder</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, corpus</span>):<br>        <span class="hljs-built_in">super</span>(Decoder, self).__init__()<br>        self.src_emb = nn.Embedding(corpus.vocab_size, d_embedding)  <span class="hljs-comment"># 词嵌入层（参数为词典维度）</span><br>        self.pos_emb = nn.Embedding(corpus.seq_len, d_embedding)  <span class="hljs-comment"># 位置编码层（参数为序列长度）        </span><br>        self.layers = nn.ModuleList([DecoderLayer() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_layers)])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, dec_inputs</span>):        <br>        positions = torch.arange(<span class="hljs-built_in">len</span>(dec_inputs), device=dec_inputs.device).unsqueeze(-<span class="hljs-number">1</span>) <span class="hljs-comment"># 位置信息        </span><br>        inputs_embedding = self.src_emb(dec_inputs) + self.pos_emb(positions) <span class="hljs-comment"># 词嵌入与位置编码相加        </span><br>        attn_mask = get_attn_subsequent_mask(inputs_embedding).to(dec_inputs.device) <span class="hljs-comment"># 生成自注意力掩码</span><br>        dec_outputs =  inputs_embedding <span class="hljs-comment"># 初始化解码器输入，这是第一层解码器层的输入      </span><br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> self.layers:<br>            <span class="hljs-comment"># 每个解码器层接收前一层的输出作为输入，并生成新的输出</span><br>            <span class="hljs-comment"># 对于第一层解码器层，其输入是 dec_outputs，即词嵌入和位置编码的和</span><br>            <span class="hljs-comment"># 对于后续的解码器层，其输入是前一层解码器层的输出            </span><br>            dec_outputs = layer(dec_outputs, attn_mask) <span class="hljs-comment"># 将输入数据传递给解码器层</span><br>        <span class="hljs-keyword">return</span> dec_outputs <span class="hljs-comment"># 返回最后一个解码器层的输出，作为整个解码器的输出</span><br></code></pre></td></tr></table></figure><h5 id="文本生成">文本生成</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> nltk.tokenize <span class="hljs-keyword">import</span> word_tokenize <span class="hljs-comment"># 分词工具</span><br><br><span class="hljs-comment"># 贪心搜索</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_text_greedy_search</span>(<span class="hljs-params">model, input_str, max_len=<span class="hljs-number">5</span></span>):<br>    <span class="hljs-comment"># 将模型设置为评估（测试）模式，关闭 dropout 和 batch normalization 等训练相关的层</span><br>    model.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-comment"># 使用 NLTK 工具进行词汇切分</span><br>    input_str = word_tokenize(input_str)<br>    <span class="hljs-comment"># 将输入字符串中的每个 token 转换为其在词汇表中的索引, 如果输入的词不在词表里面，就忽略这个词</span><br>    input_tokens = [model.corpus.vocab[token] <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> input_str <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> model.corpus.vocab]<br>    <span class="hljs-comment"># 检查输入的有意义的词汇长度是否为 0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(input_tokens) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span>         <br>    <span class="hljs-comment"># 创建一个列表，用于存储生成的词汇</span><br>    output_tokens = input_tokens<br>    <span class="hljs-comment"># 禁用梯度计算，以节省内存并加速测试过程</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-comment"># 生成最多 max_len 个 tokens</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_len):<br>            <span class="hljs-comment"># 将当前生成的 tokens 转换为 torch 张量并将其传递给模型</span><br>            device = <span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span><br>            inputs = torch.LongTensor(output_tokens).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>            outputs = model(inputs)                <br>            <span class="hljs-comment"># 只关心最后一个时间步（即最新生成的 token）的 logits</span><br>            logits = outputs[:, -<span class="hljs-number">1</span>, :]<br>            <span class="hljs-comment"># 找到具有最高分数的 token</span><br>            _, next_token = torch.topk(logits, <span class="hljs-number">1</span>, dim=-<span class="hljs-number">1</span>)<br>            <span class="hljs-comment"># 如果生成的 token 是 EOS（结束符），则停止生成</span><br>            <span class="hljs-keyword">if</span> next_token.item() == model.corpus.vocab[<span class="hljs-string">&quot;&lt;eos&gt;&quot;</span>]:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-comment"># 否则，将生成的 token 添加到生成的词汇列表中</span><br>            output_tokens.append(next_token.item())<br>    <span class="hljs-comment"># 将输出 tokens 转换回文本字符串</span><br>    output_str = <span class="hljs-string">&quot; &quot;</span>.join([model.corpus.idx2word[token] <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> output_tokens])<br>    <span class="hljs-keyword">return</span> output_str<br><br><span class="hljs-comment"># 集束搜索</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_text_beam_search</span>(<span class="hljs-params">model, input_str, max_len=<span class="hljs-number">5</span>, beam_width=<span class="hljs-number">5</span>, repetition_penalty=<span class="hljs-number">1.2</span></span>):<br>    <span class="hljs-comment"># 将模型设置为评估（测试）模式，关闭 dropout 和 batch normalization 等训练相关的层</span><br>    model.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-comment"># 分词</span><br>    input_str = word_tokenize(input_str)<br>    <span class="hljs-comment"># 将输入字符串中的每个 token 转换为其在词汇表中的索引, 如果输入的词不再词表里面，就忽略这个词</span><br>    input_tokens = [model.corpus.vocab[token] <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> input_str <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> model.corpus.vocab]<br>    <span class="hljs-comment"># 检查输入的有意义的词汇长度是否为0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(input_tokens) == <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span>         <br>    <span class="hljs-comment"># 创建一个列表，用于存储候选序列，初始候选序列只包含输入 tokens</span><br>    candidates = [(input_tokens, <span class="hljs-number">0.0</span>)]    <br>    <span class="hljs-comment"># 创建一个列表，用于存储所有生成的序列及其得分</span><br>    final_results = []<br>    <span class="hljs-comment"># 禁用梯度计算，以节省内存并加速测试过程</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-comment"># 生成最多max_len个tokens</span><br>        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(max_len):<br>            <span class="hljs-comment"># 创建一个新的候选列表，用于存储当前时间步生成的候选序列</span><br>            new_candidates = []            <br>            <span class="hljs-comment"># 遍历当前候选序列</span><br>            <span class="hljs-keyword">for</span> candidate, candidate_score <span class="hljs-keyword">in</span> candidates:<br>                <span class="hljs-comment"># 将当前候选序列转换为 torch 张量并将其传递给模型</span><br>                device = <span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span><br>                inputs = torch.LongTensor(candidate).unsqueeze(<span class="hljs-number">0</span>).to(device)<br>                outputs = model(inputs)                <br>                <span class="hljs-comment"># 只关心最后一个时间步（即最新生成的token）的logits</span><br>                logits = outputs[:, -<span class="hljs-number">1</span>, :]<br>                <span class="hljs-comment"># 应用重复惩罚：为已经生成的词汇应用惩罚，降低它们再次被选择的概率</span><br>                <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> <span class="hljs-built_in">set</span>(candidate):<br>                    logits[<span class="hljs-number">0</span>, token] /= repetition_penalty<br>                <span class="hljs-comment"># 将 &lt;pad&gt; 标记的得分设置为一个很大的负数，以避免选择它</span><br>                logits[<span class="hljs-number">0</span>, model.corpus.vocab[<span class="hljs-string">&quot;&lt;pad&gt;&quot;</span>]] = -<span class="hljs-number">1e9</span>                <br>                <span class="hljs-comment"># 找到具有最高分数的前 beam_width 个 tokens</span><br>                scores, next_tokens = torch.topk(logits, beam_width, dim=-<span class="hljs-number">1</span>)<br>                <span class="hljs-comment"># 遍历生成的 tokens 及其得分</span><br>                <span class="hljs-keyword">for</span> score, next_token <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(scores.squeeze(), next_tokens.squeeze()):<br>                    <span class="hljs-comment"># 将生成的 token 添加到当前候选序列</span><br>                    new_candidate = candidate + [next_token.item()]                    <br>                    <span class="hljs-comment"># 更新候选序列得分</span><br>                    new_score = candidate_score - score.item()                    <br>                    <span class="hljs-comment"># 如果生成的 token 是 EOS（结束符），将其添加到最终结果中</span><br>                    <span class="hljs-keyword">if</span> next_token.item() == model.corpus.vocab[<span class="hljs-string">&quot;&lt;eos&gt;&quot;</span>]:<br>                        final_results.append((new_candidate, new_score))<br>                    <span class="hljs-keyword">else</span>:<br>                        <span class="hljs-comment"># 将新生成的候选序列添加到新候选列表中</span><br>                        new_candidates.append((new_candidate, new_score))<br>            <span class="hljs-comment"># 从新候选列表中选择得分最高的 beam_width 个序列</span><br>            candidates = <span class="hljs-built_in">sorted</span>(new_candidates, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)[:beam_width]<br>    <span class="hljs-comment"># 选择得分最高的候选序列，如果 final_results 为空，选择当前得分最高的候选序列</span><br>    <span class="hljs-keyword">if</span> final_results:<br>        best_candidate, _ = <span class="hljs-built_in">sorted</span>(final_results, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">else</span>:<br>        best_candidate, _ = <span class="hljs-built_in">sorted</span>(candidates, key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>])[<span class="hljs-number">0</span>]<br>    <span class="hljs-comment"># 将输出 token 转换回文本字符串</span><br>    output_str = <span class="hljs-string">&quot; &quot;</span>.join([model.corpus.idx2word[token] <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> best_candidate])<br>    <span class="hljs-keyword">return</span> output_str<br></code></pre></td></tr></table></figure><h5 id="gpt-完整实现">GPT 完整实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GPT</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, corpus</span>):<br>        <span class="hljs-built_in">super</span>(GPT, self).__init__()<br>        self.corpus = corpus<br>        self.decoder = Decoder(corpus) <span class="hljs-comment"># 解码器，用于学习文本生成能力</span><br>        self.projection = nn.Linear(d_embedding, corpus.vocab_size)  <span class="hljs-comment"># 全连接层，输出预测结果</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, dec_inputs</span>):        <br>        dec_outputs = self.decoder(dec_inputs) <span class="hljs-comment"># 将输入数据传递给解码器</span><br>        logits = self.projection(dec_outputs) <span class="hljs-comment"># 传递给全连接层以生成预测</span><br>        <span class="hljs-keyword">return</span> logits <span class="hljs-comment"># 返回预测结果</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">decode</span>(<span class="hljs-params">self, input_str, strategy=<span class="hljs-string">&#x27;greedy&#x27;</span>, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> strategy == <span class="hljs-string">&#x27;greedy&#x27;</span>: <span class="hljs-comment"># 贪心解码函数</span><br>            <span class="hljs-keyword">return</span> generate_text_greedy_search(self, input_str, **kwargs)<br>        <span class="hljs-keyword">elif</span> strategy == <span class="hljs-string">&#x27;beam_search&#x27;</span>: <span class="hljs-comment"># 集束解码函数</span><br>            <span class="hljs-keyword">return</span> generate_text_beam_search(self, input_str, **kwargs)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">f&quot;Unknown decoding strategy: <span class="hljs-subst">&#123;strategy&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="预训练一个轻量-gpt">预训练一个轻量 GPT</h4><h5 id="定义语料库类">定义语料库类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># WikiCorpus语料库类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WikiCorpus</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sentences, max_seq_len=<span class="hljs-number">256</span></span>):<br>        self.sentences = sentences<br>        self.seq_len = max_seq_len<br>        self.vocab = self.create_vocabularies()<br>        self.vocab_size = <span class="hljs-built_in">len</span>(self.vocab)<br>        self.idx2word = &#123;v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> self.vocab.items()&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_vocabularies</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># counter = Counter(word for sentence in self.sentences for word in sentence.split())</span><br>        <span class="hljs-comment"># vocab = &#123;&#x27;&lt;pad&gt;&#x27;: 0, &#x27;&lt;sos&gt;&#x27;: 1, &#x27;&lt;eos&gt;&#x27;: 2, **&#123;word: i+3 for i, word in enumerate(counter)&#125;&#125;</span><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;shared_vocab.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            vocab = &#123;line.split()[<span class="hljs-number">0</span>]: <span class="hljs-built_in">int</span>(line.split()[<span class="hljs-number">1</span>]) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f&#125;<br>        <span class="hljs-keyword">return</span> vocab   <br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_batch</span>(<span class="hljs-params">self, batch_size</span>):<br>        input_batch, target_batch = [], []<br><br>        <span class="hljs-comment"># 随机选择句子索引</span><br>        sentence_indices = torch.randperm(<span class="hljs-built_in">len</span>(self.sentences))[:batch_size]<br>        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> sentence_indices:<br>            sentence = self.sentences[index]<br>            words = sentence.split()[:self.seq_len - <span class="hljs-number">2</span>]  <span class="hljs-comment"># 截断句子,确保长度不超过 max_seq_len - 2（为了留出 &lt;sos&gt; 和 &lt;eos&gt;）</span><br>            seq = [self.vocab[<span class="hljs-string">&#x27;&lt;sos&gt;&#x27;</span>]] + [self.vocab[word] <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> words] + [self.vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]]<br><br>            <span class="hljs-comment"># 对序列进行填充</span><br>            seq += [self.vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]] * (self.seq_len - <span class="hljs-built_in">len</span>(seq))<br><br>            <span class="hljs-comment"># 将处理好的序列添加到批次中</span><br>            input_batch.append(seq[:-<span class="hljs-number">1</span>])<br>            target_batch.append(seq[<span class="hljs-number">1</span>:])<br><br>        <span class="hljs-comment"># 将批次转换为LongTensor类型</span><br>        input_batch = torch.LongTensor(input_batch)<br>        target_batch = torch.LongTensor(target_batch)<br><br>        <span class="hljs-keyword">return</span> input_batch, target_batch<br></code></pre></td></tr></table></figure><h5 id="训练类">训练类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trainer</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, model, corpus, batch_size=<span class="hljs-number">24</span>, learning_rate=<span class="hljs-number">0.01</span>, epochs=<span class="hljs-number">10</span>, device=<span class="hljs-literal">None</span></span>):<br>        self.model = model<br>        self.corpus = corpus<br>        self.vocab_size = corpus.vocab_size<br>        self.batch_size = batch_size<br>        self.lr = learning_rate<br>        self.epochs = epochs<br>        self.device = device <span class="hljs-keyword">or</span> (<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)        <br>        self.criterion = nn.CrossEntropyLoss(ignore_index=corpus.vocab[<span class="hljs-string">&quot;&lt;pad&gt;&quot;</span>])<br>        self.optimizer = optim.Adam(self.model.parameters(), self.lr)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self</span>):<br>        self.model.to(self.device)<br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(self.epochs):<br>            self.optimizer.zero_grad()<br>            dec_inputs, target_batch = self.corpus.make_batch(self.batch_size)<br>            dec_inputs, target_batch = dec_inputs.to(self.device), target_batch.to(self.device)<br>            outputs = self.model(dec_inputs)<br>            loss = self.criterion(outputs.view(-<span class="hljs-number">1</span>, self.corpus.vocab_size), target_batch.view(-<span class="hljs-number">1</span>))<br>            loss.backward()<br>            self.optimizer.step()<br></code></pre></td></tr></table></figure><h5 id="训练过程">训练过程</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> Utilities <span class="hljs-keyword">import</span> read_data<br><br><span class="hljs-comment"># 导入数据集    </span><br><span class="hljs-keyword">from</span> CorpusLoader <span class="hljs-keyword">import</span> WikiCorpus<br>corpus = WikiCorpus(read_data(<span class="hljs-string">&#x27;wikitext-103/wiki.train.txt&#x27;</span>)) <br><br><span class="hljs-comment"># 导入 GPT 模型</span><br><span class="hljs-keyword">from</span> GPT_Model_with_Decode <span class="hljs-keyword">import</span> GPT<br>WikiGPT = GPT(corpus)<br><span class="hljs-built_in">print</span>(WikiGPT) <span class="hljs-comment"># 打印模型架构</span><br><br><span class="hljs-comment"># 训练 GPT 模型</span><br><span class="hljs-keyword">from</span> ModelTrainer <span class="hljs-keyword">import</span> Trainer<br>trainer = Trainer(WikiGPT, corpus, learning_rate=<span class="hljs-number">0.01</span>, epochs = <span class="hljs-number">200</span>)<br>trainer.train()  <br><br><span class="hljs-keyword">import</span> datetime<br><span class="hljs-comment"># 获取当前时间戳</span><br>now = datetime.datetime.now()<br>timestamp = now.strftime(<span class="hljs-string">&quot;%Y%m%d_%H%M%S&quot;</span>)<br><br><span class="hljs-comment"># 保存模型</span><br><span class="hljs-keyword">import</span> torch<br>model_save_path = <span class="hljs-string">f&#x27;99_TrainedModel/WikiGPT_<span class="hljs-subst">&#123;trainer.lr&#125;</span>_<span class="hljs-subst">&#123;trainer.epochs&#125;</span>_<span class="hljs-subst">&#123;timestamp&#125;</span>.pth&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="从-gpt-到-chatgpt">从 GPT 到 ChatGPT</h4><p>GPT预训练模型是完整语言模型的基础。预训练模型通过在大量文本上学习语言的统计规律，来获得对语言的一般理解。这个阶段模型不专注于任何特定任务，只是学习如何预测文本中下一个单词的出现。</p><p>完成预训练后，模型可以用于各种特定的语言任务，如文本生成、翻译、问答等。为了在这些任务上表现得更好，模型通常会进行<strong>微调（Fine-tuning）</strong>，在特定任务的数据集上进一步训练，以适应特定的语言使用场景。预训练模型为这个过程提供了一个强大的起点，微调则根据特定任务进一步优化模型。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-03-122925.png" style="zoom:67%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-03-114144.png" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Transformer</tag>
      
      <tag>GPT</tag>
      
      <tag>LLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy 框架学习笔记</title>
    <link href="/2023/11/20/Scrapy%20%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/11/20/Scrapy%20%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Scrapy 是一个基于 Python 的快速的、高级别的 web 爬虫和 web抓取框架，旨在用于抓取 web 站点并从页面中提取结构化的数据。Scrapy可以应用于一系列的网路数据抓取任务，从信息提取、数据挖掘到监控和自动化测试。</p><p>以下是笔者根据<ahref="https://docs.scrapy.org/en/latest/">官方文档</a>和 B站上的教程写的一份学习笔记。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-20-075343.png"  style="zoom:40%;" /></p><hr /><h4 id="scrapy-核心组件">Scrapy 核心组件</h4><ul><li><strong>爬虫（Spiders）</strong>：这些是遍历网络收集数据的网络爬虫。它们向网站发送请求并解析响应。</li><li><strong>调度器（Scheduler）</strong>：此组件管理爬虫爬行网页的顺序。它安排爬虫发出的请求，通常使用算法来优先决定访问哪些页面。</li><li><strong>下载器（Downloader）</strong>：请求被调度后，发送给下载器，下载器从互联网上获取网页。下载器处理对网服务器的实际HTTP 请求。</li><li><strong>引擎（Engine）</strong>：引擎是系统的核心部分，协调整个过程。它控制系统组件之间的数据流动，并触发事件。</li><li><strong>中间件（Middleware）</strong>：中间件组件用于处理系统中传递的请求和响应。它们可以修改、丢弃或丰富请求和响应。例如，它们可以处理用户代理轮换、代理管理或内容转换等事宜。</li><li><strong>项目管道（ItemPipelines）</strong>：数据被爬取后，需要进行处理、清洗和存储。项目管道负责在爬虫提取数据后处理数据项。</li></ul><p>Scrapy 框架工作流：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-20-075950.png" style="zoom:67%;" /></p><ol type="1"><li><p>爬虫向引擎发送请求（1）。</p></li><li><p>引擎将请求发送给调度器（2）。</p></li><li><p>调度器将请求排队，然后发送回引擎（3）。</p></li><li><p>引擎再将请求发送至下载器（4）。</p></li><li><p>下载器从互联网获取数据，并将响应发送回引擎（5）。</p></li><li><p>引擎将响应发送给爬虫（6）。</p></li><li><p>爬虫处理响应并提取项目，这些项目被发送到项目管道（7）。</p></li><li><p>处理过的项目然后从项目管道发送到引擎（8），可能用于进一步处理或存储。</p></li></ol><h4 id="安装库并新建一个-scrapy-项目">安装库并新建一个 Scrapy 项目</h4><p><strong>安装 <code>scrapy</code> 库</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install scrapy<br></code></pre></td></tr></table></figure><p><strong>新建 Scrapy 项目</strong>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy startproject project_name<br></code></pre></td></tr></table></figure><p>使用 <code>scrapy startproject</code> 后就会在当前工作目录下新建一个Scrapy 项目，项目目录结构如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">project_name/<br>├── scrapy.cfg<br>└── project_name<br>    ├── __init__.py<br>    ├── items.py<br>    ├── middlewares.py<br>    ├── pipelines.py<br>    ├── settings.py<br>    └── spiders<br>        ├── __init__.py<br>        ├── spider1.py<br>        └── spider2.py<br></code></pre></td></tr></table></figure><p>这个结构图展示了一个典型的Scrapy项目的文件和目录层次，其中：</p><ul><li><code>scrapy.cfg</code> 是项目的部署配置文件。</li><li><code>myproject</code>文件夹是项目的Python模块，您的代码会在这里编写和组织。</li><li><code>items.py</code> 中定义了项目中的数据结构。</li><li><code>middlewares.py</code> 中定义了项目的中间件。</li><li><code>pipelines.py</code>中定义了项目的管道，用于处理抓取的数据。</li><li><code>settings.py</code> 包含了项目的设置。</li><li><code>spiders</code> 目录包含了所有爬虫相关的代码。</li></ul><p>在<code>spiders</code>目录下，每个文件代表了一个爬虫。您可以根据需要添加更多的爬虫文件。每个爬虫文件定义了一个<code>Spider</code>类，用于指定如何抓取网页和解析页面内容以提取数据。</p><h4 id="scrapy-命令行工具"><code>scrapy</code> 命令行工具</h4><p>除了上文提到的创建项目指令，Scrapy 还提供了一系列其他命令：</p><ul><li><p>在当前项目下创建一个新的 <code>Spider</code> ：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy genspider spider_name &#x27;example.com&#x27;<br></code></pre></td></tr></table></figure></p></li><li><p>运行当前项目下的某个 <code>Spider</code> ：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy crawl spider_name<br></code></pre></td></tr></table></figure></p></li><li><p>列出当前所有的 <code>Spider</code> ：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy list<br></code></pre></td></tr></table></figure></p></li><li><p>启动一个交互式的 Scrapy Shell，可以在这里尝试抓取数据</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy shell &#x27;http://example.com&#x27;<br></code></pre></td></tr></table></figure></p></li><li><p>下载一个网页并且显示在控制台上：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy fetch &#x27;http://example.com&#x27;<br></code></pre></td></tr></table></figure></p></li><li><p>在浏览器中打开一个网页，方便进行可视化调试</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy view &#x27;http://example.com&#x27;<br></code></pre></td></tr></table></figure></p></li><li><p>使用 <code>Spider</code>解析一个网页，这对于测试和调试爬虫非常有用</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy parse &#x27;http://example.com/page&#x27; --callback parse_item<br></code></pre></td></tr></table></figure></p><blockquote><p>这将使用 <code>parse_item</code> 方法来解析指定的 URL</p></blockquote></li></ul><h4 id="spider-类"><code>Spider</code> 类</h4><p>在 Scrapy 框架中，<code>Spider</code>类是定义如何抓取某个或某些网站的关键组成部分。这包括抓取的动作，例如：访问网站的哪些页面，如何进行跟进链接，以及如何从页面内容中提取结构化数据（即抓取什么数据）。每个<code>Spider</code> 都能处理一个或多个特定的网站或页面。</p><h5 id="基本属性">基本属性</h5><ul><li><code>name</code> ：识别 <code>Spider</code>的唯一名称。<strong>这个名称在项目中必须是唯一的</strong>，即不能为不同的<code>Spider</code> 设置相同的名字。</li><li><code>start_url</code> ：包含一个或多个 URL的列表，<code>Spider</code> 将从这些 URL 开始抓取数据。当没有指定特定的URL 时，<code>Spider</code> 将默认从这个列表中的 URL 开始进行抓取。</li><li><code>allowed_domains</code>：可选属性，包含一个域名的列表，用于指定 <code>Spider</code>可以抓取的域名。如果设置了这个属性，Spider将不会抓取这个列表以外的域名下的页面。</li></ul><h5 id="基本方法">基本方法</h5><ul><li><code>start_requests()</code>：此方法用于生成初始的请求。您可以重写这个方法来实现自定义的请求初始化。默认情况下，它生成<code>start_urls</code> 中定义的 URL 的请求。</li><li><code>parse()</code> ：<strong>当响应返回时，Scrapy下载器将响应作为参数传递给此方法</strong>。这是处理响应并提取数据的主要方法，或者进一步生成要跟踪的URL 的请求。</li></ul><h5 id="工作方式">工作方式</h5><ol type="1"><li><code>Spider</code> 在 <code>start_urls</code> 中指定的 URL开始抓取。</li><li>对每个起始 URL，Scrapy 生成 <code>Request</code> 对象，并将<code>parse</code> 方法作为回调函数指定。</li><li>当页面被下载后，Scrapy 引擎调用 <code>parse</code>方法处理响应。</li><li>在 <code>parse</code>方法内部，您可以使用响应对象来提取信息，或者查找新的 URL来创建新的请求（Scrapy 会处理这些请求，调用相应的回调）。</li><li>通常情况下，<code>parse</code> 方法将解析响应数据，提取信息并用<code>yield</code> 语句生成 <code>Item</code> 对象，或者生成新的<code>Request</code> 对象。</li></ol><h5 id="基本示例">基本示例</h5><p>爬取豆瓣电影排名前 250 的电影的名字和评分：</p><ol type="1"><li><p>创建项目：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy startproject Douban &amp;&amp; cd Douban<br></code></pre></td></tr></table></figure></p></li><li><p>编写 <code>item.py</code></p><p>爬虫获取到的数据需要组装成 <code>Item</code>对象，所以我们需要预先定义封装数据的 <code>Item</code> 对象：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieItem</span>(scrapy.Item):<br>    title = scrapy.Field()<br>    rating = scrapy.Field()<br></code></pre></td></tr></table></figure></p></li><li><p>创建并编写一个 <code>Spider</code> 来爬取电影：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy genspider Movie &#x27;Movie.douban.com&#x27;<br></code></pre></td></tr></table></figure></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy <span class="hljs-keyword">import</span> Selector, Request<br><span class="hljs-keyword">from</span> Douban.items <span class="hljs-keyword">import</span> MovieItem<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;Movie&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;movie.douban.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://movie.douban.com/top250&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        sel = Selector(response)<br>        list_items = sel.css(<span class="hljs-string">&#x27;#content &gt; div &gt; div.article &gt; ol &gt; li&#x27;</span>) <span class="hljs-comment"># 根据 Selector 进行捕获</span><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> list_items:<br>            movieItem = MovieItem()<br>            movieItem[<span class="hljs-string">&#x27;title&#x27;</span>] = item.css(<span class="hljs-string">&#x27;span.title::text&#x27;</span>).extract_first()<br>            movieItem[<span class="hljs-string">&#x27;rating&#x27;</span>] = item.css(<span class="hljs-string">&#x27;span.rating_num::text&#x27;</span>).extract_first()<br>            <br>            <span class="hljs-keyword">yield</span> movieItem<br>        <br>        hrefs_list = sel.css(<span class="hljs-string">&#x27;#content &gt; div &gt; div.article &gt; div.paginator &gt; a::attr(href)&#x27;</span>).extract() <span class="hljs-comment"># 获取底部其他页的链接</span><br>        next_pages = [response.urljoin(href) <span class="hljs-keyword">for</span> href <span class="hljs-keyword">in</span> hrefs_list <span class="hljs-keyword">if</span> href != <span class="hljs-string">&#x27;?start=0&amp;filter=&#x27;</span>]<br>        <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> next_pages:<br>            <span class="hljs-keyword">yield</span> Request(url=url)<br></code></pre></td></tr></table></figure></p><p>这里 <code>Selector</code>是一个非常重要的组件，我们传递响应作为参数可以初始化一个<code>Selector</code> 对象，其可以使用 XPath 或 CSS 表达式来选择 HTML 或XML 中的特定部分。</p></li><li><p>将抓取的数据保存：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy crawl Movie -o top250_movie.csv # 保存为 csv 格式<br>scrapy crawl Movie -o top250_movie.json # 保存为 json 格式<br>scrapy crawl Movie -o top250_movie.xml # 保存为 xml 格式<br></code></pre></td></tr></table></figure></p></li></ol><blockquote><p>另外一种 <code>Spider</code> 的定义方式，通过定义<code>start_requests()</code> 函数来获取到更多页面：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy <span class="hljs-keyword">import</span> Selector, Request<br><span class="hljs-keyword">from</span> Douban.items <span class="hljs-keyword">import</span> MovieItem<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MovieSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;Movie&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;movie.douban.com&quot;</span>]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_requests</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>            <span class="hljs-keyword">yield</span> Request(url=<span class="hljs-string">f&#x27;https://movie.douban.com/top250?start=<span class="hljs-subst">&#123;<span class="hljs-number">25</span> * page&#125;</span>&amp;filter=&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        sel = Selector(response)<br>        list_items = sel.css(<span class="hljs-string">&#x27;#content &gt; div &gt; div.article &gt; ol &gt; li&#x27;</span>) <span class="hljs-comment"># 根据 Selector 进行捕获</span><br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> list_items:<br>            movieItem = MovieItem()<br>            movieItem[<span class="hljs-string">&#x27;title&#x27;</span>] = item.css(<span class="hljs-string">&#x27;span.title::text&#x27;</span>).extract_first()<br>            movieItem[<span class="hljs-string">&#x27;rating&#x27;</span>] = item.css(<span class="hljs-string">&#x27;span.rating_num::text&#x27;</span>).extract_first()<br>            <br>            <span class="hljs-keyword">yield</span> movieItem<br></code></pre></td></tr></table></figure><p>这样定义可以避免同一个网页 URL相同而导致重复请求的情况，而且保证了请求的次序不被打乱。</p></blockquote><h5 id="定义多个回调函数">定义多个回调函数</h5><p>假设我们现在要请求 HTML网页列表的子链接的内容，并对子链接的网页进行爬取，那我们就需要定义多个回调函数。</p><p><strong>示例</strong>：</p><ol type="1"><li><p>分析chinaz.com网站行业网站页面结构（链接：https://top.chinaz.com/hangye/）</p></li><li><p>爬取每个行业分类下面的网站信息，包括网站标题、网站关键词、网站描述信息。</p></li><li><p>将爬取结果存取成 csv格式，每行的数据格式为：网站域名，网站行业分类、网站标题、网站关键词、网站描述信息</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Item 对象定义</span><br><br><span class="hljs-keyword">import</span> scrapy<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HangyeItem</span>(scrapy.Item):<br>    domain = scrapy.Field()<br>    web_class = scrapy.Field()<br>    title = scrapy.Field()<br>    key_words = scrapy.Field()<br>    description = scrapy.Field()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Spider 定义</span><br><br><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> scrapy <span class="hljs-keyword">import</span> Request, Selector<br><span class="hljs-keyword">from</span> ChinaZ.items <span class="hljs-keyword">import</span> HangyeItem<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HangyeSpider</span>(scrapy.Spider):<br>    name = <span class="hljs-string">&quot;Hangye&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;top.chinaz.com&quot;</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start_requests</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">yield</span> Request(url=<span class="hljs-string">&#x27;https://top.chinaz.com/hangye/index.html&#x27;</span>)<br>        <span class="hljs-keyword">for</span> page <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, <span class="hljs-number">1873</span>):<br>            <span class="hljs-keyword">yield</span> Request(url=<span class="hljs-string">f&#x27;https://top.chinaz.com/hangye/index_<span class="hljs-subst">&#123;page&#125;</span>.html&#x27;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse</span>(<span class="hljs-params">self, response</span>):<br>        sel = Selector(response)<br>        items_list = sel.css(<span class="hljs-string">&#x27;#content &gt; div.Wrapper.TopIndexCentWrap.pt10 &gt; div.TopListCent &gt; div.TopListCent-listWrap &gt; ul &gt; li.clearfix &gt; div.CentTxt&#x27;</span>)<br>        <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> items_list:<br>            title = item.css(<span class="hljs-string">&#x27;h3 &gt; a::text&#x27;</span>).extract_first()<br>            domain = item.css(<span class="hljs-string">&#x27;h3 &gt; span::text&#x27;</span>).extract_first()<br>            href = item.css(<span class="hljs-string">&#x27;h3 &gt; a::attr(href)&#x27;</span>).extract_first()<br><br>            <span class="hljs-keyword">yield</span> Request(url=response.urljoin(href), callback=self.parse_sublink, meta=&#123;<br>                <span class="hljs-string">&#x27;title&#x27;</span>: title,<br>                <span class="hljs-string">&#x27;domain&#x27;</span>: domain<br>            &#125;)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_sublink</span>(<span class="hljs-params">self, response</span>):<br>        hangyeItem = HangyeItem()<br>        hangyeItem[<span class="hljs-string">&#x27;title&#x27;</span>] = response.meta[<span class="hljs-string">&#x27;title&#x27;</span>]<br>        hangyeItem[<span class="hljs-string">&#x27;domain&#x27;</span>] = response.meta[<span class="hljs-string">&#x27;domain&#x27;</span>]<br>        sel = Selector(response)<br>        hangyeItem[<span class="hljs-string">&#x27;web_class&#x27;</span>] = <span class="hljs-string">&#x27;, &#x27;</span>.join(sel.css(<span class="hljs-string">&#x27;#content &gt; div.Wrapper.TopIndexCentWrap.pt10 &gt; div &gt; div.TopPageCent.clearfix &gt; div.TPageCent-TopMain.mt10.clearfix &gt; div &gt; div &gt; p:nth-child(1) &gt; a::text&#x27;</span>).getall())<br>        hangyeItem[<span class="hljs-string">&#x27;description&#x27;</span>] = sel.css(<span class="hljs-string">&#x27;#content &gt; div.Wrapper.TopIndexCentWrap.pt10 &gt; div &gt; div.TopPageCent.clearfix &gt; div.TPageCent-TMain01.mb40 &gt; div:nth-child(2) &gt; div.Centright.fr.SimSun &gt; p::text&#x27;</span>).extract_first()<br>        hangyeItem[<span class="hljs-string">&#x27;key_words&#x27;</span>] = <span class="hljs-string">&#x27;, &#x27;</span>.join(sel.css(<span class="hljs-string">&#x27;#content &gt; div.Wrapper.TopIndexCentWrap.pt10 &gt; div &gt; div.TopPageCent.clearfix &gt; div.clearfix.mb40 &gt; div.TPageCent-TMainmob.fl &gt; ul &gt; li:not(.ListHead) &gt; span.Lnone::text&#x27;</span>).getall())<br><br>        <span class="hljs-keyword">yield</span> hangyeItem<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy crawl Hangye -o cn_web_info.csv<br></code></pre></td></tr></table></figure><h4 id="数据管道">数据管道</h4><p>Scrapy 中的数据管道（DataPipeline）是用于处理从网页中提取出的数据的组件。它们提供了一个清晰的方式来处理、过滤和存储爬虫抓取的数据。</p><p>要在 Scrapy 项目中使用数据管道，你需要在 <code>settings.py</code>文件中启用并配置它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">ITEM_PIPELINES = &#123;<br>   <span class="hljs-string">&quot;MyProject.pipelines.MyProjectPipeline&quot;</span>: <span class="hljs-number">300</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个数据管道都是一个 Python 类，定义在 <code>pipelines.py</code>中，它实现了一个或多个方法，这个方法会被 Scrapy自动调用来处理每一个提取的项（Item）。</p><p>例如，将爬取到的数据保存到数据库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># setting.py</span><br><span class="hljs-comment"># ...</span><br><br>ITEM_PIPELINES = &#123;<br>   <span class="hljs-string">&quot;Douban.pipelines.DoubanPipeline&quot;</span>: <span class="hljs-number">300</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># piplines.py</span><br><br><span class="hljs-keyword">from</span> itemadapter <span class="hljs-keyword">import</span> ItemAdapter<br><span class="hljs-keyword">import</span> mysql.connector<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DoubanPipeline</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">try</span>:<br>            self.my_db = mysql.connector.connect(<br>                host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>                user=<span class="hljs-string">&#x27;root&#x27;</span>,<br>                passwd=<span class="hljs-string">&#x27;&#x27;</span>,<br>                database=<span class="hljs-string">&#x27;movie&#x27;</span><br>            )<br>            self.cs = self.my_db.cursor()<br>            self.cs.execute(<span class="hljs-string">&#x27;truncate table top250_mv&#x27;</span>)<br>        <span class="hljs-keyword">except</span> mysql.connector.Error <span class="hljs-keyword">as</span> err:<br>            <span class="hljs-built_in">print</span>(err)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_item</span>(<span class="hljs-params">self, item, spider</span>):<br>        mv_name, rating = item[<span class="hljs-string">&#x27;title&#x27;</span>], item[<span class="hljs-string">&#x27;rating&#x27;</span>]<br>        <span class="hljs-keyword">try</span>:<br>            self.cs.execute(<span class="hljs-string">&#x27;insert into top250_mv(name, rating) values(%s, %s)&#x27;</span>, (mv_name, rating))<br>            self.my_db.commit()<br>            <span class="hljs-keyword">return</span> item<br>        <span class="hljs-keyword">except</span> mysql.connector.Error <span class="hljs-keyword">as</span> err:<br>            <span class="hljs-built_in">print</span>(err)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">close_spider</span>(<span class="hljs-params">self, spider</span>):<br>        <span class="hljs-keyword">try</span>:<br>            self.cs.close()<br>            self.my_db.close()<br>        <span class="hljs-keyword">except</span> mysql.connector.Error <span class="hljs-keyword">as</span> err:<br>            <span class="hljs-built_in">print</span>(err)<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-20-124824.png" style="zoom:40%;" /></p><p><strong>设置多个管道</strong></p><p>在 Scrapy 的 <code>ITEM_PIPELINES</code> 设置中，数字（如上文例子中的<code>300</code>）表示该管道的优先级。Scrapy支持同时定义多个管道，并且通过这个优先级数字来决定各个管道的执行顺序。优先级的范围是从0 到 1000。</p><ul><li><p><strong>低数字表示高优先级</strong>：数字越小，管道的优先级越高。这意味着优先级数字较低的管道会先于优先级数字较高的管道处理Item。</p></li><li><p><strong>执行顺序</strong>：当一个 Item 被爬虫抓取并传递给 ItemPipeline 时，它会按照由低到高的优先级顺序经过每个激活的管道。</p></li></ul><p>例如，假设你有以下的设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">ITEM_PIPELINES = &#123;<br>    <span class="hljs-string">&#x27;MyProject.pipelines.MyFirstPipeline&#x27;</span>: <span class="hljs-number">300</span>,<br>    <span class="hljs-string">&#x27;MyProject.pipelines.MySecondPipeline&#x27;</span>: <span class="hljs-number">400</span>,<br>    <span class="hljs-string">&#x27;MyProject.pipelines.MyThirdPipeline&#x27;</span>: <span class="hljs-number">100</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyThirdPipeline</code>（优先级为 100）将首先处理Item，其次是 <code>MyFirstPipeline</code>（优先级为 300），最后是<code>MySecondPipeline</code>（优先级为 400）。</p><p>这种机制允许开发者灵活地控制不同管道处理 Item的顺序，这在进行复杂的数据处理时非常有用，例如，一个管道可能负责清洗数据，另一个管道可能负责将数据存储到数据库中。通过调整它们的优先级，可以确保数据在存储之前被正确地清洗。</p><h4 id="中间件的使用">中间件的使用</h4><p>Scrapy中的中间件是一种可插拔的组件，用于在请求和响应的处理过程中执行自定义的操作。在Scrapy 中有两种主要类型的中间件：<strong>下载器中间件（DownloaderMiddleware</strong>）和<strong>蜘蛛中间件（SpiderMiddleware）</strong>。</p><ul><li><p><strong>下载中间件</strong>：</p><p>下载器中间件用于处理 Scrapy 发出的 HTTP 请求和收到的 HTTP响应。它在请求从蜘蛛发送到服务器和响应从服务器返回到蜘蛛的过程中起作用。下载器中间件的常见用途包括：</p><ul><li>修改发出的请求：比如设置代理、添加或修改请求头、重定向请求等。</li><li>处理返回的响应：比如处理重定向或错误的响应、修改响应内容等。</li><li>处理请求异常：比如在连接错误或超时时重试请求。</li></ul><p><strong>主要方法</strong>：</p><ul><li><code>process_request(request, spider)</code>：在请求被发送到下载器之前调用。</li><li><code>process_response(request, response, spider)</code>：在下载器完成 HTTP 请求，返回响应之后调用。</li><li><code>process_exception(request, exception, spider)</code>：当下载处理过程中出现异常时调用。</li></ul><p>例如，写一个中间件修改所有的请求头：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDownloaderMiddleware</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_request</span>(<span class="hljs-params">self, request, spider</span>):<br>        request.headers[<span class="hljs-string">&#x27;User-Agent&#x27;</span>] = <span class="hljs-string">&#x27;My Custom User Agent&#x27;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># 返回 None 继续正常处理</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_response</span>(<span class="hljs-params">self, request, response, spider</span>):<br>        <span class="hljs-comment"># 可以在这里处理响应，例如检查状态码</span><br>        <span class="hljs-keyword">return</span> response  <span class="hljs-comment"># 必须返回 Response 对象</span><br></code></pre></td></tr></table></figure></p><blockquote><p>通常，我们可以在请求中间件内给请求加上 Cookie，从而获得某些权限。</p></blockquote></li><li><p><strong>蜘蛛中间件</strong>：</p><p>蜘蛛中间件用于处理蜘蛛的输入（响应）和输出（提取的项目和新的请求）。它主要在解析响应和生成提取项或进一步请求的过程中起作用。蜘蛛中间件的常见用途包括：</p><ul><li>修改或丢弃蜘蛛接收到的响应。</li><li>修改蜘蛛产生的提取项。</li><li>修改或丢弃蜘蛛产生的新的请求。</li></ul><p><strong>主要方法</strong>：</p><ul><li><code>process_spider_input(response, spider)</code>：在蜘蛛解析响应之前调用。</li><li><code>process_spider_output(response, result, spider)</code>：在蜘蛛解析响应并返回结果之后调用。</li><li><code>process_spider_exception(response, exception, spider)</code>：当解析过程中出现异常时调用。</li><li><code>process_start_requests(start_requests, spider)</code>：在蜘蛛开始发出初始请求时调用。</li></ul><p>例如，写一个中间件过滤掉某些响应：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MySpiderMiddleware</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_spider_input</span>(<span class="hljs-params">self, response, spider</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;不需要处理的条件&#x27;</span> <span class="hljs-keyword">in</span> response.text:<br>            <span class="hljs-keyword">raise</span> IgnoreRequest()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">process_spider_output</span>(<span class="hljs-params">self, response, result, spider</span>):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:<br>            <span class="hljs-keyword">yield</span> i<br></code></pre></td></tr></table></figure></p></li></ul><p>要启用中间，需要在 <code>settings.py</code> 中进行配置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">DOWNLOADER_MIDDLEWARES = &#123;<br>    <span class="hljs-string">&#x27;MyProject.middlewares.MyCustomDownloaderMiddleware&#x27;</span>: <span class="hljs-number">543</span>,<br>&#125;<br><br>SPIDER_MIDDLEWARES = &#123;<br>    <span class="hljs-string">&#x27;MyProject.middlewares.MyCustomSpiderMiddleware&#x27;</span>: <span class="hljs-number">543</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的数字表示中间件的优先级，数字越小优先级越高。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transfomer 框架 | 逐层剖析，从原理到代码</title>
    <link href="/2023/11/15/Transfomer%20%E6%A1%86%E6%9E%B6/"/>
    <url>/2023/11/15/Transfomer%20%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>本文是笔者根据 2017 年由 Google 的研究者发表的论文<ahref="https://arxiv.org/pdf/1706.03762.pdf">《Attention is all youneed》</a>与 <ahref="https://www.shenlanxueyuan.com/course/620">深蓝学院的 LLM 课程</a>总结的一份 Transformer 框架的技术文档。</p><p>Transformer是当下非常流行的深度学习模型，自从其提出来后，它迅速成为了许多 NLP任务的基础架构，比如机器翻译、文本摘要、情感分析和问答系统，大名鼎鼎的ChatGPT 系列其实也是基于 Transformer 模型构建的，后来 Transformer也被大量用于机器视觉的运用，例如 Non-local、ViT等等。总而言之，Transformer 是一款非常强大的模型。</p><hr /><h3 id="transfomer-整体结构">Transfomer 整体结构</h3><p>下图展示了 Transformer 的整体结构：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-02-030447.png" alt="《Attention is all you need》论文原图" style="zoom:67%;" /></p><h4 id="编码器-解码器">编码器 &amp; 解码器</h4><p>Transformer主要由两部分组成：即<strong>编码器（Encoder）</strong>和<strong>解码器（Decoder）</strong>。</p><ul><li><strong>编码器</strong>的作用是<strong>处理输入序列</strong>，将输入数据转换成一系列连续的表示形式，这些表示包含了输入数据的复杂内部结构信息。在处理自然语言任务时，这通常意味着将一句话或文档编码为一系列向量，每个向量对应输入序列中的一个元素（比如一个单词）。</li><li><strong>解码器</strong>的作用是<strong>基于编码器的输出以及之前已生成的输出，逐步生成目标序列</strong>。对于自然语言生成任务来说，解码器会一个接一个地生成词汇，直到产生结束符号为止。</li></ul><p>整体来看，编码器负责理解输入数据，将其转化为一系列高维的内部表示；解码器则负责将这些表示转换为意义明确的输出序列。两者协同工作。以机器翻译为例，以下展示了Transformer 的整体工作原理。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-080202.png" style="zoom:67%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-080230.png" style="zoom:67%;" /></p><h4 id="嵌入层-位置编码">嵌入层 &amp; 位置编码</h4><h5 id="嵌入层">嵌入层</h5><p><strong>嵌入层（Embedding Layer）</strong>是 Transformer输入的第一层，一般而言是通过某种特定的变换（比如 Word2Vec技术），将输入单词的 One-Hot编码转化为空间中连续的向量，其维度与模型维度 <spanclass="math inline">\(d_{model}\)</span> 一致。</p><p>通过这种方式，模型能够将离散的、符号化的输入转换为连续的向量，这些向量是神经网络能够处理的形式。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-081257.png" style="zoom:67%;" /></p><h5 id="位置编码">位置编码</h5><p><strong>位置编码（Positioning Encoding）</strong>是 Transformer模型中的一个关键创新，用于解决模型缺乏序列顺序信息的问题。因为Transformer不使用递归神经网络结构，所以需要某种机制来利用输入序列中单词的位置信息。</p><p>Transformer 的原始论文提供了一种使用三角函数的位置编码方案：</p><p>对于序列中的每个位置 <span class="math inline">\(pos\)</span>和维度索引 <span class="math inline">\(i\)</span> ，位置编码如下：</p><ul><li><p>对于偶数索引 <span class="math inline">\(2i\)</span> ： <spanclass="math display">\[  PE_{(pos, 2 i)} = sin(\frac{ {pos}}{10000 ^ {\frac{2i}{d_{model}}}})  \]</span></p></li><li><p>对于奇数索引 <span class="math inline">\(2i + 1\)</span> ： <spanclass="math display">\[  PE_{(pos, 2 i + 1)} = cos(\frac{pos}{10000 ^ {\frac{2i}{d_{model}}}})  \]</span></p></li></ul><p>这说明了对于不同维度的特征，其位置编码有不一样的频率。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-27-085731.png" style="zoom:67%;" /></p><blockquote>为什么使用正弦函数进行位置编码：<ol><li>正弦函数具有周期性，可以很好地捕获一些自然语言的周期性问题与重复出现的模式；</li><li>事实上在自然语言中，很多语法结构是重复出现的。</li></ol></blockquote><h4 id="注意力机制">注意力机制</h4><p>注意力机制是 Transformer的核心组件之一，其允许模型<strong>在处理序列的每个元素时动态地聚焦于序列中的其他部分</strong>，这种方式对于理解序列内各元素之间的复杂关系尤其有效。</p><h5 id="自注意力机制">自注意力机制</h5><p><strong>自注意力（Self-Attention）</strong>是一种特殊形式的注意力机制，使模型能够在处理序列的每一个元素时，考虑到序列中的所有元素。对于给定的输入序列，自注意力允许每一个输出在生成时加权引入输入序列中所有位置的信息。</p><p>在自注意力机制中，每一个输入会被映射到三个不同的向量，它们通常由学习得到的权重矩阵生成：</p><ul><li><p><strong>查询向量（Query）</strong> <span class="math display">\[  q_0 = x_0 W_{xq}  \]</span></p></li><li><p><strong>键向量（Key）</strong> <span class="math display">\[  k_0 = x_0 W_{xk}  \]</span></p></li><li><p><strong>值向量（Value）</strong> <span class="math display">\[  v_0 = x_0 W_{xv}  \]</span></p></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-082405.png" style="zoom:50%;" /></p><p>对于序列中的每一个元素，自注意力的计算过程可以分解为以下步骤：</p><ol type="1"><li><strong>点积计算</strong>：计算查询向量与键向量的点积，得到一个分数，表示该元素与序列中每个元素的兼容性或关联程度。</li><li><strong>缩放</strong>：通常将点积的结果除以一个缩放因子（通常是键向量维度的平方根），以避免梯度消失或爆炸。</li><li><strong>Softmax 归一化</strong>：应用 Softmax函数将这些分数转换为概率，用于确定每个元素应该赋予多少关注度。</li><li><strong>加权和</strong>：利用 Softmax的输出作为权重，结合值向量计算加权和，得到自注意力的输出。</li></ol><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-121404.png" style="zoom:67%;" /></p><p>如上图，计算出所有加权后，我们就可以计算出自注意力的输出： <spanclass="math display">\[\hat x_i = \sum_{j} \hat a_i ^ j v_j\]</span> 自注意力机制的矩阵表达： <span class="math display">\[Z = softmax(\frac{Q K ^ T}{\sqrt{d_k}}) V\]</span> 其中： <span class="math display">\[Q = [q_0 ^ T \ q_1 ^ T\ ... \ q_n ^ T] ^ T\]</span></p><p><span class="math display">\[K = [k_0 ^ T \ k_1 ^ T\ ... \ k_n ^ T] ^ T\]</span></p><p><span class="math display">\[V = [v_0 ^ T \ v_1 ^ T\ ... \ v_n ^ T] ^ T\]</span></p><p><span class="math display">\[Z = [\hat x_0 ^ T \ \hat x_1 ^ T\ ... \ \hat x_n ^ T] ^ T\]</span></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-085707.png" style="zoom:67%;" /></p><h5 id="多头注意力机制">多头注意力机制</h5><p><strong>多头注意力（Multi-HeadAttention）</strong>是将自注意力扩展为多个并行的头部。它允许模型在不同的子空间中并行地学习输入之间的不同表示。每个头部执行上述自注意力计算，但是会有不同的权重矩阵。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-090040.png" style="zoom:50%;" /></p><p>对于不同的权重矩阵 <spanclass="math inline">\(W_{xq}^{(i)}\)</span>、<spanclass="math inline">\(W_{xk}^{(i)}\)</span>、<spanclass="math inline">\(W_{xv}^{(i)}\)</span>，可以计算出不同的输出 <spanclass="math inline">\(Z_i\)</span> 。</p><p>假设我们有一共 8 个头部，即 24 个权重矩阵，则我们一共可以得到 8个输出。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-090638.png" style="zoom:50%;" /></p><p>接下来我们考虑将 8 个头部的输出矩阵进行拼接，然后右乘一个权重矩阵<span class="math inline">\(W_O\)</span> 即可得到最后的输出。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-090920.png" style="zoom:70%;" /><span class="math display">\[Z = [Z_0 \ Z_1 \ ... Z_7] W_O\]</span>通过这种方式，<strong>模型可以捕获数据在不同表示空间中的不同特征</strong>，<strong>并且可以在不同级别的抽象上理解信息</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-091320.png" alt="编码器中的多头注意力" style="zoom:67%;" /></p><p><strong>多头注意力机制的优势</strong></p><ol type="1"><li><strong>并行计算</strong>：注意力机制计算每个元素的输出时，不依赖于其他元素的输出，因此可以高效地并行处理。</li><li><strong>捕捉长距离依赖</strong>：自注意力可以直接计算序列内任意两个元素之间的交互，不受它们在序列中位置距离的影响，这对于捕捉长距离依赖关系非常有效。</li><li><strong>灵活的关注焦点</strong>：模型可以学习在不同的上下文中关注序列的不同部分，这种动态的关注机制对于理解和生成语言至关重要。</li></ol><h5 id="解码器中的多头注意力机制">解码器中的多头注意力机制</h5><ul><li><p><strong>添加掩码的多头注意力</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-100053.png"  style="zoom:67%;" /></p><p>Masked Multi-Head Attention是解码器（Decoder）部分的核心组件，它使得解码器能够在生成序列时只关注到当前位置之前的输出，而不是之后的输出，从而防止信息的提前泄露。</p><p>在具体操作中，解码器的每个时间步都会生成一个掩码（mask），用于屏蔽（maskout）那些不应被当前位置所“看到”的未来位置。然后在计算 Softmax函数前，这个掩码会被加到注意力对数分数上（即，对应未来位置的分数变成非常大的负数）。这样经过Softmax激活函数后，这些位置的注意力权重接近于零，确保模型不会考虑未来的单词。</p><p>举个简单的例子，假设在某一时间步，我们正在尝试生成一个句子的第三个词，MaskedAttention会确保注意力机制只会考虑第一个词和第二个词，而不是之后的词。掩码矩阵可能如下所示：</p><p><span class="math display">\[  \begin{bmatrix}      0 &amp; -\infty &amp; -\infty &amp; -\infty \\      0 &amp; 0 &amp; -\infty &amp; -\infty \\      0 &amp; 0 &amp; 0 &amp; -\infty \\      0 &amp; 0 &amp; 0 &amp; 0 \\  \end{bmatrix}  \]</span> 这个矩阵会与注意力对数分数相加，确保在进行 Softmax时，每一行的未来位置的权重都接近于零。</p></li><li><p><strong>编码器-解码器注意力</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-100934.png" style="zoom:67%;" /></p><p>编码器-解码器注意力层在解码器中扮演着关键角色，它允许解码器聚焦编码器的输出。<strong>这个注意力层作为桥梁将编码器的信息传递给解码器。解码器通过这个层来查看编码器的输出，并结合自身已生成的部分翻译来预测下一个单词。</strong></p><p>这一层的多头注意力机制使用<strong>解码器的输出作为查询（Query）</strong>，而将<strong>编码器的输出作为键（Key）和值（Value）</strong>。通过计算查询与键的相似度，得到一个注意力权重，然后用这个权权重来加权对应的值，生成这一层的输出。</p></li></ul><h4 id="层归一化与残差连接">层归一化与残差连接</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-091715.png" style="zoom:40%;" /></p><p>Transformer 架构中使用了<strong>层归一化（LayerNormalization）</strong>和<strong>残差连接（ResidualConnection）</strong>来促进深度网络的训练。这两种技术都是为了解决训练深层神经网络时常遇到的问题，比如梯度消失和梯度爆炸。</p><ul><li><p><strong>层归一化</strong></p><p>层归一化是一种在训练深度神经网络时常用的技术，其目的是稳定神经网络的学习过程。层归一化的工作原理是<strong>对单个样本的所有激活进行归一化</strong>，这和批量归一化（BatchNormalization）不同，后者是对同一层中不同样本的同一激活进行归一化。层归一化可以使得网络层的输出更加稳定。</p><p><strong>具体步骤</strong></p><p>对于一个具体的样本，在网络的每一层（通常在非线性激活函数前），层归一化按以下步骤进行：</p><ol type="1"><li>计算所有激活值 <span class="math inline">\(x_i\)</span> 的均值 <spanclass="math inline">\(\mu\)</span> 和方差 <spanclass="math inline">\(\sigma ^ 2\)</span></li><li>对每个 <span class="math inline">\(x_i\)</span> 进行归一化：<spanclass="math inline">\(x_i := \frac{x_i - \mu}{\sqrt{\sigma ^ 2 +\epsilon}}\)</span>（这里的 <spanclass="math inline">\(\epsilon\)</span>是一个很小的正实数，用于防止出现分母为 0 的情况）</li><li>应用可学习的参数 <span class="math inline">\(\gamma\)</span> 和<span class="math inline">\(\beta\)</span>来缩放和位移归一化后的值：<span class="math inline">\(x_i := \gamma x_i+ \beta\)</span></li></ol></li><li><p><strong>残差连接</strong></p><p>残差连接，也称作跳跃连接（SkipConnection），是指在网络的某一层上将输入直接加到该层的输出上。它允许梯度直接流过网络，这有助于训练过程中更有效地传播梯度，减轻梯度消失的问题。</p><p>在 Transformer 中，残差连接的数学表达式可以写为： <spanclass="math display">\[  Output = LayerNorm(Input + Sublayer(Input))  \]</span> 这里的 <span class="math inline">\(Sublayer()\)</span>指多头注意力层或者前馈神经网络层的输出。<spanclass="math inline">\(LayerNorm()\)</span>则表示层归一化。通过这种方式，即使网络非常深，输入信息也可以在网络中更远地传播。</p></li></ul><h4 id="前馈神经网络">前馈神经网络</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-102516.png" style="zoom:50%;" /></p><p><strong>前馈神经网络（Feed-ForwardNetwork，FFN）</strong>是每个编码器和解码器层的主要组成部分之一。</p><p>Transformer 中的 FNN 由两个全连接层组成，中间有一个 ReLU激活函数，数学表达式如下： <span class="math display">\[FNN(x) = max(0, xW_1 + b_1) W_2 + b_2\]</span> 前馈神经网络为 Transformer模型提供了非线性处理能力。<strong>虽然自注意力层非常擅长处理输入序列中元素之间的依赖关系，但它本质上是一个线性操作</strong>。前馈神经网络通过非线性变换，增加了模型的表达能力。</p><p>除了使用两个线性层，这里也可以使用两个一维卷积层实现同样的功能：<span class="math display">\[FFN(x) = max(0, x * w_1 + b_1) * w_2 + b_2\]</span></p><h3 id="代码实现">代码实现</h3><h4 id="组件一注意力机制">组件一：注意力机制</h4><h5 id="缩放点积注意力">缩放点积注意力</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br>d_k = <span class="hljs-number">64</span><br>d_v = <span class="hljs-number">64</span><br><span class="hljs-comment"># 向量维度</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScaledDotProductAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ScaledDotProductAttention, self).__init__()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, Q, K, V, attn_mask</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        Q(..., n_seq, d_k)</span><br><span class="hljs-string">        K(..., n_seq, d_k)</span><br><span class="hljs-string">        V(..., n_seq, d_v)</span><br><span class="hljs-string">        attn_mask(..., n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        scores = torch.matmul(Q, K.transpose(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>)) / d_k ** <span class="hljs-number">0.5</span><br>        scores.masked_fill_(attn_mask, -<span class="hljs-number">1e9</span>) <span class="hljs-comment"># 掩码机制</span><br>        <span class="hljs-comment"># scores(..., n_seq, n_seq)</span><br>        weights = torch.softmax(scores, dim=-<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># weights(..., n_seq, n_seq)</span><br>        context = torch.matmul(weights, V)<br>        <span class="hljs-comment"># context(..., n_seq, d_v)</span><br><br>        <span class="hljs-keyword">return</span> context, weights <span class="hljs-comment"># 返回上下文向量和注意力分数</span><br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        context(..., n_seq, d_v)</span><br><span class="hljs-string">        weights(..., n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h5 id="多头注意力">多头注意力</h5><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-27-081525.png" style="zoom:35%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> ScaledDotProductAttention <span class="hljs-keyword">import</span> *<br><br>d_embedding = <span class="hljs-number">512</span><br>n_heads = <span class="hljs-number">8</span><br>batch_size = <span class="hljs-number">3</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiHeadAttention</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MultiHeadAttention, self).__init__()<br>        self.W_Q = nn.Linear(d_embedding, d_k * n_heads)<br>        self.W_K = nn.Linear(d_embedding, d_k * n_heads)<br>        self.W_V = nn.Linear(d_embedding, d_v * n_heads)<br>        self.linear = nn.Linear(d_v * n_heads, d_embedding)<br>        self.layer_norm = nn.LayerNorm(d_embedding)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x1, x2, x3, attn_mask</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        x1, x2, x3(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">        attn_mask(batch_size, n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 对于自注意力而言，x1 == x2 == x3</span><br>        residual, batch_size = x1, x1.size(<span class="hljs-number">0</span>) <span class="hljs-comment"># 保留残差连接</span><br><br>        <span class="hljs-comment"># 拆分头</span><br>        q_s = self.W_Q(x1).view(batch_size, -<span class="hljs-number">1</span>, n_heads, d_k).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        k_s = self.W_K(x2).view(batch_size, -<span class="hljs-number">1</span>, n_heads, d_k).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        v_s = self.W_V(x3).view(batch_size, -<span class="hljs-number">1</span>, n_heads, d_k).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        W_Q(x1), W_K(x2) (batch_size, n_seq, d_k * n_heads)</span><br><span class="hljs-string">        q_s, k_s(batch_size, n_heads, n_seq, d_k)</span><br><span class="hljs-string">        W_V(x3) (batch_size, n_seq, d_v * n_heads)</span><br><span class="hljs-string">        v_s(batch_size, n_heads, n_seq, d_v)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br><br>        <span class="hljs-comment"># 将注意力掩码复制到多头 attn_mask</span><br>        attn_mask = attn_mask.unsqueeze(<span class="hljs-number">1</span>).repeat(<span class="hljs-number">1</span>, n_heads, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># attn_mask(batch_size, n_heads, n_seq, n_seq)</span><br><br>        <span class="hljs-comment"># 使用缩放点积注意力计算上下文向量和注意力权重</span><br>        context, weights = ScaledDotProductAttention()(q_s, k_s, v_s, attn_mask)<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        context(batch_size, n_heads, n_seq, d_v)</span><br><span class="hljs-string">        weights(batch_size, n_heads, n_seq, n_seq) </span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 拼接输出</span><br>        context = context.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>).contiguous().view(batch_size, -<span class="hljs-number">1</span>, n_heads * d_v)<br>        <span class="hljs-comment"># context(batch_size, n_seq, n_heads * d_v)</span><br><br>        <span class="hljs-comment"># 线性变换</span><br>        output = self.linear(context)<br>        <span class="hljs-comment"># output(batch_size, n_seq, d_embedding)</span><br><br>        <span class="hljs-comment"># 残差连接和层归一化</span><br>        output = self.layer_norm(output + residual)<br>        <span class="hljs-comment"># output(batch_size, n_seq, d_embedding)</span><br><br>        <span class="hljs-keyword">return</span> output, weights<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        output(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">        weights(batch_size, n_heads, n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="组件二前馈神经网络">组件二：前馈神经网络</h4><h5 id="使用线性全连接层">使用线性全连接层</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br>d_mid = <span class="hljs-number">2048</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FFN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(FFN, self).__init__()<br>        self.linear1 = nn.Linear(d_embedding, d_mid)<br>        self.linear2 = nn.Linear(d_mid, d_embedding)<br>        self.layer_norm = nn.LayerNorm(d_embedding)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs</span>):<br>        residual = inputs<br>        output = torch.relu(self.linear1(inputs))<br>        output = self.linear2(output)<br>        output = self.layer_norm(output + residual) <span class="hljs-comment"># 残差连接与层归一化</span><br><br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h5 id="使用一维卷积层">使用一维卷积层</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br>d_mid = <span class="hljs-number">2048</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FFN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(FFN, self).__init__()<br>        self.conv1 = nn.Conv1d(d_embedding, d_mid, kernel_size=<span class="hljs-number">1</span>)<br>        self.conv2 = nn.Conv1d(d_mid, d_embedding, kernel_size=<span class="hljs-number">1</span>)<br>        self.layer_norm = nn.LayerNorm(d_embedding)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, inputs</span>):<br>        residual = inputs<br>        output = torch.relu(self.conv1(inputs.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)))<br>        output = self.conv2(output).transpose(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>        output = self.layer_norm(output + residual)<br><br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure><h4 id="组件三正弦位置编码表">组件三：正弦位置编码表</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_sin_enc_table</span>(<span class="hljs-params">n_position, d_embedding</span>):<br>    sinusoid_table = torch.zeros(n_position, d_embedding, dtype=torch.float64)<br>    <span class="hljs-keyword">for</span> pos_i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_position):<br>        <span class="hljs-keyword">for</span> hid_j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(d_embedding):<br>            sinusoid_table[pos_i, hid_j] = pos_i / (<span class="hljs-number">10000</span> ** ((hid_j &amp; ~<span class="hljs-number">1</span>) / d_embedding))<br>    sinusoid_table[:, <span class="hljs-number">0</span>::<span class="hljs-number">2</span>] = torch.sin(sinusoid_table[:, <span class="hljs-number">0</span>::<span class="hljs-number">2</span>])<br>    sinusoid_table[:, <span class="hljs-number">1</span>::<span class="hljs-number">2</span>] = torch.cos(sinusoid_table[:, <span class="hljs-number">1</span>::<span class="hljs-number">2</span>])<br><br>    <span class="hljs-keyword">return</span> sinusoid_table<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    sinusoid_table(n_position, d_embedding)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="组件四填充位置掩码生成函数">组件四：填充位置掩码生成函数</h4><p>填充位置掩码是 Transformer中一种特殊的方法，用来防止对填充部分进行学习。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_attn_pad_mask</span>(<span class="hljs-params">seq_q, seq_k</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    len_q == len_k</span><br><span class="hljs-string">    seq_q(batch_size, n_seq)</span><br><span class="hljs-string">    seq_k(batch_size, n_seq)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    batch_size, len_q = seq_q.size()<br>    batch_size, len_k = seq_k.size()<br>    pad_attn_mask = seq_k.data.eq(<span class="hljs-number">0</span>).unsqueeze(<span class="hljs-number">1</span>) <span class="hljs-comment"># 因为在许多 NLP 任务中 0 被用作填充值</span><br>    <span class="hljs-comment"># pad_attn_mask(batch_size, 1, n_seq)</span><br>    pad_attn_mask = pad_attn_mask.expand(batch_size, len_q, len_k)<br><br>    <span class="hljs-keyword">return</span> pad_attn_mask<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    pad_attn_mask(batch_size, n_seq, n_seq)</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="组件五编码器">组件五：编码器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> MultiHeadAttention <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> FFN <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> functions <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderLayer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(EncoderLayer, self).__init__()<br>        self.enc_self_attn = MultiHeadAttention()<br>        self.ffn = FFN()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, enc_inputs, enc_self_attn_mask</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        enc_inputs(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">        enc_self_attn_mask(batch_size, n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        enc_outputs, attn_weights = self.enc_self_attn(enc_inputs, enc_inputs, enc_inputs, enc_self_attn_mask)<br>        enc_outputs = self.ffn(enc_outputs)<br><br>        <span class="hljs-keyword">return</span> enc_outputs, attn_weights<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        enc_outputs(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">        attn_weights(batch_size, n_heads, n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br><br><br>n_layers = <span class="hljs-number">6</span> <span class="hljs-comment"># EncoderLayer 的层数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Encoder</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, corpus</span>):<br>        <span class="hljs-built_in">super</span>(Encoder, self)<br>        self.src_emb = nn.Embedding(<span class="hljs-built_in">len</span>(corpus.src_vocab), d_embedding)<br>        self.pos_emb = nn.Embedding.from_pretrained(get_sin_enc_table(corpus.src_len + <span class="hljs-number">1</span>, d_embedding=d_embedding), freeze=<span class="hljs-literal">True</span>)<br>        self.layers = nn.ModuleList([EncoderLayer() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_layers)])<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, enc_inputs</span>):<br>        <span class="hljs-comment"># 生成位置编码并与词嵌入向量相加</span><br>        pos_indices = torch.arange(<span class="hljs-number">1</span>, enc_inputs.size(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>).unsqueeze(<span class="hljs-number">0</span>).to(enc_inputs)<br>        enc_outputs = self.src_emb(enc_inputs) + self.pos_emb(pos_indices)<br>        <span class="hljs-comment"># enc_outputs(batch_size, n_seq, d_embedding)</span><br><br>        enc_self_attn_mask = get_attn_pad_mask(enc_inputs, enc_inputs) <span class="hljs-comment"># 生成自注意力掩码</span><br>        <span class="hljs-comment"># enc_self_attn_mask(batch_size, n_seq, n_seq)</span><br><br>        enc_self_attn_weights = []<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> self.layers:<br>            enc_outputs, enc_self_attn_weight = layer(enc_outputs, enc_self_attn_mask)<br>            enc_self_attn_weights.append(enc_self_attn_weight)<br>            <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">            enc_outputs(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">            enc_self_attn_weight(batch_szie, n_heads, n_seq, n_seq)</span><br><span class="hljs-string">            &#x27;&#x27;&#x27;</span><br>        <br>        <span class="hljs-keyword">return</span> enc_outputs, enc_self_attn_weights <span class="hljs-comment"># 返回编码器输出和编码器注意力权重</span><br></code></pre></td></tr></table></figure><h4 id="组件六后续位置掩码">组件六：后续位置掩码</h4><p>前文已经提及，在序列生成任务中，解码器每个时间步都依赖于前面已生成的部分序列，后续位置掩码是为了防止当前位置依赖未来的信息。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-27-101137.png" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_attn_subsequent_mask</span>(<span class="hljs-params">seq</span>):<br>    attn_shape = [seq.size(<span class="hljs-number">0</span>), seq.size(<span class="hljs-number">1</span>), seq.size(<span class="hljs-number">1</span>)]<br>    subsequent_mask = torch.triu(torch.ones(attn_shape)).<span class="hljs-built_in">bool</span>()<br><br>    <span class="hljs-keyword">return</span> subsequent_mask<br></code></pre></td></tr></table></figure><h4 id="组件七解码器">组件七：解码器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> MultiHeadAttention <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> FFN <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> functions <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoderLayer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(DecoderLayer, self).__init__()<br>        self.dec_self_attn = MultiHeadAttention()<br>        self.dec_enc_attn = MultiHeadAttention()<br>        self.ffn = FFN()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, dec_inputs, enc_outputs, dec_self_attn_mask, dec_enc_attn_mask</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        dec_inputs, enc_outputs(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">        dec_self_attn_mask, dec_enc_attn_mask(batch_size, n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 多头自注意力层</span><br>        dec_outputs, dec_self_attn = self.dec_self_attn(dec_inputs, dec_inputs, dec_inputs, dec_self_attn_mask)<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        dec_outputs(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">        dec_self_attn(batch_size, n_heads, n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 编码器-解码器多头注意力层</span><br>        <span class="hljs-comment"># 解码器的第一层注意力输出生成 Q, 编码器的最终输出生成 K &amp; V</span><br>        dec_outputs, dec_enc_attn = self.dec_enc_attn(dec_outputs, enc_outputs, enc_outputs, dec_enc_attn_mask)<br>        dec_outputs = self.ffn(dec_outputs)<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        dec_outputs(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">        dec_enc_attn(batch_size, n_heads, n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br><br>        <span class="hljs-keyword">return</span> dec_outputs, dec_self_attn, dec_enc_attn<br><br><br>n_layers = <span class="hljs-number">6</span> <span class="hljs-comment"># DecoderLayer 的层数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Decoder</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, corpus</span>):<br>        <span class="hljs-built_in">super</span>(Decoder, self).__init__()<br>        self.tgt_emb = nn.Embedding(<span class="hljs-built_in">len</span>(corpus.tgt_vacab), d_embedding)<br>        self.pos_emb = nn.Embedding.from_pretrained(get_sin_enc_table(corpus.tgt_len + <span class="hljs-number">1</span>, d_embedding=d_embedding), freeze=<span class="hljs-literal">True</span>)<br>        self.layers = nn.ModuleList([DecoderLayer() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n_layers)])<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, dec_inputs, enc_inputs, enc_outputs</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        dec_inputs, enc_inputs, enc_outputs(batch_size, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># enc_inputs 在这里仅用于生成掩码</span><br>        pos_indices = torch.arange(<span class="hljs-number">1</span>, dec_inputs.size(<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>).unsqueeze(<span class="hljs-number">0</span>).to(dec_inputs)<br>        <span class="hljs-comment"># pos_indices(1, n_seq) -&gt; pos_emb(pos_indices) (1, n_seq, embedding)</span><br>        dec_outputs = self.tgt_emb(dec_inputs) + self.pos_emb(pos_indices)<br>        <span class="hljs-comment"># (batch_size, n_seq, d_embedding) + (1, n_seq, d_embedding) -&gt; dec_outputs(batch_size, n_seq, d_embedding)</span><br>        dec_self_attn_pad_mask = get_attn_pad_mask(dec_inputs, dec_inputs) <span class="hljs-comment"># 填充位掩码</span><br>        <span class="hljs-comment"># dec_self_attn_pad_mask(batch_size, n_seq, n_seq)</span><br>        dec_self_attn_subsequent_mask = get_attn_subsequent_mask(dec_inputs) <span class="hljs-comment"># 后续位掩码</span><br>        <span class="hljs-comment"># dec_self_attn_subsequent_mask(batch_size, n_seq, n_seq)</span><br>        dec_self_attn_mask = torch.gt(dec_self_attn_pad_mask + dec_self_attn_subsequent_mask, <span class="hljs-number">0</span>) <span class="hljs-comment"># 两掩码相加</span><br>        <span class="hljs-comment"># dec_self_attn_mask(batch_size, n_seq, n_seq)</span><br><br>        dec_enc_attn_mask = get_attn_pad_mask(dec_inputs, enc_inputs) <span class="hljs-comment"># 解码器-编码器掩码</span><br>        <span class="hljs-comment"># dec_enc_attn_mask(batch_size, n_seq, n_seq)</span><br><br>        dec_self_attns, dec_enc_attns = [], []<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> self.layers:<br>            dec_outputs, dec_self_attn, dec_enc_attn = layer(dec_outputs, enc_outputs, dec_self_attn_mask, dec_enc_attn_mask)<br>            <span class="hljs-comment"># dec_outputs(batch_size, n_seq, d_embedding)</span><br>            <span class="hljs-comment"># dec_self_attn, dec_enc_attn(batch_size, n_heads, n_seq, n_seq)</span><br>            dec_self_attns.append(dec_self_attn)<br>            dec_enc_attns.append(dec_enc_attn)<br>        <br>        <span class="hljs-keyword">return</span> dec_outputs, dec_self_attns, dec_enc_attns<br></code></pre></td></tr></table></figure><h4 id="完整组合">完整组合</h4><p>有了以上铺垫，我们就可以实现完整的 Transformer 框架了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> MultiHeadAttention <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> FFN <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> functions <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Encoder <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> Decoder <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Transformer</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, corpus</span>):<br>        <span class="hljs-built_in">super</span>(Transformer, self).__init__()<br>        self.encoder = Encoder(corpus=corpus) <span class="hljs-comment"># 编码器</span><br>        self.decoder = Decoder(corpus=corpus) <span class="hljs-comment"># 解码器</span><br>        self.proj = nn.Linear(d_embedding, <span class="hljs-built_in">len</span>(corpus.tgt_vacab), bias=<span class="hljs-literal">False</span>) <span class="hljs-comment"># 最后的全连接</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, enc_inputs, dec_inputs</span>):<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        enc_inputs, dec_inputs(batch_size, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 将输入传递给编码器, 获取编码器输出和自注意力权重</span><br>        enc_outputs, enc_self_attns = self.encoder(enc_inputs)<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        enc_outputs(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">        enc_self_attns(n_layers, batch_size, n_heads, n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 将解码器输入、编码器输入和编码器输出输入给解码器</span><br>        dec_outputs, dec_self_attns, dec_enc_attns = self.decoder(dec_inputs, enc_inputs, enc_outputs)<br>        <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">        dec_outputs(batch_size, n_seq, d_embedding)</span><br><span class="hljs-string">        dec_self_attns, dec_enc_attns(n_layers, n_heads, batch_size, n_seq, n_seq)</span><br><span class="hljs-string">        &#x27;&#x27;&#x27;</span><br>        <span class="hljs-comment"># 将解码器输出传递给最后的全连接层</span><br>        dec_logits = self.proj(dec_outputs)<br>        <span class="hljs-comment"># dec_logits(batch_size, n_seq, num_of_voc)</span><br><br>        <span class="hljs-keyword">return</span> dec_logits, enc_self_attns, dec_self_attns, dec_enc_attns<br></code></pre></td></tr></table></figure><h3 id="案例基于-transformer-的翻译器">案例：基于 Transformer的翻译器</h3><h4 id="定义语料库类">定义语料库类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter <span class="hljs-comment"># 导入 Counter 类</span><br><span class="hljs-keyword">import</span> jieba <span class="hljs-comment"># 使用 jieba 库分词</span><br><br><span class="hljs-comment"># 定义 TranslationCorpus 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TranslationCorpus</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, sentences</span>):<br>        self.sentences = sentences<br>        self.src_sen = [<span class="hljs-string">&#x27; &#x27;</span>.join(jieba.cut(sentence[<span class="hljs-number">0</span>])) <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> sentences] <span class="hljs-comment"># 中文句子库</span><br>        self.tgt_sen = [sentence[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> sentence <span class="hljs-keyword">in</span> sentences] <span class="hljs-comment"># 英文句子库</span><br>        <span class="hljs-comment"># 计算源语言和目标语言的最大句子长度，并分别加 1 和 2 以容纳填充符和特殊符号</span><br>        self.src_len = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(s.split()) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> self.src_sen) + <span class="hljs-number">1</span> <span class="hljs-comment"># 这里包括 &lt;pad&gt;</span><br>        self.tgt_len = <span class="hljs-built_in">max</span>(<span class="hljs-built_in">len</span>(s.split()) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> self.tgt_sen) + <span class="hljs-number">2</span> <span class="hljs-comment"># 这里包括 &lt;sos&gt;, &lt;eos&gt;</span><br>        <span class="hljs-comment"># 创建源语言和目标语言的词汇表</span><br>        self.src_vocab, self.tgt_vocab = self.create_vocabularies()<br>        <span class="hljs-comment"># 创建索引到单词的映射</span><br>        self.src_idx2word = &#123;v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> self.src_vocab.items()&#125;<br>        self.tgt_idx2word = &#123;v: k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> self.tgt_vocab.items()&#125;<br>    <br>    <span class="hljs-comment"># 创建词汇表的函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_vocabularies</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 统计源语言和目标语言的单词频率</span><br>        src_counter = Counter(w <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> self.src_sen <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> sen.split())<br>        tgt_counter = Counter(w <span class="hljs-keyword">for</span> sen <span class="hljs-keyword">in</span> self.tgt_sen <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> sen.split())<br>        <span class="hljs-comment"># 创建源语言和目标语言的词汇表，并为每个单词分配一个唯一的索引</span><br>        src_vocab = &#123;<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>: <span class="hljs-number">0</span>, **&#123;word: i + <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(src_counter)&#125;&#125;<br>        tgt_vocab = &#123;<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;&lt;sos&gt;&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>: <span class="hljs-number">2</span>, **&#123;word: i + <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> i, word <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(tgt_counter)&#125;&#125;<br>        <br>        <span class="hljs-keyword">return</span> src_vocab, tgt_vocab<br>    <span class="hljs-comment"># 创建批次数据的函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">make_batch</span>(<span class="hljs-params">self, batch_size, test_batch=<span class="hljs-literal">False</span></span>):<br>        input_batch, output_batch, target_batch = [], [], []<br>        <span class="hljs-comment"># 随机选择句子索引</span><br>        sentence_indices = torch.randperm(<span class="hljs-built_in">len</span>(self.sentences))[:batch_size]<br>        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> sentence_indices:<br>            src_sentence, tgt_sentence = self.src_sen[index], self.tgt_sen[index]<br>            <span class="hljs-comment"># 将源语言和目标语言的句子转换为索引序列</span><br>            src_seq = [self.src_vocab[word] <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> src_sentence.split()]<br>            tgt_seq = [self.tgt_vocab[<span class="hljs-string">&#x27;&lt;sos&gt;&#x27;</span>]] + [self.tgt_vocab[word] <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> tgt_sentence.split()] + [self.tgt_vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]]            <br>            <span class="hljs-comment"># 对源语言和目标语言的序列进行填充</span><br>            src_seq += [self.src_vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]] * (self.src_len - <span class="hljs-built_in">len</span>(src_seq))<br>            tgt_seq += [self.tgt_vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]] * (self.tgt_len - <span class="hljs-built_in">len</span>(tgt_seq))            <br>            <span class="hljs-comment"># 将处理好的序列添加到批次中</span><br>            input_batch.append(src_seq)<br>            output_batch.append([self.tgt_vocab[<span class="hljs-string">&#x27;&lt;sos&gt;&#x27;</span>]] + ([self.tgt_vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]] * (self.tgt_len - <span class="hljs-number">2</span>)) <span class="hljs-keyword">if</span> test_batch <span class="hljs-keyword">else</span> tgt_seq[:-<span class="hljs-number">1</span>])<br>            target_batch.append(tgt_seq[<span class="hljs-number">1</span>:])        <br>        <span class="hljs-comment"># 将批次转换为 LongTensor 类型</span><br>        input_batch = torch.LongTensor(input_batch)<br>        output_batch = torch.LongTensor(output_batch)<br>        target_batch = torch.LongTensor(target_batch)<br><br>        <span class="hljs-keyword">return</span> input_batch, output_batch, target_batch<br></code></pre></td></tr></table></figure><h4 id="训练">训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 准备一些中译英语料</span><br>sentences = [<br>    [<span class="hljs-string">&#x27;我&#x27;</span>, <span class="hljs-string">&#x27;I&#x27;</span>],<br>    [<span class="hljs-string">&#x27;我是&#x27;</span>, <span class="hljs-string">&#x27;I am&#x27;</span>],<br>    [<span class="hljs-string">&#x27;中国人&#x27;</span>, <span class="hljs-string">&#x27;Chinese&#x27;</span>],<br>    [<span class="hljs-string">&#x27;美国人&#x27;</span>, <span class="hljs-string">&#x27;American&#x27;</span>],<br>    [<span class="hljs-string">&#x27;苹果&#x27;</span>, <span class="hljs-string">&#x27;apples&#x27;</span>],<br>    [<span class="hljs-string">&#x27;香蕉&#x27;</span>, <span class="hljs-string">&#x27;bananas&#x27;</span>],<br>    [<span class="hljs-string">&#x27;菠萝&#x27;</span>, <span class="hljs-string">&#x27;pineapples&#x27;</span>],<br>    [<span class="hljs-string">&#x27;我和中国人&#x27;</span>, <span class="hljs-string">&#x27;Chinese and I&#x27;</span>],<br>    [<span class="hljs-string">&#x27;我和美国人&#x27;</span>, <span class="hljs-string">&#x27;American and I&#x27;</span>],<br>    [<span class="hljs-string">&#x27;中国人和美国人&#x27;</span>, <span class="hljs-string">&#x27;Chinese and American&#x27;</span>],<br>    [<span class="hljs-string">&#x27;美国人喜欢苹果&#x27;</span>, <span class="hljs-string">&#x27;American like apples&#x27;</span>],<br>    [<span class="hljs-string">&#x27;中国人喜欢菠萝&#x27;</span>, <span class="hljs-string">&#x27;Chinese like pineapples&#x27;</span>],<br>    [<span class="hljs-string">&#x27;我是中国人&#x27;</span>, <span class="hljs-string">&#x27;I am Chinese&#x27;</span>],<br>    [<span class="hljs-string">&#x27;我是美国人&#x27;</span>, <span class="hljs-string">&#x27;I am American&#x27;</span>],<br>    [<span class="hljs-string">&#x27;我喜欢苹果&#x27;</span>, <span class="hljs-string">&#x27;I like apples&#x27;</span>],<br>    [<span class="hljs-string">&#x27;我喜欢香蕉&#x27;</span>, <span class="hljs-string">&#x27;I like bananas&#x27;</span>],<br>    [<span class="hljs-string">&#x27;我喜欢菠萝&#x27;</span>, <span class="hljs-string">&#x27;I like pineapples&#x27;</span>]<br>]<br>corpus = TranslationCorpus(sentences) <span class="hljs-comment"># 创建语料库类实例</span><br><br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim <span class="hljs-comment"># 导入优化器</span><br>device = <span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span><br>model = Transformer(corpus).to(device) <span class="hljs-comment"># 创建模型实例</span><br>criterion = nn.CrossEntropyLoss() <span class="hljs-comment"># 损失函数</span><br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">0.0001</span>) <span class="hljs-comment"># 优化器</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>): <span class="hljs-comment"># 训练 100 轮</span><br>    optimizer.zero_grad() <span class="hljs-comment"># 梯度清零</span><br>    <span class="hljs-comment"># Generate a batch of input, output, and target sequences</span><br>    enc_inputs, dec_inputs, target_batch = corpus.make_batch(batch_size) <span class="hljs-comment"># 创建训练数据        </span><br>    enc_inputs, dec_inputs, target_batch = enc_inputs.to(device), dec_inputs.to(device), target_batch.to(device)<br>    outputs, _, _, _ = model(enc_inputs, dec_inputs) <span class="hljs-comment"># 获取模型输出</span><br>    <span class="hljs-comment"># target_batch(batch_size, n_seq)</span><br>    <span class="hljs-comment"># outputs(batch_size, n_seq, num_of_voc)</span><br>    loss = criterion(outputs.view(-<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(corpus.tgt_vocab)), target_batch.view(-<span class="hljs-number">1</span>)) <span class="hljs-comment"># 计算损失</span><br>    <span class="hljs-keyword">if</span> (epoch + <span class="hljs-number">1</span>) % <span class="hljs-number">20</span> == <span class="hljs-number">0</span>: <span class="hljs-comment"># 打印损失</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch: <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>:04d&#125;</span> cost = <span class="hljs-subst">&#123;loss:<span class="hljs-number">.6</span>f&#125;</span>&quot;</span>)<br>    loss.backward()       <br>    optimizer.step()<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs output">Epoch: 0020 cost = 0.566277<br>Epoch: 0040 cost = 0.339869<br>Epoch: 0060 cost = 0.029208<br>Epoch: 0080 cost = 0.006405<br>Epoch: 0100 cost = 0.004169<br></code></pre></td></tr></table></figure><h4 id="解码器输出">解码器输出</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个大小为 1 的批次，目标语言序列 dec_inputs 在测试阶段，仅包含句子开始符号 &lt;sos&gt;</span><br>enc_inputs, dec_inputs, target_batch = corpus.make_batch(batch_size=<span class="hljs-number">1</span>,test_batch=<span class="hljs-literal">True</span>) <br>enc_inputs, dec_inputs, target_batch = enc_inputs.to(device), dec_inputs.to(device), target_batch.to(device)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;编码器输入:&quot;</span>, enc_inputs) <span class="hljs-comment"># 打印编码器输入</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;解码器输入:&quot;</span>, dec_inputs) <span class="hljs-comment"># 打印解码器输入</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;目标数据:&quot;</span>, target_batch) <span class="hljs-comment"># 打印目标数据</span><br>predict, enc_self_attns, dec_self_attns, dec_enc_attns = model(enc_inputs, dec_inputs) <span class="hljs-comment"># 用模型进行翻译</span><br>predict = predict.view(-<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(corpus.tgt_vocab)) <span class="hljs-comment"># 将预测结果维度重塑</span><br>predict = predict.data.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)[<span class="hljs-number">1</span>] <span class="hljs-comment"># 找到每个位置概率最大的词汇的索引</span><br><span class="hljs-comment"># 解码预测的输出，将所预测的目标句子中的索引转换为单词</span><br>translated_sentence = [corpus.tgt_idx2word[idx.item()] <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> predict.squeeze()]<br><span class="hljs-comment"># 将输入的源语言句子中的索引转换为单词</span><br>input_sentence = [corpus.src_idx2word[idx.item()] <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> enc_inputs[<span class="hljs-number">0</span>]]<br><span class="hljs-built_in">print</span>(input_sentence, <span class="hljs-string">&#x27;-&gt;&#x27;</span>, translated_sentence) <span class="hljs-comment"># 打印原始句子和翻译后的句子</span><br></code></pre></td></tr></table></figure><p><strong>输出结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs output">编码器输入: tensor([[ 1, 10,  7,  0,  0,  0]])<br>解码器输入: tensor([[1, 0, 0, 0]])<br>目标数据: tensor([[ 3, 11,  8,  2]])<br>[&#x27;我&#x27;, &#x27;喜欢&#x27;, &#x27;香蕉&#x27;, &#x27;&lt;pad&gt;&#x27;, &#x27;&lt;pad&gt;&#x27;, &#x27;&lt;pad&gt;&#x27;] -&gt; [&#x27;I&#x27;, &#x27;I&#x27;, &#x27;I&#x27;, &#x27;I&#x27;]<br></code></pre></td></tr></table></figure><p>这里只生成了一个 token，因为还没有使用到 Transformer解码层的自回归机制。</p><h4 id="生成式解码">生成式解码</h4><p>在 Transformer模型中，我们通过最大化预测正确词的概率来优化模型。而在推理的过程中，我们可以以选择概率最大的词作为下一个词，这就是我们常说的贪心搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">greedy_decoder</span>(<span class="hljs-params">model, enc_input, start_symbol, steps=<span class="hljs-number">5</span></span>):<br>    enc_outputs, enc_self_attns = model.encoder(enc_input)<br>    dec_input = torch.zeros(<span class="hljs-number">1</span>, steps).type_as(enc_input)<br>    next_symbol = start_symbol<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, steps):<br>        dec_input[<span class="hljs-number">0</span>, i] = next_symbol<br>        <span class="hljs-keyword">if</span> next_symbol == corpus.tgt_vocab[<span class="hljs-string">&#x27;&lt;eos&gt;&#x27;</span>]: <span class="hljs-keyword">break</span><br>        dec_output, _, _ = model.decoder(dec_input, enc_input, enc_outputs)<br>        proj = model.projection(dec_output)<br>        <span class="hljs-comment"># proj(batch_size=1, n_seq, num_of_voc)</span><br>        prob = proj.squeeze(<span class="hljs-number">0</span>).<span class="hljs-built_in">max</span>(dim=-<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">False</span>)[<span class="hljs-number">1</span>]<br>        <span class="hljs-comment"># prob(batch_size=1, n_seq)</span><br>        next_word = prob.data[i]<br>        next_symbol = next_word.item() <span class="hljs-comment"># 预测下一词</span><br>    final_output = dec_input<br><br>    <span class="hljs-keyword">return</span> final_output<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用贪婪搜索翻译文本</span><br>enc_inputs, dec_inputs, target_batch = corpus.make_batch(batch_size=<span class="hljs-number">1</span>, test_batch=<span class="hljs-literal">True</span>) <br>enc_inputs, dec_inputs, target_batch = enc_inputs.to(device), dec_inputs.to(device), target_batch.to(device)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;编码器输入:&quot;</span>, enc_inputs) <span class="hljs-comment"># 打印编码器输入</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;解码器输入:&quot;</span>, dec_inputs) <span class="hljs-comment"># 打印解码器输入</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;目标数据:&quot;</span>, target_batch) <span class="hljs-comment"># 打印目标数据</span><br>greedy_dec_output = greedy_decoder(model, enc_inputs, start_symbol=corpus.tgt_vocab[<span class="hljs-string">&#x27;&lt;sos&gt;&#x27;</span>], steps=corpus.tgt_len)<br>greedy_dec_output_words = [corpus.tgt_idx2word[n.item()] <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> greedy_dec_output.squeeze()]<br>enc_inputs_words = [corpus.src_idx2word[code.item()] <span class="hljs-keyword">for</span> code <span class="hljs-keyword">in</span> enc_inputs[<span class="hljs-number">0</span>]]<br><span class="hljs-built_in">print</span>(enc_inputs_words, <span class="hljs-string">&#x27;-&gt;&#x27;</span>, greedy_dec_output_words)<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs output">编码器输入: tensor([[1, 6, 7, 0, 0]])<br>解码器输入: tensor([[1, 0, 0, 0]])<br>目标数据: tensor([[3, 7, 8, 2]])<br>[&#x27;我&#x27;, &#x27;喜欢&#x27;, &#x27;苹果&#x27;, &#x27;&lt;pad&gt;&#x27;, &#x27;&lt;pad&gt;&#x27;] -&gt; [&#x27;&lt;sos&gt;&#x27;, &#x27;I&#x27;, &#x27;like&#x27;, &#x27;apples&#x27;, &#x27;&lt;eos&gt;&#x27;]<br></code></pre></td></tr></table></figure><h4 id="测试">测试</h4><p>接下来我们现在找个训练集没有出现的数据来测试模型的泛化能力：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">test_enc_inputs = [corpus.src_vocab[w] <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> <span class="hljs-built_in">list</span>(jieba.cut(<span class="hljs-string">&#x27;美国人喜欢香蕉&#x27;</span>))]<br>test_enc_inputs = torch.LongTensor(test_enc_inputs + (corpus.src_len - <span class="hljs-built_in">len</span>(test_enc_inputs)) * [corpus.src_vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]]).unsqueeze(<span class="hljs-number">0</span>)<br>dec_inputs = torch.LongTensor([corpus.tgt_vocab[<span class="hljs-string">&#x27;&lt;sos&gt;&#x27;</span>]] + (corpus.tgt_len - <span class="hljs-number">1</span>) * [corpus.tgt_vocab[<span class="hljs-string">&#x27;&lt;pad&gt;&#x27;</span>]]).unsqueeze(<span class="hljs-number">0</span>)<br><br>greedy_test_dec_output = greedy_decoder(model, test_enc_inputs, start_symbol=corpus.tgt_vocab[<span class="hljs-string">&#x27;&lt;sos&gt;&#x27;</span>], steps=corpus.tgt_len)<br>ans = [corpus.tgt_idx2word[idx.item()] <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> greedy_test_dec_output[<span class="hljs-number">0</span>]]<br><br><span class="hljs-built_in">print</span>(ans)<br></code></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">[&#x27;&lt;sos&gt;&#x27;, &#x27;American&#x27;, &#x27;like&#x27;, &#x27;bananas&#x27;, &#x27;&lt;eos&gt;&#x27;]<br></code></pre></td></tr></table></figure><h3 id="transformer-的发展">Transformer 的发展</h3><h4 id="nlp-领域">NLP 领域</h4><p>自从 Transformer 架构在 2017年被提出后，大型语言模型的发展经历了显著的变革和快速的进步。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-103633.png" alt="Transformer 在 NLP 中的发展" style="zoom:67%;" /></p><ol type="1"><li>2018 年，<strong>BERT（Bidirectional Encoder Representations fromTransformers）</strong>由 Google 提出，BERT 是基于 Transformer的首个重要应用。</li><li>2018 - 2020 年，OpenAI 发布了 <strong>GPT（Generative PretrainedTransformer）</strong>系列模型，包括 GPT-2 和 GPT-3。GPT-3特别因其巨大的规模（1750亿个参数）和强大的生成能力而受到关注。</li><li>2021 - 2023 年，模型如 GPT-4 和 Google 的 PaLM（Pathways LanguageModel）通过扩大规模和改进训练技巧，进一步提高了性能。</li><li>...</li></ol><h4 id="视觉领域">视觉领域</h4><p>Transformer最初是为自然语言处理（NLP）任务设计的，但其核心思想—基于注意力机制的模型架构—也被发现对于处理视觉信息非常有效。因此，Transformer在机器视觉领域的应用也变得越来越广泛。</p><h5 id="vit">ViT</h5><p>Google Research 在 2020 年推出了 <strong>VisionTransformer（ViT）</strong>，这是首次将 Transformer完全应用于图像识别任务。ViT将图像分割成固定大小的图像块，将每个图像块展平并映射到一个高维空间（就像NLP中的词嵌入），然后在这些块上应用标准的Transformer 模型。ViT在多个图像识别基准测试中表现出色，与当时的卷积神经网络（CNN）模型相比，它在一些任务上达到了更好的性能。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-103909.png" style="zoom:67%;" /></p><h5 id="mae">MAE</h5><p>MAE（MaskedAutoencoders）技术是一种自监督学习方法，它是通过预训练一个神经网络以重建被随机遮挡（mask）的输入数据的方法来学习数据的有效表示。这个技术通常与自编码器（Autoencoder）相关，自编码器是一个试图通过较小的隐藏层来重构输入的神经网络结构。MAE通过随机遮挡输入数据的一部分，然后让网络预测这些遮挡部分的原始内容，从而迫使模型学习到数据的内在结构和模式。</p><p>MAE技术可以应用于多种类型的数据，包括图像、文本、声音等。在视觉任务中，MAE的一个例子是，输入一张图像，然后在图像上随机选择一些像素或区域并将其遮挡，随后模型的任务是预测这些遮挡区域的像素值。这种方法迫使模型学习到图像的低级特征（如边缘和纹理）以及更高级的概念（如对象的部分和整体结构），因为要正确重建被遮挡的部分，模型需要理解其周围的上下文。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-04-104543.png" style="zoom:80%;" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>Transformer</tag>
      
      <tag>CV</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 多线程编程</title>
    <link href="/2023/11/15/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/11/15/Java-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h4 id="在-java-中构造一个线程实例">在 Java 中构造一个线程实例</h4><p>Java 有两种方式定义一个线程，分别是通过继承 <code>Thread</code>类和实现 <code>Runnable</code> 接口。</p><h5 id="通过继承-thread-类">通过继承 <code>Thread</code> 类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="通过实现-runnable-接口">通过实现 <code>Runnable</code> 接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><code>Thread</code> 构造函数接收一个 <code>Runnable</code>的实现类。</p><p>两种方法都需要重写 <code>run()</code> 方法，<code>run()</code>方法是一个回调函数，包含线程的运行逻辑，在线程启动后调用。</p><h4 id="java-线程的生命周期">Java 线程的生命周期</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-25-125318.png" style="zoom:35%;" /></p><p><strong>New</strong>：即使用 <code>new</code> 关键字创建一个<code>Thread</code> 实例。</p><p><strong>Runnable</strong>：表示线程可运行，当实例调用<code>start()</code> 方法后进入该状态。</p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>           &#125;<br>        &#125;);<br>        <br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Running</strong>：表示线程正在执行。</p><p><strong>Blocked/Waiting/Sleeping</strong>：分别表示线程处于阻塞、等待和睡眠状态。具体的方法我们在后面介绍。</p><p><strong>Dead</strong>：当线程执行结束后会被自动销毁。</p><p><strong>其他方法</strong></p><p><strong><code>sleep()</code></strong></p><p><code>Thread</code> 类的 <code>sleep</code>方法用于暂停当前执行的线程指定的毫秒数。当线程调用 <code>sleep</code>方法时，它告诉线程调度器自己愿意放弃其当前的时间片段，并在指定的时间内不参与调度。<code>sleep</code>方法主要用于模拟延迟或等待一段时间，让其他线程有机会执行。</p><p>形式：<code>sleep(long millis)</code>：使当前执行的线程休眠（暂停执行）指定的毫秒数。</p><p>该方法是静态方法，可以通过 <code>Thread.sleep</code> 直接调用。</p><p><strong><code>interrput()</code></strong></p><p><code>interrupt</code> 方法是 <code>Thread</code>类的一个实例方法，用于中断线程或者更准确地说，是用于请求中断线程。当一个线程运行时，其他线程可以通过调用这个线程的<code>interrupt</code> 方法来请求它停止当前正在做的事情。</p><p>中断机制是一种协作机制。调用 <code>interrupt</code>并不会立即停止目标线程。相反，<strong>它设置了线程的中断状态</strong>，然后线程可以决定如何响应中断。</p><blockquote><p>每个线程都有一个状态标识符表示其是否处于中断状态，通过<code>isInterrupted()</code> 方法可以查看其状态。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                    <span class="hljs-comment">// 线程的工作代码</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread is running...&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 可能会抛出 InterruptedException</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Thread was interrupted!&quot;</span>);<br>            &#125;<br>        &#125;);<br>        thread.start();<br>        System.out.println(thread.isInterrupted()); <span class="hljs-comment">// false</span><br>        <span class="hljs-comment">// 给线程一些时间来运行</span><br>        Thread.sleep(<span class="hljs-number">3000</span>);<br><br>        <span class="hljs-comment">// 请求中断线程</span><br>        thread.interrupt();<br>        System.out.println(thread.isInterrupted()); <span class="hljs-comment">// true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="java-内存模型">Java 内存模型</h4><p><strong>Java 内存模型（Java MemoryModel，JMM）</strong>是一种规范，用于管理Java程序中的内存读写和数据同步。Java内存模型的主要目的是定义程序中变量的读取和写入如何在多线程环境下进行。下面是其主要特点和组成部分的简要介绍：</p><ol type="1"><li><strong>可见性（Visibility）</strong>:在多线程环境中，一个线程对共享变量的修改对其他线程是可见的。Java内存模型通过 <code>volatile</code> 关键字和 <code>synchronized</code>块来保证变量修改的可见性。</li><li><strong>原子性（Atomicity）</strong>:确保操作的不可分割性。例如，在写入或读取变量时，不会出现只完成一部分操作的情况。在Java 中，原子性通常通过 <code>synchronized</code> 来实现。</li><li><strong>有序性（Ordering）</strong>: 在 Java内存模型中，操作的执行顺序可能与代码顺序不同，这被称为指令重排。为了控制指令重排，Java提供了 <code>volatile</code> 关键字和 happens-before 原则。</li><li><strong>happens-before 原则</strong>：这是 Java内存模型的核心概念之一，它定义了一组规则，这些规则确定了一个操作的结果对另一个操作可见的条件。例如，一个锁的释放happens-before 于随后对这个锁的获取。<ol type="1"><li><strong>线程内顺序规则</strong>：在同一个线程内，按照程序顺序，前一个操作对于后续操作是可见的。也就是说，一个线程内的每一个动作都发生在它后面的动作之前。</li><li><strong>监视器锁规则</strong>：当一个线程释放（Unlock）一个监视器（也就是释放一个同步块的锁），这个动作发生在随后对同一个监视器加锁（Lock）的任何动作之前。这确保了释放锁之后，后续获取该锁的线程可以看到之前线程在同步块内所有的写入。</li><li><strong><code>volatile</code> 变量规则</strong>：对一个<code>volatile</code> 字段的写入对于后续对这个 <code>volatile</code>字段的读取是可见的。这意味着一旦一个线程写入一个 <code>volatile</code>变量，任何后续读取这个 <code>volatile</code>变量的线程都将看到这个新值。</li><li><strong>线程启动规则</strong>：主线程 A 中调用另一个线程 B 的<code>start()</code> 方法发生在任何线程 B 中的动作之前。这意味着，线程 B可以看到线程 A 在调用 <code>start()</code> 之前的所有操作。</li><li><strong>线程终止规则</strong>：如果线程 A 执行了线程 B 的<code>join()</code> 方法并成功返回，那么线程B中的所有动作都发生在线程A从<code>join()</code> 方法成功返回之前。换句话说，线程 A 在<code>join()</code> 之后可以看到线程 B 的所有操作。</li></ol></li></ol><p><strong>Java 内存模型的硬件表示</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-26-020753.png" style="zoom:67%;" /></p><p>在 Java 多线程环境中，每个线程都可能在自己的 CPU核心上执行，并且每个核心都有自己的寄存器和高速缓存（即工作内存），这里存储了线程执行时所需要的数据副本。Java内存模型保证了线程对共享变量的操作最终一致地反映在主内存中，并且其他线程能够看到这些变化。</p><ul><li><strong>CPU寄存器</strong>：最快的存储区域，通常用于存储指令、本地变量或临时计算结果。在JMM 中没有直接对应，但可以看作是线程在执行计算时的临时存储。</li><li><strong>CPU 缓存</strong>：高速缓存是 CPU和主内存之间的小容量存储，用于减少访问主内存的延迟。在 JMM中，这可以被认为是线程的工作内存的一部分，线程在这里读写它们需要的变量。</li><li><strong>主内存（RAM）</strong>: 所有的 CPU核心共享主内存，它保存了程序运行时的数据和状态。在 JMM中，主内存存储共享变量，是多个线程通信的媒介。</li></ul><blockquote><ul><li><p>当 CPU 需要读取住内存中的变量，其会读取一部分住内存到 CPU缓存，然后从缓存中读取变量到寄存器再进行操作。</p></li><li><p>当 CPU 需要将变量写入内存时，其会将内部寄存器的值刷新到 CPU缓存中，接下来<strong>在某时刻</strong>将缓存中的数据刷新到住内存（一般是主内存需要这个变量的时候）。</p></li></ul></blockquote><p>也就是说，不同的线程获取和更新主内存都不是及时的，会在一定程度上出现延迟，这样就带来了两个问题：</p><ul><li><p>不同线程更新的不可见性：当线程 A 的 CPU 修改完变量 <code>x</code>后，未及时将修改后的值更新到主内存，于此同时，线程 B 在主内存读取到了<code>x</code> 原来的值。</p></li><li><p><strong>竞态条件（Race Condition）</strong>：两个线程同时对变量<code>x</code> 做修改，导致了错误的更新。</p><p>示例：</p><p>在以下代码中，10 个线程同时操作 <code>Counter</code>对象，可能导致竞态条件的发生。事实上，每次输出的结果可能都不一样。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Counter</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Counter</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num_of_threads</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        Thread[] th_arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>[num_of_threads];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num_of_threads; i++) &#123;<br>            th_arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Increment</span>(c, <span class="hljs-number">20</span>, <span class="hljs-number">1</span>));<br>            th_arr[i].start();<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num_of_threads; i++) &#123;<br>            th_arr[i].join();<br>        &#125;<br>        System.out.println(c.getCnt()); <span class="hljs-comment">// 如果输出不是 200，就说明出现了竞态条件</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cnt += x;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCnt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Increment</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Counter c;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> max_n;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> x;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Increment</span><span class="hljs-params">(Counter c, <span class="hljs-type">int</span> max_n, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-built_in">this</span>.c = c;<br>        <span class="hljs-built_in">this</span>.max_n = max_n;<br>        <span class="hljs-built_in">this</span>.x = x;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; max_n; i++) &#123;<br>                c.add(x);<br>                Thread.sleep((<span class="hljs-type">long</span>)(<span class="hljs-number">100</span> * Math.random()));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="volatile-关键字"><code>volatile</code> 关键字</h5><p><code>volatile</code> 是 Java中的一个重要关键字，用于声明该变量将会被多个不同的线程修改。<code>volatile</code>关键字保证了一个线程对该变量的写操作对其他线程立即可见。这意味着当一个线程更新了一个<code>volatile</code>变量的值时，新值对于正在读取这个变量的其他线程是立即可知的。</p><p><strong>写入 <code>volatile</code> 变量</strong></p><ol type="1"><li><strong>立即写入主内存</strong>: 当线程对一个 <code>volatile</code>变量执行写操作时，它会立即将这个新值刷新到主内存中。</li><li><strong>写屏障（Write Barrier）</strong>: 在写入<code>volatile</code> 变量之后，JVM会插入一个写屏障（也叫做存储屏障），这防止了指令重排序。具体来说，写屏障会确保所有在写<code>volatile</code> 变量之前的操作都不会被重排到写操作之后。</li><li><strong>无缓存行失效</strong>：由于 <code>volatile</code>变量的操作直接写入主内存，这意味着不会有缓存行失效的问题，因为缓存行失效主要发生在缓存之间的数据同步过程中。</li><li><strong>变量的“发布”</strong>：写操作实质上是将变量的值“发布”出去，使得之后对这个<code>volatile</code> 变量的读操作都能看到最新的值。</li></ol><p><strong>读取 <code>volatile</code> 变量</strong></p><ol type="1"><li><strong>直接从主内存读取</strong>：当线程对一个<code>volatile</code>变量执行读操作时，它会<strong>直接从主内存中读取值而不是从缓存中读取</strong>。这确保了它看到的是最新写入的值。</li><li><strong>读屏障（Read Barrier）</strong>：在读取<code>volatile</code> 变量之前，JVM会插入一个读屏障，防止指令重排序。这意味着，在读 <code>volatile</code>变量之前的操作不会被重排到读操作之后。</li><li><strong>禁止缓存</strong>：<code>volatile</code>读取操作不会将值缓存在寄存器或其他 CPU缓存中，因为这个值在后续指令中必须从主内存重新读取。</li><li><strong>变量的“获取”</strong>: 读操作实际上是“获取”了<code>volatile</code>变量的最新值，保证了后续的操作都是在最新值的基础上进行的。</li></ol><blockquote><p>注：虽然 <code>volatile</code>提供了操作的可见性和有序性，但它并不保证操作的原子性。例如，<code>volatile</code>不适用于复合操作（比如<code>volatileVar++</code>），因为这类操作包含多个步骤，每个步骤都需要原子性保证。</p></blockquote><h5 id="synchronized-关键字"><code>synchronized</code> 关键字</h5><p><code>volatile</code>保证了操作的有序性，但无法保证操作的原子性（即操作不可分），这里我们就需要使用<code>synchronized</code> 关键字了。</p><p>在介绍 <code>synchronized</code> 关键字之前，我们先简单介绍一下 Java对象的内部锁（Intrinsic Lock）。在 Java中，每个对象都有一个内部锁或监视器锁，它是实现同步的一种机制。这个内部锁是用来控制对对象同步部分的并发访问的。当多个线程尝试同时执行对象中的同步代码时，这个锁确保了一次只有一个线程能执行该代码块。</p><p><code>synchronized</code>关键字有两种修饰方法，一种是直接修饰类方法，另一种是使用<code>synchronized</code> 代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span> &#123;&#125;<br><br><span class="hljs-keyword">synchronized</span>(obj) &#123;&#125;<br></code></pre></td></tr></table></figure><p>当我们要访问 <code>synchronized</code>关键字修饰的方法和代码块时，必须要获取到方法或代码块所属对象的内部锁，而当一个线程获取到锁的时候，其他线程都无法获取到该锁。例如，我们只需要稍微修改上述例子中的<code>Counter</code> 对象，就可以解决竞态度条件的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-built_in">this</span>.cnt += x;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCnt</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>监视器</strong></p><p>监视器（Monitor）是一个同步机制，它用于实现对对象的互斥访问。每个Java对象都有一个监视器与之关联，它用来帮助管理那些试图访问同步代码块的线程。监视器内部有几个组成部分，主要包括Entry Set、Owner 以及 Wait Set。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-26-034101.png" style="zoom:50%;" /></p><ul><li><p><strong>Owner（锁的所有者）</strong></p><p>监视器的 Owner是当前持有对象锁的线程。<strong>在任意时间点，最多只有一个线程可以成为监视器的Owner</strong>。这个线程获得锁后，其他任何试图获得该锁的线程都必须等待，直到当前线程释放锁。Owner是执行同步代码块的线程。</p></li><li><p><strong>Entry Set（锁池）</strong></p><p><strong>当线程尝试进入同步代码块时，如果锁已经被占用</strong>，那么该线程将被放置到Entry Set中，这也被称为锁池。这是一个包含了所有等待锁的线程的集合。当锁被释放时，这些线程中的一个（或多个，取决于JVM 实现）将有机会尝试获取锁。如果获得锁成功，则线程从 Entry Set 移动到Owner。</p></li><li><p><strong>Wait Set（等待集合）</strong></p><p>Wait Set 是一个包含了所有调用了 <code>wait()</code>方法（在同步代码块内部调用）的线程的集合。这些线程在调用<code>wait()</code> 方法后<strong>释放了锁</strong>，并等待其他线程通过<code>notify()</code> 或 <code>notifyAll()</code>方法通知它们。<strong>一旦线程被通知，它们会离开 Wait Set 并尝试重新进入Entry Set 以获取锁</strong>。</p></li></ul><p><strong>示例</strong></p><p>接下来我们定义了一个邮箱对象，并定义了一个读线程和写线程分别操作这个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MailBox</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MailBox</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">num_of_msg</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">w_thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Writer</span>(m, num_of_msg));<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">r_thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Reader</span>(m, num_of_msg));<br>        w_thread.start();<br>        r_thread.start();<br><br>        w_thread.join();<br>        r_thread.join();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> MailBox m;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num_of_msg;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Reader</span><span class="hljs-params">(MailBox m, <span class="hljs-type">int</span> num_of_msg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = m;<br>        <span class="hljs-built_in">this</span>.num_of_msg = num_of_msg;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; num_of_msg; i++) &#123;<br>            m.read();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Writer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> MailBox m;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> num_of_msg;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Writer</span><span class="hljs-params">(MailBox m, <span class="hljs-type">int</span> num_of_msg)</span> &#123;<br>        <span class="hljs-built_in">this</span>.m = m;<br>        <span class="hljs-built_in">this</span>.num_of_msg = num_of_msg;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= num_of_msg; i++) &#123;<br>            m.write(<span class="hljs-string">&quot;Message Number: &quot;</span> + i);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MailBox</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">empty</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (empty) &#123;<br>                wait(); <span class="hljs-comment">// 释放锁</span><br>            &#125;<br>            System.out.println(message);<br>            empty = <span class="hljs-literal">true</span>;<br>            notifyAll(); <span class="hljs-comment">// 通知 Wait Set 中的线程</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (!empty) &#123;<br>                wait(); <span class="hljs-comment">// 释放锁</span><br>            &#125;<br>            <span class="hljs-built_in">this</span>.message = message;<br>            empty = <span class="hljs-literal">false</span>;<br>            notifyAll(); <span class="hljs-comment">// 通知 Wait Set 中的线程</span><br>        &#125;<br>        <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs output">Message Number: 1<br>Message Number: 2<br>Message Number: 3<br>Message Number: 4<br>Message Number: 5<br>Message Number: 6<br>Message Number: 7<br>Message Number: 8<br>Message Number: 9<br>Message Number: 10<br></code></pre></td></tr></table></figure><p>一个标准的 <code>wait/notify</code> 用法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (status) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        wait();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>    <span class="hljs-comment">// ...</span><br>    notify(); <span class="hljs-comment">// 或者 notifyAll()</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="总结">总结</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-26-042554.png" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>多线程</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>给你的 Python 循环加上进度条</title>
    <link href="/2023/11/05/%E7%BB%99%E4%BD%A0%E7%9A%84%20Python%20%E5%BE%AA%E7%8E%AF%E5%8A%A0%E4%B8%8A%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <url>/2023/11/05/%E7%BB%99%E4%BD%A0%E7%9A%84%20Python%20%E5%BE%AA%E7%8E%AF%E5%8A%A0%E4%B8%8A%E8%BF%9B%E5%BA%A6%E6%9D%A1/</url>
    
    <content type="html"><![CDATA[<p>在使用 Python 编程的过程中，我们有时需要知道 Python循环的当前进展，特别是机器学习的过程，接下来我们介绍 Python 的进度条库<code>tqdm</code>。</p><hr /><h4 id="tqdm-简介"><code>tqdm</code> 简介</h4><p><code>tqdm</code>是一个快速、可扩展的Python进度条库，可以很容易地添加到现有的Python代码中。<code>tqdm</code>这个名字来源于阿拉伯语单词"taqaddum"（تقدُّم）的缩写，意为"进展"。在使用时，它会显示一个进度条提供信息，比如迭代的完成百分比、已经过时间、预计剩余时间以及每秒的迭代次数。</p><p>在使用 <code>tqdm</code> 之前，我们需要安装 <code>tqdm</code>包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install tqdm<br></code></pre></td></tr></table></figure><p><code>tqdm</code>可以用在任何可以迭代的对象上，包括列表、字典、文件等。使用<code>tqdm</code> 最简单的方式是将它包裹在任何迭代器上，例如在<code>for</code>循环中。下面是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)):<br>    time.sleep(<span class="hljs-number">0.01</span>)<br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-06-134200.png" style="zoom:67%;" /></p><h4 id="tqdm-常用参数"><code>tqdm()</code> 常用参数</h4><p>为了满足工作的实际需求，<code>tqdm</code>函数提供了多种参数来自定义进度条的行为和显示效果：</p><ol type="1"><li><code>desc</code> ：进度条前面的描述文字（即前缀），默认为空。</li><li><code>total</code> ：迭代总次数。如果未提供，则使用<code>iterable</code> 的长度。如果 <code>iterable</code>是无法直接获取长度的迭代器，可以通过<code>total</code>参数手动设置。</li><li><code>leave</code>：布尔值，设置为<code>True</code>时，在进度条结束后，进度条将保留下来；如果设置为<code>False</code> ，进度条结束后将会被删除。默认为<code>True</code>。</li><li><code>unit</code>：进度条每次更新代表的单位，默认是<code>'it'</code>（迭代），可以设置成其他如<code>'files'</code>、<code>'blocks'</code> 等。</li><li><code>initial</code> ： 设置开始时的初始计数，默认是0。这个参数在迭代器被部分消费后再使用 <code>tqdm</code> 时很有用。</li></ol><h4 id="案例">案例</h4><ul><li><p>用于神经网络参数训练时记录当前训练的 epoch 进度：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(epoch_num), unit=<span class="hljs-string">&#x27;epoch&#x27;</span>, desc=<span class="hljs-string">&#x27;Training&#x27;</span>):<br>    <span class="hljs-keyword">for</span> batch_idx, (data, target) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>        op.zero_grad()<br>        output = model(data)<br>        l = loss(output, target)<br>        l.backward()<br>        op.step()<br>    <br>    torch.save(model.state_dict(), <span class="hljs-string">f&#x27;net/epoch-<span class="hljs-subst">&#123;epoch&#125;</span>.pth&#x27;</span>)<br>    tqdm.write(<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch&#125;</span> is over, loss = <span class="hljs-subst">&#123;l.item():<span class="hljs-number">.6</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></p><p>效果：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-06-135411.png" style="zoom:67%;" /></p></li><li><p>我们也可以记录每个 epoch 的迭代进度：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch_num):<br>    <span class="hljs-keyword">for</span> batch_idx, (data, target) <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">enumerate</span>(train_loader), total=<span class="hljs-built_in">len</span>(train_datasets) // batch_size, desc=<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch&#125;</span>&#x27;</span>):<br>        op.zero_grad()<br>        output = model(data)<br>        l = loss(output, target)<br>        l.backward()<br>        op.step()<br>        <br>    torch.save(model.state_dict(), <span class="hljs-string">f&#x27;net/epoch-<span class="hljs-subst">&#123;epoch&#125;</span>.pth&#x27;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch&#125;</span> is over, loss = <span class="hljs-subst">&#123;l.item():<span class="hljs-number">.6</span>f&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure></p><p>效果：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-06-140021.png"  style="zoom:67%;" /></p></li><li><p>在下载大文件时显示进度条：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&quot;http://example.com/large_file.zip&quot;</span><br>response = requests.get(url, stream=<span class="hljs-literal">True</span>)<br><br>total_size_in_bytes = <span class="hljs-built_in">int</span>(response.headers.get(<span class="hljs-string">&#x27;content-length&#x27;</span>, <span class="hljs-number">0</span>))<br>chunk_size = <span class="hljs-number">1024</span><br><br><span class="hljs-keyword">with</span> tqdm(total=total_size_in_bytes, unit=<span class="hljs-string">&#x27;B&#x27;</span>, unit_scale=<span class="hljs-literal">True</span>, desc=url.split(<span class="hljs-string">&#x27;/&#x27;</span>)[-<span class="hljs-number">1</span>]) <span class="hljs-keyword">as</span> progress_bar:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;large_file.zip&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>        <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> response.iter_content(chunk_size):<br>            progress_bar.update(<span class="hljs-built_in">len</span>(data))<br>            file.write(data)<br></code></pre></td></tr></table></figure></p></li></ul><blockquote><p>注：<code>tqdm</code>本身是一个迭代器装饰器，其作用是对原始迭代器进行包装，在迭代过程中动态地显示进度，而不更改原始迭代的返回值。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>tqdm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内存管理</title>
    <link href="/2023/11/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <url>/2023/11/02/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="为什么需要内存管理">为什么需要内存管理？</h3><ul><li><p>计算机的内存被所有进程共享，但是编译器和程序员无法得知当前还有多少进程在内存中的什么地方。</p></li><li><p>内存管理的主要需求：</p><ul><li><p><strong>代码重定向（Code relocation）</strong></p><p><strong>代码重定位</strong>是指将程序中的某些代码或数据从一个位置移动到另一个位置的过程。</p></li><li><p><strong>保护 &amp; 共享（Protection &amp;Sharing）</strong></p></li><li><p><strong>使得每个进程都有自己的地址空间，便于程序员编程</strong></p></li></ul></li></ul><h3 id="虚拟内存-物理内存">虚拟内存 &amp; 物理内存</h3><ul><li><p><strong>虚拟内存（Virtualmemory）</strong>，也称<strong>逻辑内存（Logicalmemory）</strong>，是给每个程序进程分配的内存，其大小由计算机寻址位数决定，对于32 位机器而言，虚拟内存的大小为 <span class="math inline">\(2 ^{32}\)</span> B <span class="math inline">\(=\)</span> <spanclass="math inline">\(4\)</span> GB；对于 64为机器而言，虚拟地址的大小为 <span class="math inline">\(2 ^{64}\)</span> B <span class="math inline">\(\approx\)</span> <spanclass="math inline">\(4 \times 10 ^ 9\)</span>GB，这已经满足绝大多数内存存储需求。</p><p>虚拟内存中的地址称为虚拟地址，是每个进程可以访问的地址。如下图，使用64 位 ARM 机器编写的一个 C 语言程序，所打印的变量地址就是虚拟地址：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-05-163955.png" style="zoom:50%;" /></p></li><li><p><strong>物理内存（Phsicalmemory）</strong>，也称<strong>真实内存（Realmemory）</strong>，物理内存中的地址称为物理地址，是程序真正占用的地址，每个有效虚拟地址都会映射到与之特定的物理地址。</p></li></ul><h3 id="内存映射">内存映射</h3><p>由于虚拟内存是不存在的，所以我们在寻址时要根据虚拟内存找到对应的物理内存，这样的技术称为内存映射。</p><h4 id="内存分区">内存分区</h4><p>内存分区（PartitionMemory）是一种古老的内存映射方式，其有两个主要分类，一个是<strong>不变分区（FixedPartitioning）</strong>，另一个是<strong>动态分区（DynamicPartitioning）</strong>。</p><ul><li><p><strong>不变分区</strong>：</p><ul><li><p>在机器启动时间（Boottime）就将内存分为几个连续的分区，<strong>每个分区只能装载一个进程，分区大小在系统启动时确定，并在整个运行期间保持不变。</strong></p><p>如下图所示，<code>x</code> 表示进程已使用内存：</p><table><thead><tr class="header"><th>Block 1</th><th>Block 2</th><th>Block 3</th><th>Block 4</th><th>Block 5</th></tr></thead><tbody><tr class="odd"><td><code>xxxxx</code></td><td><code>xx000</code></td><td><code>x0000</code></td><td><code>xxx00</code></td><td><code>x0000</code></td></tr></tbody></table><p>可见，这样简单粗暴的分区方式一是限制了每个进程内存的增长，同时产生了大量的<strong>内部碎片（Internelfragmentation）</strong>，即<strong>我们可能会给一些进程预留一些不会使用到的内存</strong>。</p></li><li><p>硬件要求：一个<strong>基地址寄存器（Baseregister）</strong>，基地址寄存器存储了每个进程对应物理内存的起始地址，<strong>寄存器的数据在上下文切换（Contextswitch）时由 OS 加载</strong>。</p></li><li><p>映射公式： <span class="math display">\[  \text{Physical Address} = \text{Logical Address} + \text{BaseRegister}  \]</span></p></li></ul></li><li><p><strong>动态分区</strong></p><ul><li><p>动态分区相对而言更加灵活，动态分区技术只在程序被加载，即操作系统创建新进程时创建分区。</p></li><li><p>这种按需分配的分区技术<strong>可以避免内部碎片</strong>，但是未被分配的内存会零散分布在内存中，造成<strong>外部碎片（Externalfragmentation）</strong>，例如下图：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-05-172132.png" style="zoom:35%;" /></p></li><li><p>硬件要求：一个<strong>基地址寄存器</strong>，这一点和不变分区技术一致；同时还需要一个<strong>限制寄存器（Limitregister）</strong>，限制寄存器限制了进程内存的最大偏移量。</p></li><li><p>映射公式： <span class="math display">\[  \text{Physical Address} = \text{Logical Address} + \text{BaseRegister}  \]</span> 保护机制： <span class="math display">\[  \text{if}\ (\text{Physical Address} &gt; \text{Base register} +\text{Limit register}) \implies \text{TRAP!}  \]</span>当程序尝试访问超出其限制寄存器定义的内存段范围时，操作系统会捕获并处理异常，这就是我们常说的段错误（Segmentationfault）。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-05-173038.png" style="zoom:40%;" /></p></li></ul></li></ul><h4 id="页-帧">页 &amp; 帧</h4><p><strong>页（Page）</strong>和<strong>帧（Frame）</strong>是现代计算机内存管理中两个重要概念，它们都是一种固定大小且相等的内存块（一般是4KB）。页用于指代虚拟内存，而帧用于指代物理内存。有效的页都可以映射到物理内存中的某个帧，即计算机会给每个正在运行的进程的每个页分配一个帧（不考虑多级页表）。</p><p>我们根据页查找到帧，然后根据帧号找到真实的物理内存：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-05-174425.png" style="zoom:40%;" /></p><p>页到帧的映射是如何进行的呢？接下来就引入了我们的页表。</p><h4 id="页表-一级页表寻址">页表 &amp; 一级页表寻址</h4><p>以 32 位操作系统为例，每个逻辑地址我们可以分成两部分：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-022601.png" style="zoom:50%;" /></p><ul><li>高 20 位比特：用于表示<strong>页编号（Page number）</strong>，大小从<span class="math inline">\(0\)</span> 到 <span class="math inline">\(2^ {20} - 1\)</span>。</li><li>低 12 位比特：用于表示<strong>页偏移地址（Offset inpage）</strong>，大小从 <span class="math inline">\(0\)</span> B 到<span class="math inline">\(2 ^ {12} - 1\)</span> B，说明每个页的大小为<span class="math inline">\(4\)</span> KB。</li></ul><p>操作系统为每个进程维护了一个<strong>页表（Pagetable）</strong>，每个<strong>页表项（PTE）</strong>如下：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-023128.png" style="zoom:80%;" /></p><ul><li><strong>高 20位比特表示页帧编号，对应的是物理地址的帧编号，即作为物理地址的高 20位比特</strong>。</li><li>后续几个域：<ul><li>P（Present）：一般用作有效位，即该页表项对应的帧是否在内存中。</li><li>W（Writeable）：表示页面是否可写。</li><li>U（User）：用于表示用户权限。</li><li>PWT（Page WriteTransparent）：用于指定页面级别的写透明策略（External cachewrite-through）。</li><li>PCD（Page Cache Disabled）：是否禁用高速缓存。</li><li>A（Accessd）：表示页面最近是否被访问过。</li><li>D（Dirty）：页面最近是否被修改过（只用于 PTE）。</li><li>L（Large）：指示操作系统和硬件是否使用大页面（LargePage）而不是标准的小页面（Small Page）来管理内存。</li></ul></li></ul><p><strong>如何根据逻辑地址加页表寻址</strong>？</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-032450.png" alt="Paging workflow" style="zoom:50%;" /></p><ol type="1"><li><p>根据逻辑地址的页编号，加上<strong>存储页表地址的寄存器</strong>存储的值就可以找到目标页编号对应的页表项；</p><blockquote><p>以 x86 架构为例子，CR3（Control Register3）用于管理分页机制。CR3寄存器主要用于存储页目录表的基地址（PageDirectory BaseAddress），它是分页机制中的重要组成部分，用于虚拟地址到物理地址的转换。</p></blockquote></li><li><p>页表项中的页帧号对应物理内存中的帧编号，加上逻辑地址的偏移值，即可映射到真实的物理地址。</p></li></ol><p>这种映射方式由许多<strong>优点</strong>：</p><ul><li><p><strong>消除了外部碎片</strong>，可能还会有内部碎片，但是对于 4KB的页面而言内部碎片不会造成多大的空间浪费；</p></li><li><p>易于实现；</p></li><li><p>易于保护和共享；</p></li><li><p>很容易分配物理内存，每次从空闲帧列表中选择一些帧进行分配即可。</p><blockquote><p>空闲帧列表（List of freeframes）是一个在操作系统内存管理中常见的数据结构，用于跟踪系统中哪些物理内存帧（或页面帧）当前是空闲的，可以用于分配给新的进程或任务。</p></blockquote></li></ul><p>于此同时也造成了一些<strong>问题</strong>：</p><ul><li><p><strong>页表太大（Page table size is too large）</strong>：</p><p>一个页表项一共 <span class="math inline">\(4\)</span>B，页面编号一共有 <span class="math inline">\(2 ^ {20}\)</span>个，每个进程都要维护一个 <span class="math inline">\(4 \times 2 ^{20}\)</span> B <span class="math inline">\(=\)</span> <spanclass="math inline">\(4\)</span> MB 的页表，如果当前系统有 1000个进程，则需要维护约 <span class="math inline">\(4\)</span> GB的页表，事实上每个进程有许多页面都是完全不使用的，造成了很大的空间浪费。</p></li><li><p><strong>内存访问慢（Memory access is slow）</strong>：</p><p>不同于之前的内存分区技术，页面映射需要通过页表进行内存访问，这样使得访问速度大打折扣。</p></li></ul><p>后文我们提及的<strong>多级页表</strong>和 <strong>TLB</strong>技术将解决这两个问题。</p><h4 id="页面交换-页面错误">页面交换 &amp; 页面错误</h4><h5 id="页面交换">页面交换</h5><p>我们不难注意到，当前 64位机器的逻辑内存远远大于实际的物理内存大小，那么当物理内存不够后，逻辑内存又是如何分配的呢？</p><p>事实上，物理内存中许多帧长期不会被使用，这样的帧操作系统会将其置换到磁盘中（这里可以类比进程的挂起），这样的技术称为<strong>页面交换（PageSwapping）</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-035909.png" alt="Page Swapping" style="zoom:35%;" /></p><p>回到刚刚的问题，当物理内存不够后，又要给新的逻辑地址分配帧时，又该如何做呢？</p><p>答案是：将当前物理内存中的闲置帧转移到磁盘中，给新的帧预留位置，然后对页表进行对应的更新，如下图所示（<ahref="https://www.bilibili.com/video/BV1924y1B7L7/?spm_id_from=333.788&amp;vd_source=8ba5b8b5f59444a6cbd4c3984325e82f">图源：B站</a>）。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-040903.png" alt="" style="zoom:40%;" /></p><p><strong>帧锁定（Frame Locking）</strong></p><p>注意，不是所有帧都可以被置换到磁盘，有些特殊的帧会被锁定而无法被置换到磁盘，比如：</p><ul><li>系统内核</li><li>I/O 缓存</li><li>...</li></ul><h5 id="页面错误">页面错误</h5><p>如果某时刻，进程需要访问某个页面，如果发现该页面对应的帧不在内存中，这个时候就会触发<strong>页面错误（Pagefault）</strong>。至于这个页面是否在内存中，由前文提到的 PTE中的比特位「P」决定。</p><p>页面错误主要有两种：</p><ul><li><p><strong>Major Page Fault（主要页面错误）</strong></p><p>进程尝试访问虚拟内存中的页面，但该页面尚未在物理内存中。一般是我们在上文提到的已加载的页面因为换出到磁盘而不再在物理内存中。</p></li><li><p><strong>Minor Page Fault（次要页面错误）</strong></p><p>次要页面错误是发生在虚拟内存系统中的一种事件。当一个进程尝试访问当前不在其<strong>转换后备缓冲器（TLB，这个一会会讲）</strong>中但实际上已经加载到物理内存中的页时，就会发生轻微页面错误。换句话说，这意味着所需的数据是在内存中的，只是没有在快速查找的硬件缓存中记录。</p></li></ul><p>这里我们说说主要页面错误的处理流程：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-044029.png" style="zoom:45%;" /></p><ol type="1"><li>处理器读取到进程访问逻辑地址的请求，将地址传送至内存管理单元（MMU，MemoryManagement Unit），通过页面编号找到对应的页表项，通过其判断位「P」为0，说明其对应物理帧不在内存中，触发了一个页面错误；</li><li>接着将信息传达给操作系统的页面错误处理器，从磁盘找到对应的物理帧；</li><li>找到对应帧后，将数据加载到内存中；</li><li>更新对应的页表项；</li></ol><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-044930.png" style="zoom:45%;" /></p><ol start="5" type="1"><li>完成上述步骤后，页面错误处理器通知调度器，重新进行调度。</li></ol><p><strong>常规保护错误（GPF）</strong></p><p><strong>常规保护错误（General ProtectionFault）</strong>是一种计算机硬件或操作系统的错误，它表示发生了一种无法处理的保护性异常。通常情况下，GPF会导致程序崩溃，操作系统终止程序的执行，并通常会生成错误报告以记录问题。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-050037.png" style="zoom:45%;" /></p><p>如果是<strong>用户级进程触发 GPF，则操作系统会将该进程kill</strong>，如果是<strong>内核级的进程，则可能导致系统崩溃而重启</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-050147.png" alt="GPF" style="zoom:50%;" /></p><h4 id="多级页表">多级页表</h4><p>前文我们提到，如果使用一级页表结构，则每个进程都要维护一个包含大约100 万个 PTE的页表，十分占用空间。为了解决这个问题，现代操作系统中一般使用多级页表结构。</p><h5 id="二级页表">二级页表</h5><p>二级页表引入了<strong>页表目录（PageDirectory）</strong>的概念，即很多个页表会被存储在一个页表目录中，处理器寻址时先通过页表目录找到逻辑地址对应的目录，然后找到目录中对应的页表，最后找到页表中的目标页表项，实现多级索引。</p><p>以 32位操作系统为例，在二级页表目录中，一个逻辑地址可以被划分如下：</p><table><thead><tr class="header"><th>10 bits</th><th>10 bits</th><th>12 bits</th></tr></thead><tbody><tr class="odd"><td>Directory Index</td><td>Page Table Index</td><td>Offset in page</td></tr></tbody></table><p><strong>寻址过程</strong>：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-055334.png" style="zoom:67%;" /></p><ol type="1"><li>根据逻辑地址高 10 位比特（31 ～22）的目录索引，与基地址寄存器的值（页表目录的起始地址）相加，得到目标PDE 的值；</li><li>目标 PDE 的高 20 位比特表示页表的编号，逻辑地址中间 10 位比特（21 ～12）表示页表项的索引，从而可以找到目标 PTE；</li><li>目标 PTE 的高 20 位比特表示目标物理帧的编号，加上逻辑地址最后 12个比特表示的偏置，即可得到最后的地址。</li></ol><p><strong>为什么二级页表可以节省空间呢</strong>？</p><p>让我们来算一算，对于每个进程而言，需要维护一个页表目录，页表目录一共有有<span class="math inline">\(2 ^ {10}\)</span> 个 PDE，每个 PDE 大小为<span class="math inline">\(4\)</span> B，因此总大小为 <spanclass="math inline">\(4 \times 2 ^ {10}\)</span> B = <spanclass="math inline">\(4\)</span>KB。接下来，我们根据程序内存需求给页表目录分配页表即可。因此对于每一个进程，需要维护的最小内存就只有<span class="math inline">\(4\)</span>KB，相对于一级页表足足小了近一千倍。</p><p>事实上，如果进程内存分配比较密集，就意味着有大量的 PDE是不需要分配页表项的。</p><h5 id="三级页表-四级页表">三级页表 &amp; 四级页表</h5><p>三级页表和四级页表通常用于 64 位操作系统，特别是在 x86_64 或 AMD64架构中。这是因为 64 位操作系统能够访问非常大的虚拟地址空间，通常超过了32位操作系统的限制。为了有效地管理如此大的虚拟内存空间，需要更多级的页表来进行地址映射和管理。</p><p>事实上它们的原理和二级页表差不多，无非就是多了几层映射罢了。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-061913.png" alt="3-Level Paging" style="zoom:50%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-062030.png" alt="4-Level Paging" style="zoom:70%;" /></p><p>引入多级页表后，我们解决了进程页表空间过大的问题，但我们还没有解决寻址速度慢的问题，而且随着访问级数的增加，访问慢的问题甚至被加剧了。为了解决这个问题，人们又提出了<strong>TLB</strong> 技术。</p><h4 id="tlb">TLB</h4><h5 id="tlb-介绍">TLB 介绍</h5><p>TLB（Translation LookasideBuffer），是计算机体系结构中的一个关键硬件组件，<strong>用于加速虚拟内存到物理内存的地址转换过程</strong>。TLB是<strong>全关联高速缓存（FullyAssociativeCache）</strong>的一种，专门用于存储最近执行的虚拟地址到物理地址的映射关系，以提高内存访问速度。</p><blockquote><p>Fully associativecache（全关联高速缓存）是一种高速缓存（Cache）的组织结构，其中缓存中的每个数据块可以存储在任何位置，而不受特定的缓存行或集的限制。与其他类型的高速缓存结构相比，全关联高速缓存提供了更大的灵活性，但通常需要更复杂的硬件来实现。</p></blockquote><p>TLB存储了虚拟地址到物理地址的映射表项。每个表项包括<strong>虚拟地址</strong>、<strong>物理地址</strong>和其他控制信息。当处理器执行内存访问指令时，它会首先检查TLB，看是否存在所需的映射，如果存在，就会使用 TLB中的映射进行地址转换（<strong>TLBhit</strong>），否则，它将访问主内存或页表来获取映射（<strong>TLBmiss</strong>），使用页表映射获取物理内存后回过头来更新TLB，下一次访问同一个进程的同一页只需要访问 TLB 就行。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-063754.png" style="zoom:50%;" /></p><p>当操作系统进行进程<strong>上下文切换</strong>时，TLB通常会被刷新。这是因为不同的进程具有不同的虚拟地址空间，因此之前在 TLB中的虚拟地址到物理地址的映射不再有效。切换到新的进程时，TLB需要被清空，以确保新进程的地址映射生效。</p><p><strong>现代操作系统寻址过程</strong>：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-070137.png" style="zoom:60%;" /></p><h5 id="引用局部性">引用局部性</h5><p>尽管 TLB 可以提高 CPU 访问逻辑地址的速度，但 TLB能存储的空间非常小，远小于实际内存大小，它是如何实现一个全局加速效果的呢？</p><p><strong>引用局部性（Locality ofreference）</strong>是计算机科学和计算机体系结构中的一个重要概念，用于描述在程序访问内存或数据时的一种观察现象。引用局部性指的是程序在一段时间内倾向于多次访问相邻的内存地址或数据元素，而不是随机分散地访问内存。</p><p>引用局部性通常分为两种主要类型：</p><ol type="1"><li><strong>时间局部性（TemporalLocality）</strong>：时间局部性表示程序在短时间内多次访问相同的内存地址或数据元素。这意味着一旦程序访问了某个内存位置，它可能会在不久的将来再次访问相同的位置。这种情况下，缓存（如TLB等）可以有效地提高性能，因为它们可以<strong>保存最近访问的数据</strong>，以供稍后的访问使用。</li><li><strong>空间局部性（SpatialLocality）</strong>：空间局部性表示程序在访问一个内存地址或数据元素时，可能会紧接着访问相邻的内存地址或数据元素。这意味着程序倾向于连续地访问内存位置，而不是跳跃式地访问。空间局部性有助于高效地使用缓存，因为缓存<strong>可以将相邻的数据块一起加载</strong>，从而提高数据的有效性。</li></ol><p>这是一个统计意义上的概念，其很好解释了 TLB 的加速原理。</p><p><strong>几个问题</strong></p><ul><li><p>页面大小对寻址速度的影响？</p><p>页面越大，其包含的内存就越大，则可以减少 TLB miss的数量，可以加快页面映射的速度。</p></li><li><p>缓存慢之后如何更新 TLB 的条目？</p><p>采用 FIFO 算法进行调度，保证 TLB存储的页面中永远有最新访问的。</p></li></ul><h5 id="做一个小测试">做一个小测试</h5><p>为了测试 TLB 对运行效率的影响，我们准备以下两段程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo_1.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">10000</span>][<span class="hljs-number">10000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>            arr[i][j] = i + j;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <br>    std::chrono::duration&lt;<span class="hljs-type">double</span>&gt; elapsed = end - start;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;耗时: &quot;</span> &lt;&lt; elapsed.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 秒&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// demo_2.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><br><span class="hljs-type">int</span> arr[<span class="hljs-number">10000</span>][<span class="hljs-number">10000</span>];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10000</span>; j++) &#123;<br>            arr[j][i] = i + j;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <br>    std::chrono::duration&lt;<span class="hljs-type">double</span>&gt; elapsed = end - start;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;耗时: &quot;</span> &lt;&lt; elapsed.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot; 秒&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码中，二者唯一的区别就是循环的顺序不一样，<code>demo_1.cpp</code>内层循遍历数组第二维，外层循环遍历数组第一维，<code>demo_2.cpp</code>反之。</p><p>接下来我们比较二者的运行效率，在这里我们使用 <code>-O0</code>参数保证 <code>g++</code> 编译器不对程序做过多优化。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-162921.png" style="zoom:67%;" /></p><p>注意到两段几乎一样的代码，<code>demo_1.cpp</code> 比<code>demo_2.cpp</code> 快了一倍不止。</p><p>这是为什么呢？</p><p>总所周知，在 C/C++中，所有的二维数组本质上还是一维数组，即它们所有行在空间上都是连续的，如果我像<code>demo_1.cpp</code>那样先进行行遍历，然后进行列遍历，就意味着当进程第一次访问<code>arr[i][j]</code> 出现次要页面错误后会将其所在页放置在 TLB缓存中，之后对 <code>arr[i][j + 1]</code> 、<code>arr[i][j + 2]</code>... 这些在同一个页面的地址数据的访问都会触发 TLBhit，就不需要再进行一轮页面映射操作了。而对于 <code>demo_2.cpp</code>而言，其先遍历列，然后遍历行，<code>arr[j][i]</code> 和<code>arr[j + 1][i]</code> 不在同一个页面内，因此每一次访问都会触发 TLBmiss，从而只能进行页面映射找到对应的物理帧，效率远低于<code>demo_1.cpp</code>。</p><h4 id="thrashing">Thrashing</h4><p><strong>Thrashing</strong>通常用来描述在虚拟内存系统中的一种严重性能问题。Thrashing指的是操作系统不断地将页面从物理内存交换到磁盘，然后再将其换回物理内存，不断地重复这个过程。这种情况导致系统的性能急剧下降，因为大部分时间都用于页面交换，而不是执行实际的计算任务。Thrashing一般发生在<strong>工作集（WorkingSet）</strong>不在内存中从而导致<strong>页面错误率（Page FaultRate）</strong>高的情况。</p><blockquote><p>WorkingSet（工作集）是计算机内存管理领域的一个重要概念，它用于描述<strong>一个进程或应用程序在一段时间内所活跃地使用的物理内存中的一组页面或内存块</strong>。工作集有助于了解进程的内存访问模式，以便更好地管理内存资源并优化性能。</p></blockquote><p>除此之外，页面大小也可以影响页面错误率：</p><ul><li>小页面：在主存中会发现大量的页面随着执行过程中时间的推移将包含进程中靠近最近引用的部分，从而导致低页面错误率。</li><li>大页面：导致页面包含远离最近引用的位置，从而导致高页面错误率。</li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-080949.png" style="zoom:50%;" /></p><p><strong>当一个进程在 Paging上花费的时间比程序本身执行的时间要长，我们就可以称这个进程处于 Thrashing状态</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-06-075920.png" alt="Thrashing 状态下系统资源基本用于 Paging，导致处理器的执行使用率低" style="zoom:67%;" /></p><p>解决 Thrashing 的方案：</p><ol type="1"><li><p>增加物理内存；</p></li><li><p>进程的页按需分配；</p></li><li><p>使用更高效的页面替换策略（如 LRU 或 LFU 等）。</p><blockquote><p>LRU（Least RecentlyUsed）是一种常见的页面置换算法，用于管理计算机系统中的高速缓存或虚拟内存中的页面。LRU算法的目标是<strong>确定哪个页面最久没有被访问，并将其替换掉，以便给新的页面或数据腾出空间</strong>。</p><ul><li>如何实现？—— 比如利用 x86 32 位 PTE 中的比特位「A」</li></ul></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>内存管理</tag>
      
      <tag>MMU</tag>
      
      <tag>页表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>N-gram: 最早的语言模型</title>
    <link href="/2023/11/01/N-gram-%E6%9C%80%E6%97%A9%E7%9A%84%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/11/01/N-gram-%E6%9C%80%E6%97%A9%E7%9A%84%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>N-gram模型是自然语言处理（NLP）中一种常用的语言模型。它基于一个假设：一个词出现的概率仅依赖于它前面的有限个词。这种模型用于文本数据的各种任务，如语言模型构建、文本生成、拼写检查和机器翻译。</p><p class="note note-info">N-gram 模型的概念最早可以追溯到 20世纪初。这一概念的早期形式出现在安德烈·马尔可夫（AndreyMarkov）的工作中，他是一位俄罗斯数学家，以马尔可夫链著称。马尔可夫在1913 年发表了一篇论文，其中介绍了马尔可夫链的概念，这可以被视为 N-gram模型的一个早期形式。在马尔可夫的工作之后，20 世纪 40 年代和 50年代，信息论的先驱如克劳德·香农（ClaudeShannon）开始探索语言建模和信息内容的概念。香农在他的开创性论文中使用了类似于N-gram 的概念来建模和分析语言结构，尽管他没有直接使用“N-gram”这个术语。</p><h4 id="模型说明">模型说明</h4><p>在 N-gram 模型中，我们通过文本分割近似成连续的 n 个词的组合（即N-gram），来近似描述词汇序列的联合概率。</p><p>以句子 <code>I love that cat</code> 为例子：</p><table><thead><tr class="header"><th>N</th><th>名称</th><th>文本组合</th></tr></thead><tbody><tr class="odd"><td>1</td><td>Unigram</td><td><code>I</code> <br><code>love</code> <br><code>that</code><br><code>cat</code></td></tr><tr class="even"><td>2</td><td>Bigram</td><td><code>I</code> <code>love</code> <br/><code>love</code><code>that</code> <br/><code>that</code> <code>cat</code></td></tr><tr class="odd"><td>3</td><td>Trigram</td><td><code>I</code> <code>love</code> <code>that</code><br><code>love</code> <code>that</code> <code>cat</code></td></tr><tr class="even"><td>...</td><td>...</td><td>...</td></tr></tbody></table><p>N-gram 模型中假设一个词出现的概率只取决于前 <spanclass="math inline">\(n - 1\)</span> 个词，数学概率表示如下： <spanclass="math display">\[P(W_i | W_{i - 1}, W_{i - 2}, ..., W_{i - n + 1})\]</span> N-gram 流程：</p><ol type="1"><li>构建实验语料库，将句子分为 <span class="math inline">\(N\)</span> 个"gram"</li><li>统计每个 N-gram 出现的频率</li><li>输入一个前缀，根据之前计算过的词频预测后文</li></ol><h4 id="代码实现">代码实现</h4><h5 id="分词">分词</h5><p>分词，就是将给定的句子分成一个个基本单位 "gram"，也称为 "token"。</p><p>Python 中常用的分词工具有<code>NLTK</code>（英文）、<code>jieba</code>（中文）等。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> jieba<br><br>text = <span class="hljs-string">&#x27;世界上只有一种英雄主义，就是看清生活的真相之后依然热爱生活&#x27;</span><br><br>tokens = jieba.cut(text) <span class="hljs-comment"># 返回分词结果的迭代器</span><br><span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> tokens:<br>    <span class="hljs-built_in">print</span>(token)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">世界<br>上<br>只有<br>一种<br>英雄主义<br>，<br>就是<br>看清<br>生活<br>的<br>真相<br>之后<br>依然<br>热爱生活<br></code></pre></td></tr></table></figure><h5 id="计算词频">计算词频</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict, Counter<br><span class="hljs-keyword">import</span> jieba<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">n_grams_prob</span>(<span class="hljs-params">dataset: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; defaultdict(Counter):<br>    n_grams_prob = defaultdict(Counter)<br>    <span class="hljs-keyword">for</span> sent <span class="hljs-keyword">in</span> dataset:<br>        tokens = <span class="hljs-built_in">list</span>(jieba.cut(sent))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(tokens) - n + <span class="hljs-number">1</span>):<br>            n_gram = <span class="hljs-built_in">tuple</span>(tokens[i : i + n])<br>            prefix = n_gram[: -<span class="hljs-number">1</span>]<br>            suffix = n_gram[-<span class="hljs-number">1</span>]<br>            n_grams_prob[prefix][suffix] += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> prefix, cnt <span class="hljs-keyword">in</span> n_grams_prob.items():<br>        total_sum = <span class="hljs-built_in">sum</span>(cnt.values())<br>        <span class="hljs-keyword">for</span> suffix <span class="hljs-keyword">in</span> cnt:<br>            cnt[suffix] /= total_sum<br><br>    <span class="hljs-keyword">return</span> n_grams_prob  <br></code></pre></td></tr></table></figure><p>以以下数据集为例子，使用 Bigram：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">dataset = [<br>    <span class="hljs-string">&#x27;今天天气真好。&#x27;</span>,<br>    <span class="hljs-string">&#x27;今天天气怎么样？&#x27;</span>,<br>    <span class="hljs-string">&#x27;今天天气很晴朗。&#x27;</span>,<br>    <span class="hljs-string">&#x27;今天天气很阴沉。&#x27;</span>,<br>    <span class="hljs-string">&#x27;今天的天气很晴朗。&#x27;</span>,<br>    <span class="hljs-string">&#x27;今天的天气很好！&#x27;</span>,<br>    <span class="hljs-string">&#x27;你觉得今天的天气怎么样？&#x27;</span>,<br>    <span class="hljs-string">&#x27;今天的天气太好了！&#x27;</span><br>]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    bigram_prob = n_grams_prob(dataset=dataset, n=<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">for</span> prefix, distribution <span class="hljs-keyword">in</span> bigram_prob.items():<br>        <span class="hljs-built_in">print</span>(prefix, distribution)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">(&#x27;今天天气&#x27;,) Counter(&#123;&#x27;很&#x27;: 0.5, &#x27;真&#x27;: 0.25, &#x27;怎么样&#x27;: 0.25&#125;)<br>(&#x27;真&#x27;,) Counter(&#123;&#x27;好&#x27;: 1.0&#125;)<br>(&#x27;好&#x27;,) Counter(&#123;&#x27;。&#x27;: 0.5, &#x27;！&#x27;: 0.5&#125;)<br>(&#x27;怎么样&#x27;,) Counter(&#123;&#x27;？&#x27;: 1.0&#125;)<br>(&#x27;很&#x27;,) Counter(&#123;&#x27;晴朗&#x27;: 0.5, &#x27;阴沉&#x27;: 0.25, &#x27;好&#x27;: 0.25&#125;)<br>(&#x27;晴朗&#x27;,) Counter(&#123;&#x27;。&#x27;: 1.0&#125;)<br>(&#x27;阴沉&#x27;,) Counter(&#123;&#x27;。&#x27;: 1.0&#125;)<br>(&#x27;今天&#x27;,) Counter(&#123;&#x27;的&#x27;: 1.0&#125;)<br>(&#x27;的&#x27;,) Counter(&#123;&#x27;天气&#x27;: 1.0&#125;)<br>(&#x27;天气&#x27;,) Counter(&#123;&#x27;很&#x27;: 0.5, &#x27;怎么样&#x27;: 0.25, &#x27;太好了&#x27;: 0.25&#125;)<br>(&#x27;你&#x27;,) Counter(&#123;&#x27;觉得&#x27;: 1.0&#125;)<br>(&#x27;觉得&#x27;,) Counter(&#123;&#x27;今天&#x27;: 1.0&#125;)<br>(&#x27;太好了&#x27;,) Counter(&#123;&#x27;！&#x27;: 1.0&#125;)<br></code></pre></td></tr></table></figure><h5 id="根据前缀预测后文">根据前缀预测后文</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">next_tokens</span>(<span class="hljs-params">n_grams_prob: defaultdict(<span class="hljs-params">Counter</span>), prefix: <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-built_in">str</span>:<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;&#x27;</span>.join(prefix)<br>    <span class="hljs-keyword">while</span> prefix <span class="hljs-keyword">in</span> n_grams_prob:<br>        next_tokens_prob = n_grams_prob[prefix]<br>        next_token = <span class="hljs-built_in">max</span>(next_tokens_prob, key=next_tokens_prob.get)<br>        <span class="hljs-keyword">yield</span> next_token<br>        prefix = (*prefix[<span class="hljs-number">1</span> :], next_token)<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;\n&#x27;</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    bigram_prob = n_grams_prob(dataset=dataset, n=<span class="hljs-number">2</span>)<br><br>    prefix = (<span class="hljs-string">&#x27;今天&#x27;</span>, )<br>    <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> next_tokens(n_grams_prob=bigram_prob, prefix=prefix):<br>        <span class="hljs-built_in">print</span>(token, end=<span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">今天的天气很晴朗。<br></code></pre></td></tr></table></figure><h4 id="n-gram-的优点和局限">N-gram 的优点和局限</h4><ul><li>优点：模型简单，易于实现。</li><li>缺点：无法捕捉到长距离的词汇关系。</li></ul><p class="note note-info">虽然 N-gram局限性较大，但它启发了后来许多更强大的自然语言处理技术，具有启程碑意义。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NLP</tag>
      
      <tag>N-gram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>循环神经网络 RNN</title>
    <link href="/2023/10/30/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/10/30/%E5%BE%AA%E7%8E%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>时序神经网络</strong></p><p><strong>时序神经网络（Time Series Neural Networks,TSNN）</strong>并不是一个特定的神经网络类型，而是指那些用于处理时间序列数据的神经网络。这种数据具有<strong>时间顺序</strong>的特点，如自然语言、股票价格、气象数据、音频信号、视频帧等。常见的时序神经网络有RNN、LSTM、GRU、1D CNN 等等。</p><p>设想接下来一个场景：我们设计了一个自动购票系统，我们根据用户输入的语句自动判断其起点、终点以及出发时间。</p><blockquote><p>Input：</p><ul><li>I wish to go to <strong>Changsha</strong> from<strong>Beijing</strong> on <strong>December 12th</strong></li></ul><p>Output：</p><ul><li>Time：12.12</li><li>From：Beijing</li><li>To：Changsha</li></ul></blockquote><p>在该系统中，用户的输入被认为是具有时序性的，即 3个关键词通过不同的组合或使用句势语法结构可能影响到输出的结果。</p><p>因此，我们需要一个能够处理时序信息的神经网络。</p><h4 id="rnn">RNN</h4><p><strong>循环神经网络（Recurrent Neural Networks,RNN）</strong>，也叫递归神经网络，它的关键思想是利用网络的循环链接来储存之前时间步的信息。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-01-051304.png" style="zoom:67%;" /></p><p>在 RNN中，会有一个记忆单元，每次存储上一次隐藏层的输出，然后在下一次输入时使用该记忆单元中的向量。</p><p>其更新方式通常为： <span class="math display">\[a_t = \sigma(W_{xa} x_t + W_{aa} a_{t - 1} + b_a)\]</span> 其中，<span class="math inline">\(x_t\)</span> 是时间步 <spanclass="math inline">\(t\)</span> 的输入，<spanclass="math inline">\(a_{t - 1}\)</span> 是上一个时间步的隐藏状态，<spanclass="math inline">\(W_{xa}\)</span>、<spanclass="math inline">\(W_{aa}\)</span> 表示权重矩阵，<spanclass="math inline">\(b_a\)</span> 表示一个偏置，<spanclass="math inline">\(\sigma\)</span> 在这里是一个激活函数。</p><p>RNN 神经网络早期有两种主要形式，分别是 Elman 神经网络和 Jordan神经网络，这两种网络在 90 年代初由 Jeffrey Elman 和 Michael I. Jordan分别提出。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-01-054527.png" alt="左：Elman NN 右：Jordan NN" style="zoom:50%;" /></p><ul><li>Elman网络是一种三层网络，包括输入层、隐藏层和输出层。其特点是隐藏层的输出（即隐藏状态）被反馈到一个特殊的上下文单元，然后在下一个时间步，这些上下文单元作为额外的输入供给隐藏层。</li><li>Jordan 网络与 Elman 网络非常相似，但它们的循环连接方式有所不同。在Jordan网络中，输出层的值被反馈到上下文单元，然后这些上下文单元作为额外的输入提供给隐藏层。</li></ul><h4 id="bptt">BPTT</h4><p>BPTT（Backpropagation ThroughTime）是一种特殊的反向传播算法，用于训练时间序列数据上的循环神经网络（RNN）。由于RNN 的特殊结构，标准的反向传播算法不能直接应用于它们。BPTT是对反向传播的一个扩展，使其适用于处理 RNN 的时间依赖性。</p><p>接下来我们举一个具体的例子，来说说 BPTT 是如何计算的。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2024-01-12-021505.png" style="zoom:50%;" /></p><p>假设在上述 RNN 网络中，输入层、输出层、隐藏层和参数矩阵 <spanclass="math inline">\(U\)</span>、<spanclass="math inline">\(W\)</span>、<span class="math inline">\(V\)</span>的大小定义如下： <span class="math display">\[\begin{array}{}x_t \in R ^ n \\h_t \in R ^ d \\\hat y_t \in R ^ k \\U \in R ^ {n \times d} \\V \in R ^ {d \times k} \\W \in R ^ {d \times d}\end{array}\]</span> 其中： <span class="math display">\[\begin{array}{}h_t = \delta(x_t U + h_{t - 1} W + b_W) \\\hat y_t = \delta(h_t V + b_V)\end{array}\]</span> <span class="math inline">\(\delta(\cdot)\)</span>在这里是激活函数。</p><p>假设损失函数是 <span class="math inline">\(f(\hat y_t,y_t)\)</span>，则我们可以认为到 <span class="math inline">\(T\)</span>时刻为止，总损失值 <span class="math inline">\(L = \frac{\sum_{t = 0} ^T L_t}{T + 1} =\frac{\sum_{t = 0} ^ T f(\hat y_t, y_t)}{T +1}\)</span>。</p><p>在上图中可学习参数一共有 5 个：<spanclass="math inline">\(U\)</span>、<spanclass="math inline">\(W\)</span>、<spanclass="math inline">\(V\)</span>、<spanclass="math inline">\(b_W\)</span> 和 <spanclass="math inline">\(b_V\)</span>。</p><p>其中，<span class="math inline">\(V\)</span> 和 <spanclass="math inline">\(b_V\)</span>的梯度计算与经典的梯度下降算法没有什么区别，其只在输出层使用，不参与隐藏层的计算。</p><p>而对于 <span class="math inline">\(U\)</span>、<spanclass="math inline">\(W\)</span> 和 <spanclass="math inline">\(b_W\)</span>而言，其梯度的计算则会复杂很多。这里我们以 <spanclass="math inline">\(\nabla_{W} L_t\)</span> 为例，来介绍 BPTT的具体计算过程：</p><p>根据 RNN 网络的计算规则，我们可以得到隐藏层和输出层的计算图：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2024-01-12-025400.png" style="zoom:50%;" /></p><p>根据链式法则，<span class="math inline">\(L_t\)</span> 关于 <spanclass="math inline">\(W\)</span> 的偏导等于计算图上所有 <spanclass="math inline">\(W\)</span> 到 <spanclass="math inline">\(L_t\)</span> 的路径偏导之和： <spanclass="math display">\[\nabla_W L_t = \frac{\partial L_t}{\partial y_t} \frac{\partialy_t}{\partial h_t} \sum_{k = 0} ^ {t - 1} \frac{\partial h_k}{\partialW} \prod_{i = k} ^ {t - 1} \frac{\partial h_{i + 1}}{\partial h_i}\]</span> 由此可见，BPTT 的计算中会引入大量的矩阵连乘，这使得传统 RNN在长距离依赖序列的梯度计算上容易出现<strong>梯度消失</strong>和<strong>梯度爆炸</strong>的问题。</p><h4 id="传统-rnn-面临的问题">传统 RNN 面临的问题</h4><ol type="1"><li><strong>梯度消失（Vanishing Gradients）</strong><ul><li><strong>描述</strong>：当神经网络反向传播过程中的梯度值变得非常小，以至于权重几乎不更新，这种情况被称为梯度消失。</li><li><strong>原因</strong>：主要因为链式法则和非线性激活函数。例如，当使用sigmoid 或 tanh 激活函数时，如果输入值过大或过小，其导数会趋近于0，多层网络中这种小导数的<strong>连乘</strong>会导致整体的梯度非常小。</li><li><strong>结果</strong>：深度神经网络的低层（接近输入层的层）权重更新非常缓慢，导致训练过程停滞。</li></ul></li><li><strong>梯度爆炸（Exploding Gradients）</strong><ul><li><strong>描述</strong>：神经网络反向传播过程中的梯度值变得非常大，使权重更新过大，这种情况被称为梯度爆炸。</li><li><strong>原因</strong>：与梯度消失类似，梯度爆炸也与链式法则有关。但在这种情况下，网络中的梯度值大于1，多层网络中这些大梯度值的<strong>连乘</strong>导致整体的梯度变得非常大。</li><li><strong>结果</strong>：权重更新过大，可能导致网络不稳定，损失函数值震荡或发散。</li><li><strong>解决方案</strong>：常见的解决方案有<strong>梯度裁剪（GradientClipping）</strong>，即给反向传递的梯度设定一个阈值 <spanclass="math inline">\(M\)</span>，若梯度的模长超过了该阈值，则减小梯度到合适大小的值。</li></ul></li></ol><p>不难发现：上述提及的梯度消失和梯度爆炸都是由一个原因导致的，那就是传统RNN神经网络中，<strong>如果时间序列过长，可能造成隐藏层中大梯度值的连乘</strong>，指数级的增长或衰减很可能造成梯度爆炸或梯度消失。</p><h4 id="代码实现">代码实现</h4><p>PyTorch 提供了 <code>nn.RNN</code>模块，用于构建循环神经网络（RNN）。</p><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRNN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, hidden_size, output_size</span>):<br>        <span class="hljs-built_in">super</span>(SimpleRNN, self).__init__()<br>        self.rnn = nn.RNN(input_size, hidden_size, batch_first=<span class="hljs-literal">True</span>)<br>        self.fc = nn.Linear(hidden_size, output_size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-comment"># x shape: (batch, seq_length, input_size)</span><br>        out, hidden = self.rnn(x)<br>        <span class="hljs-comment"># 只使用最后一个时间步的输出</span><br>        out = self.fc(out[:, -<span class="hljs-number">1</span>, :])<br>        <span class="hljs-keyword">return</span> out<br></code></pre></td></tr></table></figure><p><strong>主要参数</strong></p><p><code>nn.RNN</code> 的主要参数包括：</p><ul><li><code>input_size</code> ：输入特征的维度。</li><li><code>hidden_size</code> ：隐藏层的维度，即隐藏状态的大小。</li><li><code>num_layers</code> ：RNN 的层数，默认为1。</li><li><code>nonlinearity</code> ：激活函数的类型，可以是<code>'tanh'</code> 或 <code>'relu'</code>，默认是<code>'tanh'</code>。</li><li><code>batch_first</code> ：如果为<code>True</code>，则输入和输出的张量的形状为<code>(batch, seq, feature)</code>，默认为 <code>False</code>，即<code>(seq, batch, feature)</code>。</li><li><code>dropout</code>：如果不为零，则在除最后一层外的每层后添加一个Dropout层。</li><li><code>bidirectional</code> ：如果为 <code>True</code>，则使用双向RNN，默认为 <code>False</code>。</li></ul>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>NLP</tag>
      
      <tag>深度学习</tag>
      
      <tag>时序神经网络</tag>
      
      <tag>RNN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层——流量控制</title>
    <link href="/2023/10/29/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/10/29/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E2%80%94%E2%80%94%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="为什么需要流量控制">为什么需要流量控制 ？</h4><p><strong>流量控制（Flowcontrol）</strong>是链路层中主要功能之一，主要目的是确保发送方不会溢出接收方的缓冲区。这是一种防止发送方发送太多数据给接收方，后者来不及处理的机制。</p><h3 id="流量控制协议">流量控制协议</h3><h4 id="乌托邦协议">乌托邦协议</h4><p><strong>乌托邦协议（Utopian simplexprotocol）</strong>是最理想状态下的传输协议，此协议有以下假设：</p><ul><li>单工信道（Simplex channel）</li><li>信道无错（Error-free），即不会发生帧错误</li><li>接收方有不受限制的缓存（Unlimitied buffers）</li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-29-083125.png" alt="Utopian simplex protocol" style="zoom:50%;" /></p><p>乌托邦协议是非常理想的协议，正如其名字一样，实际的链路层通信是完全不一样的，由于接收方缓存有限，且信道的差错无可避免，我们需要考虑<strong>流量控制</strong>和<strong>差错控制</strong>。</p><p><strong>ARQ</strong></p><p>自动重传请求（Automatic Repeat reQuest，简称ARQ）是一种用于数据通信中的错误控制方法。当传输的数据帧在接收端被检测到有错误时，ARQ协议会要求发送端重新发送该帧。这种机制确保了数据的完整性和正确性。ARQ通常与前向纠错编码（FEC）相结合，后者允许在不重新发送数据的情况下纠正错误。</p><p>接下来要介绍的停等协议和滑动窗口协议，都属于 ARQ。</p><h4 id="停等协议">停等协议</h4><p><strong>停等协议（Stop-and-Waitprotocol）</strong>引入了<strong>应答（ACK）</strong>的概念，每次发送方发出一个数据帧后，接收方接受数据帧，如果接受成功就会发送一个应答（ACK），只有发送方接收到ACK 后才会发送下一个数据帧。如果发送方长时间没有收到ACK，则其会认为接收方没有收到目标数据帧，就会重新发送该数据帧。</p><blockquote><p>有些协议中可能会有<strong>否定应答（NAK）</strong>，即接收方收到数据，通过纠错码（如CRC）判断数据出错后会向发送方发送 NAK，发送方收到 NAK后则会重新发送数据帧。</p></blockquote><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-29-173121.png" style="zoom:67%;" /></p><p>以上展示了停等协议的四种主要情况，在情况（d）中，发送方没有成功接收到接收方的ACK，其认定数据帧传输失败，于是重新传输数据帧，造成了<strong>数据冗余（Duplication）</strong>。</p><p>为了解决 ACK Lost 的问题，我们引入了 SN（Sequence number）编号。</p><p>在停等协议中，帧和 ACK 的 SN 编号只需要 1 个 bit即可，具体操作如下：</p><p><strong>发送方按照奇偶次序依次发送 SN 编号为 0 和 1的帧，接收方则在收到发送方的信号后返回对应的 ACK</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-29-174053.png" style="zoom:50%;" /></p><p>使用 SN 编号的停等协议就可以解决之前提到的全部问题了。</p><ul><li><p><strong>数据帧丢失（Frame gets lost）</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-29-174847.png" style="zoom:50%;" /></p></li><li><p><strong>ACK 丢失（ACK Lost）</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-29-174823.png" style="zoom:67%;" /></p></li><li><p><strong>ACK 延迟（ACK Delayed）</strong></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-29-175118.png" style="zoom:67%;" /></p><blockquote><p>注：<strong>ACK 也必须要有 SN编号</strong>，如果只对数据帧编号，则上图的接收方在收到 Frame 0的重传递后会发送一个一样的 ACK，若发送方发送了 Frame 1且接收方没有收到，则发送会误判接收方成功收到了 Frame 0 和 Frame1，实际上接收方只收到了 Frame 0。</p></blockquote></li></ul><p><strong>计时器（Timer）</strong>：</p><p>一般而言，发送方会设置一个固定的 Timeout interval，一旦在发送目标帧 i后如果没有在规定的时间内收到 ACK（i），则会重新发送数据帧i，这个时间段不宜过短，如果太短，可能导致发送方发送过多不必要的数据帧；也不宜过长，不然会导致数据接收的响应慢。</p><p><strong>停等协议的优缺点</strong></p><p><strong>优点：</strong></p><ol type="1"><li><strong>简单性（Easy toimplement）</strong>：停等协议的结构简单，容易实现。对于需要简单可靠数据传输的应用，该协议可能是合适的。</li><li><strong>完整性（Integrity）</strong>：由于每次只发送一个数据帧并等待确认，所以在低误差率的通信环境中，可以确保数据的完整性。</li></ol><p><strong>缺点：</strong></p><ol type="1"><li><strong>低效率（Lowefficiency）</strong>：在高带宽或大延迟的通信环境中，停等协议的效率可能会很低。因为大部分时间可能都花在了等待确认上，而不是数据传输。</li><li><strong>延迟（Dalay）</strong>：每次发送一个数据帧后都要等待确认，这增加了传输的总延迟。</li><li><strong>资源利用不足（Insufficient utilization ofresources）</strong>：在有大量可用带宽的情况下，停等协议可能无法充分利用所有的带宽，导致带宽浪费。</li></ol><h4 id="滑动窗口协议">滑动窗口协议</h4><h5 id="捎带应答">捎带应答</h5><p><strong>捎带应答（Piggybacking）</strong>指的是在<strong>全双工（Full-duplex）</strong>信道传输中，接收方在收到数据帧后先将ACK暂存起来，然后将其捎带在数据帧处发送出去，这样能一定程度上节约信道的使用。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-29-181756.png" alt="Piggybacking" style="zoom:80%;" /></p><p><strong>什么是滑动窗口协议 ？</strong></p><p>更确切来说，这里提到的<strong>滑动窗口（Slidingwindow）</strong>，主要由两部分组成：</p><ul><li><p><strong>发送窗口（Sending window）</strong></p><p>发送方维护一个窗口，只有处于该窗口的数据帧可以被发送。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-30-013204.png" alt="Sending window, size = 5" style="zoom:40%;" /></p></li><li><p><strong>接收窗口（Receiving window）</strong></p><p>接收方维护一个窗口，只能处于该窗口的数据帧可以被接收。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-30-013248.png" alt="Receiving window, size = 1" style="zoom:40%;" /></p></li></ul><p><strong>滑动窗口协议允许发送方在收到 ACK之前发送多个数据帧</strong>。</p><p>在滑动窗口协议中，若发送窗口大小为 <spanclass="math inline">\(W_T\)</span> ，接收窗口大小为 <spanclass="math inline">\(W_R\)</span> ，SN 模数为 <spanclass="math inline">\(m\)</span>（通常 <span class="math inline">\(m = 2^ n\)</span>），则必须满足 <span class="math inline">\(W_T + W_R \leqm\)</span></p><p>，至于原因，我们会在下文中介绍。</p><h5 id="累积-ack">累积 ACK</h5><p><strong>累计 ACK（Cumulative ACK）</strong>，即一种记录累积效果的ACK，若发送方收到 ACK（i），则说明 Frame（0 ~ i）都被成功接收。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-30-014102.png" alt="左图：常规 ACK；右图：累积 ACK" style="zoom:67%;" /></p><h5 id="go-back-n">Go-Back-N</h5><p>在 Go-Back-N协议中，<strong>如果某个帧接收失败，则接收方会拒绝所有在此之后发送过来的数据帧直到错误帧被成功接收</strong>。因此若发送方发送的数据帧未被成功接收，则其必须回退重发该帧。</p><p>一般而言，GBN 协议中接收窗口的尺寸为1，因此某一时刻只能接收特定帧。</p><ul><li><p>数据帧损坏：</p><ol type="1"><li>接收方检测到 Frame（i）出错</li><li>接收方丢弃 Frame（i）与所有后续帧</li><li>超时之后，发送方重发 Frame（i）与后续帧</li></ol><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-30-020443.png" alt="GBN，Lost Frame" style="zoom:67%;" /></p></li><li><p>ACK 丢失：</p><ol type="1"><li>接收方成功收到 Frame（i）并发送了 ACK（i），但是发送方没有成功收到ACK</li><li>但由于这里的 ACK 记录累积效果，所以如果在 Frame（i）重传之前收到了ACK（i + n），那么 Frame（i）就不需要再重传</li><li>如果超时，重传 Frame（i）与后续帧</li></ol><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-30-021524.png" alt="GBN，ACK Lost" style="zoom:67%;" /></p></li></ul><p>根据上文提及的 <span class="math inline">\(W_T + W_R \leqm\)</span>，我们不难得出在 GBN 协议中有 <span class="math inline">\(W_T+ 1 \leq m\)</span> ，即 <span class="math inline">\(W_T &lt; m\)</span>，如果 <span class="math inline">\(W_T \geq m\)</span>会发生什么事情呢？</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-30-025407.png" style="zoom:67%;" /></p><p>如上图所示，接收窗口的大小等于 SN 模数（4），若前 4 帧的 ACK均未被成功接收，则发送方会因为超时重新发送Frame（0），<strong>此刻接收方的接收窗口恰好与发送窗口有重叠部分</strong>0，此时接收方会错误地接收冗余的 Frame（0）并认为这是新的一帧。</p><p>因此 <span class="math inline">\(W_T + W_R \leq m\)</span>其实就是为了保证：</p><p>当发送方发送完发送窗口内所有帧，在未收到 ACK之前，<strong>接收方正确接收到所有发送来的帧，接收窗口向前推移</strong>，此时，必须保证发送窗口与接收窗口在序号上不能重叠。</p><h5 id="选择重传协议">选择重传协议</h5><p>选择重传协议（Selective Repeat ARQ），与 GBN协议相比，选择重传协议更加高效，其减少了重传的次数，同时也更加复杂。</p><p>与 GBN协议不同的是，选择重传协议的接收窗口尺寸通常更大，这意味着<strong>接收方可以接受失序的帧</strong>。<strong>当接收到失序的帧时，它不会丢弃这些帧，而是将它们缓存起来，并为每个正确接收的帧发送确认</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-30-031657.png" style="zoom:67%;" /></p><p>上图中接收方在收到 Frame（4）和 Frame（5）后依然发送ACK（1）是因为目前连续接收成功的帧只有 0 ~ 1，在收到Frame（2）后才会发送 ACK（5）。</p><p>假设 SN 模数为 <span class="math inline">\(2 ^ n\)</span>，则在选择重传协议中发送窗口和接收窗口尺寸的选择有以下要求：</p><ul><li><span class="math inline">\(W_T + W_R \leq 2 ^ n\)</span></li><li><span class="math inline">\(W_T \geq W_R\)</span></li></ul><p>一般而言，我们会选择 <span class="math inline">\(W_T = W_R = 2 ^ {n -1}\)</span></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-30-032213.png" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>流量控制</tag>
      
      <tag>数据链路层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RSA 加密算法</title>
    <link href="/2023/10/17/RSA%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/17/RSA%20%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="前置知识">前置知识</h4><h5 id="欧拉函数">欧拉函数</h5><p>欧拉函数，即 <span class="math inline">\(\phi(n)\)</span>，表示不超过 <span class="math inline">\(n\)</span> 的数中与 <spanclass="math inline">\(n\)</span> 互素的数的个数。</p><p>当 <span class="math inline">\(n\)</span> 为素数时，显然有 <spanclass="math inline">\(\phi(n) = n - 1\)</span></p><p><strong>欧拉函数的常用性质</strong></p><ul><li>积性函数：若 <span class="math inline">\(gcd(x, y) = 1\)</span>，则有 <span class="math inline">\(\phi(xy) = \phi(x)\phi(y)\)</span></li><li><span class="math inline">\(n = \sum_{d | n} \phi(d)\)</span></li><li>若 <span class="math inline">\(n = p ^ k\)</span> ，<spanclass="math inline">\(p\)</span> 是素数，则有 <spanclass="math inline">\(\phi(n) = p ^ k - p ^ {k - 1}\)</span></li><li>若 <span class="math inline">\(n = \prod_{i = 1} ^ s p_i ^{k_i}\)</span> ，则有 <span class="math inline">\(\phi(n) = n \prod_{i =1} ^ s \frac{p_i - 1}{p_i}\)</span></li><li><span class="math inline">\(\phi(n) = \sum_{d | n} d\\mu(\frac{n}{d})\)</span></li></ul><h5 id="欧拉定理">欧拉定理</h5><p>若 <span class="math inline">\(gcd(a, n) = 1\)</span>，则有： <spanclass="math display">\[a ^ {\phi(n)} \equiv 1\ (mod\ n)\]</span></p><h5 id="逆元">逆元</h5><p>对于整数 <span class="math inline">\(x\)</span> 而言，若存在 <spanclass="math inline">\(y\)</span> 使得 <span class="math inline">\(xy\equiv 1\ (mod\ p)\)</span>，则称 <span class="math inline">\(y\)</span>是 <span class="math inline">\(mod\ p\)</span> 意义下的逆元，记做：<span class="math display">\[y \equiv x ^ {-1}\ (mod\ p)\]</span></p><h4 id="rsa-加密算法">RSA 加密算法</h4><p><strong>RSA（Rivest-Shamir-Adleman）</strong>是一种非对称加密算法，它使用一对密钥，分为公钥和私钥。公钥用于加密数据，而私钥用于解密数据。RSA是目前广泛用于加密和数字签名的加密技术之一。它的名称源自其发明者：RonRivest、Adi Shamir 和 Leonard Adleman。</p><p>RSA 的具体过程可以描述如下：</p><ol type="1"><li><p>挑选两个大素数 <span class="math inline">\(p\)</span> 和 <spanclass="math inline">\(q\)</span>，令 <span class="math inline">\(n =pq\)</span>，<span class="math inline">\(n\)</span>在这里称为模数</p></li><li><p>计算 <span class="math inline">\(n\)</span> 的欧拉函数，<spanclass="math inline">\(\phi(n) = (p - 1)(q - 1)\)</span></p></li><li><p>选择一个公开的加密指数（公钥）<spanclass="math inline">\(e\)</span>（通常是一个小素数，<spanclass="math inline">\(e &lt; \phi(n)\)</span>），同时生成 <spanclass="math inline">\(e\)</span> 在 <span class="math inline">\(mod\\phi(n)\)</span> 意义下的逆元 <span class="math inline">\(d\)</span>，即<span class="math inline">\(ed \equiv 1\ (mod\\phi(n))\)</span></p></li><li><p>加密过程：<span class="math inline">\(c = m ^ e\ mod\n\)</span></p><p><span class="math inline">\(key_e = \{e, n\}\)</span></p></li><li><p>解密过程：<span class="math inline">\(m = c ^ d\ mod\n\)</span></p><p><span class="math inline">\(key_d = \{d, n\}\)</span></p></li></ol><blockquote><p><strong>原理</strong>： <span class="math display">\[c ^ d = m ^ {ed} = m ^ {k\phi(n) + 1}\]</span> 由欧拉定理： <span class="math display">\[c ^ d \equiv m ^ {k\phi(n) + 1} \equiv m\ (mod\ n)\]</span></p></blockquote><h4 id="代码实现">代码实现</h4><ul><li><p>生成密钥：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> cryptography.hazmat.backends <span class="hljs-keyword">import</span> default_backend<br><span class="hljs-keyword">from</span> cryptography.hazmat.primitives.asymmetric <span class="hljs-keyword">import</span> rsa<br><span class="hljs-keyword">from</span> cryptography.hazmat.primitives <span class="hljs-keyword">import</span> serialization<br><br><span class="hljs-comment"># 生成RSA密钥对</span><br>private_key = rsa.generate_private_key(<br>    public_exponent=<span class="hljs-number">65537</span>,<br>    key_size=<span class="hljs-number">2048</span>,<br>    backend=default_backend()<br>)<br><br><span class="hljs-comment"># 保存私钥到文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;private_key.pem&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> private_key_file:<br>    private_key_pem = private_key.private_bytes(<br>        encoding=serialization.Encoding.PEM,<br>        <span class="hljs-built_in">format</span>=serialization.PrivateFormat.PKCS8,<br>        encryption_algorithm=serialization.NoEncryption()<br>    )<br>    private_key_file.write(private_key_pem)<br><br><span class="hljs-comment"># 获取公钥</span><br>public_key = private_key.public_key()<br><br><span class="hljs-comment"># 保存公钥到文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;public_key.pem&quot;</span>, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> public_key_file:<br>    public_key_pem = public_key.public_bytes(<br>        encoding=serialization.Encoding.PEM,<br>        <span class="hljs-built_in">format</span>=serialization.PublicFormat.SubjectPublicKeyInfo<br>    )<br>    public_key_file.write(public_key_pem)<br><br></code></pre></td></tr></table></figure></p></li><li><p>加密 &amp; 解密：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> cryptography.hazmat.backends <span class="hljs-keyword">import</span> default_backend<br><span class="hljs-keyword">from</span> cryptography.hazmat.primitives <span class="hljs-keyword">import</span> hashes<br><span class="hljs-keyword">from</span> cryptography.hazmat.primitives.asymmetric <span class="hljs-keyword">import</span> padding<br><span class="hljs-keyword">from</span> cryptography.hazmat.primitives <span class="hljs-keyword">import</span> serialization<br><br><span class="hljs-comment"># 加载私钥</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;private_key.pem&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> private_key_file:<br>    private_key = serialization.load_pem_private_key(<br>        private_key_file.read(),<br>        password=<span class="hljs-literal">None</span>,<br>        backend=default_backend()<br>    )<br><br><span class="hljs-comment"># 加载公钥</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;public_key.pem&quot;</span>, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> public_key_file:<br>    public_key = serialization.load_pem_public_key(<br>        public_key_file.read(),<br>        backend=default_backend()<br>    )<br><br><span class="hljs-comment"># 要加密的数据</span><br>data = <span class="hljs-string">b&quot;Hello, RSA encryption!&quot;</span><br><br><span class="hljs-comment"># 加密数据</span><br>ciphertext = public_key.encrypt(<br>    data,<br>    padding.OAEP(<br>        mgf=padding.MGF1(algorithm=hashes.SHA256()),<br>        algorithm=hashes.SHA256(),<br>        label=<span class="hljs-literal">None</span><br>    )<br>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Ciphertext:&quot;</span>, ciphertext)<br><br><span class="hljs-comment"># 解密数据</span><br>plaintext = private_key.decrypt(<br>    ciphertext,<br>    padding.OAEP(<br>        mgf=padding.MGF1(algorithm=hashes.SHA256()),<br>        algorithm=hashes.SHA256(),<br>        label=<span class="hljs-literal">None</span><br>    )<br>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Decrypted Data:&quot;</span>, plaintext.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全</tag>
      
      <tag>密码学</tag>
      
      <tag>RSA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>I/O 与磁盘</title>
    <link href="/2023/10/15/IO%20%E4%B8%8E%E7%A3%81%E7%9B%98/"/>
    <url>/2023/10/15/IO%20%E4%B8%8E%E7%A3%81%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h3 id="io">I/O</h3><p>I/O是计算机科学中的一个常见缩写，它代表了输入/输出（Input/Output）的意思。在计算机系统中，I/O涉及到<strong>计算机与外部设备之间的数据传输</strong>。输入通常是指从外部设备（如键盘、鼠标、磁盘驱动器、网络等）传输数据到计算机系统，而输出是指从计算机系统传输数据到外部设备。</p><p>I/O 是操作系统中非常复杂的一个话题，因为其牵涉到相当多部分。</p><p>计算机系统中不同操作的延迟或响应时间的估计数字：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-21-040804.png" alt="Latency numbers for the 2020s" style="zoom:50%;" /></p><ol type="1"><li><p>内存访问延迟：访问计算机内存通常是非常快的操作，延迟通常在纳秒级别（几十纳秒或更短）。这意味着从内存读取或写入数据的速度非常快。</p></li><li><p>磁盘 I/O 延迟：与内存相比，访问磁盘通常更慢。典型的磁盘读取操作可能需要几毫秒（毫秒）的时间，具体取决于磁盘驱动器的类型和性能。</p></li><li><p>网络通信延迟：网络通信延迟取决于网络延迟和带宽，通常在几毫秒到数十毫秒之间。这包括发送数据到远程服务器和接收响应的时间。</p></li></ol><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-21-040906.png" style="zoom:67%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-21-041248.png" alt="常见 I/O 设备传输效率" style="zoom:67%;" /></p><h4 id="计算机存储结构">计算机存储结构</h4><p>下图展示了典型现代计算机系统的数据存储结构以及 I/O在该结构中的位置：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-21-044032.png" style="zoom:67%;" /></p><ol type="1"><li><p><strong>寄存器（Registers）</strong>是计算机系统中<strong>最快速、最小</strong>的存储设备之一，用于存储和处理数据。它们通常位于中央处理单元（CPU）内部，并用于执行计算和控制指令。由于其极高的速度，寄存器在执行计算和控制任务时起到关键作用，而且在CPU 设计和程序优化中具有重要意义。</p></li><li><p><strong>高速缓存（Cache）</strong>是计算机系统中用于提高数据访问速度和性能的关键组件。它是一种快速存储器，用于存储最常用的数据，以减少对较慢存储器（如主内存或硬盘驱动器）的访问次数。</p><blockquote><p>计算机系统通常采用多层内存层次结构，其中包括高速缓存、主内存和较慢的外部存储器（如硬盘驱动器）。高速缓存位于主内存和中央处理单元（CPU）之间，具有不同级别，如一级缓存（L1）、二级缓存（L2）、三级缓存（L3）等。</p></blockquote></li><li><p><strong>动态随机访问存储器（Dynamic Random-AccessMemory，DRAM）</strong>的缩写，它是计算机系统中广泛使用的主要内存类型之一。DRAM是一种易失性存储器，用于存储计算机程序和数据，但它<strong>需要不断刷新以保持数据的完整性</strong>。与CPU 缓存不同，DRAM 的容量通常较大，但速度较慢。</p></li><li><p><strong>次级存储（Secondarystorage）</strong>是计算机系统中的一种主要存储层级，用于长期数据存储和备份。与主内存（RAM）不同，它通常是非易失性的，意味着数据在断电后仍然保持完好。次级存储包括各种设备和媒体，例如硬盘驱动器（HDD）、固态硬盘（SSD）、光盘（如CD 和 DVD）、磁带、USB闪存驱动器、网络附加存储（NAS）以及云存储服务等。</p><ul><li><p><strong>硬盘驱动器（Hard DiskDrive，HDD）</strong>是一种常见的计算机数据存储设备，用于长期数据存储和检索。HDD使用旋转的磁性盘片和机械臂来读写数据。</p><blockquote><p>HDD内部包含一个或多个盘片（通常是金属或玻璃制成），盘片上分成了一系列磁性轨道和扇区。数据以磁性方式存储在这些表面上。机械臂负责将读/写头移动到正确的磁道上来读取或写入数据。磁头将数据编码为磁性位，然后根据需要将其读取或写入。</p></blockquote></li><li><p><strong>固态硬盘（Solid-StateDrive，SSD）</strong>是一种用于数据存储的非机械式存储设备。SSD是一种高性能、可靠、耐用且节能的数据存储解决方案，它已经取代了许多传统的HDD，并成为现代计算机和移动设备的标配之一。</p></li></ul></li><li><p><strong>I/O 控制器（I/OController）</strong>，是计算机系统中的硬件组件，用于管理和协调输入和输出设备的数据传输和通信。I/O控制器起到桥梁的作用，协调主处理器（CPU）与外部设备之间的数据交换。不同类型的I/O控制器针对不同类型的设备，如存储设备、网络设备和外围设备等，都具有特定的功能和特点。</p></li></ol><h4 id="io-传输">I/O 传输</h4><h6 id="io-bus">I/O bus</h6><p>I/O 总线（I/OBus）是计算机体系结构中的一个关键组成部分，用于传输数据和控制信息，以连接计算机主板上的主处理器（CPU）和内存与外部设备之间。I/O总线是计算机系统内部的物理或电子通道，它允许不同类型的输入/输出设备与计算机进行通信，包括硬盘驱动器、键盘、鼠标、显示器、打印机、USB设备和网络适配器等。</p><p>总得来说，我们可以认为 I/O 总线由两部分组成：</p><ul><li>一组连接设备用于数据传输的线（Wires）</li><li>数据传输操作的协议（Protocols）</li></ul><p>不同类型的计算机和体系结构可能使用不同的 I/O 总线标准，如PCI（Peripheral Component Interconnect）、PCI Express、USB、SATA等。这些标准规定了总线的电气和物理规格，以确保设备的互操作性。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-21-051758.png" alt="PCI 架构" style="zoom:67%;" /></p><ul><li><p><strong>PCI Bus（Peripheral Component InterconnectBus）</strong>：</p><p>PCI 是一种高性能总线标准，最早于1992年引入，并经过多次更新和改进。PCI总线具有较高的数据传输速度和带宽，通常适用于连接<strong>高性能设备</strong>，如图形卡等等。</p></li><li><p><strong>SCSI Bus（Small Computer System InterfaceBus）</strong>：</p><p>SCSI是一种用于连接计算机和<strong>外部设备</strong>的标准接口。它最早出现于1980年代。现在SCSI总线用于连接各种类型的设备，包括硬盘驱动器、光盘驱动器、打印机、扫描仪、磁带驱动器等。它通常用于需要高性能和可靠性的存储设备。</p></li></ul><h4 id="操作系统与-io-的交互">操作系统与 I/O 的交互</h4><p>操作系统和 I/O设备之间的交互通常需要使用<strong>寄存器</strong>来管理和监控 I/O操作的进展和状态。这些寄存器通常是硬件设备上的寄存器，用于记录设备的状态和控制信息。</p><ol type="1"><li><p><strong>状态寄存器（Status Register）</strong>：</p><p>状态寄存器通常包含设备的当前状态信息，如设备是否忙碌、是否就绪、是否有错误等。操作系统可以定期轮询这个寄存器来检查设备状态，以决定是否可以执行I/O 操作。</p><p>典型的状态位包括忙碌位（Busy）、错误位（Error）、就绪位（Ready）等。</p></li><li><p><strong>数据寄存器（Data Register）</strong>：</p><p>数据寄存器用于实际的数据传输，包括从 CPU发送数据到设备或从设备接收数据到CPU。操作系统通过读取或写入数据寄存器来传递数据。我们可以认为数据寄存器充当了<strong>数据传输的临时存储区域</strong>，允许数据在不同硬件模块之间进行有效的交换。</p></li><li><p><strong>命令寄存器（Command Register）</strong>：</p><p>命令寄存器包含了<strong>控制 I/O设备的命令码</strong>。这些命令码告诉设备要执行的操作，例如读取、写入、打开、关闭、复位等。通过命令寄存器，操作系统可以向设备发送启动或停止命令，以开始或终止I/O 操作。</p></li></ol><blockquote><p>一个典型的操作系统与 I/O 交互的执行过程：</p><ol type="1"><li>操作系统根据<strong>状态寄存器</strong>判断什么时候某个设备处于就绪状态（Ready）；</li><li>若启动I/O，则操作系统会向<strong>数据寄存器</strong>写入数据，并且设置<strong>命令寄存器</strong>的数据为我们需要的I/O 操作的操作码（此时，<strong>I/O控制器</strong>会设置该设备的状态寄存器为 Busy）；</li><li><strong>I/O控制器</strong>接下来读取<strong>命令寄存器</strong>和<strong>数据寄存器</strong>的内容，并开始执行命令；</li><li>操作系统根据执行结果对<strong>状态寄存器</strong>进行修改：</li></ol><ul><li>若正常执行结束，即所有指令都执行完成，控制器将清除该命令，并将其Busy 状态复位</li><li>若出现异常状态，则在必要情况下将状态寄存器设置为 Error</li></ul></blockquote><h5 id="中断-轮询">中断 &amp; 轮询</h5><p>在执行 I/O 操作时，操作系统需要知道：</p><ul><li>某个设备是否<strong>完成了 I/O 操作</strong></li><li>某个设备的特定 I/O 操作是否<strong>遇到了异常</strong></li></ul><p>这意味着 I/O 设备必须与 OS 实现有效通信。</p><ul><li><p><strong>I/O 中断（I/O Interrupt）</strong></p><p><strong>当设备需要 CPU 的处理时，I/O设备会生成一个中断信号</strong>，CPU在接收到中断信号后立即暂停正在执行的任务，保存当前状态（通常通过将寄存器内容保存到堆栈），并跳转到中断处理程序。中断处理程序负责执行与中断相关的任务，然后返回到先前中断之前的任务。</p><p><strong>中断是异步的，它们随时可能发生，而不需要 CPU连续地检查设备状态。</strong></p><ul><li><p>优点：能较好地<strong>处理不可预判的异常（Greatrobustness）</strong></p></li><li><p>缺点：<strong>开销大（High overhead）</strong></p><blockquote><p>这里的开销主要来自于 I/O 中断造成的上下文切换（Contextswitching）</p></blockquote></li></ul></li><li><p><strong>轮询（Polling）</strong></p><p>在轮询中，<strong>操作系统或应用程序周期性检查设备的状态寄存器</strong>，以查看是否需要处理。如果发现有事件发生，系统会采取相应的措施。</p><ul><li><strong>优点：开销小（Low overhead）</strong></li><li>缺点：如果 I/O 操作不频繁或不可预测，则会在轮询上花费过多时间</li></ul></li></ul><h5 id="设备驱动程序">设备驱动程序</h5><p><strong>设备驱动程序（DeviceDriver）</strong>是计算机<strong>软件</strong>的一部分，它<strong>允许操作系统与硬件设备进行通信</strong>。它的主要作用是作为操作系统和物理硬件设备之间的桥梁，使得操作系统可以控制和操作硬件。</p><p>设备驱动程序为操作系统提供了一个统一的接口，使得操作系统可以与各种各样的硬件设备进行交互，而不需要知道它们的具体细节。</p><h5 id="编程-io-dma">编程 I/O &amp; DMA</h5><p>在解决状态访问的问题后我们还需要实现数据传输，常见的两种方法是编程I/O 和直接内存访问。</p><ul><li><p><strong>编程 I/O（Programmed I/O）</strong></p><p>编程 I/O（Programmed I/O）是计算机系统中的一种基本 I/O操作方法，它<strong>通过 CPU执行的程序来控制数据的传输和通信</strong>。在 Programmed I/O中，CPU负责直接处理 I/O操作，包括从外部设备读取数据或将数据写入外部设备。<strong>即编程 I/O所有数据的传输都依托于处理器的指令</strong>。</p><ul><li>优点：因为是从编程角度出发的，因此易于实现，对硬件需求低</li><li>缺点：会消耗与数据大小成比例的处理器周期</li></ul></li><li><p><strong>直接内存访问（Directly Memory Access，DMA）</strong></p><p>直接内存访问（Direct MemoryAccess，DMA），是一种计算机系统中用于提高数据传输性能的技术。DMA<strong>允许外部设备</strong>（如硬盘驱动器、网络适配器、图形卡等）<strong>直接访问主内存</strong>，而<strong>无需CPU 的直接干预</strong>，从而<strong>减少 CPU的负担</strong>，提高数据传输效率。</p><p><strong>DMA 的具体过程</strong>：</p><ol type="1"><li><strong>设备驱动程序被通知</strong>：首先，<strong>CPU告诉设备驱动程序</strong>需要从磁盘将数据传输到内存中的某个缓冲区（地址X）。</li><li><strong>设备驱动程序通知磁盘控制器</strong>：<strong>设备驱动程序随后指示磁盘控制器</strong>从磁盘传输C 字节的数据到内存中的缓冲区（地址X）。</li><li><strong>磁盘控制器启动 DMA 传输</strong>：<strong>磁盘控制器开始 DMA传输的过程</strong>。</li><li><strong>磁盘控制器与 DMA控制器的交互</strong>：磁盘控制器<strong>将每一个字节发送到 DMA控制器</strong>。</li><li><strong>DMA 控制器传输数据</strong>：<strong>DMA 控制器开始向缓冲区X 传输字节</strong>，同时递增内存地址，并减少 C 的值，直到 C 变为0。</li><li><strong>DMA 中断 CPU</strong>：当所有的数据都被传输完毕（即 C =0）时，DMA 会<strong>发出一个中断信号</strong>给CPU，告知其数据传输已经完成。</li></ol></li></ul><h4 id="内存映射-io">内存映射 I/O</h4><p><strong>内存映射 I/O（Memory-mappedI/O）</strong>是一种在计算机系统中用于管理 I/O设备的通用方法，它允许操作系统和应用程序<strong>将 I/O设备视为内存地址范围的一部分</strong>，使其可以直接读取和写入设备数据，就像操作内存一样。</p><p>在内存映射 I/O 中，每个 I/O设备都被分配一个在物理内存地址空间中的范围。这个地址范围通常称为设备寄存器的地址空间，其中包含了与设备通信的特定<strong>寄存器</strong>（状态寄存器、数据寄存器、命令寄存器等等）和<strong>数据缓冲（Buffer）</strong>。</p><p>注：该内存分配区域<strong>一般只用于 I/O通信而不会进行其他操作</strong>。</p><h4 id="io-的四大类型">I/O 的四大类型</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-27-022210.png" style="zoom:50%;" /></p><ul><li><p><strong>同步阻塞 I/O（Synchronous Blocking I/O）</strong></p><p>最常见的 I/O 模型之一就是同步阻塞 I/O模型。在这种模型中，用户空间应用程序执行一个系统调用，导致应用程序阻塞。这意味着应用程序会一直阻塞，直到系统调用完成（数据传输或出错）。调用应用程序处于不消耗CPU 的状态，只是等待响应，因此从处理角度来看是高效的。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-27-022803.png" style="zoom:50%;" /></p></li><li><p><strong>同步非阻塞 I/O（Synchronous Non-blockingI/O）</strong></p><p>同步非阻塞 I/O是同步阻塞的一个效率较低的变体。在这种模型中，设备以非阻塞方式打开。这意味着，与其立即完成一个I/O操作，读操作可能返回一个错误代码，表明命令不能立即得到满足（<code>EAGAIN</code>或 <code>EWOULDBLOCK</code>）。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-27-023111.png" style="zoom:50%;" /></p></li><li><p><strong>异步阻塞 I/O（Asynchronous Blocking I/O）</strong></p><p>另一种阻塞范式是使用阻塞通知的非阻塞 I/O。在这种模型中，配置了非阻塞I/O，然后使用阻塞的 select 系统调用来确定何时存在针对 I/O描述符的任何活动。使 select调用变得有趣的是，它可以用来为不只一个描述符提供通知，而是多个。对于每个描述符，你可以请求通知描述符写数据的能力、可读数据的可用性，以及是否发生了错误。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-27-024023.png" style="zoom:50%;" /></p></li><li><p><strong>异步非阻塞 I/O（Ansynchronous Non-blockingI/O）</strong></p><p>最后，异步非阻塞 I/O 模型是一个 <strong>I/O与处理重叠</strong>的模型。读取请求立即返回，表示读取操作已经成功启动。应用程序随后可以在后台读取操作完成的同时执行其他处理。当读取响应到达时，可以生成一个信号或基于线程的回调来完成I/O 事务。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-12-27-024211.png" style="zoom:50%;" /></p></li></ul><h4 id="一个-io-请求的生命周期">一个 I/O 请求的生命周期</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-22-081225.png" style="zoom:67%;" /></p><h3 id="磁盘">磁盘</h3><p>磁盘（Disk）是计算机系统中用于存储数据的主要外部设备之一。磁盘是一种非易失性存储媒体，意味着数据会在断电或重启后仍然保留。</p><h4 id="hdd">HDD</h4><h5 id="基本结构">基本结构</h5><p>硬盘驱动器（Hard DiskDrive，HDD）是一种用于存储数据的计算机存储设备。HDD是一种机械式存储设备，其工作原理是使用旋转的磁性盘片和移动的读写磁头来读取和写入数据。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-22-082028.png" style="zoom:50%;" /></p><ol type="1"><li><strong>磁道（Track）</strong>：<ul><li>磁道是硬盘驱动器上的一个圆形轨迹或路径，位于硬盘盘片的表面上；</li><li>硬盘的每个盘片通常包含多个同心圆磁道，这些磁道从盘片的中心开始，向外扩展；</li><li>每个磁道上的数据通常具有相似的物理位置，因此可以更快地被访问。</li></ul></li><li><strong>柱面（Cylinder）</strong>：<ul><li>柱面是多个硬盘盘片上相同位置的磁道的集合；</li><li>每个盘片上具有相同半径位置的磁道被组合成一个柱面；</li><li>从柱面的角度来看，这些磁道在不同盘片之间对齐，因此它们可以一起被读取或写入，从而提高数据的传输速度。</li></ul></li><li><strong>扇区（Sector）</strong>：<ul><li>扇区是磁道上的最小存储单位，通常包含 512 字节或更多数据；</li><li>每个磁道被划分成多个扇区，以便更有效地存储和检索数据；</li><li>操作系统和硬件通过扇区来访问硬盘上的数据。数据的读取和写入是以扇区为单位进行的。</li></ul></li></ol><h5 id="时延分析">时延分析</h5><p>HDD 技术寻址并传输数据的时间开销我们可以认为由以下 3 部分组成：</p><ol type="1"><li><strong>寻道时间（Seektime）</strong>：即移动磁头到目标所在柱面和磁道所花费的时间。寻道时间受到磁头移动的距离和速度的影响。较短的寻道时间表示硬盘可以更快地访问数据，因此是一个性能指标。</li><li><strong>旋转延迟（Rotationaldelay）</strong>：找到目标位置后需要旋转磁盘使得磁头落在目标扇区，这由磁盘盘片的旋转速度相关（单位：RPM，每分钟旋转次数）。</li><li><strong>传输延迟（Transferdelay）</strong>：使用读写头来传输数据。实际的数据传输时间取决于硬盘的数据传输速度。这通常以每秒字节（Bps）或兆字节每秒（MBps）来表示。</li></ol><blockquote><p>我们假设某个 HDD 设备的平均寻道时间是 5ms，盘片旋转速度为 7200RPM，传输速率为 50 MB/s，一个数据块的大小为 4KB，则有：</p><ul><li><p>平均旋转延迟 = 盘片旋转一圈的时间 / 2 = 8ms / 2 = 4ms</p></li><li><p>一个数据块的平均传输时间 = 4 KB / 50 MB/s = 0.08ms</p></li></ul><p>进一步，我们可以得到：</p><ul><li><strong>随机读取一个数据块</strong>的时间开销 = 平均寻道时间 +平均旋转延迟 + 数据块传输延迟 = 9.08ms</li><li><strong>随机读取同一个柱面的某个数据块</strong>的时间开销 =平均旋转延迟 + 数据块传输延迟 = 4.08ms</li><li><strong>读取同一个柱面同一个磁道的下一个数据块</strong>的时间开销 =数据传输延迟 = 0.08ms</li></ul></blockquote><h5 id="磁盘调度">磁盘调度</h5><p>由于 HDD获取盘片速度较慢，所以我们当我们的任务队列中有多个任务时需要合适的调度策略来处理任务。</p><p>假设我们的任务队列当前有 6个任务，每个任务所在磁道与盘片圆心的距离分别为99，10，50，150，11，30。则这些任务在不同调度策略下的磁头移动方式如下：</p><h6 id="fifo">FIFO</h6><p><strong>先来先服务（First In FirstOut，FIFO）</strong>，即严格按照队列结构实行先进先出。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-23-011258.png" alt="FIFO" style="zoom:50%;" /></p><p>优点：最公平。</p><p>缺点：由于任务位置可能是随机的，可能会花费很多寻道时间。</p><h6 id="sstf">SSTF</h6><p><strong>最短寻道时间优先（Shortest Seek TimeFirst，SSTF）</strong>，即磁头每次都向最近的任务移动。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-23-011839.png" alt="SSTF，假设磁头从 99 处开始" style="zoom:50%;" /></p><p>优点：利于减少寻道时间。</p><p>缺点：可能在调度出现某个任务长期未得到响应而造成饥饿。</p><h6 id="scan">Scan</h6><p><strong>Scan</strong> 调度，也叫电梯算法（Elevatoralgorithm），相比于 SSTF，Scan策略每次只选择当前运动方向最近的请求。当完成磁道半径最大的请求后就会逆转当前方向。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-23-012421.png" alt="Scan，假设磁头初始在 99 的位置，初始方向是由低磁道到高磁道" style="zoom:50%;" /></p><p>优点：避免了请求饥饿。</p><p>缺点：某些情况可能不够公平。（比如上图在磁道 10 处的请求）</p><h6 id="c-scan">C-Scan</h6><p><strong>C-Scan</strong> 调度，就是在 <strong>Scan</strong>调度的基础上，不处理逆转方向过程中遇到的任何请求，这可以使得<strong>C-Scan</strong> 调度相比于 <strong>Scan</strong>调度而言更加公平。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-23-013332.png" alt="C-Scan，假设磁头初始在 99 的位置，初始方向是由低磁道到高磁道" style="zoom:50%;" /></p><h4 id="ssd">SSD</h4><p>即固态硬盘（Solid StateDrive，SSD），是一种用于数据存储的存储设备，它使用集成电路（Integratedcircuits）来存储数据，而不像传统硬盘驱动器（HDD）那样使用旋转磁盘和机械臂来读写数据，SSD中没有任何异动的机械器件。</p><figure><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-23-013838.png"alt="SSD" /><figcaption aria-hidden="true">SSD</figcaption></figure><p>由于不依赖机械臂读写数据，所以 SSD 读写数据就不再受到像 HDD中的寻道时间和旋转延迟的限制。</p><h5 id="nand-闪存">NAND 闪存</h5><p>在 SSD 中广泛使用 NAND 闪存（NAND cell flashmemory）技术，其通过<strong>晶体管（Transistor）</strong>存储一个或多个bit，通过此可以划分为两种类型：</p><ul><li>SLC（Single Level Cell）：每个存储单元只存储一个 bit。<ul><li>特点：快速、高耐用性（Endurance）、成本高</li></ul></li><li>MLC（Multiple Level Cell）：每个存储单元可以存储多个 bit，一般是 2 ~3。<ul><li>特点：相对较慢、低耐用性、成本低</li></ul></li></ul><blockquote><p>有关耐用性：</p><p>SSD中存储单元的擦除/写入次数是受到限制的，每次执行擦除和写入操作时，存储单元中的浮动栅承受一定的电荷和电压压力。随着时间的推移，这些操作会导致存储单元中的浮动栅逐渐受损，降低了其可靠性和性能。</p><p>MLC 闪存相对 SLC而言更容易受到擦除/写入次数限制，因为它每个存储单元的擦除/写入次数较少。这意味着MLC 闪存的寿命可能会较短，尤其在高度写入密集的应用中。</p></blockquote><h5 id="flash-芯片结构">Flash 芯片结构</h5><p>SSD 采用 Flash 芯片结构（Flash ChipStructure），其结构可以划分如下：</p><ul><li>一个芯片可以划分为多个<strong>块组（Banks）</strong><ul><li>一个块组可以划分为多个<strong>块（Blocks）</strong>（e.g. 256KB）<ul><li>一个块可以划分为多个<strong>页（Pages）</strong>（e.g. 4KB）</li></ul></li></ul></li></ul><h5 id="ssd-中的读与写">SSD 中的读与写</h5><ul><li><strong>读取（Reading）</strong><ul><li>操作单位：页（Page)</li><li>运行时间大约 10ms，远快于 HHD</li></ul></li><li><strong>写（Writing）</strong><ul><li>每次在执行写操作前要先<strong>擦除数据（Erasing ablock）</strong>，具体操作如下：<ol type="1"><li>将目标数据块的所有 bit 置为 1（1 ～ 2ms）</li><li>对相应的页执行写操作，将一些 bit 设置为 0（200ms 左右）</li></ol></li></ul></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-23-021020.png" style="zoom:50%;" /></p><p><strong>HDD vs SSD</strong></p><ul><li>对于<strong>随机访问 I/O（Random-access I/O）</strong>，SSD具有更大的优势，因为其没有机械部件带来的时间开销。</li><li>对于<strong>顺序访问 I/O（Sequential-accessI/O）</strong>，二者差距较小。</li><li>相比于 HDD，SSD 质量更轻、功耗更少、运行噪声也更小。</li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>贝叶斯分类器</title>
    <link href="/2023/10/14/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <url>/2023/10/14/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="核心思想">核心思想</h4><p>贝叶斯分类器是一种基于贝叶斯定理的统计分类方法。在给定数据的情况下，它使用概率模型来预测数据点的类别。贝叶斯分类器的核心思想是，<strong>对于给定的样本，我们可以计算它属于每个类别的概率，并将样本分配给概率最大的类别</strong>。</p><p>贝叶斯公式： <span class="math display">\[P(A | B) = \frac{P(B | A) P(A)}{P(B)}\]</span></p><ul><li><strong>先验概率（PriorProbability）</strong>：指在没有额外信息的情况下，一个事件发生的概率。</li><li><strong>后验概率（PosteriorProbability）</strong>：给定某些证据后，时间发生的概率。</li><li><strong>似然性（Likelihood）</strong>：给定假设为真时观察到证据的概率。</li></ul><p><strong>使用后验概率来进行分类的分类器称之为贝叶斯分类器（BayesClassifier）</strong>。</p><h4 id="数学表示">数学表示</h4><p>我们以二分类问题为例，假设在数据集 <spanclass="math inline">\(S\)</span> 中的数据有两个类 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span>，则贝叶斯分类器一般用<strong>优势比（OddsRatio）</strong>来描述某个数据点的所属类别： <spanclass="math display">\[\frac{P(y = A|x)}{P(y = B|x)}\]</span><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-16-033413.png" style="zoom:67%;" /></p><p>若上式子大于 1，即 <span class="math inline">\(P(y = A | x) &gt; P(y= B | x)\)</span>，则认为数据点的特征向量为 <spanclass="math inline">\(x\)</span> 的情况下，其属于 <spanclass="math inline">\(A\)</span> 类的概率更大，反之则认为其属于 <spanclass="math inline">\(B\)</span> 类的概率更大。</p><p>根据贝叶斯公式，上式可以表示为： <span class="math display">\[\frac{P(x | y = A) P(y = A)}{P(x | y = B) P(y = B)}\]</span> 其中 <span class="math inline">\(P(y = A)\)</span> 和 <spanclass="math inline">\(P(y = B)\)</span>由两个类别在数据集中的占比决定，而 <span class="math inline">\(P(x | y =A)\)</span> 和 <span class="math inline">\(P(x | y = B)\)</span>则由两个类别中数据的分布相关。</p><h5 id="判别分析">判别分析</h5><p><strong>判别分析（DiscriminantAnalysis）</strong>是机器学习和统计学中的一种技术，用于将一组观测值分类到预定义的类别中。该方法假设不同的类别通过不同的<strong>高斯分布（GuassianDistribution）</strong>生成数据。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-16-032722.png" style="zoom:67%;" /><span class="math display">\[p(x | y = A) = \frac{1}{(2 \pi) ^ {\frac{d}{2}} {|\Sigma_A|} ^\frac{1}{2}} exp(-\frac{1}{2}(x - \mu_A) ^ T \Sigma_A^{-1} (x - \mu_A))\]</span></p><p><span class="math display">\[p(x | y = B) = \frac{1}{(2 \pi) ^ {\frac{d}{2}} {|\Sigma_B|} ^\frac{1}{2}} exp(-\frac{1}{2}(x - \mu_B) ^ T \Sigma_B^{-1} (x - \mu_B))\]</span></p><p>主要类型的判别分析包括：</p><ol type="1"><li><p><strong>线性判别分析（Linear DiscrinantAnalysis，LDA）</strong>：这种方法假设不同类别具有相同的协方差矩阵。它找到一个特征的线性组合，这个组合能够表征或者区分两个或多个类别。目的是在类别之间找到一个<strong>线性边界</strong>。</p></li><li><p><strong>二次判别分析（Quadratic DiscrinantAnalysis，QDA）</strong>：与 LDA 不同，QDA假设每个类别都有自己的协方差矩阵。它在分类上更加灵活，因为它可以创建<strong>二次边界</strong>，因此得名。</p></li></ol><blockquote><p>通常而言，两个类别的协方差矩阵相等或者十分接近，例如其差值的矩阵二范数<span class="math inline">\(||\Sigma_A - \Sigma_B || ^ 2\)</span>是一个很小的值，我们就可以认为数据集的判别分析类型为 LDA。</p></blockquote><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-16-034510.png" style="zoom:67%;" /></p><h5 id="考虑错误分类成本">考虑错误分类成本</h5><p>在机器学习和统计分类问题中，<strong>错误分类成本（MisclassificationCosts）</strong>指的是将一个实例错误分类为另一个类别时所产生的代价或损失。在某些情况下，不同类型的错误可能会导致不同程度的负面影响。例如，在医疗诊断中，将患有疾病的病人错误地判定为健康（漏诊）通常比将健康的病人错误判定为患病（误诊）带来更严重的后果。</p><p>错误分类成本可以是不对称的，意味着对于不同的错误分类，成本可以不一样。在设计分类器时，我们通常希望最小化总体的错误分类成本，而不仅仅是错误分类的数量。</p><p>考虑错误分类成本的贝叶斯分类器（也称为成本敏感的贝叶斯分类器）是一种在决策过程中考虑到不同类型错误分类所带来成本的分类器。这种分类器不仅仅追求最大化整体的准确率，而是尝试最小化总的期望分类成本。</p><p>以上文提及的二分类为例，我们定义<strong>成本矩阵（CostsMatrix）</strong>： <span class="math display">\[C = \begin{bmatrix}C(A | A) &amp; C(A | B) \\C(B | A) &amp; C(B | B)\end{bmatrix}\]</span> 在成本矩阵中 <span class="math inline">\(C(I | J)\)</span>表示将标签为 <span class="math inline">\(J\)</span> 类的数据识别为 <spanclass="math inline">\(I\)</span> 类需要付出的成本。</p><p>对于一个新的实例 <span class="math inline">\(x\)</span>，我们可以计算出其属于每个类别的期望成本： <span class="math display">\[EC(y = A | x) = P(y = A | x)C(A | A) + P(y = B | x) C(A | B)\]</span></p><p><span class="math display">\[EC(y = B | x) = P(y = B | x)C(B | B) + P(y = A | x)C(B | A)\]</span></p><p>最后我们只需要选择期望成本最小的类别即可，我们一般认为 <spanclass="math inline">\(C(A | A) = C(B | B) =0\)</span>，因为通常情况下正确识别不需要花费额外的成本。</p><p>因此考虑错误分类成本的优势比可以表示如下： <spanclass="math display">\[\frac{P(y = A | x)C(B | A)}{P(y = B | x)C(A | B)}\]</span> 即如果满足 <span class="math inline">\(\frac{P(y = A | x)}{P(y= B |x)} &gt; T\ (T = \frac{C(A | B)}{C(B | A)})\)</span> ，则考虑将样本<span class="math inline">\(x\)</span> 划分为 A 类更合适。<spanclass="math inline">\(T\)</span> 在这里就是分类器的阈值，不同的 <spanclass="math inline">\(T\)</span> 会有不同的分类边界。</p><h4 id="分类器的评估">分类器的评估</h4><h5 id="混淆矩阵">混淆矩阵</h5><p><strong>混淆矩阵（ConfusionMatrix）</strong>是一种特定的表格用于可视化算法性能，尤其是在监督学习中对分类问题的性能评估。它展示了实际类别与模型预测类别之间的关系，以此来揭示模型在各个类别上的错误类型。</p><p>对于一个二分类问题，混淆矩阵包含四个部分：</p><ol type="1"><li><strong>真正例（True Positives,TP）</strong>：模型正确预测为正类的数量。</li><li><strong>假正例（False Positives,FP）</strong>：模型错误预测为正类的数量。</li><li><strong>真负例（True Negatives,TN）</strong>：模型正确预测为负类的数量。</li><li><strong>假负例（False Negatives,FN）</strong>：模型错误预测为负类的数量。</li></ol><p>混淆矩阵通常如下所示：</p><p><span class="math display">\[\begin{array}{cc}&amp; \text{预测正类} &amp; \text{预测负类} \\\text{实际正类} &amp; TP &amp; FN \\\text{实际负类} &amp; FP &amp; TN \\\end{array}\]</span> 这个矩阵使我们能够快速计算出几个重要的性能指标，如：</p><ul><li><strong>准确率（Accuracy）</strong>：所有正确分类的观测值占总观测值的比例，计算公式为<span class="math inline">\((TP + TN) / (TP + TN + FP +FN)\)</span>。</li><li><strong>精确率（Precision）</strong>：正确预测为正类的观测值占预测为正类的比例，计算公式为<span class="math inline">\(TP / (TP + FP)\)</span>。</li><li><strong>召回率（Recall）或灵敏度（Sensitivity）</strong>：正确预测为正类的观测值占实际正类的比例，计算公式为<span class="math inline">\(TP / (TP + FN)\)</span>。</li><li><strong>特异性（Specificity）</strong>：正确预测为负类的观测值占实际负类的比例，计算公式为<span class="math inline">\(TN / (TN + FP)\)</span>。</li></ul><p>解决一个分类问题，实际上即使要找到一个分类边界，可以最大化<strong>敏感度</strong>和<strong>特异性</strong>。</p><h5 id="roc-平面与-auc-指标">ROC 平面与 AUC 指标</h5><p>ROC（接收者操作特征）平面是用来评估二分类系统性能的图形化工具。它通过绘制真正例率（TruePositive Rate, TPR）对假正例率（False Positive Rate,FPR）来展示分类器的性能。</p><p>在 ROC 平面中：</p><ul><li><strong>真正例率（TPR）</strong>，也就是召回率（Recall）或灵敏度（Sensitivity），是指正确识别为正例的样本占所有实际正例的比例。计算公式为：<spanclass="math inline">\(\text{TPR} = \frac{TP}{TP + FN}\)</span>。</li><li><strong>假正例率（FPR）</strong>，是指错误识别为正例的样本占所有实际负例的比例。计算公式为：<spanclass="math inline">\(\text{FPR} = \frac{FP}{TN + FN}\)</span> ，即<span class="math inline">\(1 - \text{specificity}\)</span>。</li></ul><p>在 ROC曲线上，每个点代表对应于某个决策阈值的（FPR，TPR）对。<strong>曲线下面积（AreaUnder the Curve，AUC）</strong>用来量化分类器的总体性能：<strong>AUC值为1 表示完美分类器，AUC 值为 0.5表示无效分类器，即其性能不如随机猜测</strong>。</p><p>ROC平面上的主要特点包括：</p><ol type="1"><li><strong>ROC曲线越靠近左上角，分类器的性能越好</strong>：这意味着高的真正例率和低的假正例率。</li><li><strong>ROC曲线下的面积（AUC）越大，分类器的整体性能越好</strong>：它为我们提供了一个分类器性能的单一度量，可以用来比较不同的分类器。</li><li><strong>ROC曲线提供了一个无需担心类别分布或者决策阈值选择的性能度量</strong>：这使得它在评估不平衡数据集的分类器时特别有用。</li></ol><p>因此，ROC平面和AUC指标是评估和比较分类模型性能的强有力工具。它们允许我们在不同的阈值设置下考虑分类器的性能，为选择最佳模型提供了依据。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-16-061436.png" style="zoom:67%;" /></p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论</tag>
      
      <tag>贝叶斯公式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件系统</title>
    <link href="/2023/10/06/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/10/06/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h4 id="文件系统介绍">文件系统介绍</h4><p><strong>文件系统（Filesystem）</strong>是操作系统的一层，它将磁盘（或其他块设备）的<strong>块接口（Blockinterface）</strong>转换为文件、目录等。</p><p>文件系统的主要功能：</p><ul><li><p><strong>磁盘管理（Disk management）</strong></p><p>将磁盘块集成文件。</p></li><li><p><strong>命名（Naming）</strong></p><p>接口通过名字访问文件而不是磁盘块。</p></li><li><p><strong>保护（Protection）</strong></p><p>保护文件数据安全。</p></li><li><p><strong>可靠性/耐用性（Reliability/Durability）</strong></p><p>保证文件的持久性。</p></li></ul><h5 id="文件">文件</h5><p><strong>文件是一种对计算机上非易失性（non-volatile）存储的抽象。</strong></p><p>其包括了：</p><ul><li><p><strong>数据（Data）</strong>：</p><p>在硬件上存储的数据块。</p></li><li><p><strong>元数据（Metadata）</strong></p><ul><li><p><strong>用户（Owner）</strong></p></li><li><p><strong>大小（Size）</strong></p></li><li><p>最近开启时间（Last opened）</p></li><li><p>最后一次修改时间（Last modified）</p></li><li><p><strong>权限（Access rights）</strong></p><p>在 Unix / Linux 操作系统中，一般用 9 个 bit来描述文件的权限，分别表示所属用户、群组用户和外部用户对该文件是否有读（Read）、写（Write）和执行（Execute）的权限。</p></li><li><p>硬链接的数量（Number of hard links to the file）</p></li></ul><blockquote><p>在 Unix / Linux 操作系统中，我们可以使用 <code>ls</code>指令输出文件详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -l demo.txt<br></code></pre></td></tr></table></figure><p>终端输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">-rw-r--r--@ 1 username  staff  0 10 12 16:38 demo.txt<br></code></pre></td></tr></table></figure><ol type="1"><li><code>-rw-r--r--</code> ：</li></ol><p>这部分显示了文件的权限模式。在这个权限模式中，有10个字符，它们按顺序表示了文件的不同权限。这个权限模式可以分为三部分：</p><ul><li>第一位是文件的类型， <code>-</code> 表示 <code>demo.txt</code>是一个普通文件。</li><li>接下来的 3位（<code>rw-</code>）表示文件的所有者（<code>username</code>）具有读（r）和写（w）的权限，但没有执行（x）权限。</li><li>再接下来的3位（<code>r--</code>）表示文件的组（<code>staff</code>）具有只读（r）的权限，但没有写入（w）或执行（x）的权限。</li><li>最后的3位（<code>r--</code>）表示其他用户也具有只读（r）的权限，但没有写入（w）或执行（x）的权限。</li></ul><p>可以使用 <code>chmod</code> 指令对文件权限进行修改：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-12-101251.png" style="zoom:40%;" /></p><ol start="2" type="1"><li><p><code>1</code> ：这个数字表示文件的硬链接数。在这个示例中，文件<code>demo.txt</code>有一个硬链接。硬链接是指多个文件名指向相同的文件数据块。每个文件都有一个硬链接计数，当这个计数变为零时，文件数据才会被删除。</p></li><li><p><code>username</code>：文件<strong>所有者（Owner）</strong>的用户名。</p></li><li><p><code>staff</code> ：文件所属组（Group）名。</p></li><li><p><code>0</code>：这是文件的大小，以字节为单位。在这个示例中，文件大小为0字节，表示这是一个空文件。</p></li><li><p><code>10 12 16:38</code>：这是文件的最后修改时间。具体来说，这个文件的最后时间是在 10 月 12 日的16:38。</p></li></ol></blockquote></li><li><p><strong>文件的需求</strong></p><ul><li>可变的大小（<strong>Variable size</strong>）</li><li>可实现多个并发用户和进程，同时能有保护作用（<strong>Multipleconcurrent users / peocesses</strong> but with<strong>protection</strong>）</li><li>高效的查找技术（<strong>Being able to find files</strong>）</li><li>管理空闲磁盘块（<strong>Manage free disk blocks</strong>）</li></ul></li></ul><h5 id="文件系统的组成部分">文件系统的组成部分</h5><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-12-085412.png" alt="Components of a File System" style="zoom:67%;" /></p><ul><li><p><strong>目录结构（Directory Structure）</strong></p><p>目录结构是文件系统中用于组织和管理文件和目录的方式。通常，它采用树状结构（Hierarchytree-likestructure），类似于文件夹（目录）和文件的层次结构。根目录位于顶层，包含子目录和文件，这些子目录又可以包含更多的子目录和文件，以此类推。每个目录都可以包含文件和其他目录。</p><p>Unix / Linux 操作系统使用的目录结构是一个树状结构，根目录通常表示为<code>/</code>，然后有多个子目录和文件，如<code>/home</code>、<code>/usr</code> 等等。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-12-090133.png" alt="Files in the Linux root directory" style="zoom:67%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-12-091248.png" style="zoom:50%;" /></p></li><li><p><strong>文件索引结构（File Index Structure）</strong></p><p>文件索引结构是文件系统用于管理文件和文件属性的内部数据结构。它包含有关文件的元数据信息，例如文件名、大小、创建日期、修改日期、权限和链接数等。文件索引结构的设计取决于文件系统的类型。</p><p>例如，在 Unix / Linux 中，常见的文件系统如 Ext4使用了<strong>索引节点（Inode）</strong>结构来存储文件的元数据。每个文件和目录都有一个唯一的索引节点号，而这个索引节点包含了关于文件的所有信息。这使得操作系统能够有效地查找和管理文件。</p><p>我们可以给 <code>ls</code> 指令加上 <code>-i</code> 参数来显示文件的inode 属性：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-12-090915.png" style="zoom:67%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-12-092100.png" style="zoom:50%;" /></p></li><li><p><strong>数据块（Data Block）</strong></p><p>数据块是文件系统用来存储文件内容的基本单位。当文件太大以至于无法一次存储在内存中时，文件会被划分为多个数据块，每个数据块包含文件的一部分内容。这些数据块通常由文件系统管理，而文件索引结构中的信息将告诉操作系统如何组合这些数据块以获取完整的文件内容。</p><p>在大多数文件系统中，数据块通常是一个连续的、固定大小的块，例如 4KB 或8KB。文件系统会维护一个映射，将文件的逻辑块地址映射到物理磁盘上的数据块。</p></li></ul><h4 id="文件的启动与关闭">文件的启动与关闭</h4><h5 id="打开文件表">打开文件表</h5><p><strong>操作系统需要在内存维护所有开启文件的信息</strong>。</p><p><strong>打开文件表（Open filetable）</strong>是操作系统内部用于跟踪已打开文件的数据结构，它包含了文件的元数据和状态信息，允许操作系统和进程有效地管理对文件的访问。每个正在运行的进程都有其自己的打开文件表，用于跟踪该进程所打开的文件。</p><ul><li><p><strong>系统范围的打开文件表（System-wide open filetable）</strong></p><p>系统范围的打开文件表是操作系统维护的一个数据结构，用于跟踪在整个系统范围内打开的文件。<strong>它存储了有关每个系统中已打开文件的信息（Informationfor every currently open file in thesystem）</strong>，<strong>例如存储在 inode属性中的信息（文件名、大小、所属用户等）</strong>。</p><p>系统范围的打开文件表<strong>允许不同的进程共享文件的访问信息</strong>。当多个进程打开同一个文件时，它们可以共享相同的系统范围的打开文件表条目，这意味着它们可以看到对该文件的更改。这有助于提高操作系统的效率，因为不需要为每个打开的文件创建独立的系统资源，只需在系统范围的打开文件表中引用相同的信息即可。</p></li><li><p><strong>进程内的打开文件表（Per-process open filetable）</strong></p><p>每个进程都有自己的进程内打开文件表，用于跟踪该进程打开的文件。每个进程内的打开文件表包含了一个<strong>指向系统打开文件表的指针（Apointer to the system open file table）</strong>和其他信息如文件描述符、文件状态标志、当前文件偏移量等。</p><p>进程内的打开文件表使每个进程能够独立地管理其打开的文件，包括读取、写入和定位文件指针等操作。这确保了不同进程之间的文件访问彼此隔离，一个进程的文件操作不会影响其他进程。</p></li></ul><h5 id="open-和-close"><code>open()</code> 和 <code>close()</code></h5><p>在 Linux 内核中，<code>open()</code> 和 <code>close()</code>是两个重要的系统调用函数，用于打开和关闭文件。这些函数在文件操作中起着关键作用，允许进程与文件进行交互。</p><p>一下展示两个系统调用在 C 语言中的接口：</p><ul><li><p><strong><code>open()</code> 函数</strong>：</p><p><code>open()</code> 函数用于打开文件，并返回一个称为文件描述符（FileDescriptor）的整数值，该文件描述符在后续的文件操作中用于唯一标识打开的文件。函数原型如下：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span>;<br></code></pre></td></tr></table></figure></p><ul><li><code>pathname</code>：是要打开的文件的路径或文件名。</li><li><code>flags</code>：是一组标志，用于指定文件的打开方式，如只读、只写、追加等。常见的标志包括<code>O_RDONLY</code>（只读）、<code>O_WRONLY</code>（只写）、<code>O_RDWR</code>（读写）、<code>O_APPEND</code>（追加写入）、<code>O_CREAT</code>（如果文件不存在则创建）、<code>O_TRUNC</code>（截断文件）等。</li><li><code>mode</code>：是文件权限的设置，通常与 <code>O_CREAT</code>标志一起使用，用于新创建的文件。（如果文件已存在则不需要传递该参数）</li></ul><p><code>open()</code>函数返回一个非负整数文件描述符，如果打开文件失败，则返回-1。文件描述符在进程的打开文件表中唯一标识已打开的文件，可以用于后续的读取、写入和关闭操作。</p></li><li><p><strong><code>close()</code> 函数</strong>：</p><p><code>close()</code> 函数用于关闭先前通过 <code>open()</code>函数打开的文件，释放与文件描述符相关的资源。函数原型如下：</p><p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span>;<br></code></pre></td></tr></table></figure></p><ul><li><code>fd</code>：是要关闭的文件描述符。</li></ul><p><code>close()</code>函数会关闭指定的文件描述符，使该文件描述符不再可用，同时释放与该文件描述符相关的资源，如文件表项和文件描述符表中的条目。关闭文件是一项重要的操作，它有助于避免资源泄漏和确保文件在不再需要时不会继续占用系统资源。</p></li></ul><p><strong>当我们打开一个文件</strong>：</p><ol type="1"><li>先进行 <code>open()</code> 系统调用，<strong>从磁盘中读取目标文件的inode 信息，并存储在系统范围的打开文件表内。</strong></li><li><strong>当前进程内的打开文件表新增一个指向系统范围内打开文件表的索引（或指针）</strong>，并通过<code>open()</code> 函数返回给程序（在 Unix / Linux 中称为 Filedescriptor，在 Windows 中称为 File handle）。</li></ol><p><strong>当我们关闭一个文件</strong>：</p><ol type="1"><li>释放<strong>进程表项（Per-process table entry）</strong>。</li><li>当前存储在此文件的<strong>内存缓存（Memorycache</strong>）中的任何数据都将在必要时写入磁盘。</li></ol><h4 id="文件的共享">文件的共享</h4><p><strong>一个文件可以被多个用户 /进程访问</strong>，如果同一时间多个用户或进程以只读方式打开文件，那该过程可以正常执行，但如果多个用户或进程同时读写就可能引发冲突。</p><p>因此 OS 中引入了<strong>锁（Lock）</strong>：</p><p>文件锁技术是一种用于控制对文件的并发访问的机制。它允许多个进程或线程协调共享对文件的访问，以防止竞争条件和数据损坏。文件锁通常用于多进程或多线程环境中，其中多个实体需要访问相同的文件。</p><p>有两种主要类型的文件锁：共享锁（Shared Lock）和独占锁（ExclusiveLock）。这些锁可以在文件上的不同部分或整个文件上设置。</p><ol type="1"><li><strong>共享锁（Shared Lock）</strong>：<ul><li>多个进程可以同时持有共享锁。</li><li>共享锁允许多个进程同时读取文件，但阻止其他进程获得独占锁。</li><li>共享锁通常用于并发读取操作，以防止竞争条件。</li></ul></li><li><strong>独占锁（Exclusive Lock）</strong>：<ul><li>仅一个进程可以持有独占锁。</li><li>独占锁阻止其他进程获得任何类型的锁，共享锁和独占锁都被阻止。</li><li>独占锁通常用于写入和修改文件的操作，以确保数据的一致性。</li></ul></li></ol><blockquote><p>例如，用户 A在读取文件时每个进程都持有共享锁，其他进程无法对文件内容进行修改，只能以只读方式打开文件。</p></blockquote><h4 id="文件索引与文件信息">文件索引与文件信息</h4><h5 id="unixlinux-inode">Unix/Linux Inode</h5><p>在 Unix 和 Linux文件系统中，"inode"（索引节点）是一个关键的<strong>数据结构</strong>，用于管理和存储文件的元数据信息。<strong>每个文件和目录都有一个唯一的inode</strong>，用于跟踪文件的属性、权限、所在位置等等，我们可以认为一个文件的inode 主要维护了以下两类信息：</p><ul><li><strong>元数据（Metadata）</strong></li><li><strong>数据块地址（Which disk blocks belong to whichfile）</strong></li></ul><blockquote><p>元数据在上文中已经介绍，包括文件的一些基本信息，数据块地址则是文件实际内容的存储地址。</p></blockquote><p>我们可以使用 <code>stat</code> 指令查看文件包括 inode在内的各种详细信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">stat filename<br></code></pre></td></tr></table></figure><p><strong>示例</strong>：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-12-102335.png" style="zoom:67%;" /></p><p><strong>Inode 存储在什么地方？</strong></p><p>在早期的 UNIX 系统中，它们被存储在磁盘。</p><ul><li>Inode不在数据块附近存储。要读一个小文件，先查找索引节点，再查找回数据。（<strong>Poorperformance</strong>）</li><li>如果外部磁盘损坏，意味着文件系统会丢失。（<strong>Poorreliability</strong>）</li></ul><p>在后来的系统中，<strong>索引节点分布在磁盘块组中，更接近数据块本身</strong>。</p><h6 id="文件链接">文件链接</h6><p>文件链接允许我们创建一个文件的副本，即一份文件有两份不同名的实例，文件链接有以下两种：</p><ul><li><p>软链接（Symbolic (soft) links）</p><p><strong>保存原文件的路径</strong>，类似于 Windows 中的快捷方式。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s original link<br></code></pre></td></tr></table></figure></p></li><li><p>硬链接（Hard links）</p><p><strong>链接文件与原文件拥有同样的 Inode编号</strong>，<strong>但需要注意的是目录是无法创建硬链接的</strong>。</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln original link<br></code></pre></td></tr></table></figure></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-14-112600.png" style="zoom:67%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-14-112034.png" style="zoom:67%;" /></p><p>如上图，(a) 表示文件初始状态；(b)表示创建了一个硬链接，此时文件的硬链接数变为 2；(c)表示文件原来所属用户将文件删除，此时文件的硬链接数变为 1。</p></li></ul><h5 id="unix-目录">Unix 目录</h5><p><strong>目录（Directory）</strong>是一种<strong>特殊的文件</strong>，其包含：</p><ul><li><strong>文件名列表（A list of filenames）</strong></li><li><strong>指向 Inode 的指针（Pointers to inodes）</strong></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-13-093456.png" style="zoom:50%;" /></p><p class="note info-note">We are used to thinking about a directory containing files. This isreally an illusion. Directories do not contain files. The data of thefiles is not stored in the directory.<br> A directory is really just afile. It's a special file with special rules (you can't just type<code>cp /dev/null directory</code> to erase it. It's got special bitsto make sure a mere mortal can't mess it up. Because if a file systemgets corrupted, then you can say goodbye to your data. On older UNIXsystems, you actually could "read" the contents, using <code>cat.</code> , of a directory. But let me get back to that in asecond...<br> <strong>A Unix file is "stored" in two different parts ofthe disk - the data blocks and the inodes. (I won't get into superblocksand other esoteric information.) The data blocks contain the "contents"of the file. The information about the file is stored elsewhere - in theinode.</strong><br> <strong>Above all, the directory is just a tablethat contains the filenames in the directory, and the matchinginode.</strong></p><h4 id="文件分配">文件分配</h4><h5 id="连续分配">连续分配</h5><p><strong>连续文件分配（Contiguous FileAllocation）</strong>即所有文件在存储空间内是连续存储的，在文件分配表中所有文件只需要两个值来维护：</p><ol type="1"><li>起始位置（Start address）</li><li>数据大小（Length）</li></ol><blockquote><p>这种分配方式在 CD 和 DVD 中常用。</p></blockquote><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-14-102022.png" style="zoom:50%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-14-102109.png" style="zoom:50%;" /></p><p>这样的分配方式的优点就是易于实现，缺点也很明显，就是数据块之间存在许多未分配的小空间，这里我们称为<strong>外部碎片（Externalfragmentation）</strong>，另一个就是其不能完全满足文件大小动态增长的需求，例如文件过大则可能超过预先分区的大小。</p><h5 id="链式分配">链式分配</h5><p><strong>链式分配（LinkedAllocation）</strong>是一种文件存储分配方式。在链式分配中，文件中的数据块不是连续分配的，而是通过链表来链接。每个数据块都包含一个指向下一个数据块的指针，创建一个链表结构，使文件的数据块按照其实际分配的顺序链接在一起。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-14-103529.png" style="zoom:67%;" /></p><h6 id="fat">FAT</h6><p>FAT（File AllocationTable）是一种经典的文件系统结构，通常用于存储媒体，如硬盘驱动器、闪存驱动器和其他可移动存储设备。</p><p><strong>在 FAT文件系统中，每个文件都由一系列链接在一起的簇来表示。文件的起始簇被存储在文件的目录项中，而接下来的簇号在FAT 表格中找到。这样，文件的数据块通过 FAT表格中的指针链起来，形成一个链表结构。</strong></p><p>在 FAT 中，未被使用的数据块也会被放在一个链表中，称为 FATfree-list。</p><blockquote><p>因此当我们格式化磁盘后，会发生以下两件事：</p><ol type="1"><li>清空所有数据块的信息</li><li>将所有数据块链接为 free-list</li></ol></blockquote><ul><li>优点：易于实现</li><li>缺点：对于大型文件而言，FAT访问需要跳转许多数据块，可能造成过大的时间开销</li></ul><h5 id="bitmap">Bitmap</h5><p>操作系统需要管理未分配区域（Free space），除了上文提及的 FAT 中的free-list 之外，还有另外一个常见的解决方案，就是使用<strong>Bitmap</strong>。</p><p>Bitmap是一个数组，其维护了每个数据块是否被使用，如果该数据块被使用了，则为1，否则为 0。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-14-105957.png" alt="Bitmap" style="zoom:67%;" /></p><p><strong>优点</strong>：</p><ul><li>对任意一种存储方式都适用</li><li>只需要很小的存储空间</li></ul><h4 id="常用文件系统">常用文件系统</h4><ul><li><p>Unix / Linux</p><ul><li><p>EXT 2/3/4</p><p>EXT（Extended File System）广泛用于 Linux 和 Unix操作系统家族，特别是在 Linux 系统中。它有多个版本，其中 EXT2、EXT3、和EXT4 是最常见的。</p></li><li><p>ZFS</p><p>ZFS（Zettabyte FileSystem）是一种先进的、先进的文件系统和存储管理系统，最初由 SunMicrosystems（现在是 Oracle Corporation 的一部分）开发。</p></li></ul></li><li><p>Apple</p><ul><li><p>HFS+</p><p>HFS+（Hierarchical File System Plus）最初由 Apple Inc. 开发并用于Macintosh 计算机。它是 HFS（Hierarchical FileSystem）的升级版本，引入了许多改进和新特性。</p></li></ul></li><li><p>Microsoft</p><ul><li><p>FAT 16/32</p><p>主要在 MS-DOS 和 Windows XP 中使用。</p></li><li><p>NTFS</p><p>NTFS（New Technology File System）是一种现代的文件系统，最初由Microsoft 开发并引入到 Windows NT 操作系统中。</p></li><li><p>exFAT</p><p>exFAT（Extended File Allocation Table）由 Microsoft 于 2006年引入，旨在解决一些早期文件系统（如 FAT 32）存在的限制和问题。exFAT主要设计用于存储在可移动存储介质（如闪存驱动器、SD卡、外部硬盘等）上的大容量文件，尤其是用于跨平台数据交换。</p></li></ul></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-26-032750.png" style="zoom:100%;" /></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql-connector 学习笔记</title>
    <link href="/2023/10/04/mysql-connector%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/04/mysql-connector%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="简介">简介</h4><p><code>mysql-connector</code> 是一个用于 Python 编程语言的 MySQL数据库连接库，它允许开发人员连接到 MySQL数据库并执行各种数据库操作，如查询、插入、更新和删除数据。</p><h5 id="安装">安装</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install mysql-connector<br></code></pre></td></tr></table></figure><h4 id="使用">使用</h4><h5 id="创建数据库连接">创建数据库连接</h5><p>我们先在本地创建一个名为 <code>demo</code> 的数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -u root -p<br><span class="hljs-meta prompt_"># </span><span class="language-bash">以 root 登陆 mysql 客户端</span><br><br>create table demo;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建数据库</span><br><br>show databases;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果显示有 demo，则表示创建成功</span><br></code></pre></td></tr></table></figure><p>创建成功后，我们就可以使用 <code>mysql-connector</code>连接到数据库了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> mysql.connector<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-keyword">try</span>:<br>        demo_connection = mysql.connector.connect(<br>            host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>            user=<span class="hljs-string">&#x27;root&#x27;</span>,<br>            passwd=<span class="hljs-string">&#x27;xxxxx&#x27;</span>, <span class="hljs-comment"># Your password</span><br>            database=<span class="hljs-string">&#x27;demo&#x27;</span> <span class="hljs-comment"># 指定具体的数据库，也可以不加</span><br>        )<br>    <span class="hljs-keyword">except</span> mysql.connector.Error <span class="hljs-keyword">as</span> err:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Connection Error!&#x27;</span>, err)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="操作数据库">操作数据库</h5><p>连接成功后我们就可以操作本地数据库了。为了操作数据库，我们需要创建一个「Cursor」 对象。</p><blockquote><p>Cursor 是一个重要的对象，它用于执行 SQL 查询和操作数据库。</p></blockquote><ol type="1"><li><p><strong>创建 Cursor 对象</strong>： 在使用<code>mysql-connector</code> 连接到 MySQL 数据库后，首先需要创建一个<code>cursor</code> 对象。通常，可以使用<code>connection.cursor()</code> 方法来创建一个新的 <code>cursor</code>对象，其中 <code>connection</code> 是数据库连接的实例。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">my_cursor = demo_connection.cursor()<br></code></pre></td></tr></table></figure></p></li><li><p><strong>执行 SQL 语句</strong>： 通过 <code>cursor</code>对象，可以执行各种 SQL 查询。要执行查询，可以使用<code>cursor.execute(sql_query)</code> 方法，其中 <code>sql_query</code>是包含 SQL 语句的字符串。</p><p>假设 <code>demo</code> 数据库中有表格<code>stuff(s_id, s_name, gender, salary, dept_id)</code></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">my_cursor.execute(<span class="hljs-string">&#x27;select * from stuff&#x27;</span>)<br><br>my_cursor.execute(<span class="hljs-string">&#x27;insert into stuff values(%s, %s, %s, %s, %s)&#x27;</span>, (<span class="hljs-number">2023100</span>, <span class="hljs-string">&#x27;Frank&#x27;</span>, <span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">40000</span>, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure></p><blockquote><p>注：如果要一次性向表格插入多个数据，<code>execute()</code>方法的第二个参数可以接收一个包含了多个元组的列表。</p></blockquote></li><li><p><strong>获取查询结果</strong>：一旦执行了查询，可以使用不同的方法来获取查询结果。例如，可以使用<code>cursor.fetchone()</code> 获取一行记录，或者使用<code>cursor.fetchall()</code> 获取所有匹配的记录。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 获取一行记录</span><br>row = my_cursor.fetchone()<br><br><span class="hljs-comment"># 获取所有匹配的记录</span><br>rows = my_cursor.fetchall()<br></code></pre></td></tr></table></figure></p></li><li><p><strong>提交事务</strong>： 在执行写操作（如<code>INSERT</code>、<code>UPDATE</code> 或 <code>DELETE</code>）后，通常需要提交事务以确保更改生效。可以使用<code>connection.commit()</code> 方法来提交事务。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 提交事务</span><br>demo_connection.commit()<br></code></pre></td></tr></table></figure></p></li><li><p><strong>关闭 Cursor 和连接</strong>： 使用完 <code>cursor</code>和数据库连接后，应该关闭它们以释放资源。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 关闭 Cursor</span><br>my_cursor.close()<br><br><span class="hljs-comment"># 关闭连接</span><br>demo_connection.close()<br></code></pre></td></tr></table></figure></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>数据库系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet 学习笔记</title>
    <link href="/2023/10/03/Servlet%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/10/03/Servlet%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="servlet-简介">Servlet 简介</h4><p>Servlet 是 Java EE（Java Platform, Enterprise Edition）中的一种 Java程序组件，用于处理 Web 应用程序中的 HTTP 请求和响应。Servlet 通常运行在Web 服务器或 Servlet 容器中，并提供了一种有效的方式来创建动态的 Web内容。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-03-055254.png" style="zoom:50%;" /></p><p class="note note-info">Servlets were Java’s answer to CGI (Common Gateway Interface), and<strong>programs that run on web server acting as middle layer betweenHTTP request and databases or other applications.</strong></p><h5 id="mvc-模型">MVC 模型</h5><p>MVC（Model-View-Controller）是一种软件架构模式，用于组织和分离应用程序的不同组成部分，以提高应用程序的可维护性、可扩展性和可重用性。MVC模型将应用程序分为三个主要组件，每个组件都有不同的责任。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-03-055757.png" alt="MVC Model" style="zoom:50%;" /></p><p class="note note-info">Java classes/beans —— The business logic (Model)<br> JSP —— Thepresentation logic (View)<br> Servlet —— Handling the HTTP protocol andcoordination (Controller)</p><ol type="1"><li><strong>模型（Model）</strong>：<ul><li>模型代表应用程序的数据和业务逻辑。</li><li>模型负责处理数据的获取、存储、验证和操作，以确保数据的完整性和一致性。</li><li>模型通常不直接与用户界面交互，而是通过控制器来处理数据的请求和响应。</li></ul></li><li><strong>视图（View）</strong>：<ul><li>视图负责呈现数据给用户，并负责用户界面的显示。</li><li>视图通常不包含应用程序的业务逻辑，它只负责显示数据和接收用户输入。</li><li>视图可以是图形用户界面（GUI）、Web页面、命令行界面或其他任何用户界面形式。</li></ul></li><li><strong>控制器（Controller）</strong>：<ul><li>控制器充当模型和视图之间的中介，它接收来自用户界面的用户输入。</li><li>控制器负责解释用户输入，并相应地调用模型的方法来执行业务逻辑。</li><li>控制器还可以更新视图以反映模型的状态变化。</li></ul></li></ol><h5 id="servlet-优点">Servlet 优点</h5><ul><li><p>高效性（Efficient，lower overhead）</p><p>Servlet 在 JVM上运行，<strong>每一个请求都使用线程而不是开启一个新的进程</strong>。</p></li><li><p>便利（Convenient）</p><p>提供解析和解码 HTML 表单的基础设施。</p></li><li><p>功能强大（Powerful）</p><ul><li><strong>可以直接和 Web Server 连接</strong>；</li><li><strong>多个 Servlet 可以共享数据库链接</strong>。</li></ul></li><li><p>跨平台（Portable）</p><ul><li>使用 Java 编写，可移植性强。</li></ul></li></ul><h5 id="tomcat">Tomcat</h5><p>Apache Tomcat（通常称为Tomcat）是一个开源的 Servlet容器，用于实现和管理 Java Servlet 和 JSP。它是 Apache软件基金会的一个项目，作为一个轻量级的 Web 服务器，被广泛用于运行 JavaWeb 应用程序。</p><p>目录结构：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-03-070211.png" style="zoom:50%;" /></p><h4 id="servlet-生命周期">Servlet 生命周期</h4><p>Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet遵循的过程：</p><ul><li><p>Servlet 初始化后调用 <code>init()</code> 方法。</p><blockquote><p>注：<code>init()</code>方法不等同于构造方法，构造方法只会创建一个对象，只有调用完<code>init()</code> 方法后对象才是一个合格的 Servlet。</p></blockquote></li><li><p>Servlet 调用 <code>service()</code>方法来处理客户端的请求。</p></li><li><p>Servlet 销毁前调用 <code>destroy()</code> 方法。</p></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-03-060132.png" style="zoom:50%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-03-065137.png" style="zoom:60%;" /></p><h4 id="第一个-servlet-实例">第一个 Servlet 实例</h4><p>通过 IDEA 构建一个 Jakarta EE 项目，创建一个简单的 Servlet 实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.example.Servlet_demo;<br><br><span class="hljs-meta">@WebServlet(name = &quot;helloServlet&quot;, value = &quot;/hello-servlet&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        message = <span class="hljs-string">&quot;Hello World!&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-built_in">super</span>.service(req, res);<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        response.setContentType(<span class="hljs-string">&quot;text/html&quot;</span>);<br><br>        <span class="hljs-comment">// Hello</span><br>        <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> response.getWriter();<br>        out.println(<span class="hljs-string">&quot;&lt;html&gt;&lt;body&gt;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;&lt;h1&gt;&quot;</span> + message + <span class="hljs-string">&quot;&lt;/h1&gt;&quot;</span>);<br>        out.println(<span class="hljs-string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Servlet is destroyed&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置 <code>web.xml</code> 文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;https://jakarta.ee/xml/ns/jakartaee https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;5.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.example.servlet_demo.HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/HelloServlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>Servlet 中的部署描述符（Deployment Descriptor，DD）是一个 XML文件，通常命名为 <code>web.xml</code>，用于配置和管理 Web 应用程序中的Servlet 组件。Deployment Descriptor 提供了一种在 Servlet 容器中配置Servlet 和其他 Web 应用程序组件的方式，这样 Web服务器可以正确地加载和运行这些组件。</p><p>以下是一些常用的 <code>web.xml</code> 配置标签及其功能：</p><ol type="1"><li><code>&lt;web-app&gt;</code> ：<code>web.xml</code>文件的根元素，用于定义整个 Web 应用程序的配置。它包含各种子元素，如<code>&lt;servlet&gt;</code>、<code>&lt;servlet-mapping&gt;</code>、<code>&lt;filter&gt;</code>、<code>&lt;filter-mapping&gt;</code>等，用于配置 Servlet、Filter、Listener 等。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.1&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置其他元素 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li><code>&lt;servlet&gt;</code> ：用于配置 Servlet，指定 Servlet类名、Servlet 名称等信息。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>MyServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.example.MyServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li><code>&lt;servlet-mapping&gt;</code> ：将 Servlet 映射到 URL模式，指定哪些 URL 请求将由哪个 Servlet 处理。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>MyServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/Myservlet<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="4" type="1"><li><code>&lt;filter&gt;</code>：用于配置过滤器（Filter），允许对请求和响应进行处理。过滤器通常用于执行预处理、日志记录、身份验证等任务。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>MyFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.example.MyFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><code>&lt;filter-mapping&gt;</code>：将过滤器映射到 URL模式，指定哪些请求将由哪个过滤器处理。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>MyFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/myfilter<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="6" type="1"><li><code>&lt;listener&gt;</code>：配置监听器（Listener），用于监听 Web应用程序的生命周期事件，如启动和销毁。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>com.example.MyListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="7" type="1"><li><code>&lt;init-param&gt;</code> ：用于为特定的 Servlet提供初始化参数。这些初始化参数可以在 Servlet的初始化阶段读取，以配置和自定义 Servlet的行为。通常情况下，<code>&lt;init-param&gt;</code> 标签是放在<code>&lt;servlet&gt;</code> 标签内的，用于为特定的 Servlet配置参数。以下是有关 <code>&lt;init-param&gt;</code> 的详细信息：</li></ol><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>MyServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.example.MyServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>param1<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>value1<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>param2<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>value2<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>上述示例中，我们在 <code>&lt;servlet&gt;</code> 标签内定义了两个<code>&lt;init-param&gt;</code> 子元素，每个<code>&lt;init-param&gt;</code> 都包含一个<code>&lt;param-name&gt;</code> 和一个<code>&lt;param-value&gt;</code>。这些元素的含义如下：</p><ul><li><code>&lt;param-name&gt;</code>：用于指定初始化参数的名称。这是一个字符串，用于标识参数。</li><li><code>&lt;param-value&gt;</code>：用于指定初始化参数的值。这是实际的参数值，可以是字符串、数字或其他合适的数据类型。</li></ul><p>在 Servlet 类中，您可以通过<code>getInitParameter(String paramName)</code>方法来获取这些初始化参数的值。例如：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>        <span class="hljs-built_in">super</span>.init(config);<br>        <br>        <span class="hljs-comment">// 获取初始化参数</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">param1</span> <span class="hljs-operator">=</span> getInitParameter(<span class="hljs-string">&quot;param1&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">param2</span> <span class="hljs-operator">=</span> getInitParameter(<span class="hljs-string">&quot;param2&quot;</span>);<br>        <br>        <span class="hljs-comment">// 使用参数值进行初始化</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 其他 Servlet 方法</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过这种方式，您可以在部署描述符中为 Servlet 配置一些参数，以在Servlet 初始化时使用这些参数进行定制。这对于在不同环境中部署同一个Servlet 并根据需要进行不同的配置非常有用。</p></blockquote><p><code>index.jsp</code> 文件：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="hljs-string">&quot;UTF-8&quot;</span> %&gt;<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;title&gt;JSP - Hello World&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;&lt;%= <span class="hljs-string">&quot;Hello World!&quot;</span> %&gt;<br>&lt;/h1&gt;<br>&lt;br/&gt;<br>&lt;a href=<span class="hljs-string">&quot;hello-servlet&quot;</span>&gt;Hello Servlet&lt;/a&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><blockquote><p>JSP (JavaServer Pages) 是一种基于 Java的技术，用于创建动态的、数据驱动的网页。JSP 允许开发者直接在 HTML页面中嵌入 Java 代码，这使得动态生成的内容可以轻松地与静态的 HTML内容结合起来。</p><ul><li><strong>基于 HTML</strong>：JSP 页面看起来很像普通的 HTML页面。实际上，你可以直接将一个 HTML 文件的扩展名从 <code>.html</code>更改为 <code>.jsp</code>，它仍然可以正常工作。但是，这只是 JSP最基本的用法。</li><li><strong>动态内容</strong>：与纯 HTML 页面只能展示固定内容不同，JSP允许开发者在 HTML 中嵌入 Java代码片段。这些代码片段在页面请求时执行，并动态生成内容。在 JSP中，可以使用特殊的标签（如<code>&lt;%= ... %&gt;</code>）来插入动态内容。例如，<code>&lt;%= new Date() %&gt;</code>会在页面上显示当前的日期和时间。</li><li><strong>JSP 标签库</strong>：除了基本的 Java 代码，JSP还支持自定义标签库，如 JSTL (JavaServer Pages Standard TagLibrary)。这些标签库提供了一组可在 JSP页面中使用的预定义功能，从而避免了直接嵌入复杂的 Java 代码。</li><li><strong>生命周期</strong>：当请求一个 JSP 页面时，它首先被转换为一个Java Servlet，然后由 Servlet 容器（如 ApacheTomcat）编译和执行。这意味着，虽然 JSP允许你以更声明性的方式编写动态网页，但在幕后，它实际上是一个完整的 JavaServlet。</li></ul></blockquote><p>在生成的 HTML 网页中点击超链接 "Hello Servlet" ，即调用<code>HelloServlet</code> 的 <code>doGet()</code> 方法，在页面打印"Hello World!"，同时每次刷新页面都会调用 <code>service()</code>方法，在控制台窗口打印 "Hello World!"。</p><p>执行原理：</p><ol type="1"><li>当服务器接收到客户浏览器的请求后，会解析请求 URL 路径，获取访问的Servlet 的资源路径</li><li>查找 <code>web.xml</code> 文件，查找是否存在<code>&lt;url-pattern&gt;</code> 标签体内容</li><li>如果有，则在找到对应的 <code>&lt;servlet-class&gt;</code>全类名</li><li>Tomcat 会将类的字节码文件加载进内存，并且创建其对象</li><li>调用对应方法</li></ol><h4 id="servlet-基本方法详解">Servlet 基本方法详解</h4><h5 id="生命周期">生命周期</h5><h6 id="init"><code>init()</code></h6><p><code>init()</code> 方法是 Servlet生命周期中的一个非常重要的方法。它主要用于执行只需要在 Servlet启动时进行一次的初始化操作。这意味着，在 Servlet的整个生命周期中，<code>init()</code> 方法只会被调用一次。</p><p><strong>定义</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException;<br></code></pre></td></tr></table></figure><p><strong>方法参数</strong>：</p><ul><li><p><code>ServletConfig</code> ：此对象包含 Servlet的初始化参数，这些参数在部署描述符（通常是 <code>web.xml</code>文件）中定义。你可以使用这个对象来获取 Servlet的名称、初始化参数等。现如今在定义 <code>init()</code>方法的时候已经可以不需要带该参数了，不带参数的 <code>init()</code>方法内部会通过 <code>getServletConfig()</code> 方法获取到<code>ServletConfig</code> 对象，所以你仍然可以在这个方法内访问 Servlet的配置信息。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-comment">// 初始化代码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">configFile</span> <span class="hljs-operator">=</span> getServletConfig().getInitParameter(<span class="hljs-string">&quot;configFile&quot;</span>);<br>    loadConfig(configFile);<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul><h6 id="service"><code>service()</code></h6><p><code>service()</code> 方法是 Servlet生命周期中的一个核心方法，负责处理来自客户端的请求并返回响应。</p><p><strong>定义</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(ServletRequest req, ServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException;<br></code></pre></td></tr></table></figure><p><strong>方法参数</strong>：</p><ul><li><code>req</code>：代表客户端发送给服务器的请求信息。这个对象提供了读取输入流、获取参数、查询头信息等方法。</li><li><code>res</code>：代表服务器发送回客户端的响应信息。这个对象提供了设置响应内容、设置响应状态、设置响应头等方法。</li></ul><p><code>service()</code> 方法根据请求的类型（如 GET、POST、PUT、DELETE等）将请求分派到相应的处理方法，如 <code>doGet()</code>,<code>doPost()</code>, <code>doPut()</code>, <code>doDelete()</code>等。</p><p>例如，当一个 HTTP GET 请求到达时，<code>service()</code> 方法会调用<code>doGet()</code> 方法进行处理。同样地，对于 HTTP POST请求，<code>service()</code> 会调用 <code>doPost()</code> 方法。</p><p>通常，你不需要直接重写 <code>service()</code> 方法。相反，你应该重写<code>doGet()</code> ， <code>doPost()</code> ，<code>doPut()</code>，<code>doDelete()</code> 等方法来处理特定类型的请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-comment">// 在所有请求前执行的逻辑</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-comment">// 调用父类的 service 方法以确保请求被分派到 doGet(), doPost() 等方法</span><br>    <span class="hljs-built_in">super</span>.service(req, res);<br><br>    <span class="hljs-comment">// 在所有请求后执行的逻辑</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><code>doGet(HttpServletRequest request, HttpServletResponse response)</code>：<ul><li>该方法用于处理 HTTP GET 请求。</li><li>它通常用于获取资源或执行只读操作，不应该对服务器状态进行更改。</li><li>通过<code>request</code>对象获取请求参数、头信息等，并通过<code>response</code> 对象生成响应内容发送给客户端。</li></ul></li><li><code>doPost(HttpServletRequest request, HttpServletResponse response)</code>：<ul><li>该方法用于处理HTTP POST请求。</li><li>POST请求通常用于提交数据，例如表单数据，用于对服务器状态进行更改。</li><li>通过 <code>request</code> 对象获取请求参数、头信息等，并通过<code>response</code> 对象生成响应内容发送给客户端。</li></ul></li><li><code>doPut(HttpServletRequest request, HttpServletResponse response)</code>：<ul><li>该方法用于处理 HTTP PUT 请求。</li><li>PUT请求通常用于更新或替换指定的资源，客户端通常会提供完整的资源表示。</li><li>通过<code>request</code>对象获取请求参数、头信息等，并通过<code>response</code> 对象生成响应内容发送给客户端。</li></ul></li><li><code>doDelete(HttpServletRequest request, HttpServletResponse response)</code>：<ul><li>该方法用于处理 HTTP DELETE 请求。</li><li>DELETE 请求通常用于删除指定的资源。</li><li>通过 <code>request</code> 对象获取请求参数、头信息等，并通过<code>response</code> 对象生成响应内容发送给客户端。</li></ul></li></ol><h6 id="destroy"><code>destroy()</code></h6><p><code>destroy()</code> 方法是 Servlet 生命周期中的最后一个方法，它在Servlet的生命周期结束时被调用，通常用于释放资源、执行清理操作或执行其他与终止相关的任务。</p><p><strong>定义</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>当 Servlet 容器（例如 Tomcat）决定从服务中移除一个 Servlet实例时，它首先会调用该 Servlet 的 <code>destroy()</code>方法。此时，Servlet可以释放它所持有的资源，如数据库连接、线程、文件句柄等，并确保所有的清理工作都已完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 清理代码</span><br>    <span class="hljs-comment">// 例如：关闭数据库连接、释放资源等</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Servlet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进程管理</title>
    <link href="/2023/09/24/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <url>/2023/09/24/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="进程">进程</h3><p>早期的计算机一次只能执行一个程序（如MS-DOS），这种程序完全控制系统，并且访问所有系统资源。</p><p>相比之下，现代计算机系统允许加在多个程序到内存，以便并发执行。这种改进要求：对各种程序提供更严格的控制和划分。这些需求导致了<strong>进程（Process）</strong>概念的产生，即进程为执行程序。<strong>进程是现代分时操作系统的工作单元</strong>。</p><hr /><h4 id="进程概念">进程概念</h4><p><strong>一个进程就是一个运行程序的实例</strong>，其由以下两个部分组成：</p><ul><li><p><strong>当前状态（Current state）</strong></p><ul><li><p><strong>内存信息（Memory contents）</strong></p></li><li><p><strong>程序计数器（Program counter）</strong></p></li><li><p><strong>堆栈指针（Stack / Heap pointers）</strong></p></li><li><p>...</p></li></ul></li><li><p><strong>系统资源（System resources）</strong></p></li></ul><p class="note note-info">我们强调：程序本身不是进程。程序只是被动（passive）实体，进程是活动（active）实体。<br>当一个可执行文件（executable file）被加载到内存时，这个程序就成为进程。</p><h4 id="进程状态">进程状态</h4><h5 id="二状态模型-排队模型">二状态模型 &amp; 排队模型</h5><p>在任何时刻，一个进程要么在执行中，要么未执行，因此我们可以简单将线程构建为最简单的两个状态：</p><ul><li><strong>执行中（Running）</strong></li><li><strong>未执行（Not running）</strong></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-25-143048.png" alt="Two-State Process Model" style="zoom:65%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-25-143345.png" alt="Queuing diagram" style="zoom:50%;" /></p><ul><li><p><strong>Enter</strong></p><p>即产生新的进程，进入队列。</p></li><li><p><strong>Dispatch</strong></p><p>Dispatch在这里是调度器的意思，即进行进程切换，处理器将处理新的进程。</p></li><li><p><strong>Pause</strong></p><p>当前运行的进程被中断，操作系统的调度器将选择一个新的进程运行。</p><blockquote><p>这里中断的原因有很多，最常见的原因就是超过了操作系统的指令周期。</p><p>假设操作系统为了避免任何一个进程独占处理器时间，仅允许一个进程最多连续执行6 个指令周期：</p><p>若进程 A 有 12 条指令，且刚刚出队列进入运行状态，则其执行完前 6条指令后则会超时而重新入队，同时处理器切换到下一个进程。进程 A在下一次出队后执行完接下来的 6 条指令后结束，然后退出该系统。</p></blockquote></li><li><p><strong>Exit</strong></p><p>即进程结束退出系统。</p></li></ul><p class="note note-info">二状态模型具有很大的漏洞，即如果存在一些处于运行状态但已经就绪等待执行的进程，同时还存在一些阻塞状态例如等待I/O结束的进程，又由于该模型使用单队列，<strong>因此无法区分出未被阻塞的进程从而在阻塞状态的进程上浪费大量处理器资源</strong>。具体来说就是若进程A 处于 I/O 阻塞状态，则在需要的 I/O 结束之前进程 A会一直参与到进程排队的循环中，既浪费了处理器的工作时间，也增加了其他正常可执行的进程的排队时间。</p><h5 id="五状态模型">五状态模型</h5><p>为了解决以上二状态模型的问题，又提出了<strong>五状态模型</strong>：</p><ul><li><p><strong>新的（New）</strong></p><p>New 状态用于存储那些暂时不能进入 Ready队列的进程，一方面可能是资源问题，另一方面可能是优先级问题。</p></li><li><p><strong>运行（Running）</strong></p></li><li><p><strong>阻塞（Blocked）</strong></p></li><li><p><strong>就绪（Ready）</strong></p></li><li><p><strong>退出（Exit）</strong></p></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-24-063428.png" alt="Five-state Process Model" style="zoom:50%;" /></p><p>五状态模型在二状态模型的基础上新增了阻塞态，可以理解为用于存放等待I/O 的阻塞态进程的队列。</p><p>当相关的 I/O 发生后，处于阻塞态的进程将会进入就绪态。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-25-151148.png" alt="Queuing diagram" style="zoom:67%;" /></p><p class="note note-info">五状态模型依然存在潜在的问题。对于一般的计算机而言，处理器远快于I/O，会出现内存中所有进程都在等待 I/O的现象，此时处理器多数时间处于空闲状态，且需要大量的空间来维护处于阻塞状态的进程。<br></p><h5 id="被挂起的进程">被挂起的进程</h5><p>为了解决以上问题，操作系统会将部分进程<strong>挂起（Suspend）</strong>，即把内存内存中某个进程的一部分或者全部移动到<strong>磁盘</strong>中。</p><p>当内存中不存在就绪态的进程时，操作系统就会把被阻塞的进程换出到磁盘的<strong>挂起队列（Suspendqueue）</strong>，即<strong>临时从内存中移除的进程队列</strong>。操作系统从此要么从挂起队列中取出一个进程，要么接受一个新的进程，将其放在内存中运行。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-25-154301.png" style="zoom:67%;" /></p><p>特别说明：</p><ul><li><p><strong>Blocked</strong> <span class="math inline">\(\to\)</span><strong>Blocked/Suspend</strong></p><p>若没有就绪进程，则至少换出一个阻塞进程，以便为另外一个未阻塞进程腾出空间。</p></li><li><p><strong>Blocked/Suspend</strong> <spanclass="math inline">\(\to\)</span> <strong>Ready/Suspend</strong></p><p>若等待的时间发生 I/O，则处于 <em>阻塞/挂起</em> 状态的进程可以转化到<em>就绪/挂起</em> 状态。</p></li><li><p><strong>Ready/Suspend</strong> <spanclass="math inline">\(\to\)</span> <strong>Ready</strong></p><p>若内存没有就绪态进程，则操作系统需要调入一个进程来执行。处于<em>就绪/挂起</em>状态的进程与处于就绪状态的进程相比<strong>优先级更高</strong>。</p></li><li><p><strong>Ready</strong> <span class="math inline">\(\to\)</span><strong>Ready/Suspend</strong></p><p>通常，操作系统更倾向于挂起阻塞态进程而非就绪态进程，因为就绪态进程可以立即执行，而阻塞态进程虽然占用了空间却不能执行。<strong>若释放内存来得到足够空间的唯一方式是挂起一个就绪态进程，则这种转化是必须的</strong>。</p></li></ul><blockquote><p><strong>操作系统的控制结构</strong>：</p><p>操作系统为了管理进程和资源，必须掌握每个进程和资源的当前状态。</p><p>普遍采用的方法是：OS 构造并维护其管理的每个实体的信息表。我们称其为<strong>OS control table</strong>，如下图。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-01-143818.png" style="zoom:50%;" /></p><ul><li><p><strong>内存表（Memory table）</strong></p><p>用于跟踪内存和外存。</p></li><li><p><strong>I/O 表（I/O table）</strong></p><p>管理计算机的 I/O 设备和通道。</p></li><li><p><strong>文件表（files table）</strong></p><p>用于提供文件信息。</p></li><li><p><strong>进程表（Process table）</strong></p><p>用于管理计算机进程。</p></li></ul></blockquote><h5 id="进程控制块pcb">进程控制块（PCB）</h5><p>操作系统在管理和控制进程时，首先要知道进程的位置，其次要知道进程的属性（如PID，进程状态等）。</p><p>为了维护进程的这些值，我们采用<strong>进程控制块（Process ControlBlock, PCB）</strong>，它包括许多与某个特定进程相关的消息：</p><ul><li><p><strong>进程状态（Process state）</strong></p></li><li><p><strong>程序计数器（Program counter，PC）</strong></p><p>计数器表示进程将要执行的下个指令的地址。这里可以理解为 8086 CPU 中的CS 和 IP 寄存器指向的地址。</p></li><li><p><strong>CPU 寄存器（CPU register）</strong></p><p>包括累加器、索引寄存器、堆栈指针、通用寄存器、条件码寄存器等等。</p></li><li><p><strong>CPU 调度信息（CPU-sheduling information）</strong></p><p>这类信息包括进程优先级、调度队列的指针和其他参数。</p></li><li><p><strong>内存管理信息（Memory-managementinformation）</strong></p><p>根据操作系统使用的内存系统，这类信息可以包括基地址和界限寄存器的值、页表或段表。</p></li><li><p><strong>记账信息（Accounting information）</strong></p><p>这类信息包括 CPU时间、实际使用时间、时间期限、记账数据、作业或进程数量等。</p></li><li><p><strong>I/O 状态信息（I/O status information）</strong></p><p>这类信息包括分配给进程的 I/O 设备列表、打开文件列表等等。</p></li></ul><blockquote><p>Linux 操作系统的进程控制块采用 C 语言结构体 <code>task_struct</code>来表示，它位于内核源码目录内的头文件 <code>&lt;linux/sched.h&gt;</code>内。</p><p><ahref="https://github.com/torvalds/linux/blob/master/include/linux/sched.h"><code>linux/sched.h</code>内核源码</a></p></blockquote><h4 id="进程控制">进程控制</h4><h5 id="执行模式">执行模式</h5><p>大多数处理器至少支持两种执行模式。<strong>某些指令只能在特权模式下运行</strong>，包括读取或改变诸如程序状态字之类的控制寄存器的指令、原始I/O指令和与内存管理相关的指令。另外，<strong>部分内存区域仅能在特权模式下访问</strong>。</p><p>非特权模式通常称为<strong>用户模式（Usermode）</strong>，特权模式通常称为<strong>内核模式（Kernelmode）</strong>，后者也常常被称为<strong>系统模式（Systemmode）</strong>或者<strong>控制模式（Controlmode）</strong>，内核模式指的是操作系统的内核，它是操作系统中包含重要系统功能的部分。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-044455.png" alt="Typical Functions of an OS Kernel" style="zoom:50%;" /></p><p class="note note-info">使用两种模式的原因是保护操作系统和重要的操作系统表（如PCB）不受用户程序的干扰。在内核模式下，软件会完全控制处理器及其所有指令、寄存器和内存。为了安全起见，这种级别的控制对用户程序而言没有必要。</p><p>在给出两种模式后，我们就遇到了两个问题：</p><ol type="1"><li><p>处理器如何区分当前的进程是以什么模式来运行的？</p><p><strong>我们通常在程序状态字中设定几个指示执行模式的位</strong>。</p><p>当用户调用一个操作系统服务或中断来触发系统例程的执行时，执行模式被置为内核模式；而当从系统服务返回到用户进程时，执行模式将被置为用户模式。</p><blockquote><p>例如 64 位 IA-64 体系的 Intel Itanium 处理器中，就有一个包含 2 位<strong>CPL（Current PrivilegeLevel）</strong>字段的处理器状态寄存器（PSR）。级别 0表示内核模式，是最高特权级别，其他级别（1 ~ 3）则是用户模式。</p></blockquote></li><li><p>模式如何转变？</p><ul><li><p><strong>User <span class="math inline">\(\to\)</span>Kernel</strong></p><p>开启内核模式，并存储当前的用户 PC 指针。</p></li><li><p><strong>Kernel <span class="math inline">\(\to\)</span>User</strong></p><p>清空内核模式，将 PC 指针指向合适的用户进程。</p></li></ul></li></ol><h5 id="进程创建">进程创建 ☁️</h5><p>操作系统创建一个新进程时，会按照如下步骤操作：</p><ol type="1"><li><p><strong>为新进程创建一个唯一标识符</strong></p></li><li><p><strong>为进程分配空间</strong></p></li><li><p><strong>初始化 PCB</strong></p></li><li><p><strong>设置正确的链接</strong></p><p>若操作系统将每个调度队列都维护为一个链表，则新进程必须放在就绪或者<em>就绪/挂起</em> 链表中。</p></li><li><p><strong>创建或扩充其他数据结构</strong></p><p>例如为每个进程维护一个记账文件。</p></li></ol><h5 id="进程切换">进程切换</h5><p>基于此，我们可以得到进程切换的一般过程：</p><ol type="1"><li>存储当前进程的 PC、SP 指针与寄存器等（统称 Context）</li><li>更新当前进程的 PCB</li><li>将当前进程移动到等待队列（具体状态视情况而定）</li><li>从进程队列中选取一个新的进程来执行，从其 PCB 中读取信息</li></ol><p>...</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-24-065526.png" style="zoom:50%;" /></p><p>何时切换进程？进程切换可能在<strong>操作系统从当前正在运行进程中获得控制权的任何时刻</strong>发生。</p><p class="note note-info">由于进程切换需要内核模式的权限，所以进程切换的过程中一般都会发生执行模式的改变。</p><p>其一般有 3 种原因：</p><ol type="1"><li><p><strong>中断（Interrupt）</strong></p><p><strong>与当前正运行进程无关的某种外部事件相关</strong>，如：</p><ul><li><p>时钟中断（Timer interrupt）</p><p>当前进程运行时间已经达到最大允许时间段（Timeslice）。若超时，进程就切换到就绪态，并调入另一个进程。</p></li><li><p>I/O 中断（I/O interrupt）</p><p>操作系统确定是否已发生 I/O 活动。<strong>若 I/O活动是一个或多个进程进程正在等待的事件，则操作系统就会把所有处于阻塞态的进程转化为就绪态</strong>，<strong>此时操作系统必须决定是继续执行当前处于运行态的进程还是让优先级更高的就绪态进程抢占该进程</strong>。</p></li></ul></li><li><p><strong>陷阱（Trap）</strong></p><p><strong>与当前正在运行的进程相关</strong>，一般指当前进程出现错误或者异常条件时发生的进程切换。</p><p>此时，操作系统会判断该进程的错误或异常条件是否致命，致命时会直接进入退出态，并切换进程；若不致命，操作系统的动作取决于错误的性质和操作系统本身的设计。</p><p>Trap 有很多例子，比如常见的 Segmentation fault（段错误）、Divide byzero Exception（除 0 异常）等等。</p></li><li><p><strong>系统调用（System call）</strong></p><p><strong>类似于函数调用，不过在当前进程之外</strong>。例如，当用户执行了一个I/O操作的指令，如打开一个文件，这时该调用会转移到操作系统代码一部分的一个例程。<strong>使用系统调用会将用户进程置为阻塞态</strong>。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-01-162339.png" style="zoom:50%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-044348.png" style="zoom:50%;" /></p><p>Linux 常见系统调用的 C 语言接口：</p><ul><li><p><code>fork()</code> ：</p><p>创建一个新的子进程，该子进程是当前进程的复制。子进程和父进程将在不同的地址空间中运行，但它们会共享相同的代码和文件描述符。用于创建新进程。</p></li><li><p><code>wait()</code> 和 <code>waitpid()</code> ：</p><p>用于等待子进程的终止，并获取子进程的终止状态。这些函数通常与 fork()配合使用，用于处理子进程的退出状态。</p></li><li><p><code>exec()</code> 系列函数（如 <code>execve()</code>、<code>execl()</code> 、<code>execp()</code> 等）：</p><p>用于加载并执行新的程序。这些函数会替代当前进程的映像，将其替换为一个新的程序。<code>exec()</code>函数允许传递参数、环境变量和命令行参数给新程序。</p></li><li><p><code>open()</code> 和 <code>close()</code> ：</p><p>用于打开和关闭文件。<code>open()</code>函数用于打开文件，并返回文件描述符，<code>close()</code>函数用于关闭文件。</p></li><li><p><code>read()</code> 和 <code>write()</code> ：</p><p>用于从文件描述符读取数据和将数据写入文件描述符。它们是输入和输出的基本系统调用。</p></li></ul></li></ol><h5 id="进程调度">进程调度</h5><p>知道了进程的工作模式，OS就需要采取合适的策略进行<strong>进程调度（Processscheduling）</strong>。进程调度有以下目标：</p><ol type="1"><li><strong>响应时间（Responsetime）</strong>：降低任务的响应时间，以满足实时要求或减少用户感知的等待时间。低延迟对于需要快速响应的应用程序非常重要。</li><li><strong>高吞吐量（HighThroughput）</strong>：确保系统可以同时运行多个任务，并且能够高效地处理大量的工作负载。这对于服务器和数据中心等高负载环境至关重要。<strong>保证处理器在一定的时间内可以尽可能处理更多任务</strong>。</li><li><strong>资源利用率（ResourceUtilization）</strong>：最大化系统资源的利用率，以确保资源得到有效利用，同时避免浪费。这包括处理器时间、内存、I/O设备等资源的有效管理。</li><li>避免<strong>进程饥饿（Processstarvation）</strong>：不要出现某个进程长时间等待而没有执行。</li><li><strong>公平性（Fairness）</strong>：确保每个进程都有平等的机会获得处理器时间和其他系统资源。</li></ol><h6 id="批处理进程和交互式进程">批处理进程和交互式进程</h6><ul><li><p><strong>批处理进程（Batch processes，CPU-intensive）</strong></p><p>批处理进程通常用于执行大量相似的、非交互性的任务，这些任务按照一定的顺序依次执行，而不需要用户的交互或实时响应。</p><p><strong>对于批处理进程而言，吞吐量（Throughput）最重要</strong>。</p></li><li><p><strong>交互式进程（Interactiveprocesses，I/O-intensive）</strong></p><p>交互式进程是需要与用户进行实时交互的进程。它们等待用户的输入并立即做出响应，通常以图形用户界面（GUI）或命令行界面的形式展示给用户。</p><p><strong>对于交互式进程而言，响应时间（Responsetime）最重要</strong>。</p></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-052911.png" alt="Two types of processes" style="zoom:67%;" /></p><p><strong>绝大多数进程的 CPU 峰值时间都很短（Short CPUburst）</strong>。</p><h6 id="fcfs-策略">FCFS 策略</h6><p>先来先服务（First-Come-First-Served）策略，顾名思义就是让进程按照排队的策略进行调度。</p><p>FCFS策略十分容易实现，只需要维护一个就绪进程的队列结构，让每个新进程入队，将要执行的进程出队即可。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-100417.png" alt="FCFS / FIFO" style="zoom:50%;" /></p><p><strong>优点</strong>：</p><ul><li>易于实现；</li><li>当所有进程耗时差不多时 FCFS 策略的效果会很好。</li></ul><p><strong>缺点</strong>：</p><ul><li>一些短进程可能需要长时间的等待，可能造成进程饥饿。</li></ul><h6 id="sjf-策略">SJF 策略</h6><p>SJF 策略即最短作业优先策略（Shortest-Job-First）策略，在 SJF策略中，<strong>操作系统会选择等待队列中最短的作业（最短的执行时间）来执行</strong>，以期望最小化平均等待时间，提高系统的性能。</p><h6 id="非抢占性策略和抢占性策略">非抢占性策略和抢占性策略</h6><p><strong>非抢占性策略（Non-Preemptive Scheduling）</strong>：</p><ul><li><strong>特点</strong>：在非抢占性策略中，一旦一个进程开始执行，它将一直运行，<strong>直到完成</strong>。其他进程无法强制中断正在执行的进程，除非当前进程<strong>主动放弃CPU（Voluntarily gives up the CPU）</strong>，例如<strong>等待 I/O操作完成</strong>。</li><li><strong>优点</strong>：非抢占性策略通常比抢占性策略具有较低的上下文切换开销，因为不需要频繁地切换执行的进程。</li><li><strong>适用性</strong>：这种策略适用于不需要实时性要求的场景，如批处理系统或一些传统的桌面应用程序。它也可以简化并发编程，因为无需处理抢占和竞争条件。</li></ul><blockquote><p>以上讨论的 FCSF、SJF 调度策略都属于非抢占性策略。</p></blockquote><p><strong>抢占性策略（Preemptive Scheduling）</strong>：</p><ul><li><strong>特点</strong>：在抢占性策略中，<strong>操作系统可以强制中断当前正在执行的进程</strong>，并将CPU分配给其他等待的进程。这种策略允许<strong>更灵活地管理进程</strong>，根据进程的优先级、时间片或其他条件来决定进程的执行。</li><li><strong>优点</strong>：抢占性策略可以提高系统的响应性，因为操作系统可以在需要时迅速切换到更高优先级的进程，以满足实时性要求或更紧急的任务。</li><li><strong>适用性</strong>：抢占性策略通常适用于需要实时性、响应性和更精细的调度控制的场景，如操作系统内核、服务器应用、多媒体处理和实时系统。</li></ul><h6 id="rr-策略">RR 策略</h6><p><strong>轮转调度（RoundRobin，RR）</strong>是一种抢占性的进程调度策略。在 RR 调度中，操作系统将CPU时间分成固定大小的时间片（也称为时间量或量子），然后按照先来先服务（FCFS）的顺序将这些时间片分配给就绪队列中的进程。每个进程在一个时间片内运行，然后如果它还没有完成，就被移到队列的末尾等待下一个时间片。</p><center><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-102825.png" style="zoom:50%;" /><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-102904.png" style="zoom:50%;" /></center><p>RR 调度比 FCFS 更加公平，特别是对于时间差别较大的进程。</p><p><strong>时间片的选择：</strong></p><p>选择一个合适长度的时间片对于 RR策略而言至关重要，太长或者太短都不合适。</p><ul><li>太长：<ul><li>响应性差（Poor responsiveness）。</li></ul></li><li>太短：<ul><li>过于频繁的上下文切换（Overhead of contextswitching）可能造成较大的时间开销。</li></ul></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-104212.png" alt="Virtual Round Robin" style="zoom:50%;" /></p><blockquote><p>备用队列（Auxiliary queue）：</p><ul><li>用于存放那些从 I/O 阻塞状态释放的进程；</li><li>相对于那些在就绪队列中的进程而言拥有更高的优先级。</li></ul></blockquote><h6 id="优先级调度策略">优先级调度策略</h6><p><strong>优先级调度策略（Scheduling withPriorities）</strong>根据进程的优先级来决定下一个执行的进程。具有较高优先级的进程先执行。这可以用于根据进程的重要性和紧迫性来调度。其会给每个进程设定一个<strong>优先级（Priorityvalue）</strong>，调度器<strong>总是先选择优先级更高的进程来运行</strong>。</p><p>优先级可分为静态和动态两种，<strong>对于动态优先级而言，OS可以动态调整进程的优先级</strong>。</p><p>实现方式：对于不同优先级的进程，使用<strong>不同的队列</strong>来维护。</p><p>如下图，RQ0级别的队列优先级最高，然后随着编号增加，优先级递减。则每次处理器会先从优先级高的队列选择进程运行。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-133229.png" alt="Priority Queuing" style="zoom:50%;" /></p><p><strong>多级反馈队列</strong></p><p>多级反馈队列（Multi-Level FeedbackQueue，MLFQ）特别是用于多任务处理系统。MLFQ结合了多个队列和反馈机制，以实现灵活的进程调度，同时考虑了进程的优先级、等待时间和历史执行表现。</p><p>MLFQ包含多个队列，每个队列具有不同的优先级。通常，系统会维护一个队列数组，其中队列的优先级逐渐降低。高优先级队列中的进程在低优先级队列中的进程之前执行。在每个队列中，通常会使用一种基本的调度策略，如先来先服务（FCFS）或轮转调度（RoundRobin）。不同队列可以使用不同的基本调度策略。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-135541.png" alt="MLFQ" style="zoom:50%;" /></p><ul><li><p><strong>反馈机制</strong>：</p><p>MLFQ 使用反馈机制来动态调整进程的优先级。</p><p>如果一个进程在高优先级队列中等待了一段时间但没有完成，它将被移到较低优先级的队列中，从而允许其他进程有机会获得CPU 时间。</p><p>如果一个进程在低优先级队列中等待了很长时间而没有被执行，系统可能会提高其优先级。这是为了防止饥饿现象，即确保所有进程最终都能获得处理器时间。</p></li><li><p><strong>解决饥饿问题</strong>：</p><p>MLFQ调度中如果频繁有新的进程进入系统，可能导致优先级低的进程频繁被抢占，从而造成进程饥饿问题。</p><p>这个问题有很多解决方案，比如对于不同的优先级的队列，我们设置不同的抢占时间。</p><p>例如，对于 <span class="math inline">\(RQ_i\)</span>队列，我们将抢占时间设定为 <span class="math inline">\(2 ^i\)</span>，从而给低优先级队列的进程更多执行时间。</p></li></ul><p class="note note-info">抢占时间（Preemptiontime）是指一个进程在被操作系统抢占（即中断并停止执行）之前能够持续执行的时间长度。这个概念在抢占式进程调度策略中非常重要，因为它决定了操作系统何时可以选择停止当前正在执行的进程，以分配CPU 时间给其他等待的进程。</p><blockquote><p><strong>进程优先级在 Unix/Linux 操作系统的具体体现 ——Niceness</strong></p><p>在 Unix 和类 Unix 操作系统中，Niceness（也称为 Nice值）是一个用于表示进程优先级的概念。Niceness 值通常在 -20 到 19之间，默认是 0，其中 -20 表示最高优先级，19 表示最低优先级。更负的Niceness 值表示更高的优先级，而更正的 Niceness 值表示更低的优先级。</p><p>我们可以使用 <code>ps</code> 指令打印进程信息，从而看到进程的 Nice值。</p><ul><li><code>ps aux</code>：显示所有用户的详细进程列表。</li><li><code>ps aux | grep &lt;进程名&gt;</code>：通过管道和<code>grep</code>命令来筛选特定进程。</li><li><code>ps -e</code>：显示所有进程，包括系统进程。</li><li><code>ps -ef</code>：以全格式显示所有进程。</li><li><code>ps -u &lt;用户名&gt;</code> : 查看某个用户的进程。</li></ul></blockquote><h6 id="cfs">CFS</h6><p>CFS（Completely Fair Scheduler）是 Linux操作系统中的一种进程调度算法，用于在多任务环境中公平地分配 CPU时间给不同的进程。CFS 的目标是实现公平的 CPU时间分配，确保每个进程在一定时间内获得相同比例的 CPU时间，而不受其他进程的干扰。</p><p>底层实现原理 —— 红黑树。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-02-142205.png" style="zoom:50%;" /></p><h4 id="ubuntu-实操">Ubuntu 实操</h4><blockquote><p>其实也不一定得是 Ubuntu，其他类 Unix 系统如MacOS，本身就可以完成以下实验。</p></blockquote><h5 id="使用-python-的-os-模块实现部分-system-call">使用 Python 的<code>os</code> 模块实现部分 System call</h5><p>Python 的 <code>os</code> 模块提供了标准 UNIX 库接口与不少 POSIX系统调用，如 <code>fork()</code> ，<code>exec()</code>系列函数等等。</p><h6 id="fork"><code>fork()</code></h6><p><code>fork()</code> 函数用于创建一个新进程。<code>fork()</code>函数不接收任何参数，当 <code>fork()</code>被调用后，其会复制一份相同的进程，对于两个相同的进程，<code>fork()</code>函数返回不同的值，对于当前进程，返回子进程的 pid，对于子进程，会返回0。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    pid = os.fork()<br><br>    <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Child process&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Father process, child pid = <span class="hljs-subst">&#123;pid&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Father process, child pid = 37012<br>Child process<br></code></pre></td></tr></table></figure><h6 id="waitpid"><code>waitpid()</code></h6><p><code>os.waitpid()</code> 是 Python中用于等待子进程结束的函数之一，它允许你在父进程中等待指定的子进程完成执行。这个函数通常与<code>os.fork()</code> 一起使用，以管理子进程的执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">os.waitpid(pid, options)<br></code></pre></td></tr></table></figure><ul><li><code>pid</code> ：要等待的子进程的进程 ID（Process ID）；</li><li><code>options</code>：控制等待行为的选项标志，有以下取值：<ul><li><code>os.WNOHANG</code>：如果没有子进程退出，立即返回，不会阻塞。</li><li><code>os.WUNTRACED</code>：如果子进程进入暂停状态（例如，收到了SIGTSTP 信号），也会返回。</li><li>0，表示在子进程结束前，父进程始终是阻塞状态。</li></ul></li><li><code>os.waitpid()</code> 的返回值是一个包含两个值的元组<code>(pid, status)</code>，其中：<ul><li><code>pid</code> 是已经退出的子进程的进程 ID。</li><li><code>status</code> 包含有关子进程退出状态的信息，可以使用<code>os.WIFEXITED(status)</code>、<code>os.WEXITSTATUS(status)</code>、<code>os.WIFSIGNALED(status)</code>、<code>os.WTERMSIG(status)</code>等函数来提取这些信息。</li></ul></li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    pid = os.fork()<br><br>    <span class="hljs-keyword">if</span> pid == <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Child process&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        os.waitpid(pid, <span class="hljs-number">0</span>) <span class="hljs-comment"># 等待子进程完成</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Father process, child pid = <span class="hljs-subst">&#123;pid&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Child process<br>Father process, child pid = 37267<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>进程</tag>
      
      <tag>进程管理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux Shell 学习笔记</title>
    <link href="/2023/09/21/Linux%20Shell%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/21/Linux%20Shell%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="文件管理">文件管理</h4><h5 id="ls-命令"><code>ls</code> 命令</h5><p><code>ls</code> 来自英文单词中的 "list"的缩写，用于列出目录中文件以及其属性信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls [参数] [文件名]<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-a</code></td><td>显示所有文件及目录</td></tr><tr class="even"><td><code>-A</code></td><td>在 <code>-a</code> 的基础上不显示当前目录和父目录</td></tr><tr class="odd"><td><code>-d</code></td><td>显示目录本身的属性信息</td></tr><tr class="even"><td><code>-i</code></td><td>显示文件的 inode 属性</td></tr><tr class="odd"><td><code>-l</code></td><td>显示文件的详细属性信息，包括类型、权限等</td></tr><tr class="even"><td><code>-m</code></td><td>以逗号为间隔符，水平显示文件信息</td></tr><tr class="odd"><td><code>-r</code></td><td>依据首字母将文件以相反次序显示</td></tr><tr class="even"><td><code>-R</code></td><td>递归显示所有子文件</td></tr><tr class="odd"><td><code>-S</code></td><td>依据内容大小将文件排序显示</td></tr><tr class="even"><td><code>-t</code></td><td>依据最后修改时间将文件排序显示</td></tr><tr class="odd"><td><code>-X</code></td><td>依据拓展名将文件排序显示</td></tr><tr class="even"><td><code>--color</code></td><td>显示信息带有着色效果</td></tr></tbody></table><blockquote><p>不添加任何参数的情况下，<code>ls</code>命令会列出当前工作目录的文件信息。</p></blockquote><h5 id="cp-命令"><code>cp</code> 命令</h5><p><code>cp</code> 命令来自英文单词中 "copy"的缩写，用于复制文件或目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp [参数] 源文件名 目标文件名/复制目录<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-b</code></td><td>覆盖目标文件前先进行备份</td></tr><tr class="even"><td><code>-d</code></td><td>复制链接文件时，将目标文件也建立成链接文件</td></tr><tr class="odd"><td><code>-f</code></td><td>若目标文件已存在，则会直接覆盖</td></tr><tr class="even"><td><code>-i</code></td><td>若目标文件已存在，则会询问是否覆盖</td></tr><tr class="odd"><td><code>-l</code></td><td>对源文件建立硬链接，而非复制文件</td></tr><tr class="even"><td><code>-p</code></td><td>保留源文件或者目录的所有基本属性</td></tr><tr class="odd"><td><code>-r</code></td><td>递归复制所有子文件</td></tr><tr class="even"><td><code>-s</code></td><td>对源文件建立软链接，而非复制文件</td></tr><tr class="odd"><td><code>-a</code></td><td>功能等同于 <code>-d -p -r</code></td></tr><tr class="even"><td><code>-v</code></td><td>显示执行过程详细信息</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>在同一目录下复制 <code>demo.txt</code> 的副本：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp demo.txt demo_copy.txt<br></code></pre></td></tr></table></figure></p></li><li><p>将 <code>demo.txt</code> 复制到 <code>./demo_dict</code>目录，如果目标文件存在则覆盖：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -f demo.txt ./demo_dict<br></code></pre></td></tr></table></figure></p></li><li><p>建立 <code>dmeo.txt</code> 的软链接：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -s demo.txt demo_soft_link<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="mkdir-命令"><code>mkdir</code> 命令</h5><p><code>mkdir</code> 命令来自于英文 "Make directories"的缩写，用于创建目录文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir [参数] 目录名<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-m</code></td><td>创建目录的同时设置权限</td></tr><tr class="even"><td><code>-p</code></td><td>递归创建多级目录</td></tr><tr class="odd"><td><code>-v</code></td><td>显示执行过程详细信息</td></tr><tr class="even"><td><code>-z</code></td><td>设置目录安全上下文</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>创建一个权限为 <code>740</code> 的文件：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -m 740 dir_test<br></code></pre></td></tr></table></figure></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -ld dir_test<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出结果：</span><br>drwxr-----@ 2 username  staff  64  9 29 23:20 dir_test<br></code></pre></td></tr></table></figure></p></li><li><p>一次创建多个嵌套关系的目录：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p dir1/dir2/dir3<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="mv-指令"><code>mv</code> 指令</h5><p><code>mv</code> 指令，来自于英文单词中的"move"，用于移动或者更改文件名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv [参数] 源文件名 目标文件名<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-b</code></td><td>覆盖前为目标文件创建备份</td></tr><tr class="even"><td><code>-f</code></td><td>若文件已存在，强制覆盖目标文件</td></tr><tr class="odd"><td><code>-i</code></td><td>若文件已存在，则询问用户是否覆盖</td></tr><tr class="even"><td><code>-n</code></td><td>不要覆盖已有文件</td></tr><tr class="odd"><td><code>-u</code></td><td>当源文件比目标文件更新时，才执行覆盖操作</td></tr><tr class="even"><td><code>-v</code></td><td>显示执行过程详细信息</td></tr><tr class="odd"><td><code>-Z</code></td><td>设置文件安全上下文</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>将 <code>demo.txt</code> 改名为 <code>demo2.txt</code> ：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv demo.txt demo2.txt<br></code></pre></td></tr></table></figure></p></li><li><p>将 <code>dir1</code> 移动到 <code>dir2</code> ：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv dir1 ./dir2<br></code></pre></td></tr></table></figure></p></li><li><p>在 (1) 的基础上将 <code>dir1</code> 重命名为<code>dir0</code></p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv dir1 ./dir2/dir0<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="pwd-指令"><code>pwd</code> 指令</h5><p><code>pwd</code> 指令来自于英文中的 "Print working directory"的缩写，用于显示当前工作目录的路径。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd [参数]<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-L</code></td><td>显示逻辑路径（默认）</td></tr><tr class="even"><td><code>-P</code></td><td>显示实际物理地址</td></tr></tbody></table><h5 id="tar-指令"><code>tar</code> 指令</h5><p><code>tar</code> 指令用于压缩和解压文件，能解压或压缩 Linux系统中常见的 <code>.tar</code> 、<code>.tar.gz</code>、<code>tar.bz2</code> 等格式的压缩包文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar 参数 压缩包名 [文件或目录名]<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>-A</code></td><td>添加文件到已存在压缩包</td></tr><tr class="even"><td><code>-B</code></td><td>设置区块大小</td></tr><tr class="odd"><td><code>-c</code></td><td>创建新的压缩包</td></tr><tr class="even"><td><code>-C</code></td><td>解压缩到指定目录</td></tr><tr class="odd"><td><code>-d</code></td><td>记录文件的差别</td></tr><tr class="even"><td><code>-f</code></td><td>指定压缩包文件</td></tr><tr class="odd"><td><code>-j</code></td><td>使用 <code>bzip2</code> 压缩格式</td></tr><tr class="even"><td><code>-l</code></td><td>设置文件系统边界</td></tr><tr class="odd"><td><code>-m</code></td><td>保护文件不被覆盖</td></tr><tr class="even"><td><code>-N</code></td><td>只将较新日期的文件保存到压缩包中</td></tr><tr class="odd"><td><code>-p</code></td><td>保留原来的文件权限和属性</td></tr><tr class="even"><td><code>-t</code></td><td>显示压缩包的内容</td></tr><tr class="odd"><td><code>-u</code></td><td>更新压缩包内的文件</td></tr><tr class="even"><td><code>-v</code></td><td>显示执行过程详细信息</td></tr><tr class="odd"><td><code>-w</code></td><td>确认压缩包的完整性</td></tr><tr class="even"><td><code>-x</code></td><td>从压缩包内提取文件</td></tr><tr class="odd"><td><code>-z</code></td><td>使用 <code>gzip</code> 压缩格式</td></tr><tr class="even"><td><code>--exclude</code></td><td>排除指定的文件不压缩</td></tr><tr class="odd"><td><code>--remove-files</code></td><td>操作完后删除源文件</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>使用 <code>gzip</code> 压缩格式将 <code>demo</code>目录打包，压缩包后缀指定为 <code>.tar</code> ：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -czvf demo.tar ./demo<br></code></pre></td></tr></table></figure></p></li><li><p>将 <code>demo.tar</code> 解压到当前工作目录：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xvf demo.tar<br></code></pre></td></tr></table></figure></p></li><li><p>查看压缩包 <code>demo.tar</code> 内到文件信息：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -tvf demo.tar<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="chmod-命令"><code>chmod</code> 命令</h5><p><code>chmod</code> ，来自英文缩写 "changemode"，用于更改文件权限。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod [参数] 权限 文件名<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-c</code></td><td>改变文件权限成功后再输出成功信息</td></tr><tr class="even"><td><code>-f</code></td><td>改变文件权限失败后不显示错误信息</td></tr><tr class="odd"><td><code>-R</code></td><td>递归处理所有子文件</td></tr></tbody></table><p><strong>权限</strong>：</p><p>权限可以用数字表示，例如 755，表示 <code>rwxr-xr-x</code>权限，也可以使用 <code>+</code> 和 <code>-</code> 进行权限追加。</p><p>文件所属者、群组用户和外部用户分别用 <code>u</code> 、<code>g</code>、<code>o</code> 表示；</p><p>读、写、执行的权限分别用 <code>r</code> 、<code>w</code>、<code>x</code> 表示。</p><p><strong>示例</strong>：</p><ol type="1"><li><p>将 <code>demo.txt</code> 的权限设置为 755：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod 755 demo.txt<br></code></pre></td></tr></table></figure></p></li><li><p>给所有用户增加读 <code>demo.txt</code> 的权限：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod +r demo.txt <br></code></pre></td></tr></table></figure></p></li><li><p>剥夺外部用户写 <code>demo.txt</code> 的权限：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod o-w demo.txt<br></code></pre></td></tr></table></figure></p></li></ol><h4 id="文档编辑">文档编辑</h4><h5 id="cat-命令"><code>cat</code> 命令</h5><p><code>cat</code> 命令来自于英文中 "concatenate files and print"的缩写，用于在终端设备上显示文件内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat [参数] 文件名<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-b</code></td><td>显示行数</td></tr><tr class="even"><td><code>-E</code></td><td>每行结束时以 <code>$</code> 结尾</td></tr><tr class="odd"><td><code>-n</code></td><td>显示行数，空行也编号</td></tr><tr class="even"><td><code>-s</code></td><td>显示行数，多个空行算一个编号</td></tr></tbody></table><h5 id="more-命令"><code>more</code> 命令</h5><p><code>more</code> 是一个用于在 Linux Shell中分页显示文本文件内容的命令行工具，它允许用户逐页查看文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">more [参数] 文件名<br></code></pre></td></tr></table></figure><p><strong>使用方法</strong>：</p><ul><li>按空格键：向下滚动一页。</li><li>按 Enter 键：向下滚动一行。</li><li>按 <code>q</code> 键：退出 <code>more</code>，返回到 Shell提示符。</li><li>按 <code>/</code> 键：进行文本搜索，然后输入要搜索的文本并按 Enter键。</li><li>按 <code>n</code> 键：查找下一个匹配的搜索结果。</li><li>按 <code>p</code> 键：查找上一个匹配的搜索结果。</li></ul><p><strong>参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-l</code></td><td>显示进程名和 PID</td></tr><tr class="even"><td><code>-d</code></td><td>显示文件名和当前行号</td></tr><tr class="odd"><td><code>-c</code></td><td>清屏后显示内容</td></tr><tr class="even"><td><code>-f</code></td><td>忽略控制字符</td></tr><tr class="odd"><td><code>-s</code></td><td>合并多个空行为一个空行</td></tr></tbody></table><h5 id="echo-命令"><code>echo</code> 命令</h5><p><code>echo</code>在英文中译为回声，用于在终端输出字符串或提取后的变量值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo [参数] 字符串或$&#123;变量名&#125;<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-E</code></td><td>禁止转义字符</td></tr><tr class="even"><td><code>-e</code></td><td>启动转义字符的解释</td></tr><tr class="odd"><td><code>-n</code></td><td>不输出结尾的换行符</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>打印两行话到终端：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo -e &quot;Hello\nWorld!&quot;<br></code></pre></td></tr></table></figure></p></li><li><p>打印环境变量 <code>PATH</code> ：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $&#123;PATH&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>显示当前系统的运行时间和当前系统负载的信息：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo $(uptime)<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="rm-命令"><code>rm</code> 命令</h5><p><code>rm</code> 命令来自英文单词 "remove"的缩写，用来删除文件或目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm [参数] 文件名<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-d</code></td><td>删除无子文件的空目录</td></tr><tr class="even"><td><code>-f</code></td><td>强制删除文件不询问</td></tr><tr class="odd"><td><code>-i</code></td><td>删除文件前询问用户是否删除</td></tr><tr class="even"><td><code>-r</code></td><td>递归删除目录及其全部子文件</td></tr><tr class="odd"><td><code>-v</code></td><td>显示执行过程详细信息</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>强制删除当前工作目录下所有 <code>.txt</code> 后缀的文件：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -f *.txt<br></code></pre></td></tr></table></figure></p></li><li><p>强制删除目录 <code>dir</code> 以及其所有子文件：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf dir<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="grep-命令"><code>grep</code> 命令</h5><p><code>grep</code> 命令来自英文 "Global search regular expression andprint out the line" 的缩写，是一个强大的文本搜索工具。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep [参数] 文件名<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-b</code></td><td>显示匹配行距文件头部的偏移量</td></tr><tr class="even"><td><code>-c</code></td><td>只显示匹配的行数</td></tr><tr class="odd"><td><code>-E</code></td><td>支持拓展正则表达式</td></tr><tr class="even"><td><code>-F</code></td><td>匹配固定字符串的内容</td></tr><tr class="odd"><td><code>-h</code></td><td>搜索多文件时不显示文件名</td></tr><tr class="even"><td><code>-i</code></td><td>忽略关键词大小写</td></tr><tr class="odd"><td><code>-l</code></td><td>只显示符合匹配条件的文件名</td></tr><tr class="even"><td><code>-n</code></td><td>显示所有匹配行及其行号</td></tr><tr class="odd"><td><code>-o</code></td><td>显示匹配词距文件头部的偏移量</td></tr><tr class="even"><td><code>-q</code></td><td>静默执行模式</td></tr><tr class="odd"><td><code>-r</code></td><td>递归搜索模式</td></tr><tr class="even"><td><code>-s</code></td><td>不显示没有匹配文本的错误信息</td></tr><tr class="odd"><td><code>-v</code></td><td>显示不包括匹配文本的所有行</td></tr><tr class="even"><td><code>-w</code></td><td>精准匹配整词</td></tr><tr class="odd"><td><code>-x</code></td><td>精准匹配整行</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>查找文件 <code>OS.md</code> 中所有包含 <code>process</code>的行，并且显示其行号：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -n process OS.md<br></code></pre></td></tr></table></figure></p></li><li><p>搜索当前工作目录中包含关键词 <code>Java</code> 的文件：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep -lrs Java *<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="tail-命令"><code>tail</code> 命令</h5><p>顾名思义，<code>tail</code> 命令用于查看文件尾部内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail [参数] 文件名<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-c</code></td><td>设置显示文件尾部的字符数</td></tr><tr class="even"><td><code>-f</code></td><td>持续显示文件尾部的最新内容</td></tr><tr class="odd"><td><code>-n</code></td><td>设置显示文件尾部的行数</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>显示 <code>demo.txt</code> 最后 15 行：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail -n 15 demo.txt<br></code></pre></td></tr></table></figure></p></li><li><p>显示 <code>demo.txt</code> 最后 20 个字符：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail -c 20 demo.txt<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="rmdir-命令"><code>rmdir</code> 命令</h5><p><code>rmdir</code> 命令来自于英文中的 "Remove directory"的缩写，用于删除空目录文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rmdir [参数] 目录名<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-p</code></td><td>递归处理所有子文件</td></tr><tr class="even"><td><code>-v</code></td><td>显示执行过程详细信息</td></tr></tbody></table><h4 id="系统管理">系统管理</h4><h5 id="find-命令"><code>find</code> 命令</h5><p><code>find</code>命令的功能是用于根据给定的路径和条件查找相关文件或目录，参数灵活方便，且<strong>支持正则表达式</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find [路径] [条件] 文件名<br></code></pre></td></tr></table></figure><p><strong>常用参数：</strong></p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-name</code></td><td>匹配文件名</td></tr><tr class="even"><td><code>-perm</code></td><td>匹配文件权限</td></tr><tr class="odd"><td><code>-user</code></td><td>匹配文件所属主</td></tr><tr class="even"><td><code>-group</code></td><td>匹配文件所属组</td></tr><tr class="odd"><td><code>-mtime</code></td><td>匹配最后修改文件内容的时间</td></tr><tr class="even"><td><code>-atime</code></td><td>匹配最后读取文件内容的时间</td></tr><tr class="odd"><td><code>-ctime</code></td><td>匹配最后修改文件属性的时间</td></tr><tr class="even"><td><code>-type</code></td><td>匹配文件类型</td></tr><tr class="odd"><td><code>-size</code></td><td>匹配文件大小</td></tr><tr class="even"><td><code>-exec ... &#123;&#125; \</code></td><td>进一步执行语句</td></tr></tbody></table><p><strong>示例：</strong></p><ol type="1"><li><p>查找当前目录下所有 <code>zip</code> 压缩包：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find ./ -name *.zip<br></code></pre></td></tr></table></figure></p></li><li><p>查找当前目录下 <code>demo_dir</code> 文件夹下所有大于 1M的文件：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find ./demo_dir -size +1M<br></code></pre></td></tr></table></figure></p></li><li><p>查找工作目录最近 3 天被修改过的文件并且打印其长格式：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find ./ -mtime +3 -exec ls -l &#123;&#125; \;<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="ps-命令"><code>ps</code> 命令</h5><p><code>ps</code> 命令是 "process" 的缩写，用于显示进程信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps [参数]<br></code></pre></td></tr></table></figure><blockquote><p>如果 <code>ps</code> 不添加任何参数，则会显示当前 Shell 的进程。</p></blockquote><p><strong>常用参数：</strong></p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-a</code></td><td>显示当前终端会话的所有进程</td></tr><tr class="even"><td><code>-x</code></td><td>显示没有控制终端的进程</td></tr><tr class="odd"><td><code>-e</code></td><td>显示系统所有进程</td></tr><tr class="even"><td><code>-f</code></td><td>显示详细的进程信息</td></tr><tr class="odd"><td><code>-l</code></td><td>以长格式显示进程信息</td></tr><tr class="even"><td><code>aux</code></td><td>也是显示系统所有进程，但输出格式更加详细</td></tr><tr class="odd"><td><code>-u</code></td><td>显示与指定用户标识符（UID）相关的进程</td></tr><tr class="even"><td><code>-d</code></td><td>显示指定用户正在运行的进程</td></tr><tr class="odd"><td><code>-p</code></td><td>显示特定 PID 的进程</td></tr><tr class="even"><td><code>-o</code></td><td>自定义输出进程格式</td></tr><tr class="odd"><td><code>-t</code></td><td>显示在特定终端运行的进程</td></tr><tr class="even"><td><code>-H</code></td><td>显示进程的层次结构，包括父进程和子进程</td></tr></tbody></table><p><strong>示例：</strong></p><ol type="1"><li><p>显示系统所有进程，展示其 PID 和控制终端：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -eo pid,tty<br></code></pre></td></tr></table></figure></p></li><li><p>显示 PID 为 100 的进程信息：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -p 100<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="pstree-命令"><code>pstree</code> 命令</h5><p><code>pstree</code>命令是一个用于显示进程树的实用程序。它以一种层次结构的方式展示正在运行的进程，显示进程之间的父子关系。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pstree [参数]<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-u</code></td><td>显示与指定用户标识符（UID）相关的进程</td></tr><tr class="even"><td><code>-p</code></td><td>显示特定 PID 的进程</td></tr><tr class="odd"><td><code>-h</code></td><td>以水平格式显示进程树</td></tr></tbody></table><h5 id="pgrep-命令"><code>pgrep</code> 命令</h5><p><code>pgrep</code> 命令来自英文词组 "process global regularexpression print" 的缩写，其功能是用于检索进程 PID号码。<code>pgrep</code>命令通过正则表达式进行检索，因此用户只需要输入服务名称中的一部分即可进行搜索操作，对于不记得全名的服务程序特别好用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pgrep [参数] 服务器名<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-f</code></td><td>匹配进程名</td></tr><tr class="even"><td><code>-g</code></td><td>匹配进程组 ID</td></tr><tr class="odd"><td><code>-u</code></td><td>匹配有效用户 ID</td></tr><tr class="even"><td><code>-t</code></td><td>匹配终端号</td></tr><tr class="odd"><td><code>-c</code></td><td>显示进程数量</td></tr></tbody></table><h5 id="kill-命令"><code>kill</code> 命令</h5><p><code>kill</code> 命令用于向单个进程发送一个信号，以请求其终止。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill [参数] PID<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-a</code></td><td>不限制命令行与进程号的对应关系</td></tr><tr class="even"><td><code>-l</code></td><td>显示系统支持的信号列表</td></tr><tr class="odd"><td><code>-p</code></td><td>不发送任何信号</td></tr><tr class="even"><td><code>-s</code></td><td>设置向进程发送的信号</td></tr></tbody></table><h5 id="pkill-命令"><code>pkill</code> 命令</h5><p><code>pkill</code>命令用于根据进程名或其他进程属性来终止进程。它可以一次终止多个匹配的进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pkill [参数] 进程名称<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-c</code></td><td>匹配进程 ID</td></tr><tr class="even"><td><code>-g</code></td><td>匹配进程组</td></tr><tr class="odd"><td><code>-u</code></td><td>匹配用户 ID</td></tr><tr class="even"><td><code>-n</code></td><td>匹配最近生成的进程</td></tr><tr class="odd"><td><code>-o</code></td><td>匹配最早生成的进程</td></tr></tbody></table><h5 id="top-命令"><code>top</code> 命令</h5><p><code>top</code>是一个非常常用的命令行工具，用于实时监视和显示正在运行的进程的系统性能信息。它在类Unix 系统（如Linux、MacOS）上非常有用，可以让用户实时查看 CPU使用率、内存利用率、进程列表和其他系统性能指标。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">top<br></code></pre></td></tr></table></figure><p><strong>操作</strong>：</p><ul><li>使用键盘上的箭头键可以在进程列表中滚动。</li><li>按下 <code>q</code> 键可退出 <code>top</code>。</li><li>按下 <code>k</code> 键可终止选定的进程。</li><li>按下 <code>F</code> 键可调整排序顺序或显示的字段。</li><li>按下 <code>h</code> 键可查看帮助和快捷键列表。</li></ul><p>一般情况下，<code>top</code> 显示的信息包括：</p><ul><li><strong>进程ID（PID）</strong>：每个进程的唯一标识符。</li><li><strong>用户（USER）</strong>：运行该进程的用户。</li><li><strong>调度优先级（PR）</strong>：表示进程的调度优先级（Priority）。</li><li><strong>Niceness（NI）</strong>：表示进程的 Niceness 值。</li><li><strong>虚拟内存使用量（VIRT）</strong>：<code>VIRT</code>表示进程的虚拟内存（Virtual Memory）使用量</li><li><strong>物理占用内存（RES）</strong>：<code>RES</code>表示进程的实际物理内存占用（Resident SetSize），也就是实际分配给进程并存储在物理内存中的内存量。</li><li><strong>共享内存大小（SHR）</strong>：<code>SHR</code>表示进程共享的内存大小（SharedMemory），也就是多个进程之间共享的内存量。这包括进程使用的共享库和共享的内存段。</li><li><strong>状态（S）</strong>：进程的状态（如运行、休眠、停止等）。</li><li><strong>CPU% （CPU%）</strong>：进程占用的CPU百分比。</li><li><strong>内存% （MEM%）</strong>：进程占用的内存百分比。</li><li><strong>累计时间（TIME+）</strong>：<code>TIME+</code>列表示自进程启动以来的累积 CPU时间。这个值以小时、分钟和秒的格式表示，显示了进程占用 CPU的时间量。</li><li><strong>命令 （COMMAND）</strong>：启动进程的命令行。</li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-15-162253.png" style="zoom:67%;" /></p><h5 id="uname-命令"><code>uname</code> 命令</h5><p><code>uname</code> 命令来自英文中的 "Unixname"，用于查看系统主机名、内核及硬件架构等信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">uname [参数]<br></code></pre></td></tr></table></figure><p><strong>常用参数：</strong></p><table><thead><tr class="header"><th>参数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>-s</code></td><td>显示内核名称（默认）</td></tr><tr class="even"><td><code>-a</code></td><td>显示系统所有相关信息</td></tr><tr class="odd"><td><code>-i</code></td><td>显示硬件平台</td></tr><tr class="even"><td><code>-m</code></td><td>显示计算机硬件架构</td></tr><tr class="odd"><td><code>-n</code></td><td>显示主机名称</td></tr><tr class="even"><td><code>-o</code></td><td>显示操作系统名称</td></tr><tr class="odd"><td><code>-p</code></td><td>显示主机处理器类型</td></tr><tr class="even"><td><code>-r</code></td><td>显示内核发行版本号</td></tr><tr class="odd"><td><code>-v</code></td><td>显示内核版本</td></tr></tbody></table><h4 id="磁盘管理">磁盘管理</h4><h5 id="df-命令"><code>df</code> 命令</h5><p><code>df</code> 命令是 "Report file system disk space usage"的缩写，用于显示磁盘空间的使用情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">df [参数] 磁盘分区<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-a</code></td><td>显示所有文件系统</td></tr><tr class="even"><td><code>-h</code></td><td>以更易读的方式显示</td></tr><tr class="odd"><td><code>-H</code></td><td>以 1 KB = 1000 Byte 为换算单位</td></tr><tr class="even"><td><code>-i</code></td><td>显示索引字节信息</td></tr><tr class="odd"><td><code>-k</code></td><td>设置显示时块的大小</td></tr><tr class="even"><td><code>-l</code></td><td>只显示本地文件系统</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>以容量单位显示系统全部磁盘的使用量情况：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -h<br></code></pre></td></tr></table></figure></p></li><li><p>指定具体分区：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -h /boot<br></code></pre></td></tr></table></figure></p></li></ol><h4 id="网络通讯">网络通讯</h4><h5 id="ssh-命令"><code>ssh</code> 命令</h5><p><code>ssh</code> 命令可以让我们轻松地基于 SSH加密协议进行远程主机访问，从而实现对远程服务器的管理工‍作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh [参数] 域名|IP<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-1</code></td><td>使用 SSH 协议版本 1</td></tr><tr class="even"><td><code>-2</code></td><td>使用 SSH 协议版本 2</td></tr><tr class="odd"><td><code>-4</code></td><td>基于 IPv4 网络协议</td></tr><tr class="even"><td><code>-6</code></td><td>基于 IPv6 网络协议</td></tr><tr class="odd"><td><code>-l</code></td><td>设置登录用户名</td></tr><tr class="even"><td><code>-f</code></td><td>后台执行 SSH 命令</td></tr><tr class="odd"><td><code>-p</code></td><td>设置远程服务器的端口号</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>基于 SSH 指令访问远程主机：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh 192.168.10.10<br></code></pre></td></tr></table></figure></p></li><li><p>制定登录用户：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ssh -l linuxprobe 192.168.10.10<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="netstat-命令"><code>netstat</code> 命令</h5><p><code>netstat</code> 命令来自英文词组 “Network statistics”的缩写，其功能是显示各种网络相关信息，例如网络连接状态、路由表信息、接口状态、NAT、多播成员等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat [参数]<br></code></pre></td></tr></table></figure><p><strong>常用参数</strong>：</p><table><thead><tr class="header"><th>参数</th><th>解释</th></tr></thead><tbody><tr class="odd"><td><code>-a</code></td><td>显示所有连接中的接口信息</td></tr><tr class="even"><td><code>-c</code></td><td>持续显示网络状态</td></tr><tr class="odd"><td><code>-C</code></td><td>显示路由配置信息</td></tr><tr class="even"><td><code>-F</code></td><td>显示路由缓存信息</td></tr><tr class="odd"><td><code>-n</code></td><td>直接使用 IP 地址</td></tr><tr class="even"><td><code>-p</code></td><td>显示正在使用接口的程序识别码和名称</td></tr><tr class="odd"><td><code>-r</code></td><td>显示路由表信息</td></tr><tr class="even"><td><code>-i</code></td><td>显示网络界面信息表单</td></tr><tr class="odd"><td><code>-t</code></td><td>显示 TCP 传输协议的连接状态</td></tr><tr class="even"><td><code>-u</code></td><td>显示 UDP 传输协议的连接状态</td></tr></tbody></table><p><strong>示例</strong>：</p><ol type="1"><li><p>显示网络所有连接信息：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -a<br></code></pre></td></tr></table></figure></p></li><li><p>显示系统网络状态中的 UDP 连接信息：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -nu<br></code></pre></td></tr></table></figure></p></li><li><p>显示网卡当前状态：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -i<br></code></pre></td></tr></table></figure></p></li></ol><h4 id="常用工具">常用工具</h4><h5 id="bc-命令"><code>bc</code> 命令</h5><p><code>bc</code> 是一个用于进行任意精度计算的命令行计算器。它的名称是"Basic Calculator"的缩写，它允许你进行大数运算，包括整数和浮点数，而不受标准计算器或编程语言中固定精度的限制。<code>bc</code>是一个非常强大的工具，特别适用于需要高精度计算的数学任务。</p><p><code>bc</code> 支持的运算如下：</p><ol type="1"><li><p><strong>基本算术运算</strong>：</p><ul><li>加法：<code>+</code></li><li>减法：<code>-</code></li><li>乘法：<code>*</code></li><li>除法：<code>/</code></li><li>模运算：<code>%</code></li><li>幂运算：<code>^</code></li><li>自增运算：<code>++</code></li><li>自减运算：<code>--</code></li></ul></li><li><p><strong>逻辑运算</strong>：</p><ul><li>逻辑非（取反）：<code>!</code></li><li>逻辑与：<code>&amp;&amp;</code></li><li>逻辑或：<code>||</code></li></ul></li><li><p><strong>比较运算</strong>：</p><ul><li>等于：<code>==</code></li><li>不等于：<code>!=</code></li><li>大于：<code>&gt;</code></li><li>小于：<code>&lt;</code></li><li>大于等于：<code>&gt;=</code></li><li>小于等于：<code>&lt;=</code></li></ul></li><li><p><strong>数学函数</strong>：</p><p><code>bc</code> 支持许多数学函数，包括但不限于以下几种：</p><ul><li>平方根：<code>sqrt(x)</code></li><li>指数函数：<code>e(x)</code></li><li>自然对数：<code>l(x)</code></li><li>正弦函数：<code>s(x)</code></li><li>余弦函数：<code>c(x)</code></li><li>正切函数：<code>a(x)</code></li><li>对数函数：<code>l(x)</code></li><li>阶乘函数：<code>factorial(x)</code></li><li>取整函数：<code>floor(x)</code></li><li>绝对值函数：<code>abs(x)</code></li><li>四舍五入函数：<code>scale(n)</code></li></ul></li><li><p><strong>控制结构</strong>：</p><ul><li><code>if</code>语句：<code>if (condition) &#123; ... &#125; else &#123; ... &#125;</code></li><li><code>for</code>循环：<code>for (init; condition; update) &#123; ... &#125;</code></li><li><code>while</code> 循环：<code>while (condition) &#123; ... &#125;</code></li></ul></li><li><p><strong>变量和函数</strong>：</p><ul><li>定义变量：<code>var_name = value</code></li><li>自定义函数：<code>define function_name(parameters) &#123; ... &#125;</code></li></ul></li><li><p><strong>位运算</strong>：</p><p><code>bc</code>也支持位运算，包括按位与、按位或、按位异或等位运算操作符。</p></li></ol><h4 id="管道表达式">管道表达式</h4><p>在 Linux Shell中，管道表达式是一种非常有用的工具，它允许将一个命令的输出直接传递给另一个命令的输入，以便进行数据处理和流水线操作。管道操作符是<code>|</code>。</p><ol type="1"><li><p>基本语法： 管道操作符 <code>|</code>用于连接两个或多个命令。它的一般语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">command1 | command2 | command3<br></code></pre></td></tr></table></figure><p>这将使 <code>command1</code> 的输出成为 <code>command2</code>的输入，而 <code>command2</code> 的输出成为 <code>command3</code>的输入，依此类推。</p></li><li><p>用途： 管道表达式在 Shell 中广泛用于以下情况：</p><ul><li>数据筛选：通过将数据传递给 <code>grep</code>、<code>awk</code> 或<code>sed</code> 等工具，可以筛选、搜索和处理文本数据。</li><li>数据排序：使用 <code>sort</code> 命令对数据进行排序。</li><li>数据计算：使用工具如 <code>awk</code> 和 <code>bc</code>进行数学计算。</li><li>数据统计：使用 <code>wc</code> 命令进行行、单词和字符的统计。</li><li>数据转换：将数据从一种格式转换为另一种格式，例如将文本数据转换为 CSV格式。</li></ul></li><li><p>示例： 以下是一些使用管道表达式的示例：</p><ul><li><p>使用 <code>ls</code> 列出当前目录的文件，然后使用<code>grep</code> 过滤文件名中包含 "txt" 的文件名：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls | grep &quot;txt&quot;<br></code></pre></td></tr></table></figure></p></li><li><p>统计一个文件中的行数、单词数和字符数： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat myfile.txt | wc<br></code></pre></td></tr></table></figure></p></li><li><p>从一个文本文件中读取数据，然后使用 <code>awk</code>对数据进行处理： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat data.txt | awk &#x27;&#123;print $2, $1&#125;&#x27; | sort<br></code></pre></td></tr></table></figure></p></li><li><p>使用管道连接多个命令以完成一系列复杂的任务。</p></li></ul></li><li><p>错误处理： 管道中的每个命令都运行在自己的子 Shell中，因此如果其中一个命令失败，管道可能会终止。您可以使用<code>set -o pipefail</code> 来使管道在任何命令失败时终止整个管道。</p><p>例如： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">set -o pipefail<br>command1 | command2 | command3<br></code></pre></td></tr></table></figure></p><p>这将确保如果 <code>command1</code>、<code>command2</code> 或<code>command3</code> 中的任何一个失败，整个管道将失败。</p></li></ol><p>管道表达式是 Linux Shell中非常强大和有用的功能，它允许将多个命令组合在一起，以便以更有效的方式处理和操作数据。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表达式树</title>
    <link href="/2023/09/18/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"/>
    <url>/2023/09/18/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h4 id="三种表达式">三种表达式</h4><p>在计算机做数值运算时，我们有三种常见的表达式，分别是中缀表达式、前缀表达式、后缀表达式。</p><h5 id="中缀表达式">中缀表达式</h5><p>中缀表达式是我们通常在数学中使用的表达式表示方法，操作符位于两个操作数之间。例如，加法操作3 + 4 通常表示为 "3 +4"。中缀表达式具有运算符优先级规则，需要考虑括号来明确运算顺序。中缀表达式可以通过算法（如递归解析或运算符优先级解析器）转换为其他表达式形式，如前缀或后缀表达式。</p><p>示例： <span class="math display">\[(a + b) \times c\]</span></p><h5 id="前缀表达式">前缀表达式</h5><p>前缀表达式，也被称为波兰记法（PolishNotation）。在前缀表达式中，运算符位于操作数之前，例如，加法操作 3 + 4可以表示为"+ 34"。<strong>前缀表达式没有优先级问题</strong>，因为每个运算符都在其操作数之前，而计算前缀表达式通常需要使用栈数据结构来执行。</p><p>示例： <span class="math display">\[\times +\ a\ b\ c\]</span></p><h5 id="后缀表达式">后缀表达式</h5><p>后缀表达式，也被称为逆波兰记法（Reverse PolishNotation，RPN）。在后缀表达式中，运算符位于操作数之后，例如，加法操作 3+ 4 可以表示为"3 4+"。<strong>后缀表达式也不涉及运算符优先级</strong>，因此计算顺序是十分明确的，计算后缀表达式通常使用栈数据结构来执行。</p><p>示例： <span class="math display">\[a\ b\ + c\ \times\]</span></p><h4 id="表达式树">表达式树</h4><p>以上三种表达式都可以相互转化并且使用特定的方法求值，我们在此不做赘述，那么我们是否可以将三种表达式统一为某种适合计算机运算的数据结构呢？我们在此引入<strong>表达式树（ExpressionTree）</strong>。</p><p>表达式树是一种数据结构，用于表示数学表达式的层次结构，其中每个节点表示操作数或运算符，而边表示它们之间的关系。表达式树可以用来表示前缀、中缀或后缀表达式，并提供了一种有效的方式来表示和计算复杂的数学表达式。</p><p>以 <span class="math inline">\((a + b) \times c\)</span>为例，我们可以构造如下表达式树：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-20-061557.png" alt="一棵简单的表达式树" style="zoom:60%;" /></p><p>不难发现，表达式树有如下性质：</p><ol type="1"><li>叶节点只能是操作数，非叶节点只能是运算符；</li><li>表达式树的非叶节点的度数只能是 2。</li></ol><h5 id="表达式-to-表达式树">表达式 <spanclass="math inline">\(\to\)</span> 表达式树</h5><p>在这里我们以<strong>后缀表达式</strong>为例，展示一下表达式树的构建过程。</p><p>事实上，我们只需要创建一个栈，然后从左至右遍历表达式并重复以下步骤即可：</p><ul><li>如果遇到操作数，创建操作数节点，并压入栈内；</li><li>如果遇到运算符，创建运算符节点，从栈内弹出两个元素分别做运算符节点的右节点和左节点；</li><li>...</li></ul><p>如此重复，最后栈内会剩下唯一的节点，该节点就是表达式树的根节点。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> __expression_tree &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">node_type</span> &#123;<br>        <span class="hljs-comment">// 节点类型</span><br>        OPEROTOR,<br>        NUMBER<br>    &#125;;<br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ExpTreeNode</span> &#123;<br>        node_type type;<br>        <span class="hljs-keyword">union</span> &#123;<br>            <span class="hljs-type">char</span> op;<br>            <span class="hljs-type">int</span> val;<br>        &#125;;<br>        ExpTreeNode* left;<br>        ExpTreeNode* right;<br>        <span class="hljs-built_in">ExpTreeNode</span>(node_type _type, <span class="hljs-type">int</span> _val, ExpTreeNode* l = <span class="hljs-literal">nullptr</span>, ExpTreeNode* r = <span class="hljs-literal">nullptr</span>): <span class="hljs-built_in">type</span>(_type), <span class="hljs-built_in">left</span>(l), <span class="hljs-built_in">right</span>(r) &#123;<br>            <span class="hljs-keyword">if</span> (type == OPEROTOR) &#123;<br>                op = _val;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                val = _val;<br>            &#125;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-function">ExpTreeNode* <span class="hljs-title">suffix2tree</span><span class="hljs-params">(std::vector&lt;std::string&gt;&amp; ex)</span> </span>&#123;<br>        <span class="hljs-comment">// 后缀表达式转化为表达式树</span><br>        std::stack&lt;ExpTreeNode*&gt; st;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; ele : ex) &#123;<br>            ExpTreeNode* rt = <span class="hljs-literal">nullptr</span>;<br>            <span class="hljs-keyword">if</span> (ele == <span class="hljs-string">&quot;+&quot;</span> || ele == <span class="hljs-string">&quot;-&quot;</span> || ele == <span class="hljs-string">&quot;*&quot;</span> || ele == <span class="hljs-string">&quot;/&quot;</span>) &#123;<br>                ExpTreeNode* r = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                ExpTreeNode* l = st.<span class="hljs-built_in">top</span>();<br>                st.<span class="hljs-built_in">pop</span>();<br>                rt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ExpTreeNode</span>(OPEROTOR, ele[<span class="hljs-number">0</span>], l, r);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                rt = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ExpTreeNode</span>(NUMBER, <span class="hljs-built_in">stoi</span>(ele));<br>            &#125;<br>            st.<span class="hljs-built_in">push</span>(rt);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> st.<span class="hljs-built_in">top</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compute</span><span class="hljs-params">(ExpTreeNode* root)</span> </span>&#123;<br>        <span class="hljs-comment">// 计算以 root 为根节点的表达式树的值</span><br>        <span class="hljs-keyword">if</span> (root-&gt;type == NUMBER) <span class="hljs-keyword">return</span> root-&gt;val;<br><br>        <span class="hljs-type">int</span> l_val = <span class="hljs-built_in">compute</span>(root-&gt;left), r_val = <span class="hljs-built_in">compute</span>(root-&gt;right);<br>        <span class="hljs-keyword">switch</span> (root-&gt;op) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>: <span class="hljs-keyword">return</span> l_val + r_val;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>: <span class="hljs-keyword">return</span> l_val - r_val;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>: <span class="hljs-keyword">return</span> l_val * r_val;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>: <span class="hljs-keyword">return</span> l_val / r_val;<br>        &#125;<br>        <br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// error</span><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __expression_tree;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;std::string&gt; ex&#123;<span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;+&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>&#125;;<br>    ExpTreeNode* rt = <span class="hljs-built_in">suffix2tree</span>(ex);<br><br>    std::cout &lt;&lt; <span class="hljs-built_in">compute</span>(rt) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// (9 + 8) * 2 - 8 / 4 == 32</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是前缀表达式，则只需<strong>从右往左遍历表达式</strong>，然后采取相同的步骤即可（左右子树的顺序上会有差异）。</p><p>如果是中缀表达式，可以考虑使用递归构造表达式树，也可以先将前缀表达式转化为后缀表达式，然后再转化为表达式树。</p><h5 id="表达式树-to-表达式">表达式树 <spanclass="math inline">\(\to\)</span> 表达式</h5><p>事实上，中缀表达式、前缀表达式、后缀表达式，本质上就是表达式树的中序遍历、前序遍历与后续遍历。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::string <span class="hljs-title">tree2prefix</span><span class="hljs-params">(ExpTreeNode* root)</span> </span>&#123;<br>    <span class="hljs-comment">// 表达式树 -&gt; 前缀表达式</span><br>    <span class="hljs-keyword">if</span> (root-&gt;type == NUMBER) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(root-&gt;val);<br><br>    <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, root-&gt;op) + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">tree2prefix</span>(root-&gt;left) + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">tree2prefix</span>(root-&gt;right);<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">tree2infix</span><span class="hljs-params">(ExpTreeNode* root, <span class="hljs-type">char</span> pre_op = <span class="hljs-number">0</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 表达式树 -&gt; 中缀表达式</span><br>    <span class="hljs-keyword">if</span> (root-&gt;type == NUMBER) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(root-&gt;val);<br><br>    <span class="hljs-keyword">if</span> ((root-&gt;op == <span class="hljs-string">&#x27;+&#x27;</span> || root-&gt;op == <span class="hljs-string">&#x27;-&#x27;</span>) &amp;&amp; (pre_op == <span class="hljs-string">&#x27;*&#x27;</span> || pre_op == <span class="hljs-string">&#x27;/&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + <span class="hljs-built_in">tree2infix</span>(root-&gt;left, root-&gt;op) + <span class="hljs-string">&quot; &quot;</span> + std::<span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, root-&gt;op) + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">tree2infix</span>(root-&gt;right, root-&gt;op) + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">tree2infix</span>(root-&gt;left, root-&gt;op) + <span class="hljs-string">&quot; &quot;</span> + std::<span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, root-&gt;op) + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">tree2infix</span>(root-&gt;right, root-&gt;op);<br>&#125;<br><br><span class="hljs-function">std::string <span class="hljs-title">tree2sufix</span><span class="hljs-params">(ExpTreeNode* root)</span> </span>&#123;<br>    <span class="hljs-comment">// 表达式树 -&gt; 后缀表达式</span><br>    <span class="hljs-keyword">if</span> (root-&gt;type == NUMBER) <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">to_string</span>(root-&gt;val);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">tree2sufix</span>(root-&gt;left) + <span class="hljs-string">&quot; &quot;</span> + <span class="hljs-built_in">tree2sufix</span>(root-&gt;right) + <span class="hljs-string">&quot; &quot;</span> + std::<span class="hljs-built_in">string</span>(<span class="hljs-number">1</span>, root-&gt;op);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>表达式树</tag>
      
      <tag>波兰记法</tag>
      
      <tag>逆波兰记法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性神经网络</title>
    <link href="/2023/09/12/%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/09/12/%E7%BA%BF%E6%80%A7%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="线性回归">线性回归</h4><p><strong>回归（Regression）</strong>是能为一个或多个自变量与因变量之间的关系建模的方法。</p><p>而<strong>线性回归（Linearregression）</strong>则是基于自变量与因变量的关系是线性的假设： <spanclass="math display">\[\hat{y} = X w + b\]</span></p><h5 id="损失函数">损失函数</h5><p><span class="math display">\[L(w, b) = \frac{1}{2 N} \sum_{i} (x ^ {(i)} w + b - y ^ {(i)}) ^ 2\]</span></p><p>我们可以将参数 <span class="math inline">\(b\)</span> 并入 <spanclass="math inline">\(w\)</span> 中，则损失函数用向量可以表示为： <spanclass="math display">\[L(w, b) = \frac{1}{2 N} ||y - X w|| ^ 2\]</span> 对损失函数求导，可以得到极小值点点解析解（Analyticalsolution）如下： <span class="math display">\[w ^ * = (X ^ T X) ^ {-1} X ^ T y\]</span> 我们注意到，解析解不一定存在，因为按照上式，<spanclass="math inline">\(X ^ T X\)</span> 满秩才存在逆矩阵。</p><h5 id="随机梯度下降">随机梯度下降</h5><p>每次迭代中，我们从所有样本随机抽取一个小批量集合 <spanclass="math inline">\(B\)</span> ，进行如下迭代： <spanclass="math display">\[w := w - \frac{\eta}{|B|} \frac{\partial}{\partial w} \sum_{i \in B}l(w, x ^ {(i)})\]</span></p><h5 id="生成数据集">生成数据集</h5><p>我们设置一个符合正态分布且期望为 0 的噪声项 <spanclass="math inline">\(\epsilon\)</span> 来生成数据集： <spanclass="math display">\[\hat y = X w + b + \epsilon\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthetic_data</span>(<span class="hljs-params">w, b, num_examples</span>): <span class="hljs-comment">#@save</span><br>    X = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (num_examples, <span class="hljs-built_in">len</span>(w)))<br>    y = torch.matmul(X, w) + b<br>    y += torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, y.shape)<br><br>    <span class="hljs-keyword">return</span> X, y.reshape((<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    w = torch.tensor([<span class="hljs-number">1.8</span>])<br>    b = torch.tensor([-<span class="hljs-number">0.5</span>])<br>    num_examples = <span class="hljs-number">1000</span><br><br>    X, y = synthetic_data(w, b, num_examples=num_examples)<br><br>    plt.scatter(X.flatten(), y.flatten(), s=<span class="hljs-number">10</span>)<br>    plt.show()<br><br>    torch.save(X, <span class="hljs-string">&#x27;training dataset/X_data.pt&#x27;</span>)<br>    torch.save(y, <span class="hljs-string">&#x27;training dataset/y_data.pt&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-15-035915.png" alt="绘制数据集图像" style="zoom:100%;" /></p><h5 id="训练模型">训练模型</h5><p>基于此，我们可以实现一个简单的线性回归神经网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LinearNN</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, dim=<span class="hljs-number">1</span>, mean=<span class="hljs-number">0</span>, std=<span class="hljs-number">1</span></span>):<br>        self.w = torch.normal(mean=mean, std=std, size=(dim, <span class="hljs-number">1</span>), requires_grad=<span class="hljs-literal">True</span>)<br>        self.b = torch.normal(mean=mean, std=std, size=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>), requires_grad=<span class="hljs-literal">True</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, X: torch.tensor</span>) -&gt; torch.tensor:<br><br>        <span class="hljs-keyword">return</span> torch.matmul(X, self.w) + self.b<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">loss</span>(<span class="hljs-params">self, X: torch.tensor, y: torch.tensor</span>) -&gt; torch.float64:<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * torch.<span class="hljs-built_in">sum</span>((y - self.predict(X)) ** <span class="hljs-number">2</span>) / X.shape[<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sgd</span>(<span class="hljs-params">self, params, batch_size, lr</span>):<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>                param -= lr * param.grad / batch_size<br>                param.grad.zero_()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, X: torch.tensor, y: torch.tensor, batch_size, num_epoches, lr=<span class="hljs-number">0.03</span></span>):<br>        data_size = y.shape[<span class="hljs-number">0</span>]<br>        iter_num = (data_size + batch_size - <span class="hljs-number">1</span>) // batch_size<br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epoches):<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iter_num):<br>                batch_mask = np.random.choice(data_size, batch_size)<br>                l = self.loss(X[batch_mask, :], y[batch_mask, :])<br>                l.backward()<br>                self.sgd([self.w, self.b], batch_size, lr)<br>            <span class="hljs-keyword">with</span> torch.no_grad():<br>                l = self.loss(X, y)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span> is over, loss = <span class="hljs-subst">&#123;l&#125;</span>&#x27;</span>)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;w = <span class="hljs-subst">&#123;self.w.data&#125;</span>, b = <span class="hljs-subst">&#123;self.b.data&#125;</span>&#x27;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    X = torch.load(<span class="hljs-string">&#x27;training dataset/X_data.pt&#x27;</span>)<br>    y = torch.load(<span class="hljs-string">&#x27;training dataset/y_data.pt&#x27;</span>).T<br><br>    model = LinearNN(dim=<span class="hljs-number">1</span>)<br>    model.train(X, y, batch_size=<span class="hljs-number">100</span>, num_epoches=<span class="hljs-number">200</span>, lr=<span class="hljs-number">0.5</span>) <br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>终端输出：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-15-091344.png" style="zoom:100%;" /></p><p>最终 <span class="math inline">\(w\)</span> 和 <spanclass="math inline">\(b\)</span> 大约收敛于 1.8 和-0.5，这与我们预设的参数是基本一致的，损失函数则收敛于 0.5，约等于 <spanclass="math inline">\(\frac{\sigma ^ 2}{2}\)</span>，符合数学原理。</p><h6 id="更简单的实现方式">更简单的实现方式</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    net = torch.nn.Sequential(torch.nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br>    net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    net[<span class="hljs-number">0</span>].bias.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment"># 重写参数</span><br><br>    loss = torch.nn.MSELoss() <span class="hljs-comment"># 定义损失函数</span><br>    trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 定义优化算法，这里选择 SGD</span><br>    X = torch.load(<span class="hljs-string">&#x27;training dataset/X_data.pt&#x27;</span>)<br>    y = torch.load(<span class="hljs-string">&#x27;training dataset/y_data.pt&#x27;</span>).T<br><br>    num_epoches = <span class="hljs-number">20</span><br>    sz = X.shape[<span class="hljs-number">0</span>]<br>    batch_size = <span class="hljs-number">100</span><br><br>    iter_num = (sz + batch_size - <span class="hljs-number">1</span>) // batch_size<br>    <span class="hljs-built_in">print</span>(iter_num)<br><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epoches):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iter_num):<br>            batch_mask = np.random.choice(sz, batch_size)<br>            l = loss(net(X[batch_mask, :]), y[batch_mask, :])<br>            trainer.zero_grad()<br>            l.backward() <span class="hljs-comment"># 反向传播</span><br>            trainer.step() <span class="hljs-comment"># 更新参数</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span> is over, loss = <span class="hljs-subst">&#123;loss(net(X), y)&#125;</span>&#x27;</span>)<br><br>    w = net[<span class="hljs-number">0</span>].weight.data<br>    b = net[<span class="hljs-number">0</span>].bias.data<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;w = <span class="hljs-subst">&#123;w&#125;</span>, b = <span class="hljs-subst">&#123;b&#125;</span>&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><ul><li><p><code>torch.nn.Sequential</code></p><p><code>torch.nn.Sequential</code> 是 PyTorch中的一个容器模块，它允许你按顺序将一系列神经网络层组合在一起，以构建神经网络模型。<code>Sequential</code>可以用于定义一个前馈神经网络，其中每个层的输出都成为下一层的输入。这使得创建和管理深度神经网络模型变得更加方便。</p><p>示例：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br>model = nn.Sequential(<br>    nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">64</span>),  <span class="hljs-comment"># 输入层，输入维度为 128，输出维度为 64</span><br>    nn.ReLU(),  <span class="hljs-comment"># ReLU 激活函数</span><br>    nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">32</span>),  <span class="hljs-comment"># 隐藏层，输入维度为 64，输出维度为 32</span><br>    nn.ReLU(),<br>    nn.Linear(<span class="hljs-number">32</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># 输出层，输入维度为 32，输出维度为 10</span><br>)<br><br><span class="hljs-comment"># 打印模型的结构</span><br><span class="hljs-built_in">print</span>(model)<br></code></pre></td></tr></table></figure></p></li></ul><h4 id="softmax-回归">Softmax 回归</h4><h5 id="softmax-运算">Softmax 运算</h5><p>线性神经网络输出为 <spanclass="math inline">\(o\)</span>（多个输出），则 Softmax运算可以描述如下： <span class="math display">\[\hat y = softmax(o)\]</span> 其中： <span class="math display">\[\hat y_i = \frac{exp(o_i)}{\sum_{k} exp(o_k)}\]</span> 一个简单的线性神经网络分类模型可以归纳如下： <spanclass="math display">\[O = XW + b\]</span> <span class="math display">\[\hat Y = softmax(O)\]</span></p><p>对于数据 <span class="math inline">\(\hat y\)</span>而言，预测最可能类别是：<span class="math inline">\(\underset{i}{argmax\\hat y_i}\)</span></p><h5 id="交叉熵损失">交叉熵损失</h5><p><span class="math display">\[L(y, \hat y) = -\sum_{j} y_j log(\hat y_j)\]</span></p><h5 id="基于线性-softmax-回归的-pytorch-实现">基于线性 Softmax 回归的PyTorch 实现</h5><p>在这里我们以 MNIST 的手写数字为例，给出 Softmax 回归的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.datasets <span class="hljs-keyword">import</span> mnist<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>():<br>    (x_train, l_train), (x_test, l_test) = mnist.load_data()<br>    x_train = torch.from_numpy(x_train)<br>    x_test = torch.from_numpy(x_test)<br>    x_train = x_train / <span class="hljs-number">255.0</span><br>    x_test = x_test / <span class="hljs-number">255.0</span><br>    y_train = torch.zeros(size=(l_train.shape[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l_train.shape[<span class="hljs-number">0</span>]):<br>        y_train[i, l_train[i]] = <span class="hljs-number">1</span><br>    y_test = torch.zeros(size=(l_test.shape[<span class="hljs-number">0</span>], <span class="hljs-number">10</span>))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(l_test.shape[<span class="hljs-number">0</span>]):<br>        y_test[i, l_test[i]] = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">return</span> (x_train, y_train), (x_test, y_test)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br><br>    dataset = &#123;&#125;<br>    (dataset[<span class="hljs-string">&#x27;x_train&#x27;</span>], dataset[<span class="hljs-string">&#x27;y_train&#x27;</span>]), (dataset[<span class="hljs-string">&#x27;x_test&#x27;</span>], dataset[<span class="hljs-string">&#x27;y_test&#x27;</span>]) = get_data()<br><br>    model = nn.Sequential(<br>        nn.Flatten(),<br>        nn.Linear(<span class="hljs-number">784</span>, <span class="hljs-number">10</span>),<br>        nn.Softmax()<br>    )<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        model[<span class="hljs-number">1</span>].weight.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>        model[<span class="hljs-number">1</span>].bias.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br><br>    trainer = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.25</span>)<br><br>    loss = nn.CrossEntropyLoss()<br>    num_epoches = <span class="hljs-number">1000</span><br>    batch_size = <span class="hljs-number">6000</span><br>    sz = dataset[<span class="hljs-string">&#x27;x_train&#x27;</span>].shape[<span class="hljs-number">0</span>]<br>    sz_test = dataset[<span class="hljs-string">&#x27;x_test&#x27;</span>].shape[<span class="hljs-number">0</span>]<br>    iter_num = (sz + batch_size - <span class="hljs-number">1</span>) // batch_size<br><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epoches):<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iter_num):<br>            batch_mask = np.random.choice(sz, batch_size)<br>            l = loss(model(dataset[<span class="hljs-string">&#x27;x_train&#x27;</span>][batch_mask]), dataset[<span class="hljs-string">&#x27;y_train&#x27;</span>][batch_mask])<br>            trainer.zero_grad()<br>            l.backward()<br>            trainer.step()<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span> is over, loss = <span class="hljs-subst">&#123;loss(model(dataset[<span class="hljs-string">&quot;x_test&quot;</span>]), dataset[<span class="hljs-string">&quot;y_test&quot;</span>])&#125;</span>, &#x27;</span>, end=<span class="hljs-string">&#x27;&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;acc = <span class="hljs-subst">&#123;torch.<span class="hljs-built_in">sum</span>(torch.argmax(model(dataset[<span class="hljs-string">&quot;x_test&quot;</span>]), dim=<span class="hljs-number">1</span>) == torch.argmax(dataset[<span class="hljs-string">&quot;y_test&quot;</span>], dim=<span class="hljs-number">1</span>)) / sz_test&#125;</span>&#x27;</span>)<br>    <br>    torch.save(model.state_dict(), <span class="hljs-string">&#x27;./net/mnist_flatten_weights.pth&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>终端输出：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-19-031145.png" style="zoom:67%;" /></p><blockquote><p>在使用 SGD 训练 1000 个 epoch 之后，识别正确率维持在 92% 左右。</p></blockquote><h5 id="线性分类器的可视化">线性分类器的可视化</h5><p>在上述 MNIST 手写数字的例子中，输入层的 10 个神经元实际上就是 10个线性分类器，即我们认为，若 <span class="math inline">\(W_i x +b_i\)</span> （<span class="math inline">\(i =0、1、2、...、9\)</span>）在所有神经元的输出值中最大，则数字是 <spanclass="math inline">\(i\)</span> 的可能性越大。</p><p>我们可以将每个神经元的参数二维展开来观察其具体形态：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># ...</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    img = (model[<span class="hljs-number">1</span>].weight[i].reshape(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>) * <span class="hljs-number">255</span>).byte()<br>    plt.figure()<br>    plt.imshow(img, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>, interpolation=<span class="hljs-string">&#x27;nearest&#x27;</span>)<br>    plt.colorbar()<br>    plt.savefig(<span class="hljs-string">&#x27;./img/&#x27;</span> + <span class="hljs-built_in">str</span>(i) + <span class="hljs-string">&#x27;.png&#x27;</span>)<br></code></pre></td></tr></table></figure><div class="group-image-container"><div class="group-image-row"><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044203.png"alt="0" /></div><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044312.png"alt="1" /></div><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044337.png"alt="2" /></div></div><div class="group-image-row"><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044352.png"alt="3" /></div><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044434.png"alt="4" /></div><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044451.png"alt="5" /></div></div><div class="group-image-row"><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044506.png"alt="6" /></div><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044520.png"alt="7" /></div><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044533.png"alt="8" /></div></div><div class="group-image-row"><div class="group-image-wrap"><imgsrc="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-10-24-044545.png"alt="9" /></div></div></div><p>我们发现，训练后的神经网络的参数在可视化后竟然可以隐约看到数字的形状！尽管由于样本数量过多，可能在部分数字的参数可视化上会呈现出模糊化抽象化的特征，但在特征少的数字上我们依然可以明显看出来其代表的数字。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PyTorch</tag>
      
      <tag>深度学习</tag>
      
      <tag>线性回归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandas 库学习笔记</title>
    <link href="/2023/09/08/Pandas%20%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/09/08/Pandas%20%E5%BA%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h4 id="简介">简介</h4><p><code>pandas</code> 是一个用于数据分析和处理的强大 Python库。它提供了高性能、易于使用的数据结构和数据分析工具，使数据科学家、分析师和工程师能够更轻松地进行数据处理和探索性数据分析。以下是一些<code>pandas</code> 库的主要特点和功能：</p><ol type="1"><li><p><strong>数据结构</strong>：</p><ul><li><p><strong>Series</strong>：类似于一维数组的数据结构，是构建DataFrame 的基本组成部分。</p></li><li><p><strong>DataFrame</strong>：<code>pandas</code>最重要的数据结构之一，它类似于表格或电子表格，可以包含多种数据类型的列。DataFrame是处理和分析数据的主要工具，支持标签和位置索引。</p></li></ul></li><li><p><strong>数据导入和导出</strong>：</p><ul><li>支持从多种数据源导入数据，包括 Excel、CSV、SQL 数据库、JSON等。</li><li>可以将数据导出为各种格式的文件。</li></ul></li><li><p><strong>数据清洗和处理</strong>：</p><ul><li>支持缺失数据的处理，包括填充、删除等。</li><li>提供强大的数据过滤、排序、切片和选择功能。</li><li>可以进行数据合并和连接，以及数据的重塑和透视操作。</li></ul></li><li><p><strong>数据分析和探索</strong>：</p><ul><li>支持基本统计分析，如均值、中位数、标准差等。</li><li>提供强大的分组和聚合功能，可以进行分组统计。</li><li>可以进行时间序列数据分析和处理。</li></ul></li><li><p><strong>数据可视化</strong>：</p><ul><li><code>pandas</code> 可以与其他数据可视化库（如<code>Matplotlib</code> 和 <code>Seaborn</code>）集成，用于创建各种图表和图形。</li></ul></li><li><p><strong>高性能</strong>：</p><ul><li><code>pandas</code>经过优化，可以处理大规模数据集，提供快速的数据操作和计算。</li></ul></li><li><p><strong>多级索引</strong>：</p><ul><li>允许在 DataFrame 中创建多级索引，使数据的层次化表示更容易。</li></ul></li><li><p><strong>时间序列分析</strong>：</p><ul><li><code>pandas</code>具有强大的时间序列功能，支持日期和时间的操作、分组和重采样。</li></ul></li><li><p><strong>互动式数据分析</strong>：</p><ul><li>在 Jupyter Notebook 等互动式环境中，<code>pandas</code>非常适合用于数据探索和分析。</li></ul></li><li><p><strong>开源和社区支持</strong>：</p><ul><li><code>pandas</code>是一个开源项目，拥有庞大的社区支持，有大量文档、教程和示例可供学习和参考。</li></ul></li></ol><p><code>pandas</code>是数据科学工作流程中不可或缺的工具之一，可以帮助你加载、处理、分析和可视化数据，从而更好地理解数据并做出决策。无论是进行数据探索性分析、数据清洗、数据预处理还是建模，<code>pandas</code>都是一个强大而灵活的工具。</p><h3 id="重要数据结构">重要数据结构</h3><h4 id="series"><code>Series</code></h4><p><code>Series</code> 类似于一维数组，但可以自定义索引，这方面又有些像Python 中的字典。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = pd.Series([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], index = [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>])<br><span class="hljs-comment"># 或者 arr = pd.Series(&#123;&#x27;one&#x27;: 1, &#x27;two&#x27;: 2, &#x27;three&#x27;: 3&#125;)</span><br></code></pre></td></tr></table></figure><p>如果不定义 <code>index</code> ，就是默认的数组索引（<code>0</code> ～数组长度 - 1）</p><p><code>pandas</code>具有强大的数据对齐功能，具体体现在两个数据结构在相加时，可以将相同键值对应的值进行相加，Eg：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">s1 = pd.Series(&#123;<span class="hljs-string">&#x27;高等数学&#x27;</span>: <span class="hljs-number">98</span>, <span class="hljs-string">&#x27;大学物理&#x27;</span>: <span class="hljs-number">90</span>, <span class="hljs-string">&#x27;C++&#x27;</span>: <span class="hljs-number">100</span>&#125;)<br>s2 = pd.Series(&#123;<span class="hljs-string">&#x27;高等数学&#x27;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&#x27;大学物理&#x27;</span>: <span class="hljs-number">93</span>, <span class="hljs-string">&#x27;C++&#x27;</span>: <span class="hljs-number">91</span>&#125;)<br><br><span class="hljs-built_in">print</span>((s1 + s2) / <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">高等数学    99.0<br>大学物理    91.5<br>C++     95.5<br>dtype: float64<br></code></pre></td></tr></table></figure><p>但是，如果两组数据中出现不同的标签，对于标签不相同的数据，运算后结果是<code>NaN</code> ，此时可以使用 Pandas 自己提供的 <code>add()</code>方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(s1.add(s2, fill_value = <span class="hljs-number">0</span>))<br><span class="hljs-comment"># fill_value 表示缺省情况的默认值</span><br></code></pre></td></tr></table></figure><p>除 <code>add()</code> 方法对应加法外，数学中的减、乘、除在<code>pandas</code> 中也有对应的方法，分别是<code>sub()</code>、<code>mul()</code> 和 <code>div()</code> 。</p><h4 id="dataframe"><code>DataFrame</code></h4><p><code>DataFrame</code>是一个表格，有行和列两个维度，其中每一行或者每一列都是一个<code>Series</code> 。</p><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>pd.set_option(<span class="hljs-string">&#x27;display.unicode.ambiguous_as_wide&#x27;</span>, <span class="hljs-literal">True</span>)<br>pd.set_option(<span class="hljs-string">&#x27;display.unicode.east_asian_width&#x27;</span>, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 将中文对齐</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    s = pd.DataFrame(&#123;<span class="hljs-string">&#x27;高等数学&#x27;</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">98</span>], <span class="hljs-string">&#x27;大学物理&#x27;</span>: [<span class="hljs-number">90</span>, <span class="hljs-number">93</span>], <span class="hljs-string">&#x27;C++&#x27;</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">91</span>]&#125;)<br>    <span class="hljs-built_in">print</span>(s)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">   高等数学  大学物理  C++<br>0       100        90  100<br>1        98        93   91<br></code></pre></td></tr></table></figure><p>一般来说一个 <code>DataFrame</code> 对象通过一个字典和<code>index</code> 参数来设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">dat = &#123;<span class="hljs-string">&#x27;高等数学&#x27;</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">98</span>], <span class="hljs-string">&#x27;大学物理&#x27;</span>: [<span class="hljs-number">90</span>, <span class="hljs-number">93</span>], <span class="hljs-string">&#x27;C++&#x27;</span>: [<span class="hljs-number">100</span>, <span class="hljs-number">91</span>]&#125;<br>s = pd.DataFrame(data = dat, index = [<span class="hljs-string">&#x27;Carl&#x27;</span>, <span class="hljs-string">&#x27;Tony&#x27;</span>])<br><span class="hljs-built_in">print</span>(s)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">      高等数学  大学物理  C++<br>Carl       100        90  100<br>Tony        98        93   91<br></code></pre></td></tr></table></figure><h5 id="导入导出表格文件">导入、导出表格文件</h5><p>很多情况下，我们需要读取表格文件，Pandas提供了多种函数来读取和输出表格文件。</p><table><thead><tr class="header"><th></th><th>导入</th><th>导出</th></tr></thead><tbody><tr class="odd"><td><code>.csv</code> 表格</td><td><code>read_csv(file_path)</code></td><td><code>to_csv(file_path, index)</code></td></tr><tr class="even"><td>Excel 文件</td><td><code>read_excel(file_path)</code></td><td><code>to_excel(file_path, index)</code></td></tr></tbody></table><blockquote><p><code>index</code> 的值表示是否将最左侧的索引保存到文件中。</p></blockquote><h6 id="忽略无关数据">忽略无关数据</h6><p>在读取表格的时候，有些行是无关紧要的，我们可以通过相关参数进行控制，比如我们忽略某个表格前40 行，且只读取 40 行，可以考虑添加 <code>skiprows</code> 参数和<code>nrows</code> 参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 读取 Excel 文件，跳过前 40 行，并且只读取接下来 40 行</span><br>df = pd.read_excel(<span class="hljs-string">&#x27;data.xlsx&#x27;</span>, skiprows = <span class="hljs-built_in">range</span>(<span class="hljs-number">40</span>), nrows = <span class="hljs-number">40</span>)<br></code></pre></td></tr></table></figure><p>成功读取表格后，我们就可以进行对应的操作了。</p><p>假设我们成功读取工作目录下的表格 <code>scores.csv</code> ：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-08-092722.png" style="zoom:70%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>pd.set_option(<span class="hljs-string">&#x27;display.unicode.ambiguous_as_wide&#x27;</span>, <span class="hljs-literal">True</span>)<br>pd.set_option(<span class="hljs-string">&#x27;display.unicode.east_asian_width&#x27;</span>, <span class="hljs-literal">True</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    sc = pd.read_csv(<span class="hljs-string">&#x27;./scores.csv&#x27;</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h5 id="列操作">列操作</h5><h6 id="查看列">查看列</h6><p>例如，我需要查看每个人的高数成绩：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(sc[<span class="hljs-string">&#x27;高等数学&#x27;</span>])<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">0    100<br>1     92<br>2     94<br>Name: 高等数学, dtype: int64<br></code></pre></td></tr></table></figure><h6 id="修改列">修改列</h6><p>直接采用赋值修改即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sc[<span class="hljs-string">&#x27;大学物理&#x27;</span>] = [<span class="hljs-number">96</span>, <span class="hljs-number">94</span>, <span class="hljs-number">99</span>]<br></code></pre></td></tr></table></figure><p>此时，三个人的大物成绩就分别修改成了 96、94、99。</p><h6 id="新增列">新增列</h6><p>比如现在我需要新增「数据结构」这门课，可以考虑以下方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sc[<span class="hljs-string">&#x27;数据结构&#x27;</span>] = [<span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">90</span>]<br><span class="hljs-built_in">print</span>(sc)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">     姓名  高等数学  大学物理  C++  数据结构<br>0    Carl       100        93   91       100<br>1    Jack        92        94   93        90<br>2  Jennie        94        98   89        90<br></code></pre></td></tr></table></figure><h6 id="删除列">删除列</h6><p>删除列考虑使用 <code>drop()</code> 方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">sc.drop(<span class="hljs-string">&#x27;大学物理&#x27;</span>, axis = <span class="hljs-number">1</span>, inplace = <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>这样，我们就成功删除了「大学物理」这一列，参数 <code>axis</code>表示行或列，行为 0，列为 1，默认值为 0，<code>inplace</code>参数表示删除后是否替换原表格还是只返回删除后的表格，默认值为<code>False</code> 。</p><h5 id="行操作">行操作</h5><p>行是通过最左边的索引来获取的，再不指定的情况下，索引值默认从 0开始依次递增，可以使用 <code>loc</code> 基于索引进行表格行的操作。</p><h6 id="查看行">查看行</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(sc.loc[<span class="hljs-number">0</span>]) <span class="hljs-comment"># 查看第一行学生的成绩</span><br></code></pre></td></tr></table></figure><p>如果指定了表格的索引列，则通过相应的索引来查找行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sc = pd.read_csv(<span class="hljs-string">&#x27;./scores.csv&#x27;</span>, index_col = <span class="hljs-string">&#x27;姓名&#x27;</span>)<br><span class="hljs-built_in">print</span>(sc.loc[<span class="hljs-string">&#x27;Carl&#x27;</span>])<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">性别          M<br>高等数学    100<br>大学物理     93<br>C++          91<br>Name: Carl, dtype: object<br></code></pre></td></tr></table></figure><p>除了第一个参数外，还支持第二个参数列名，同时基于行和列获取指定数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(sc.loc[<span class="hljs-string">&#x27;Carl&#x27;</span>, <span class="hljs-string">&#x27;高等数学&#x27;</span>]) <span class="hljs-comment"># 100</span><br></code></pre></td></tr></table></figure><blockquote><p>注：<code>loc</code> 方法也支持切片和传入条件判断，但对于切片<code>l : r</code> 而言左右都是闭区间。</p></blockquote><p>修改行、新增行、删除行和列操作是类似的，故此处不加以赘述。</p><h5 id="排序">排序</h5><p>考虑使用 <code>sort_values()</code>方法，第一个参数表示排序所依靠的键值。在如下示例中，我们按照高等数学的成绩降序排列学生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">sc.sort_values(<span class="hljs-string">&#x27;高等数学&#x27;</span>, ascending = <span class="hljs-literal">False</span>, inplace = <span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(sc)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">     姓名  高等数学  大学物理  C++<br>0    Carl       100        93   91<br>2  Jennie        94        98   89<br>1    Jack        92        94   93<br></code></pre></td></tr></table></figure><h5 id="分组">分组</h5><p>分组是个很有用的功能，熟悉 SQL 语句的同学应该不会陌生，在 Pandas库中的分组功能也是差不多的。例如，接下来我们需要统计以下表格中男女生高等数学和C++ 的平均分：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-08-095400.png" style="zoom:70%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(sc.groupby(<span class="hljs-string">&#x27;性别&#x27;</span>)[[<span class="hljs-string">&#x27;高等数学&#x27;</span>, <span class="hljs-string">&#x27;C++&#x27;</span>]].mean())<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">      高等数学   C++<br>性别                <br>F         94.0  89.0<br>M         96.0  92.0<br></code></pre></td></tr></table></figure><p>类似的和分组功能一同使用的函数还有：<code>max()</code>、<code>min()</code> 、<code>sum()</code> 等。</p><h5 id="筛选数据">筛选数据</h5><p>与 Numpy 一样，可以传入筛选条件来返回所有符合条件的数据，例如查找所有C++ 分数不少于 90 的同学：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(sc[sc[<span class="hljs-string">&#x27;C++&#x27;</span>] &gt;= <span class="hljs-number">90</span>][<span class="hljs-string">&#x27;姓名&#x27;</span>])<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">0    Carl<br>1    Jack<br>Name: 姓名, dtype: object<br></code></pre></td></tr></table></figure><p>注：索引中条件的分隔符如下：</p><ul><li>或：<code>|</code></li><li>且：<code>&amp;</code></li></ul><h5 id="数据标签">数据标签</h5><p>Pandas 提供了 <code>cut()</code> 方法用于给数据添加标签并分类。</p><p>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">csc = pd.cut(sc[<span class="hljs-string">&#x27;高等数学&#x27;</span>], bins = [<span class="hljs-number">0</span>, <span class="hljs-number">59</span>, <span class="hljs-number">79</span>, <span class="hljs-number">89</span>, <span class="hljs-number">100</span>], labels = [<span class="hljs-string">&#x27;不及格&#x27;</span>, <span class="hljs-string">&#x27;及格&#x27;</span>, <span class="hljs-string">&#x27;良好&#x27;</span>, <span class="hljs-string">&#x27;优秀&#x27;</span>])<br></code></pre></td></tr></table></figure><p>第一个参数表示需要分类的键，第二个表示分类区间，默认为左开右闭，第三个参数表示每个区间对应的标签。</p><h5 id="表格合并">表格合并</h5><h6 id="纵向合并">纵向合并</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.concat([df_1, df_2, df_3])<br></code></pre></td></tr></table></figure><h6 id="横向合并">横向合并</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">df = pd.merge(df_1, df_2)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Pandas</tag>
      
      <tag>数据科学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Z 函数</title>
    <link href="/2023/09/07/Z%20%E5%87%BD%E6%95%B0/"/>
    <url>/2023/09/07/Z%20%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="介绍">介绍</h3><p>Z 函数是字符串算法中的一个重要函数，对于一个字符串 <spanclass="math inline">\(s\)</span> 而言，<spanclass="math inline">\(z[i]\)</span> 描述了以 <spanclass="math inline">\(s[i]\)</span> 开始的后缀与 <spanclass="math inline">\(s\)</span> 的最长公共前缀。</p><p>在此约定 <span class="math inline">\(z[0] = 0\)</span> 。</p><p>示例：对于字符串 <code>aabaabc</code> 而言，其 Z 函数为：<spanclass="math inline">\(\{ 0, 1, 0, 3, 1, 0, 0 \}\)</span> 。</p><p>Z 函数有很多应用，比如字符串匹配等，等会我们会一一介绍。</p><h4 id="线性时间复杂度计算-z-函数">线性时间复杂度计算 Z 函数</h4><p>假设要计算 <span class="math inline">\(s\)</span> 的 Z函数，考虑对于任意 <span class="math inline">\(i \in [0, |s| -1]\)</span> ，都计算后缀 <span class="math inline">\(s[i :]\)</span> 和<span class="math inline">\(s\)</span> 的最长公共前缀，则时间复杂度为<span class="math inline">\(O(|s| ^ 2)\)</span> 。</p><p>所以在这里我们给出一种线性计算 Z 函数的方法：</p><p>我们在这里使用两个变量：<span class="math inline">\(l\)</span> 和<span class="math inline">\(r\)</span> ，初始化均为 0，<spanclass="math inline">\(r\)</span> 维护当前已经计算过的最大的 <spanclass="math inline">\(i + z[i] - 1\)</span> ，即目前计算的过的 <spanclass="math inline">\(s[i :]\)</span> 公共前缀最长延续的下标，<spanclass="math inline">\(l\)</span> 则表示取最大值时 <spanclass="math inline">\(i\)</span> 的索引，即 <spanclass="math inline">\(r = l + z[l] - 1\)</span> 。</p><p>接下来从 1 开始便利字符串下标 <span class="math inline">\(i\)</span>即可：</p><ol type="1"><li><p>若 <span class="math inline">\(i \leq r\)</span> ：</p><p>根据定义有 <span class="math inline">\(s[i : r] = s[i - l : r -l]\)</span> ，因此：</p><ul><li>若 <span class="math inline">\(z[i - l] &lt; r - i + 1\)</span> ，则<span class="math inline">\(z[i] = z[i - l]\)</span> ；</li><li>若 <span class="math inline">\(z[i - l] \geq r - i + 1\)</span> ，则<span class="math inline">\(z[i] = r - i + 1\)</span> ，然后按照 Z函数的定义继续扩展。</li></ul></li><li><p>若 <span class="math inline">\(i &gt; r\)</span> ：</p><p>我们只需令 <span class="math inline">\(z[i] = 0\)</span> ，然后按照 Z函数的定义继续拓展即可。</p></li></ol><p>每一轮循环结束后对 <span class="math inline">\(l\)</span> 和 <spanclass="math inline">\(r\)</span> 进行更新。</p><p>代码实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z_function</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; pat)</span> </span>&#123;<br>    <span class="hljs-type">int</span> n = pat.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="hljs-number">1</span>) &#123;<br>            z[i] = z[i - l];<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            z[i] = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r - i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; pat[z[i]] == pat[i + z[i]]) z[i]++;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i + z[i] - <span class="hljs-number">1</span> &gt; r) &#123;<br>            l = i;<br>            r = i + z[i] - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> z;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意到，内层 <code>while</code> 循环每一轮都会使得 <code>r</code> 加1，而外层循环只有一次遍历，因此时间复杂度为 <spanclass="math inline">\(O(n)\)</span> 。</p><h3 id="z-函数的应用">Z 函数的应用</h3><h4 id="线性时间复杂度匹配子串">线性时间复杂度匹配子串</h4><p>众所周知，KMP 算法可以实现线性时间复杂度内查找字符串 <spanclass="math inline">\(s\)</span> 中是否存在子串 <spanclass="math inline">\(p\)</span> ，使用 Z函数则可以更为简洁地实现同样的效果：</p><p>我们构造一个新字符串 <span class="math inline">\(sp = p + \Delta +s\)</span> ，<span class="math inline">\(\Delta\)</span>表示一个分割字符，其不在 <span class="math inline">\(p\)</span> 和 <spanclass="math inline">\(s\)</span> 中出现，接下来计算 <spanclass="math inline">\(sp\)</span> 的 Z 函数，若 <spanclass="math inline">\(sp\)</span> 的 Z 函数存在某个值等于 <spanclass="math inline">\(|p|\)</span> ，则说明 <spanclass="math inline">\(p\)</span> 是 <spanclass="math inline">\(s\)</span> 的子串，反之则说明不是。</p><p>示例代码（ <code>haystack</code> 为文本串，<code>needle</code>为模式串）：</p><blockquote><p>时间复杂度：<span class="math inline">\(O(|s| + |p|)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strStr</span><span class="hljs-params">(std::string&amp; haystack, std::string&amp; needle)</span> </span>&#123;<br>        std::string str = needle + <span class="hljs-string">&#x27;&amp;&#x27;</span> + haystack;<br>        <span class="hljs-type">int</span> n = str.<span class="hljs-built_in">size</span>(), p = needle.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">z</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, l = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt;= r &amp;&amp; z[i - l] &lt; r - i + <span class="hljs-number">1</span>) &#123;<br>                z[i] = z[i - l];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                z[i] = std::<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, r - i + <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">while</span> (i + z[i] &lt; n &amp;&amp; str[z[i]] == str[i + z[i]]) z[i]++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (z[i] == p) <span class="hljs-keyword">return</span> i - p - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (i + z[i] - <span class="hljs-number">1</span> &gt; r) &#123;<br>                l = i;<br>                r = i + z[i] - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>杜教筛与莫比乌斯反演</title>
    <link href="/2023/08/30/%E6%9D%9C%E6%95%99%E7%AD%9B%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/"/>
    <url>/2023/08/30/%E6%9D%9C%E6%95%99%E7%AD%9B%E4%B8%8E%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%8D%E6%BC%94/</url>
    
    <content type="html"><![CDATA[<p>此篇文章是笔者参考 OI-wiki 写的一份简单的学习笔记。</p><hr /><h3 id="杜教筛">杜教筛</h3><h4 id="简介">简介</h4><p>杜教筛，是一种用于快速求形如 <span class="math inline">\(\sum_{i = 1}^ n f(i)\)</span> 这样前缀和形式的算法，最高效时可以达到 <spanclass="math inline">\(O(n ^ {\frac{2}{3}})\)</span> 的时间复杂度。</p><h4 id="算法思想">算法思想</h4><p>对于 <span class="math inline">\(S(n) = \sum_{i = 1} ^ nf(i)\)</span> 想办法构造一个 <span class="math inline">\(S(n)\)</span>关于 <span class="math inline">\(S([\frac{n}{k}])\)</span>的递推式。</p><p>考虑一个辅助函数 <span class="math inline">\(g(i)\)</span> ，考虑<span class="math inline">\(f\)</span> 和 <spanclass="math inline">\(g\)</span> 的狄利克雷卷积之和： <spanclass="math display">\[\sum_{i = 1} ^ n (f * g)(i) = \sum_{i = 1} ^ n \sum_{d | i}g(d)f(\frac{i}{d}) \\= \sum_{d = 1} ^ n g(d) \sum_{d | i} f(\frac{i}{d}) \\= \sum_{d = 1} ^ n g(d) \sum_{k = 1} ^ {[\frac{n}{d}]} f(k) \\= \sum_{d = 1} ^ n g(d) S([\frac{n}{d}])\]</span></p><p><span class="math display">\[\implies g(1)S(n) = \sum_{i = 1} ^ n (f * g)(i) - \sum_{d = 2} ^ n g(d)S([\frac{n}{d}])\]</span></p><p>若 <span class="math inline">\(\sum_{i = 1} ^ n (f * g)(i)\)</span>可以在 <span class="math inline">\(O(1)\)</span> 之内算出，且 <spanclass="math inline">\(\sum_{d = 2} ^ n g(d) S([\frac{n}{d}])\)</span>可以分块计算，则总时间复杂度为：<span class="math inline">\(O(n ^{\frac{3}{4}})\)</span></p><p>如果线性预处理 <span class="math inline">\(S(1)\)</span> 到 <spanclass="math inline">\(S([n ^ {\frac{2}{3}}])\)</span>的值，则时间复杂度为：<span class="math inline">\(O(n ^{\frac{2}{3}})\)</span> 。</p><p><ahref="https://www.luogu.com.cn/problem/P4213">模板题，求莫比乌斯函数和欧拉函数的前缀和</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> Solution &#123;<br><br>    <span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">2000000</span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mu</span><span class="hljs-params">(MAX_N + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::vector&lt;i64&gt; <span class="hljs-title">phi</span><span class="hljs-params">(MAX_N + <span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 预处理</span><br>        std::vector&lt;<span class="hljs-type">int</span>&gt; pri;<br>        <span class="hljs-function">std::vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">notPrime</span><span class="hljs-params">(MAX_N + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        mu[<span class="hljs-number">1</span>] = phi[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= MAX_N; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>                pri.<span class="hljs-built_in">push_back</span>(i);<br>                mu[i] = <span class="hljs-number">-1</span>;<br>                phi[i] = i - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : pri) &#123;<br>                <span class="hljs-keyword">if</span> (i * p &gt; MAX_N) <span class="hljs-keyword">break</span>;<br>                notPrime[i * p] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (i % p == <span class="hljs-number">0</span>) &#123;<br>                    mu[i * p] = <span class="hljs-number">0</span>;<br>                    phi[i * p] = phi[i] * p;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                mu[i * p] = -mu[i];<br>                phi[i * p] = phi[i] * (p - <span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= MAX_N; i++) &#123;<br>            mu[i] += mu[i - <span class="hljs-number">1</span>];<br>            phi[i] += phi[i - <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br><br>    std::unordered_map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; mob_res;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mobius_sum</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (mob_res.<span class="hljs-built_in">find</span>(n) != mob_res.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> mob_res[n];<br>        <span class="hljs-keyword">if</span> (n &lt;= MAX_N) <span class="hljs-keyword">return</span> mu[n];<br>        i64 res = <span class="hljs-number">1</span>;<br>        i64 left = <span class="hljs-number">2</span>, right;<br>        <span class="hljs-keyword">while</span> (left &lt;= n) &#123;<br>            right = n / (n / left);<br>            res -= (right - left + <span class="hljs-number">1</span>) * <span class="hljs-built_in">mobius_sum</span>(n / left);<br>            left = right + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> mob_res[n] = res;<br>    &#125;<br><br>    std::unordered_map&lt;<span class="hljs-type">int</span>, i64&gt; phi_res;<br>    <span class="hljs-function">i64 <span class="hljs-title">phi_sum</span><span class="hljs-params">(i64 n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (phi_res.<span class="hljs-built_in">find</span>(n) != phi_res.<span class="hljs-built_in">end</span>()) <span class="hljs-keyword">return</span> phi_res[n];<br>        <span class="hljs-keyword">if</span> (n &lt;= MAX_N) <span class="hljs-keyword">return</span> phi[n];<br>        i64 res = (i64)n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        i64 left = <span class="hljs-number">2</span>, right;<br>        <span class="hljs-keyword">while</span> (left &lt;= n) &#123;<br>            right = n / (n / left);<br>            res -= (right - left + <span class="hljs-number">1</span>) * <span class="hljs-built_in">phi_sum</span>(n / left);<br>            left = right + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> phi_res[n] = res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> n;<br>        std::cin &gt;&gt; n;<br>        std::cout &lt;&lt; <span class="hljs-built_in">phi_sum</span>(n) &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; <span class="hljs-built_in">mobius_sum</span>(n) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    Solution::<span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) Solution::<span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="莫比乌斯反演">莫比乌斯反演</h3><h4 id="莫比乌斯函数">莫比乌斯函数</h4><p><span class="math display">\[\begin{equation}\mu(n) =\begin{cases}1 &amp; n = 1 \\0 &amp; n \ 存在平方因子 \\(-1) ^ k &amp; n = \prod_{i = 1} ^ k p_i\end{cases}\end{equation}\]</span></p><p><strong>莫比乌斯函数常用性质</strong></p><ul><li><span class="math inline">\(\mu\)</span> 函数为积性函数，若 <spanclass="math inline">\(gcd(x, y) = 1\)</span> ，则有 <spanclass="math inline">\(\mu (xy) = \mu (x) \mu( y)\)</span></li><li><span class="math inline">\(\sum_{d | n} \mu(d) = \epsilon (n) = [n= 1]\)</span></li></ul><p>因为莫比乌斯函数是积性函数，所以可以用线性筛筛选：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> mu[MAX_N];<br><span class="hljs-type">int</span> pri[MAX_N];<br><span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>;<br><span class="hljs-type">bool</span> notPrime[MAX_N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">getMU</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>            pri[tot++] = i;<br>            mu[i] = <span class="hljs-number">-1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; tot &amp;&amp; i * pri[j] &lt;= n; j++) &#123;<br>            notPrime[i * pri[j]] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % pri[j] == <span class="hljs-number">0</span>) &#123;<br>                mu[i * pri[j]] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            mu[i * pri[j]] = -mu[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>莫比乌斯变换</strong></p><p>设 <span class="math inline">\(g(n)\)</span> 和 <spanclass="math inline">\(f(n)\)</span> 是两个数论函数，如果有： <spanclass="math display">\[f(n) = \sum_{d | n} g(d)\]</span> 则有： <span class="math display">\[g(n) = \sum_{d | n} \mu (d) f(\frac{n}{d})\]</span> 这里称 <span class="math inline">\(f(n)\)</span> 为 <spanclass="math inline">\(g(n)\)</span> 的莫比乌斯变换，<spanclass="math inline">\(g(n)\)</span> 为 <spanclass="math inline">\(f(n)\)</span> 的莫比乌斯反演。</p><h4 id="反演结论">反演结论</h4><p>根据以上结论，我们不难得到 <span class="math inline">\([gcd(i, j) =1] = \sum_{d | gcd(i, j)} \mu(d)\)</span>（事实上就是将 <spanclass="math inline">\(\sum_{d | n} \mu(d) = \epsilon (n) = [n =1]\)</span> 中的 <span class="math inline">\(n\)</span> 替换为了 <spanclass="math inline">\(gcd(i,j)\)</span>），这种替换有时候可以给我们带来意想不到的便利。</p><p>接下来我们给出一个例题：<ahref="https://www.luogu.com.cn/problem/P2522">题目链接</a></p><p>题意大概就是说有 <span class="math inline">\(n\)</span>组查询，每组查询有 5 个数字 <span class="math inline">\(a, b, c, d\ (a\leq b, c \leq d)\)</span> 以及 <spanclass="math inline">\(k\)</span>，然后求解 <spanclass="math inline">\(\sum_{x = a} ^ b \sum_{y = c} ^ d [gcd(x, y) =k]\)</span> 。</p><p>不妨设 <span class="math inline">\(f(m, n) = \sum_{x = 1} ^ m \sum_{y= 1} ^ n[gcd(x, y) = k]\)</span> ，根据容斥原理，题目的答案为： <spanclass="math display">\[f(b, d) - f(b, c - 1) - f(a - 1, d) - f(a - 1, c - 1)\]</span> 因此我们只需要求解 <span class="math inline">\(f(m,n)\)</span> 的表达式即可。 <span class="math display">\[\begin{array}{}f(m, n) = \sum_{x = 1} ^ m \sum_{y = 1} ^ n[gcd(x, y) = k] \\= \sum_{x = 1} ^ {[\frac{m}{k}]} \sum_{y = 1} ^ {[\frac{n}{k}]} [gcd(x,y) = 1] \\\end{array}\]</span> 接下来使用莫比乌斯反演，上式可化简为： <spanclass="math display">\[\sum_{x = 1} ^ {[\frac{m}{k}]} \sum_{y = 1} ^ {[\frac{n}{k}]} \sum_{d |gcd(x, y)} \mu(d) = \sum_{x = 1} ^ {[\frac{m}{k}]} \sum_{y = 1} ^{[\frac{n}{k}]} \sum_{d | x \land d | y} \mu(d)\]</span> 交换求和顺序，先枚举 <span class="math inline">\(d\)</span>，原式可进一步化简，最终可得： <span class="math display">\[f(m, n) = \sum_{d = 1} ^ {min\{[\frac{m}{k}], [\frac{n}{k}]\}} \mu(d)[\frac{m}{kd}][\frac{n}{kd}]\]</span> 接下来使用分块除法即可在 <spanclass="math inline">\(O(\sqrt{min\{[\frac{m}{k}],[\frac{n}{k}]\}}\)</span> 的时间复杂度内求解答案。</p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">5e4</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> mu[MAX_N];<br><span class="hljs-type">bool</span> notPrime[MAX_N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    mu[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; pri;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; MAX_N; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>            mu[i] = <span class="hljs-number">-1</span>;<br>            pri.<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : pri) &#123;<br>            <span class="hljs-keyword">if</span> (i * p &gt;= MAX_N) <span class="hljs-keyword">break</span>;<br>            notPrime[i * p] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % p == <span class="hljs-number">0</span>) &#123;<br>                mu[i * p] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            mu[i * p] = -mu[i];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX_N; i++) mu[i] += mu[i - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">solve</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r, b = std::<span class="hljs-built_in">min</span>(m, n); l &lt;= b; l = r + <span class="hljs-number">1</span>) &#123;<br>        r = std::<span class="hljs-built_in">min</span>(m / (m / l), n / (n / l));<br>        res += (mu[r] - mu[l - <span class="hljs-number">1</span>]) * (m / l) * (n / l);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-type">int</span> a, b, c, d, k;<br>        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d &gt;&gt; k;<br>        <span class="hljs-type">int</span> res = <span class="hljs-built_in">solve</span>(b / k, d / k) - <span class="hljs-built_in">solve</span>(b / k, (c - <span class="hljs-number">1</span>) / k) - <span class="hljs-built_in">solve</span>((a - <span class="hljs-number">1</span>) / k, d / k) + <span class="hljs-built_in">solve</span>((a - <span class="hljs-number">1</span>) / k, (c - <span class="hljs-number">1</span>) / k);<br>        std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>杜教筛</tag>
      
      <tag>莫比乌斯反演</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim 编辑器入门</title>
    <link href="/2023/08/16/Vim%20%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/"/>
    <url>/2023/08/16/Vim%20%E7%BC%96%E8%BE%91%E5%99%A8%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="简介">简介</h4><p><strong>Vim（ViIMproved）</strong>是一款强大、高度可定制且广泛使用的文本编辑器。它是Unix 系统下的一个经典编辑器，也可以在其他操作系统上运行，包括Linux、macOS 和 Windows。Vim 是从 Vi编辑器发展而来的，但在功能和特性上进行了扩展和改进，成为了一个强大的文本编辑工具。尽管Vim具有很多功能，但它的学习曲线可能较陡峭，需要一些时间来适应和掌握。许多程序员选择学习和使用Vim，因为一旦熟练掌握，它可以成为一个高效的文本编辑工具，适用于各种编程和文本处理任务。</p><h4 id="基本使用">基本使用</h4><p>Vim编辑器在使用的过程中有三种模式，即正常模式、编辑模式以及命令行模式，以下将一一介绍。</p><h5 id="使用-vim-编辑器打开或者新建文本文件">使用 Vim编辑器打开或者新建文本文件</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim filename<br></code></pre></td></tr></table></figure><p>使用 <code>vim</code> 指令后会进入<em>正常模式</em>，此刻还不能编辑文本，只能预览文本。</p><h5 id="进入编辑模式">进入编辑模式</h5><p>此刻按下 <code>i</code> 键即可进入编辑模式。</p><p>此时终端下方会显示 <code>-- INSERT --</code> ：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-15-170511.png" style="zoom:80%;" /></p><p>如何退出编辑模式进入正常模式呢？</p><p>直接按下 esc 键即可。</p><h5 id="进入命令行模式">进入命令行模式</h5><p>在正常模式下，直接输入冒号 <code>:</code>，则可进入命令行模式，此时可在底部输入命令：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-15-171008.png" style="zoom:80%;" /></p><p>一些常用命令：</p><ul><li><p>保存退出：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">:wq<br></code></pre></td></tr></table></figure></p></li><li><p>不保存退出：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">:q!<br></code></pre></td></tr></table></figure></p></li></ul><h4 id="导航与编辑">导航与编辑</h4><h5 id="kjhl-导航"><code>KJHL</code> 导航</h5><p>在正常模式下，光标的移动由 4 个键组成，即：</p><ul><li><code>H</code> ：左</li><li><code>L</code> ：右</li><li><code>K</code> ：上</li><li><code>J</code> ：下</li></ul><h5 id="不同编辑方式">不同编辑方式</h5><p>在将光标移动到合适的位置我们就可以开始编辑了，此时有几种选择：</p><ul><li><code>I</code> ：如果键入 <code>I</code>，表示插入，在光标的左边添加文本。</li><li><code>A</code> ：如果键入 <code>A</code>，表示追加，在光标的右边添加文本。</li></ul><blockquote><p>如果要在最前面添加文本，输入 Shift + <code>I</code>，同理，若要在文本最后面添加文本，输入 Shift + <code>A</code> 。</p></blockquote><ul><li><code>O</code> ：如果键入 <code>O</code>，则向下另起一行，进入编辑模式。</li></ul><blockquote><p>键入 <code>shift</code> + <code>O</code> ，则增加上一行。</p></blockquote><h5 id="行数导航">行数导航</h5><p>如果想要让 Vim 编辑器显示文本行数，则需要我们自行在<code>.vimrc</code> 文本中加入配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs .vimrc">set number<br></code></pre></td></tr></table></figure><p>如何查找到 <code>.vimrc</code> 文本的位置呢？使用<code>vim --version</code> 的指令即可显示其位置。</p><blockquote><p><code>.vimrc</code> 文本用于设置许多 Vim编辑器的配置，后续还会经常提及。</p></blockquote><p>如果想让 Vim 编辑器显示相对行数，则需要在 <code>.vimrc</code>中添加配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs .vimrc">set relativenumber<br></code></pre></td></tr></table></figure><p>行的跳转：</p><ul><li><p>将光标跳转至第一行：</p><p>键入 Shift + <code>G</code> 。</p></li><li><p>将光标跳转至最后一行：</p><p>连续 2 次键入 <code>G</code> 。</p></li><li><p>向上跳转 n 行：</p><p>键入 数字 n + <code>K</code> 。</p></li><li><p>向下跳转 n 行：</p><p>键入 数字 n + <code>J</code> 。</p></li></ul><h5 id="复制行与删除行">复制行与删除行</h5><ul><li><p>连续两次键入 <code>Y</code> ，即可复制当前行，然后再键入<code>P</code> ，就可以将复制的文本进行粘贴。</p></li><li><p>如若想删除行，可以连续两次键入 <code>D</code>，则可将该行删除。</p></li></ul><h5 id="重复最近操作和撤销操作">重复最近操作和撤销操作</h5><ul><li>键入 <code>.</code> ，则可重复最近一次的操作。</li><li>键入 <code>U</code> ，则可撤销最近一次操作。</li><li>键入 <code>crtl</code> + <code>r</code> ，恢复前一次操作。</li></ul><h5 id="修改单词">修改单词</h5><ul><li>键入 <code>W</code> ，光标跳转到下一个字母的首部。</li><li>键入 <code>E</code> ，光标跳转到下一个字母的尾部。</li><li>键入 <code>B</code> ，光标移动到上一个字母的首部。</li><li>键入 <code>D</code> + <code>W</code> ，可删除单词。</li><li>键入 <code>C</code> + <code>W</code> ，可改变单词。</li><li>键入 <code>Y</code> + <code>W</code> ，可复制单词。</li></ul><h5 id="删除括号内的内容">删除括号内的内容</h5><ul><li>键入 <code>C</code> + <code>I</code> + 括号（<code>&#123;</code>、<code>[</code> 、<code>(</code>）即可删除光标所在括号的内容。</li></ul><h4 id="搜索与替换">搜索与替换</h4><h5 id="搜索">搜索</h5><p>进入命令行模式，输入 <code>/</code> +变量名或函数名，即可将光标跳转到该函数。</p><center><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-16-165637.png" style="zoom:50%;" /><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-16-165829.png" style="zoom:50%;" /></center><h5 id="命名全局替换">命名全局替换</h5><p>在命令行模式下输入 <code>%s/旧命名/新命名/g</code>，可将所有旧命名全局替换。</p><h5 id="可视化块和可视化行">可视化块和可视化行</h5><ul><li><p>键入 <code>ctrl</code> + <code>V</code>可进入可视化块，可自己选择代码块进行相应的操作。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-16-165120.png" style="zoom:80%;" /></p></li><li><p>键入 <code>shift</code> + <code>V</code>可进入可视化行，可自己选择代码行进行相应的操作。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-16-165213.png" style="zoom:80%;" /></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假集训 杭电多校 Round 6</title>
    <link href="/2023/08/03/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%206/"/>
    <url>/2023/08/03/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%206/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://acm.hdu.edu.cn/contest/problems?cid=1099">比赛链接</a></p><p><a href="https://vjudge.net/article/3854">补题链接</a></p><hr /><h4 id="count">「1004」 Count</h4><p>签到题，<span class="math inline">\(n \not= k\)</span> 时答案为 <spanclass="math inline">\(m ^ {n - k}\)</span> ，<spanclass="math inline">\(n = k\)</span> 时答案为 <spanclass="math inline">\(m ^ n\)</span>。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(logn)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    i64 n, m, k;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    i64 t = n - k ? n - k : n;<br>    i64 res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (t) &#123;<br>        <span class="hljs-keyword">if</span> (t &amp; <span class="hljs-number">1</span>) res = (<span class="hljs-type">__int128_t</span>)res * m % mod;<br>        m = (<span class="hljs-type">__int128_t</span>)m * m % mod;<br>        t &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pair-sum-and-perfect-square">「1002」 Pair Sum and PerfectSquare</h4><p>先枚举所有满足题意的 <span class="math inline">\(i、j\)</span> 使得<span class="math inline">\(p_i + p_j\)</span> 为完全平方数，由于 <spanclass="math inline">\(P\)</span> 在这里是 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(n\)</span> 的排列，所以合法的 <spanclass="math inline">\((i, j)\)</span> 只有 <spanclass="math inline">\(O(n ^ {\frac{3}{2}})\)</span>种可能，接下来就是一个二维数点的问题了，即对于每次查询的区间 <spanclass="math inline">\((L, R)\)</span> ，需找到多少点 <spanclass="math inline">\((i, j)\)</span> 落在 <spanclass="math inline">\((L, L)\)</span> 和 <span class="math inline">\((R,R)\)</span> 组成的正方形内。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n ^ {\frac{3}{2}} + q(logq+ logn))\)</span></p><p>空间复杂度：<span class="math inline">\(O(n + k)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_Q = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">int</span> per[MAX_N];<br><span class="hljs-type">int</span> id[MAX_N];<br><br><span class="hljs-type">int</span> q;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> id;<br>&#125; query[<span class="hljs-number">4</span> * MAX_Q];<br><span class="hljs-type">int</span> res[<span class="hljs-number">4</span> * MAX_Q];<br><br><span class="hljs-keyword">namespace</span> __BIT &#123;<br>    <span class="hljs-type">int</span> tree[MAX_N];<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">prefix</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (idx) &#123;<br>            res += tree[idx];<br>            idx -= <span class="hljs-built_in">lowbit</span>(idx);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val = <span class="hljs-number">1</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (idx &lt;= n) &#123;<br>            tree[idx] += val;<br>            idx += <span class="hljs-built_in">lowbit</span>(idx);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __BIT;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        std::cin &gt;&gt; per[i];<br>        id[per[i]] = i;<br>    &#125;<br>    std::cin &gt;&gt; q;<br>    <span class="hljs-type">int</span> all = <span class="hljs-number">4</span> * q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, l, r; i &lt; all; i += <span class="hljs-number">4</span>) &#123;<br>        std::cin &gt;&gt; l &gt;&gt; r;<br>        query[i] = &#123;r, r, i&#125;;<br>        query[i + <span class="hljs-number">1</span>] = &#123;l - <span class="hljs-number">1</span>, r, i + <span class="hljs-number">1</span>&#125;;<br>        query[i + <span class="hljs-number">2</span>] = &#123;r, l - <span class="hljs-number">1</span>, i + <span class="hljs-number">2</span>&#125;;<br>        query[i + <span class="hljs-number">3</span>] = &#123;l - <span class="hljs-number">1</span>, l - <span class="hljs-number">1</span>, i + <span class="hljs-number">3</span>&#125;;<br>    &#125;<br>    std::<span class="hljs-built_in">sort</span>(query, query + all, [](<span class="hljs-type">const</span> Query&amp; q1, <span class="hljs-type">const</span> Query&amp; q2) &#123;<br>        <span class="hljs-keyword">return</span> q1.x &lt; q2.x;<br>    &#125;);<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">2</span>; ; t++) &#123;<br>            <span class="hljs-type">int</span> pf = t * t - per[i];<br>            <span class="hljs-keyword">if</span> (pf &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (pf &gt;= per[i]) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">while</span> (j &lt; all &amp;&amp; i &gt; query[j].x) &#123;<br>                <span class="hljs-comment">// 当前区间已经统计完成</span><br>                res[query[j].id] = <span class="hljs-built_in">prefix</span>(query[j].y);<br>                j++;<br>            &#125;<br>            <span class="hljs-built_in">add</span>(id[pf]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (j &lt; all) &#123;<br>        res[query[j].id] = <span class="hljs-built_in">prefix</span>(query[j].y);<br>        j++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; all; i += <span class="hljs-number">4</span>) &#123;<br>        std::cout &lt;&lt; res[i] - res[i + <span class="hljs-number">1</span>] - res[i + <span class="hljs-number">2</span>] + res[i + <span class="hljs-number">3</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="perfect-square-number">「1006」 Perfect square number</h4><p>使用一个数组动态维护所有跨越 <span class="math inline">\(a_i\)</span>的序列中增加 <span class="math inline">\(k \ (-300 \leq k \leq300)\)</span> 后序列和为完全平方数的个数。当迭代次数从 <spanclass="math inline">\(i - 1\)</span> 转移到 <spanclass="math inline">\(i\)</span> 时，我们只需要考虑更新以 <spanclass="math inline">\(a_i\)</span> 开头的序列，同时减去以 <spanclass="math inline">\(a_{i - 1}\)</span>结尾的序列中计算过的冗余即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n ^ 2\sqrt{k})\)</span></p><p>空间复杂度：<span class="math inline">\(O(n + k)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">300</span>, MAX_K = <span class="hljs-number">300</span>;<br><br><span class="hljs-type">int</span> a[MAX_N + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> s[MAX_N + <span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> s[r] - s[l - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-type">int</span> lp[MAX_N + <span class="hljs-number">5</span>], rp[MAX_N + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> plus[<span class="hljs-number">2</span> * MAX_K + <span class="hljs-number">5</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span>&amp; <span class="hljs-title">get_plus</span><span class="hljs-params">(<span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 记录跨越当前 a[i] 的序列中有多少个序列增加 k 后为完全平方数</span><br>    <span class="hljs-keyword">return</span> plus[k + MAX_K];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ub</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> t = std::<span class="hljs-built_in">sqrt</span>(x);<br>    <span class="hljs-keyword">while</span> (t * t &lt; x) t++;<br><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> </span>&#123;<br>    <span class="hljs-type">int</span> b = <span class="hljs-built_in">ub</span>(s);<br>    <span class="hljs-keyword">return</span> b * b == s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(plus, <span class="hljs-number">0x00</span>, <span class="hljs-built_in">sizeof</span>(plus));<br>    <span class="hljs-built_in">memset</span>(lp, <span class="hljs-number">0x00</span>, <span class="hljs-built_in">sizeof</span>(lp));<br>    <span class="hljs-built_in">memset</span>(rp, <span class="hljs-number">0x00</span>, <span class="hljs-built_in">sizeof</span>(rp));<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) std::cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) s[i] = s[i - <span class="hljs-number">1</span>] + a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        lp[i] += lp[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(<span class="hljs-built_in">sum</span>(j, i))) lp[i]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; i--) &#123;<br>        rp[i] += rp[i + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(<span class="hljs-built_in">sum</span>(i, j))) rp[i]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= n; j++) &#123;<br>            <span class="hljs-type">int</span> ds = <span class="hljs-built_in">sum</span>(i, j);<br>            <span class="hljs-type">int</span> b = <span class="hljs-built_in">ub</span>(ds);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ib = b; ib * ib - ds &lt;= MAX_K; ib++) &#123;<br>                <span class="hljs-built_in">get_plus</span>(ib * ib - ds)++;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ib = b - <span class="hljs-number">1</span>; ib &gt; <span class="hljs-number">0</span> &amp;&amp; ib * ib - ds &gt;= -MAX_K; ib--) &#123;<br>                <span class="hljs-built_in">get_plus</span>(ib * ib - ds)++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">1</span>; j--) &#123;<br>            <span class="hljs-type">int</span> ds = <span class="hljs-built_in">sum</span>(j, i - <span class="hljs-number">1</span>);<br>            <span class="hljs-type">int</span> b = <span class="hljs-built_in">ub</span>(ds);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ib = b; ib * ib - ds &lt;= MAX_K; ib++) &#123;<br>                <span class="hljs-built_in">get_plus</span>(ib * ib - ds)--;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> ib = b - <span class="hljs-number">1</span>; ib &gt; <span class="hljs-number">0</span> &amp;&amp; ib * ib - ds &gt;= -MAX_K; ib--) &#123;<br>                <span class="hljs-built_in">get_plus</span>(ib * ib - ds)--;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = -a[i] + <span class="hljs-number">1</span>; k &lt;= MAX_K - a[i]; k++) p = std::<span class="hljs-built_in">max</span>(p, <span class="hljs-built_in">get_plus</span>(k));<br>        res = std::<span class="hljs-built_in">max</span>(res, p + lp[i - <span class="hljs-number">1</span>] + rp[i + <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="vector">「1003」 Vector</h4><p>若三个向量线性无关，则只需要判断 <spanclass="math inline">\(A_4\)</span> 是否落在向量 <spanclass="math inline">\(A_1\)</span> ，<spanclass="math inline">\(A_2\)</span> ，<spanclass="math inline">\(A_3\)</span>的张集里面即可（由于相关系数只能是非负数，所以这里的张集是一个无穷大的三棱锥）；若三个向量线性相关，则其张集一定可以在一个平面内表示，此时用类似的方式判断<span class="math inline">\(A_4\)</span> 是否属于该集合即可。</p><p>这里要注意零向量的情况。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(1)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> __3dvector &#123;<br>    <span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Vec</span> &#123;<br>        i64 x, y, z;<br>        <span class="hljs-built_in">Vec</span>(i64 _x = <span class="hljs-number">0</span>, i64 _y = <span class="hljs-number">0</span>, i64 _z = <span class="hljs-number">0</span>): <span class="hljs-built_in">x</span>(_x), <span class="hljs-built_in">y</span>(_y), <span class="hljs-built_in">z</span>(_z) &#123;&#125;<br>    &#125;;<br>    <span class="hljs-function">Vec <span class="hljs-title">zero</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(<span class="hljs-type">const</span> Vec&amp; v1, <span class="hljs-type">const</span> Vec&amp; v2) &#123;<br>        <span class="hljs-keyword">return</span> v1.x == v2.x &amp;&amp; v1.y == v2.y &amp;&amp; v1.z == v2.z;<br>    &#125;<br>    <span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(<span class="hljs-type">const</span> Vec&amp; v1, <span class="hljs-type">const</span> Vec&amp; v2) &#123;<br>        <span class="hljs-keyword">return</span> v1.x != v2.x || v1.y != v2.y || v1.z != v2.z;<br>    &#125;<br>    Vec <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Vec&amp; v1, <span class="hljs-type">const</span> Vec&amp; v2) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vec</span>(v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);<br>    &#125;<br>    <span class="hljs-function">i64 <span class="hljs-title">dot</span><span class="hljs-params">(<span class="hljs-type">const</span> Vec&amp; v1, <span class="hljs-type">const</span> Vec&amp; v2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;<br>    &#125;<br>    <span class="hljs-function">Vec <span class="hljs-title">cross</span><span class="hljs-params">(<span class="hljs-type">const</span> Vec&amp; v1, <span class="hljs-type">const</span> Vec&amp; v2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vec</span>(<br>            v1.y * v2.z - v1.z * v2.y,<br>            - v1.x * v2.z + v1.z * v2.x,<br>            v1.x * v2.y - v1.y * v2.x<br>        );<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __3dvector;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">sgn</span><span class="hljs-params">(i64 x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> (x &gt; <span class="hljs-number">0</span>) - (x &lt; <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">judge</span><span class="hljs-params">(<span class="hljs-type">const</span> Vec&amp; v1, <span class="hljs-type">const</span> Vec&amp; v2)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sgn</span>(v1.x) * <span class="hljs-built_in">sgn</span>(v2.x) &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">sgn</span>(v1.y) * <span class="hljs-built_in">sgn</span>(v2.y) &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">sgn</span>(v1.z) * <span class="hljs-built_in">sgn</span>(v2.z) &gt;= <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    Vec v[<span class="hljs-number">4</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) std::cin &gt;&gt; v[i].x &gt;&gt; v[i].y &gt;&gt; v[i].z;<br>    i64 x1 = v[<span class="hljs-number">0</span>].x, x2 = v[<span class="hljs-number">1</span>].x, x3 = v[<span class="hljs-number">2</span>].x;<br>    i64 y1 = v[<span class="hljs-number">0</span>].y, y2 = v[<span class="hljs-number">1</span>].y, y3 = v[<span class="hljs-number">2</span>].y;<br>    i64 z1 = v[<span class="hljs-number">0</span>].z, z2 = v[<span class="hljs-number">1</span>].z, z3 = v[<span class="hljs-number">2</span>].z;<br>    <br>    i64 det = x1 * y2 * z3 + x2 * y3 * z1 + x3 * y1 * z2 - x3 * y2 * z1 - x2 * y1 * z3 - x1 * y3 * z2; <span class="hljs-comment">// 计算行列式</span><br>    <span class="hljs-keyword">if</span> (det) &#123;<br>        Vec cr1 = <span class="hljs-built_in">cross</span>(v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]), cr2 = <span class="hljs-built_in">cross</span>(v[<span class="hljs-number">1</span>], v[<span class="hljs-number">2</span>]), cr3 = <span class="hljs-built_in">cross</span>(v[<span class="hljs-number">2</span>], v[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 3 个平面的法向量</span><br>        Vec vt = v[<span class="hljs-number">0</span>] + v[<span class="hljs-number">1</span>] + v[<span class="hljs-number">2</span>];<br>        i64 dt1 = <span class="hljs-built_in">dot</span>(vt, cr1);<br>        i64 d1 = <span class="hljs-built_in">dot</span>(v[<span class="hljs-number">3</span>], cr1), d2 = <span class="hljs-built_in">dot</span>(v[<span class="hljs-number">3</span>], cr2), d3 = <span class="hljs-built_in">dot</span>(v[<span class="hljs-number">3</span>], cr3);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sgn</span>(d1) * <span class="hljs-built_in">sgn</span>(dt1) &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">sgn</span>(d2) * <span class="hljs-built_in">sgn</span>(dt1) &gt;= <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">sgn</span>(d3) * <span class="hljs-built_in">sgn</span>(dt1) &gt;= <span class="hljs-number">0</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// rank &lt;= 2</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; <span class="hljs-number">3</span>; j++) &#123;<br>                Vec cr = <span class="hljs-built_in">cross</span>(v[i], v[j]);<br>                <span class="hljs-keyword">if</span> (cr == zero) &#123;<br>                    <span class="hljs-comment">// v[i] 与 v[j] 平行</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">cross</span>(v[<span class="hljs-number">3</span>], v[i]) == zero &amp;&amp; <span class="hljs-built_in">cross</span>(v[<span class="hljs-number">3</span>], v[j]) == zero &amp;&amp; (v[i] != zero &amp;&amp; <span class="hljs-built_in">judge</span>(v[<span class="hljs-number">3</span>], v[i]) || v[j] != zero &amp;&amp; <span class="hljs-built_in">judge</span>(v[<span class="hljs-number">3</span>], v[j]))) &#123;<br>                        std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v[i] == zero &amp;&amp; v[j] == zero) &#123;<br>                        <span class="hljs-keyword">if</span> (v[<span class="hljs-number">3</span>] == zero) &#123;<br>                            std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// v[i] 与 v[j] 不平行</span><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">dot</span>(v[<span class="hljs-number">3</span>], cr) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 则 v[3] 必须与两个向量共面</span><br>                        Vec cri = <span class="hljs-built_in">cross</span>(v[<span class="hljs-number">3</span>], v[i]), crj = <span class="hljs-built_in">cross</span>(v[<span class="hljs-number">3</span>], v[j]);<br>                        Vec vt = v[i] + v[j];<br>                        Vec crit = <span class="hljs-built_in">cross</span>(vt, v[i]), crjt = <span class="hljs-built_in">cross</span>(vt, v[j]);<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">judge</span>(cri, crit) &amp;&amp; <span class="hljs-built_in">judge</span>(crj, crjt)) &#123;<br>                            std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>                            <span class="hljs-keyword">return</span>;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杭电多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假集训 杭电多校 Round 5</title>
    <link href="/2023/08/01/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%205/"/>
    <url>/2023/08/01/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%205/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://acm.hdu.edu.cn/contest/problems?cid=1098">题目链接</a></p><p><a href="https://vjudge.net/article/3854">补题链接</a></p><hr /><h4 id="typhoon">「1001」 Typhoon</h4><p>签到题，遍历每条线段到每个点的最小距离即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(mn)\)</span></p><p>空间复杂度：<span class="math inline">\(O(m)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">double</span> x, y;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">dist2</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p1, <span class="hljs-type">const</span> Point&amp; p2)</span> </span>&#123;<br>    <span class="hljs-type">double</span> dx = (p1.x - p2.x);<br>    <span class="hljs-type">double</span> dy = (p1.y - p2.y);<br><br>    <span class="hljs-keyword">return</span> dx * dx + dy * dy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">dist2line</span><span class="hljs-params">(<span class="hljs-type">const</span> Point&amp; p0, <span class="hljs-type">const</span> Point&amp; p1, <span class="hljs-type">const</span> Point&amp; p2)</span> </span>&#123;<br>    <span class="hljs-type">double</span> vx = p2.x - p1.x, vy = p2.y - p1.y;<br>    <span class="hljs-type">double</span> d1 = vx * (p1.x - p0.x) + vy * (p1.y - p0.y);<br>    <span class="hljs-type">double</span> d2 = vx * (p2.x - p0.x) + vy * (p2.y - p0.y);<br><br>    <span class="hljs-keyword">if</span> (d1 * d2 &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">double</span> f1 = (p2.x - p1.x) * (p0.y - p1.y) - (p2.y - p1.y) * (p0.x - p1.x);<br>        <span class="hljs-type">double</span> f2 = (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);<br><br>        <span class="hljs-keyword">return</span> f1 * f1 / f2;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">min</span>(<span class="hljs-built_in">dist2</span>(p0, p1), <span class="hljs-built_in">dist2</span>(p0, p2));<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 10005</span><br><br>Point pos[MAX_N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> m, n;<br>    std::cin &gt;&gt; m &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        std::cin &gt;&gt; pos[i].x &gt;&gt; pos[i].y;<br>    &#125;<br>    Point p0; <span class="hljs-comment">// 庇护所</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; p0.x &gt;&gt; p0.y;<br>        <span class="hljs-type">double</span> res = INFINITY;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; m; i++) &#123;<br>            res = std::<span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">dist2line</span>(p0, pos[i - <span class="hljs-number">1</span>], pos[i]));<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%.4lf\n&quot;</span>, std::<span class="hljs-built_in">sqrt</span>(res));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="gcd-magic">「1002」 GCD Magic</h4><p>首先，显然有 <span class="math inline">\(gcd(2 ^ i - 1, 2 ^ j -1)\)</span> = <span class="math inline">\(2 ^ {gcd(i, j)} - 1\)</span>，所以原表达式只与 <span class="math inline">\(gcd(i, j)\)</span>有关，所以我们只用枚举全部 <span class="math inline">\(i\)</span> 和<span class="math inline">\(j\)</span> 的最大公约数的数量即可。</p><p>对于 <span class="math inline">\(i、j\)</span> 满足 <spanclass="math inline">\(1 \leq i、j \leq n\)</span> 而言，满足 <spanclass="math inline">\(gcd(i, j) = t\)</span> 的数量为： <spanclass="math display">\[\begin{array}{}\sum_{i = 1} ^ n \sum_{j = 1} ^ n [gcd(i, j) = t] \\= \sum_{i = 1} ^ {[\frac{n}{t}]} \sum_{j = 1} ^ {[\frac{n}{t}]} [gcd(i,j) = 1] \\= \sum_{i = 1} ^ {[\frac{n}{t}]} \sum_{j = 1} ^ {[\frac{n}{t}]} \sum_{d| gcd(i, j)} \mu(d) \\= \sum_{d = 1} ^ {[\frac{n}{t}]} \mu(d) \sum_{i = 1} ^ {[\frac{n}{t}]}\sum_{j = 1} ^ {[\frac{n}{t}]} [d | gcd(i, j)] \\= \sum_{d = 1} ^ {[\frac{n}{t}]} \mu(d) [\frac{n}{td}] ^ 2\end{array}\]</span> 要计算的表达式可化为 <span class="math inline">\(f(t) = (2 ^ t- 1) ^ k\)</span> ，因此最终要求的表达式如下所示： <spanclass="math display">\[\sum_{t = 1} ^ n f(t) \sum_{d = 1} ^ {[\frac{n}{t}]} \mu(d)[\frac{n}{td}] ^ 2\]</span> 令 <span class="math inline">\(T = dt\)</span>，<strong>交换求和顺序</strong>，先枚举 <spanclass="math inline">\(T\)</span> ，上式可转化为： <spanclass="math display">\[\sum_{T = 1} ^ n [\frac{n}{T}] ^ 2 \sum_{d | T} f(d) \mu(\frac{T}{d})\]</span> 由于题目中的 <span class="math inline">\(n\)</span>很大，所以这里考虑使用杜教筛来计算 <span class="math inline">\(\sum_{d |T} f(d)\mu(\frac{T}{d})\)</span>的前缀和，然后使用分块除法来快速求出上式的值。</p><p>考虑狄利克雷卷积，<span class="math inline">\(f * \mu * 1 = f *\epsilon = f(T)\)</span> ，设 <span class="math inline">\(S(n) = \sum_{T= 1} ^ n \sum_{d | T} f(d) \mu(\frac{T}{d})\)</span> 则有： <spanclass="math display">\[S(n) = \sum_{T = 1} ^ n f(T) - \sum_{d = 2} ^ n S([\frac{n}{d}])\]</span></p><p><span class="math display">\[f(T) = (2 ^ T - 1) ^ K = \sum_{i = 0} ^ K C_{K} ^ i 2 ^ {Ti} (-1) ^ {K -i}\]</span></p><p>此处就是一个等比数列求和。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(K \sqrt n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> LL = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> maxs = <span class="hljs-number">1000001</span>, maxk = <span class="hljs-number">10</span>, MOD = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-type">int</span> te, K;<br>LL n;<br><span class="hljs-type">int</span> u[maxs + <span class="hljs-number">5</span>], p[maxs + <span class="hljs-number">5</span>];<br><span class="hljs-type">bool</span> pri[maxs + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> C[maxk + <span class="hljs-number">5</span>][maxk + <span class="hljs-number">5</span>], val[maxk + <span class="hljs-number">5</span>];<br><span class="hljs-type">int</span> lim, G[maxs + <span class="hljs-number">5</span>];<br>unordered_map&lt;LL, <span class="hljs-type">int</span>&gt; f;<br><span class="hljs-type">int</span> ans;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">ADD</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> x + y &gt;= MOD ? x + y - MOD : x + y; &#125;<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">MUL</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> (LL)x * y % MOD; &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Pow</span><span class="hljs-params">(<span class="hljs-type">int</span> w, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> s;<br><span class="hljs-keyword">for</span> (s = <span class="hljs-number">1</span>; b; b &gt;&gt;= <span class="hljs-number">1</span>, w = <span class="hljs-built_in">MUL</span>(w, w))<br><span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)<br>s = <span class="hljs-built_in">MUL</span>(s, w);<br><span class="hljs-keyword">return</span> s;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Make</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= maxk; i++) &#123;<br>C[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= i; j++)<br>C[i][j] = <span class="hljs-built_in">ADD</span>(C[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>], C[i - <span class="hljs-number">1</span>][j]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= maxk; i++)<br>val[i] = <span class="hljs-built_in">MUL</span>(<span class="hljs-number">1</span> &lt;&lt; i, <span class="hljs-built_in">Pow</span>((<span class="hljs-number">1</span> &lt;&lt; i) - <span class="hljs-number">1</span>, MOD - <span class="hljs-number">2</span>));<br>u[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= maxs; i++) &#123;<br><span class="hljs-keyword">if</span> (!pri[i])<br>p[++p[<span class="hljs-number">0</span>]] = i, u[i] = MOD - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>, t; j &lt;= p[<span class="hljs-number">0</span>] &amp;&amp; (t = i * p[j]) &lt;= maxs; j++) &#123;<br>pri[t] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (i % p[j])<br>u[t] = (MOD - u[i]) % MOD;<br><span class="hljs-keyword">else</span> &#123;<br>u[t] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SumF</span><span class="hljs-params">(LL n)</span> </span>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-built_in">MUL</span>(K &amp; <span class="hljs-number">1</span> ? MOD - <span class="hljs-number">1</span> : <span class="hljs-number">1</span>, n % MOD);<br><span class="hljs-type">int</span> BA = <span class="hljs-built_in">Pow</span>(<span class="hljs-number">2</span>, n % (MOD - <span class="hljs-number">1</span>)), pw = BA;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= K; j++) &#123;<br><span class="hljs-type">int</span> now = <span class="hljs-built_in">MUL</span>(C[K][j], K - j &amp; <span class="hljs-number">1</span> ? MOD - <span class="hljs-number">1</span> : <span class="hljs-number">1</span>);<br>now = <span class="hljs-built_in">MUL</span>(now, <span class="hljs-built_in">MUL</span>(val[j], <span class="hljs-built_in">ADD</span>(pw, MOD - <span class="hljs-number">1</span>)));<br>ans = <span class="hljs-built_in">ADD</span>(ans, now);<br>pw = <span class="hljs-built_in">MUL</span>(pw, BA);<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sum</span><span class="hljs-params">(LL n)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (n &lt;= lim)<br><span class="hljs-keyword">return</span> G[n];<br><span class="hljs-keyword">if</span> (f.<span class="hljs-built_in">count</span>(n))<br><span class="hljs-keyword">return</span> f[n];<br><span class="hljs-type">int</span> ans = <span class="hljs-built_in">SumF</span>(n);<br><span class="hljs-keyword">for</span> (LL l = <span class="hljs-number">2</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>r = n / (n / l);<br>ans = <span class="hljs-built_in">ADD</span>(ans, MOD - <span class="hljs-built_in">MUL</span>(<span class="hljs-built_in">Sum</span>(n / l), (r - l + <span class="hljs-number">1</span>) % MOD));<br>&#125;<br><span class="hljs-keyword">return</span> f[n] = ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">Make</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;te); te; te--) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld%d&quot;</span>, &amp;n, &amp;K);<br>lim = <span class="hljs-built_in">pow</span>(n, <span class="hljs-number">2.0</span> / <span class="hljs-number">3</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lim; i++)<br>G[i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, pw = <span class="hljs-number">2</span>; i &lt;= lim; i++, pw = <span class="hljs-built_in">MUL</span>(pw, <span class="hljs-number">2</span>)) &#123;<br><span class="hljs-type">int</span> F = <span class="hljs-built_in">Pow</span>(pw - <span class="hljs-number">1</span>, K);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i, k = <span class="hljs-number">1</span>; j &lt;= lim; j += i, k++)<br>G[j] = <span class="hljs-built_in">ADD</span>(G[j], <span class="hljs-built_in">MUL</span>(u[k], F));<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= lim; i++)<br>G[i] = <span class="hljs-built_in">ADD</span>(G[i], G[i - <span class="hljs-number">1</span>]);<br>f.<span class="hljs-built_in">clear</span>();<br>ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (LL l = <span class="hljs-number">1</span>, r; l &lt;= n; l = r + <span class="hljs-number">1</span>) &#123;<br>r = n / (n / l);<br>ans = <span class="hljs-built_in">ADD</span>(ans, <span class="hljs-built_in">MUL</span>(<span class="hljs-built_in">ADD</span>(<span class="hljs-built_in">Sum</span>(r), MOD - <span class="hljs-built_in">Sum</span>(l - <span class="hljs-number">1</span>)), <span class="hljs-built_in">MUL</span>(n / l % MOD, n / l % MOD)));<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杭电多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假集训 Nowcoder 多校 Round 4</title>
    <link href="/2023/07/28/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20Nowcoder%20%E5%A4%9A%E6%A0%A1%20Round%204/"/>
    <url>/2023/07/28/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20Nowcoder%20%E5%A4%9A%E6%A0%A1%20Round%204/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://ac.nowcoder.com/acm/contest/57358#question">比赛链接</a></p><hr /><h4 id="f-election-of-the-king">F 「Election of the King」</h4><p>签到题，每次淘汰的候选人要么是最左的，要么是最右的，因此用两个变量维护两端的索引，逐步向中间移动。</p><p>每一轮选举使用二分查找来得到两人的票数，将得票高的一方淘汰即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><p>每一轮循环也可以只看中间的人来判断谁被淘汰，可以将时间复杂度优化到<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 1000005</span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">struct</span> &#123;<br>    i64 v;<br>    <span class="hljs-type">int</span> idx;<br>&#125; a[MAX_N];<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; a[i].v;<br>        a[i].idx = i;<br>    &#125;<br>    std::<span class="hljs-built_in">sort</span>(a, a + n, [](<span class="hljs-keyword">auto</span>&amp; a1, <span class="hljs-keyword">auto</span>&amp; a2) &#123;<br>        <span class="hljs-keyword">return</span> a1.v &lt; a2.v;<br>    &#125;);<br><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt; right) &#123;<br>        <span class="hljs-type">int</span> l = left, r = right;<br>        <span class="hljs-comment">// 2 * a[l].v &lt;= a[left].v + a[right].v</span><br>        <span class="hljs-comment">// 2 * a[r].v &gt; a[left].v + a[right].v</span><br>        i64 x = a[left].v + a[right].v;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * a[r].v &lt;= x) &#123;<br>            right--;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (r - l &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-number">2</span> * a[mid].v &lt;= x) &#123;<br>                l = mid;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                r = mid;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (right - r + <span class="hljs-number">1</span> &gt; r - left) &#123;<br>            left++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            right--;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; a[left].idx + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="l-we-are-the-lights">L 「We are the Lights」</h4><p>因为后续的操作会覆盖之前的操作，所以从后往前遍历所有操作，操作过的行和列会被锁住且后续无法再修改，同时用两个变量<code>r</code> 、<code>c</code>分别维护未被锁住的行数和列数，若当前操作为 <code>row x on</code> 且<code>x</code> 行未上锁，则当前开灯总数增加 <code>c</code>，<code>r</code> 自减 1，对于其他三种情况，同理分析即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(q)\)</span></p><p>空间复杂度：<span class="math inline">\(O(m + n + q)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 1000005</span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-keyword">struct</span> &#123;<br>    std::string pos;    <br>    <span class="hljs-type">int</span> val;<br>    std::string kind;<br>&#125; op[MAX_NUM];<br><br><span class="hljs-type">bool</span> lockRow[MAX_NUM];<br><span class="hljs-type">bool</span> lockCol[MAX_NUM];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        std::cin &gt;&gt; op[i].pos &gt;&gt; op[i].val &gt;&gt; op[i].kind;<br>    &#125;<br>    <span class="hljs-type">int</span> r = n, c = m; <span class="hljs-comment">// 未被锁住的行列数</span><br>    i64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = q - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (op[i].kind == <span class="hljs-string">&quot;on&quot;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (op[i].pos == <span class="hljs-string">&quot;row&quot;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (lockRow[op[i].val]) <span class="hljs-keyword">continue</span>;<br>                res += c;<br>                r--;<br>                lockRow[op[i].val] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (lockCol[op[i].val]) <span class="hljs-keyword">continue</span>;<br>                res += r;<br>                c--;<br>                lockCol[op[i].val] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (op[i].pos == <span class="hljs-string">&quot;row&quot;</span>) &#123;<br>                <span class="hljs-keyword">if</span> (lockRow[op[i].val]) <span class="hljs-keyword">continue</span>;<br>                r--;<br>                lockRow[op[i].val] = <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (lockCol[op[i].val]) <span class="hljs-keyword">continue</span>;<br>                c--;<br>                lockCol[op[i].val] = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="j-quest-ce-que-cest">J 「Qu'est-ce Que C'est?」</h4><p>假设 <span class="math inline">\(dp[i][s]\)</span> 表示 <spanclass="math inline">\([0, i]\)</span> 序列中最小后缀和为 <spanclass="math inline">\(s\)</span>的合法情况有多少种，可以得到状态转移方程： <span class="math display">\[\begin{equation}dp[i][s] =\begin{cases}\ \sum_{k = s - m} ^ m dp[i - 1][k] &amp; s \geq 0 \\\\\ \sum_{k = - s} ^ m dp[i - 1][k] &amp; s &lt; 0\end{cases}\end{equation}\]</span>根据状态转移方程，我们需要定义一个后缀数组来维护后缀和来优化时间，同时注意到<span class="math inline">\(dp[i]\)</span> 只与 <spanclass="math inline">\(dp[i - 1]\)</span>有关，所以可以使用滚动数组优化空间。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(nm)\)</span></p><p>空间复杂度：<span class="math inline">\(O(m)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_M 5005</span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><br>i64 dp[<span class="hljs-number">2</span>][<span class="hljs-number">2</span> * MAX_M];<br>i64 sum[<span class="hljs-number">2</span>][<span class="hljs-number">2</span> * MAX_M];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = m; s &gt;= -m; s--) &#123;<br>        dp[<span class="hljs-number">0</span>][m + s] = <span class="hljs-number">1</span>;<br>        sum[<span class="hljs-number">0</span>][m + s] = (sum[<span class="hljs-number">0</span>][m + s + <span class="hljs-number">1</span>] + dp[<span class="hljs-number">0</span>][m + s]) % mod;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = m; s &gt;= -m; s--) &#123;<br>            <span class="hljs-keyword">if</span> (s &gt;= <span class="hljs-number">0</span>) &#123;<br>                dp[i &amp; <span class="hljs-number">1</span>][m + s] = sum[(i - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>][m + s - m];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                dp[i &amp; <span class="hljs-number">1</span>][m + s] = sum[(i - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>][m - s];<br>            &#125;<br>            sum[i &amp; <span class="hljs-number">1</span>][m + s] = (sum[i &amp; <span class="hljs-number">1</span>][m + s + <span class="hljs-number">1</span>] + dp[i &amp; <span class="hljs-number">1</span>][m + s]) % mod;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; sum[(n - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="h-merge-the-squares">H 「Merge the squares!」</h4><p>对于任意一个 <span class="math inline">\(n \times n\)</span>的正方形，如果 <span class="math inline">\(n &lt; 8\)</span>，则可以一次性合并，若 <span class="math inline">\(n \geq 8\)</span>，我们考虑如下分割方式：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-29-140001.png" style="zoom:33%;" /></p><p>即将一个正方形分割为两个正方形与两个矩形，两个正方形的边长分别为<span class="math inline">\(j\)</span> 和 <span class="math inline">\(n- j\)</span> ，通过枚举 <span class="math inline">\(j\)</span> ，若两个<span class="math inline">\((n - j) \times j\)</span>的矩形可以分割为不超过 24 个正方形，则总的正方形合并数不超过50。经计算，发现对任意 <span class="math inline">\(n\)</span> 满足 <spanclass="math inline">\(8 \leq n \leq 1000\)</span> 都可以找到合法的 <spanclass="math inline">\(j\)</span> 满足题意。</p><p>我们使用一个数组来维护每一个 <span class="math inline">\(n\)</span>的合法分割方案，然后使用递归来记录答案即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-type">int</span> splitGrid[<span class="hljs-number">1001</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 得到所有可行的分割方案</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">8</span>; i &lt;= <span class="hljs-number">1000</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = (i + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-type">int</span> a = j, b = i - j;<br>            <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span> (b) &#123;<br>                cnt += (a / b);<br>                a %= b;<br>                std::<span class="hljs-built_in">swap</span>(a, b);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt;= <span class="hljs-number">24</span>) &#123;<br>                splitGrid[i] = j;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">assert</span>(splitGrid[i] &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <br>    std::vector&lt;std::array&lt;<span class="hljs-type">int</span>, 3&gt;&gt; ans;<br>    std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; merge = [&amp;merge, &amp;ans](<span class="hljs-type">int</span> x1, <span class="hljs-type">int</span> y1, <span class="hljs-type">int</span> x2, <span class="hljs-type">int</span> y2) -&gt; <span class="hljs-type">void</span> &#123;<br>        <span class="hljs-keyword">if</span> (x2 - x1 == y2 - y1) &#123;<br>            <span class="hljs-type">int</span> len = x2 - x1 + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;<br>            <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">7</span>) &#123;<br>                ans.<span class="hljs-built_in">push_back</span>(&#123;x1, y1, len&#125;);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> k = splitGrid[len];<br>            <span class="hljs-built_in">merge</span>(x1, y1, x1 + k - <span class="hljs-number">1</span>, y1 + k - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">merge</span>(x1 + k, y1 + k, x2, y2);<br>            <span class="hljs-built_in">merge</span>(x1, y1 + k, x1 + k - <span class="hljs-number">1</span>, y2);<br>            <span class="hljs-built_in">merge</span>(x1 + k, y1, x2, y1 + k - <span class="hljs-number">1</span>);<br>            ans.<span class="hljs-built_in">push_back</span>(&#123;x1, y1, len&#125;);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> len1 = x2 - x1 + <span class="hljs-number">1</span>, len2 = y2 - y1 + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (len1 &gt; len2) &#123;<br>                <span class="hljs-built_in">merge</span>(x1, y1, x1 + len2 - <span class="hljs-number">1</span>, y1 + len2 - <span class="hljs-number">1</span>);<br>                x1 += len2;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">merge</span>(x1, y1, x1 + len1 - <span class="hljs-number">1</span>, y1 + len1 - <span class="hljs-number">1</span>);<br>                y1 += len1;<br>            &#125;<br>            <span class="hljs-built_in">merge</span>(x1, y1, x2, y2);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">merge</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, n);<br>    std::cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [x, y, len] : ans) &#123;<br>        std::cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; y &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; len &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-built_in">init</span>();<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nowcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假集训 杭电多校 Round 4</title>
    <link href="/2023/07/28/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%204/"/>
    <url>/2023/07/28/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%204/</url>
    
    <content type="html"><![CDATA[<p><a href="https://vjudge.net/article/3854">补题链接</a></p><hr /><h4 id="guess">「1007」 Guess</h4><p>结论题，证明得当 <span class="math inline">\(n\)</span> 为素数的幂即<span class="math inline">\(n = p ^ c\)</span> 时 <spanclass="math inline">\(S(n) = ln\ \!p\)</span> ，否则 <spanclass="math inline">\(S(n) = 0\)</span> 。</p><p>然后使用 Pollard-Rho 算法进行质因数分解即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n ^{\frac{1}{4}})\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;functional&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-function">i64 <span class="hljs-title">quickPow</span><span class="hljs-params">(i64 x, i64 n, i64 mod)</span> </span>&#123;<br>    i64 res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res = (<span class="hljs-type">__int128_t</span>)res * x % mod;<br>        x = (<span class="hljs-type">__int128_t</span>)x * x % mod;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">millerRabin</span><span class="hljs-params">(i64 n, <span class="hljs-type">int</span> test_times = <span class="hljs-number">8</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span> || n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> n == <span class="hljs-number">2</span>;<br>    i64 u = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!(u &amp; <span class="hljs-number">1</span>)) &#123;<br>        u &gt;&gt;= <span class="hljs-number">1</span>;<br>        t++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; test_times; i++) &#123;<br>        i64 a = std::<span class="hljs-built_in">rand</span>() % (n - <span class="hljs-number">2</span>) + <span class="hljs-number">2</span>;<br>        i64 v = <span class="hljs-built_in">quickPow</span>(a, u, n);<br>        <span class="hljs-keyword">if</span> (v == <span class="hljs-number">1</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> s;<br>        <span class="hljs-keyword">for</span> (s = <span class="hljs-number">0</span>; s &lt; t; s++) &#123;<br>            <span class="hljs-keyword">if</span> (v == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>            v = (<span class="hljs-type">__int128_t</span>)v * v % n;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (s == t) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">gcd</span><span class="hljs-params">(i64 x, i64 y)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> y == <span class="hljs-number">0</span> ? x : <span class="hljs-built_in">gcd</span>(y, x % y);<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">Pollard_Rho</span><span class="hljs-params">(i64 x)</span> </span>&#123;<br>    i64 s = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>;<br>    i64 c = (i64)std::<span class="hljs-built_in">rand</span>() % (x - <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> step = <span class="hljs-number">0</span>, goal = <span class="hljs-number">1</span>;<br>    i64 val = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (goal = <span class="hljs-number">1</span>; ; goal &lt;&lt;= <span class="hljs-number">1</span>, s = t, val = <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (step = <span class="hljs-number">1</span>; step &lt;= goal; step++) &#123;<br>            t = ((<span class="hljs-type">__int128_t</span>)t * t + c) % x;<br>            val = (<span class="hljs-type">__int128_t</span>)val * std::<span class="hljs-built_in">abs</span>(t - s) % x;<br>            <span class="hljs-keyword">if</span> (step % <span class="hljs-number">127</span> == <span class="hljs-number">0</span>) &#123;<br>                i64 d = <span class="hljs-built_in">gcd</span>(val, x);<br>                <span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> d;<br>            &#125;<br>        &#125;<br>        i64 d = <span class="hljs-built_in">gcd</span>(val, x);<br>        <span class="hljs-keyword">if</span> (d &gt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> d;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    i64 x;<br>    std::cin &gt;&gt; x;<br>    std::unordered_map&lt;i64, <span class="hljs-type">int</span>&gt; res;<br>    std::function&lt;<span class="hljs-type">void</span>(i64)&gt; fac = [&amp;res, &amp;fac](i64 n) &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">millerRabin</span>(n)) &#123;<br>            res[n]++;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        i64 p = n;<br>        <span class="hljs-keyword">while</span> (p &gt;= n) p = <span class="hljs-built_in">Pollard_Rho</span>(n);<br>        <span class="hljs-built_in">fac</span>(p), <span class="hljs-built_in">fac</span>(n / p);<br>    &#125;;<br>    <span class="hljs-built_in">fac</span>(x);<br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">begin</span>()-&gt;first;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numTest; i++) &#123;<br>        std::cout &lt;&lt; <span class="hljs-built_in">solve</span>() % mod &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == numTest - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杭电多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假集训 Nowcoder 多校 Round 2</title>
    <link href="/2023/07/24/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20Nowcoder%20%E5%A4%9A%E6%A0%A1%20Round%202/"/>
    <url>/2023/07/24/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20Nowcoder%20%E5%A4%9A%E6%A0%A1%20Round%202/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ac.nowcoder.com/acm/contest/57356">比赛链接</a></p><hr /><h4 id="e-square">E 「Square」</h4><p>枚举 <span class="math inline">\(k\)</span> ，然后二分查找即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(logn)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br>i64 pow10[<span class="hljs-number">19</span>];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>    pow10[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">19</span>; i++) pow10[i] = <span class="hljs-number">10ll</span> * pow10[i - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    i64 x;<br>    std::cin &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">19</span>; k++) &#123;<br>        i64 left = <span class="hljs-number">0</span>, right = <span class="hljs-number">1000000000ll</span>;<br>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>            i64 mid = (left + right) / <span class="hljs-number">2</span>;<br>            i64 prefix = mid * mid / pow10[k];<br>            <span class="hljs-keyword">if</span> (prefix &lt; x) &#123;<br>                left = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (prefix &gt; x) &#123;<br>                right = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                std::cout &lt;&lt; mid &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="f-link-with-chess-game">F 「Link with Chess Game」</h4><p>这是一道典型的二分图博弈问题，对于三元组 <spanclass="math inline">\((r, b, g)\)</span> ，我们可以看成边长为 <spanclass="math inline">\(n\)</span> 的立方体的坐标，对于 <spanclass="math inline">\(n\)</span>为偶数的情况，任意一个初始状态都是最大匹配的必要点，若 <spanclass="math inline">\(n\)</span> 为奇数，则只要 <spanclass="math inline">\(r_0 + b_0 + g_0\)</span>为偶数，则该初始状态为最大匹配点必要点。</p><p>综上所示，<span class="math inline">\(n\)</span> 为偶数或者 <spanclass="math inline">\(r_0 + b_0 + g_0\)</span> 为偶数时，先手必胜。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(1)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, r, b, g;<br>    std::cin &gt;&gt; n &gt;&gt; r &gt;&gt; b &gt;&gt; g;<br>    <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> || (r + b + g) % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Alice\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Bob\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="g-link-with-centrally-symmetric-strings">G 「Link with CentrallySymmetric Strings」</h4><p>这题需要一些前置知识：<ahref="https://oi-wiki.org/string/manacher/">Manacher 算法</a></p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nowcoder</tag>
      
      <tag>Manacher</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优终止策略 —— 为什么是 37%？</title>
    <link href="/2023/07/21/%E6%9C%80%E4%BC%98%E7%BB%88%E6%AD%A2%E7%AD%96%E7%95%A5/"/>
    <url>/2023/07/21/%E6%9C%80%E4%BC%98%E7%BB%88%E6%AD%A2%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p><em>见好就收。</em></p><hr /><h4 id="描述">描述</h4><p>考虑一个问题：假设现在有若干件同类型商品，每件商品的质量都不一样且商品质量等可能分布，我们在看到商品前不知道商品的质量，且在看商品时无法回退到上一个商品，接下来要从这些商品中挑选一件商品。现在考虑如下策略：</p><p>如果有 <span class="math inline">\(n\)</span> 件商品，我们先依次看前<span class="math inline">\(k\ (k \leq n)\)</span>件商品，不论商品质量如何，都将其舍弃，在随后的 <spanclass="math inline">\(n - k\)</span> 件商品中如果出现了质量比前 <spanclass="math inline">\(k\)</span>件商品质量更好的商品，那就选择该商品，请问选择 <spanclass="math inline">\(k\)</span>为多少，可以最大化我们选择到质量最好的商品的概率呢？</p><p>假设第 <span class="math inline">\(i\)</span>件商品的质量最高，则要选择该商品，则需要保证前 <spanclass="math inline">\(i - 1\)</span> 个商品的质量最大值在前 <spanclass="math inline">\(k\)</span> 件商品，所以若该商品被选中的概率为<span class="math inline">\(\frac{k}{i - 1}\)</span>， 因此，第 <spanclass="math inline">\(i\)</span> 件商品被选择的概率为 <spanclass="math inline">\(\frac{k}{i - 1}\)</span>，又由于商品质量分布是均匀的，所有质量最高的商品等可能出现在每一个 <spanclass="math inline">\(i\ (1 \leq i \leqn)\)</span>。综上所述，选择到最高质量 <spanclass="math inline">\(P_k\)</span> 的商品的概率为： <spanclass="math display">\[P_k = \sum_{i = k + 1} ^ n \frac{k}{i - 1} \frac{1}{n}\]</span> 当 <span class="math inline">\(n\)</span> 足够大时，<spanclass="math inline">\(\sum_{i = k + 1} ^ n \frac{1}{i - 1}\)</span>可以近似看作 <span class="math inline">\(ln(n) - ln(k)\)</span>，所以有： <span class="math display">\[P_k \approx \frac{k}{n} (ln(n) - ln(k))\]</span> 对 <span class="math inline">\(k\)</span> 求导，可得： <spanclass="math display">\[\frac{\partial P_k}{\partial k} = \frac{ln(\frac{n}{e}) - ln(k)}{n}\]</span> 可知，当 <span class="math inline">\(k \approx[\frac{n}{e}]\)</span> 时，<span class="math inline">\(P_k\)</span>取得最大值。</p><p>换言之，当 <span class="math inline">\(\frac{k}{n}\)</span>近似等于自然常数 <span class="math inline">\(\frac{1}{e}\)</span> 的时候<span class="math inline">\(P_k\)</span> 取得最大值。事实上，<spanclass="math inline">\(\frac{1}{e}\)</span> 在数值上约等于0.36787944117144233，近似等于 0.37，这也是我们经常说的 37% 法则。</p><h4 id="历史">历史</h4><p class="note note-primary">这个问题可以追溯到到上世纪 60年代，当时美国杂志《科学美国人》提出了几个趣味数学问题，其中之一是秘书问题。假如你需要聘请一个秘书，你依次面试多个候选人，每面试一个人后，你要立刻决定是否聘用她，如果放弃她，她就会去其他公司工作，可能她是最优人选，但是你错过了她，如果录用她，你就不会再面试后面的人选，可能会错过后面更好的人选。那么什么时候停止，才能选到最佳人选呢？<br> 目前已知的第一个提出 37% 法则的是数学家弗拉德。他发现 37%是最佳选择的一个分割点，当有 N 个候选人时，前 37%的人面试时，不做决策，找出最优的一位，后面每面试一位，就和前面最优的这位比较，如果劣于她，就面试下一位，如果优于，就选择当前人选，停止面试。</p><p>37%法则在生活中十分常见，它经常出现在各式各样的统计学问题和决策问题上，其描述了一种选择策略上的最优化理论，可以帮我们解决一些日常的决策纠结，37%法则让我们在面对不确定时，尽可能获取到一个较好的结果。</p>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率论</tag>
      
      <tag>37% 法则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假集训 杭电多校 Round 2</title>
    <link href="/2023/07/20/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%202/"/>
    <url>/2023/07/20/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%202/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://acm.hdu.edu.cn/contest/problems?cid=1095">比赛链接</a></p><p><a href="https://vjudge.net/article/3854">补题链接</a></p><hr /><h4 id="string-problem">「1009」 String Problem</h4><p>签到题，求出连续段字符的数量，字符串长度减去该数量就是答案。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str;<br>    std::cin &gt;&gt; str;<br>    <span class="hljs-type">int</span> dn = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, len = str.<span class="hljs-built_in">size</span>(); i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (str[i] != str[i - <span class="hljs-number">1</span>]) dn++;<br>    &#125;<br><br>    std::cout &lt;&lt; str.<span class="hljs-built_in">size</span>() - dn &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="binary-number">「1002」 Binary Number</h4><p>签到题，简单分类讨论即可。但要注意细节，各种情况都需要考虑到。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    i64 k;<br>    std::string str;<br>    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; str;<br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    i64 k0 = k;<br>    <span class="hljs-keyword">while</span> (k) &#123;<br>        <span class="hljs-keyword">while</span> (p &lt; n &amp;&amp; str[p] == <span class="hljs-string">&#x27;1&#x27;</span>) p++;<br>        <span class="hljs-keyword">if</span> (p == n) &#123;<br>            <span class="hljs-keyword">if</span> (k &amp; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">if</span> ((n == <span class="hljs-number">1</span> &amp;&amp; str[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) || (k == k0 &amp;&amp; k == <span class="hljs-number">1</span>)) &#123;<br>                    str[n - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> i;<br>            <span class="hljs-keyword">for</span> (i = p; i &lt; n &amp;&amp; str[i] == <span class="hljs-string">&#x27;0&#x27;</span>; i++) str[i] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            <span class="hljs-comment">// str[i] == &#x27;0&#x27;</span><br>            p = i;<br>            k--;<br>        &#125;<br>    &#125;<br>    <br>    std::cout &lt;&lt; str &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="card-game">「1004」 Card Game</h4><p>数学题，由题意可得 <span class="math inline">\(f(n) = 2 f(n - 1) +1\)</span> ，又因为 <span class="math inline">\(f(1) = 0\)</span>，所以有： <span class="math display">\[f(n) = 2 ^ {n - 1} - 1\]</span> 使用快速幂求出答案即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(logn)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">998244353</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1ll</span> * res * x % mod;<br>        x = <span class="hljs-number">1ll</span> * x * x % mod;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    std::cout &lt;&lt; <span class="hljs-built_in">quickPow</span>(<span class="hljs-number">2</span>, n - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="foreverlasting-and-fried-chicken">「1007 」 foreverlasting andfried-chicken</h4><p>有一说一，比赛的时候这题给我看饿了（<del>正好碰上疯狂星期四</del>）。</p><p>枚举全部不同的两个节点，一个作为炸鸡的头，一个作为炸鸡的尾，假设两个节点共同一步可达的节点数为<span class="math inline">\(cnt\)</span>，则炸鸡的躯干一共有 <spanclass="math inline">\(C_{cnt} ^ 4\)</span>种取法，对于炸鸡尾部的两个节点，将从与尾部节点相邻的其余节点中选取，一共<span class="math inline">\(C_{x - 4} ^ 2\)</span> 中取法（<spanclass="math inline">\(x\)</span>在这里表示与尾部节点相邻且不为头节点的节点数），最后枚举求和即可，时间复杂度为<span class="math inline">\(O(n ^ 3)\)</span>，对于题目的数据量而言是会超时的，所以这里考虑 <code>bitset</code>优化。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-20-154137.png" style="zoom:45%;" /></p><blockquote><p>时间复杂度：<span class="math inline">\(O(\frac{n ^3}{w})\)</span></p><p>空间复杂度：<span class="math inline">\(O(n ^ 2)\)</span></p><p><ahref="https://goer17.github.io/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/"><code>bitset</code>讲解</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 1005</span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1000000007</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">c2</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (i64)n * (n - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> % mod;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">c4</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> (i64)n * (n - <span class="hljs-number">1</span>) * (n - <span class="hljs-number">2</span>) * (n - <span class="hljs-number">3</span>) / <span class="hljs-number">24</span> % mod;<br>&#125;<br><br><br>std::bitset&lt;MAX_N&gt; g[MAX_N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) g[i].<span class="hljs-built_in">reset</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x, y; i &lt; m; i++) &#123;<br>        std::cin &gt;&gt; x &gt;&gt; y;<br>        x--, y--;<br>        g[x][y] = g[y][x] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-type">int</span> cnt_i = g[i].<span class="hljs-built_in">count</span>();<br>            <span class="hljs-type">int</span> cnt_j = g[j].<span class="hljs-built_in">count</span>();<br>            <span class="hljs-type">int</span> cnt_and = (g[i] &amp; g[j]).<span class="hljs-built_in">count</span>();<br>            <span class="hljs-keyword">if</span> (g[i][j]) &#123;<br>                cnt_i--, cnt_j--;<br>            &#125;<br>            res = (res + (i64)<span class="hljs-built_in">c4</span>(cnt_and) * (<span class="hljs-built_in">c2</span>(cnt_i - <span class="hljs-number">4</span>) + <span class="hljs-built_in">c2</span>(cnt_j - <span class="hljs-number">4</span>))) % mod;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="spy-finding-npy">「1011」SPY finding NPY</h4><p>典中典结论，若前 <span class="math inline">\(k\)</span>个不选择，则选择到 IQ 最高的对象的概率为 <spanclass="math inline">\(\sum_{i = k + 1} ^ n \frac{1}{i - 1}\frac{k}{n}\)</span> 。当 <span class="math inline">\(n\)</span>足够大的的时候，<span class="math inline">\(k\)</span> 大概等于 <spanclass="math inline">\([\frac{n}{e}]\)</span>，考虑到可能会存在误差，所以还需要在此基础上将 <spanclass="math inline">\(k\)</span> 左右微调。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p><p>在这里时间和空间的开销主要都在预处理上。</p><p><ahref="https://goer17.github.io/2023/07/21/%E6%9C%80%E4%BC%98%E7%BB%88%E6%AD%A2%E7%AD%96%E7%95%A5/">最优终止策略讲解</a></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 10005</span><br><br><span class="hljs-type">double</span> div_num[MAX_N];<br><span class="hljs-type">const</span> <span class="hljs-type">double</span> e = <span class="hljs-built_in">exp</span>(<span class="hljs-number">1</span>);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">preProcess</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; MAX_N; i++) &#123;<br>        div_num[i] = <span class="hljs-number">1.0</span> / (i - <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAX_N - <span class="hljs-number">1</span>; i++) &#123;<br>        div_num[i] += div_num[i - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">prob</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span> / n;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (div_num[n] - div_num[k]) * k / n;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> k = (<span class="hljs-type">int</span>)((n + <span class="hljs-number">0.5</span>) / e);<br>    <br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-built_in">prob</span>(n, k - <span class="hljs-number">1</span>) &gt; <span class="hljs-built_in">prob</span>(n, k)) k--;<br>    <span class="hljs-keyword">while</span> (k &lt; n &amp;&amp; <span class="hljs-built_in">prob</span>(n, k + <span class="hljs-number">1</span>) &gt; <span class="hljs-built_in">prob</span>(n, k)) k++;<br><br>    std::cout &lt;&lt; k &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">preProcess</span>();<br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="alice-game">「1001」Alice Game</h4><p>我们假设一段长度为 <span class="math inline">\(x\)</span> 的序列的<span class="math inline">\(SG\)</span> 值为 <spanclass="math inline">\(sg(x)\)</span> ，若 <span class="math inline">\(x&lt;= k\)</span> ，则先手可以且只能一次将序列全部删除，此时，<spanclass="math inline">\(sg(x) = 1\)</span> ，若 <spanclass="math inline">\(x &gt; k\)</span> ，删除长度为 <spanclass="math inline">\(k\)</span>的序列后还剩两段不相连的序列，且两段序列互不影响，这事实上就是一种 Nim游戏，此时有 <span class="math inline">\(sg(x) = \underset{i &gt; 0\\land\ n - k - i &gt; 0}{mex} \{ sg(i) \oplus sg(n - k - i) \}\)</span>，这里的 <span class="math inline">\(\oplus\)</span> 表示异或。</p><p>这样我们就可以求出 <span class="math inline">\(sg(n)\)</span>的值来判断先手是必胜还是必败了，但对于每一个 <spanclass="math inline">\(k\)</span> 和 <spanclass="math inline">\(n\)</span> 都求一次 <spanclass="math inline">\(sg(n)\)</span>的话时间开销过大，所以我们考虑打表找规律：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">k = 2:  0 3 13 23 33 43 ...<br>k = 3:  0 4 18 32 46 60 ...<br>k = 4:  0 5 23 41 59 77 ...<br></code></pre></td></tr></table></figure><blockquote><p>以上为不同的 <span class="math inline">\(k\)</span> 满足 <spanclass="math inline">\(sg(n) = 0\)</span> 的 <spanclass="math inline">\(n\)</span> 的取值。</p></blockquote><p>不难发现，必败点 <span class="math inline">\(n\)</span> 在 <spanclass="math inline">\(n &gt; 0\)</span> 的时候构成首项为 <spanclass="math inline">\(k + 1\)</span> ，公差为 <spanclass="math inline">\(4k + 2\)</span> 的等差数列。</p><p>因此可以大胆估计，当且仅当 <span class="math inline">\(n = 0\)</span>或者 <span class="math inline">\(n \equiv k + 1\ (mod\ 4k + 2)\)</span>的时候先手必败，否则先手必胜。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(1)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> k, n;<br>    std::cin &gt;&gt; k &gt;&gt; n;<br>    <span class="hljs-type">bool</span> ans = (n != <span class="hljs-number">0</span> ? n % (<span class="hljs-number">4</span> * k + <span class="hljs-number">2</span>) != k + <span class="hljs-number">1</span> : <span class="hljs-literal">false</span>);<br><br>    std::cout &lt;&lt; (ans ? <span class="hljs-string">&quot;Alice&quot;</span> : <span class="hljs-string">&quot;Bob&quot;</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>至于这个结论怎么证明，就不得而知了（<del>ACM 要什么证明</del>）。</p><p>如果读者感兴趣可以自己试试。</p>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杭电多校</tag>
      
      <tag>bitset</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假集训 杭电多校 Round 1</title>
    <link href="/2023/07/18/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%201/"/>
    <url>/2023/07/18/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%20Round%201/</url>
    
    <content type="html"><![CDATA[<p>暑假集训第一次杭电多校。</p><p><a href="https://vjudge.net/contest/569863">题目链接</a></p><hr /><h4 id="i-assertion">I 「Assertion」</h4><p>签到题，知道抽屉原理就行了。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(1)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, d;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<br>    <span class="hljs-keyword">if</span> (d &lt;= (m + n - <span class="hljs-number">1</span>) / n) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="e-cyclically-isomorphic">E 「Cyclically Isomorphic」</h4><p>判断两个字符串 <code>str1</code> 和 <code>str2</code> 是否符合"Cyclically Isomarphic" 的性质，只需要判断 <code>str2</code> 是否是<code>str1 + str1</code> 的子串即可。</p><blockquote><p>时间复杂度：<spanclass="math inline">\(O(Qm)\)</span>（重复的查询不计入）</p><p>空间复杂度：<span class="math inline">\(O(nm)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">arr</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">std::vector&lt;std::string&gt; <span class="hljs-title">pat</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::string str;<br>        std::cin &gt;&gt; str;<br>        arr[i] = str;<br>        pat[i] = str + str;<br>    &#125;<br>    std::map&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, <span class="hljs-type">bool</span>&gt; res;<br>    std::cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x, y; i &lt; q; i++) &#123;<br>        std::cin &gt;&gt; x &gt;&gt; y;<br>        x--;<br>        y--;<br>        <span class="hljs-keyword">if</span> (x &gt; y) &#123;<br>            <span class="hljs-type">int</span> tmp = x;<br>            x = y;<br>            y = tmp;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">find</span>(&#123;x, y&#125;) == res.<span class="hljs-built_in">end</span>()) &#123;<br>            res[&#123;x, y&#125;] = pat[x].<span class="hljs-built_in">find</span>(arr[y]) != std::string::npos;<br>        &#125;<br>        <br>        std::cout &lt;&lt; (res[&#123;x, y&#125;] ? <span class="hljs-string">&quot;Yes\n&quot;</span> : <span class="hljs-string">&quot;No\n&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b-city-upgrading">B 「City Upgrading」</h4><p>树上 DP，选定一个根节点，从叶节点向上DP，状态转移方程还是比较好想的，如果父节点没有被选取，则至少要有一个子节点被选取。</p><p>若父节点被选取，则子节点的子树必须都被覆盖。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> i64 inf = <span class="hljs-number">0x7f7f7f7f7f7f</span>ll;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; cost;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; g;<br>    std::vector&lt;std::vector&lt;i64&gt;&gt; dp; <span class="hljs-comment">// dp[i] 表示 i 以及其子树覆盖的最小花费</span><br>    <span class="hljs-comment">// dp[i][0] 表示不选择 i</span><br>    <span class="hljs-comment">// dp[i][1] 表示选择 i</span><br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>        dp[x][<span class="hljs-number">1</span>] = cost[x];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : g[x]) &#123;<br>            <span class="hljs-keyword">if</span> (v != fa) &#123;<br>                <span class="hljs-built_in">dfs</span>(v, x);<br>                <span class="hljs-comment">// 只需要一个子树选择父节点即可</span><br>                dp[x][<span class="hljs-number">0</span>] += std::<span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">0</span>], dp[v][<span class="hljs-number">1</span>]);<br><br>                i64 res_1 = std::<span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">0</span>], dp[v][<span class="hljs-number">1</span>]); <span class="hljs-comment">// 选择儿子节点</span><br>                i64 res_2 = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> sv : g[v]) &#123;<br>                    <span class="hljs-keyword">if</span> (sv != x) &#123;<br>                        res_2 += std::<span class="hljs-built_in">min</span>(dp[sv][<span class="hljs-number">0</span>], dp[sv][<span class="hljs-number">1</span>]);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-comment">// 不选择儿子节点，则需要覆盖该儿子节点的所有孙子子树</span><br><br>                dp[x][<span class="hljs-number">1</span>] += std::<span class="hljs-built_in">min</span>(res_1, res_2);<br>            &#125;<br>        &#125;<br>        i64 res = dp[x][<span class="hljs-number">0</span>];<br>        dp[x][<span class="hljs-number">0</span>] = inf;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : g[x]) &#123;<br>            <span class="hljs-comment">// 至少一个子树选择父节点</span><br>            <span class="hljs-keyword">if</span> (v != fa) &#123;<br>                dp[x][<span class="hljs-number">0</span>] = std::<span class="hljs-built_in">min</span>(dp[x][<span class="hljs-number">0</span>], res - std::<span class="hljs-built_in">min</span>(dp[v][<span class="hljs-number">0</span>], dp[v][<span class="hljs-number">1</span>]) + dp[v][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-type">int</span> n;<br>        std::cin &gt;&gt; n;<br>        cost.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) std::cin &gt;&gt; cost[i];<br>        g.<span class="hljs-built_in">resize</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x, y; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            std::cin &gt;&gt; x &gt;&gt; y;<br>            x--;<br>            y--;<br>            g[x].<span class="hljs-built_in">push_back</span>(y);<br>            g[y].<span class="hljs-built_in">push_back</span>(x);<br>        &#125;<br>        dp.<span class="hljs-built_in">resize</span>(n, std::<span class="hljs-built_in">vector</span>&lt;i64&gt;(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>));<br><br>        <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br><br>        std::cout &lt;&lt; std::<span class="hljs-built_in">min</span>(dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], dp[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">Solution</span>().<span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="l-play-on-tree">L 「Play on Tree」</h4><p>给定一颗树，两人轮流删掉一个子树，删掉最后一个节点的人输掉比赛。则叶节点的SG 值为 0，非叶节点的 SG 值为其所有子节点的 (SG 值 + 1) 的异或和。</p><p>对于不同的根节点，可以考虑换根 DP，从而得到每一个节点作为根节点的 SG值。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-type">int</span> first[MAX_N];<br><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> next;<br>&#125; edges[<span class="hljs-number">2</span> * MAX_N];<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    edges[cnt] = &#123;y, first[x]&#125;;<br>    first[x] = cnt++;<br>&#125;<br><br><span class="hljs-type">int</span> sg1[MAX_N];<br><span class="hljs-type">int</span> sg2[MAX_N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    sg1[v] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = first[v]; e != <span class="hljs-number">-1</span>; e = edges[e].next) &#123;<br>        <span class="hljs-type">int</span> x = edges[e].to;<br>        <span class="hljs-keyword">if</span> (x == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-built_in">dfs1</span>(x, v);<br>        sg1[v] ^= (sg1[x] + <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-comment">// 换根</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e = first[v]; e != <span class="hljs-number">-1</span>; e = edges[e].next) &#123;<br>        <span class="hljs-type">int</span> x = edges[e].to;<br>        <span class="hljs-keyword">if</span> (x == fa) <span class="hljs-keyword">continue</span>;<br>        sg2[x] = ((sg2[v] ^ (sg1[x] + <span class="hljs-number">1</span>)) + <span class="hljs-number">1</span>) ^ sg1[x];<br>        <span class="hljs-built_in">dfs2</span>(x, v);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> mod = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">quickPow</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) res = (i64)res * x % mod;<br>        x = (i64)x * x % mod;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">memset</span>(first, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(first));<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x, y; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        std::cin &gt;&gt; x &gt;&gt; y;<br>        x--, y--;<br>        <span class="hljs-built_in">addEdge</span>(x, y);<br>        <span class="hljs-built_in">addEdge</span>(y, x);<br>    &#125;<br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    sg2[<span class="hljs-number">0</span>] = sg1[<span class="hljs-number">0</span>];<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) res += sg2[i] != <span class="hljs-number">0</span>;<br><br>    std::cout &lt;&lt; (i64)<span class="hljs-function">res * <span class="hljs-title">quickPow</span><span class="hljs-params">(n, mod - <span class="hljs-number">2</span>)</span> % mod &lt;&lt; &#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杭电多校</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暑假集训 Nowcoder 多校 Round 1</title>
    <link href="/2023/07/17/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20Nowcoder%20%E5%A4%9A%E6%A0%A1%20Round%201/"/>
    <url>/2023/07/17/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%20Nowcoder%20%E5%A4%9A%E6%A0%A1%20Round%201/</url>
    
    <content type="html"><![CDATA[<p>第一次参加暑假集训的牛客多校，感觉还是挺难的。</p><p><a href="https://ac.nowcoder.com/acm/contest/57355">比赛链接</a></p><hr /><h4 id="d-chocolate">D 「Chocolate」</h4><p>签到题，只有 1 × 1 的时候 Walk Alone 会赢，其余情况均是 Kelin赢。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(1)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> &amp;&amp; m == <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Walk Alone\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Kelin\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="j-roulette">J 「Roulette」</h4><p>以 ”输-输-输-输-...-输-赢“ 为一个周期，Walk Alone 的钱只会增加 1块，且接下来重新从 1 块开始下注。</p><p>假设有 x 块钱，且从 1 开始下注的胜率为 <spanclass="math inline">\(p_x\)</span>，可得： <span class="math display">\[p_x = (1 - \frac{1}{2 ^ k}) p_{x + 1}\]</span> 其中 <span class="math inline">\(k\)</span> 满足：<spanclass="math inline">\(x \in [2 ^ r - 1, 2 ^ {r + 1} -1)\)</span>，接下来只要枚举区间然后使用快速幂即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(log^2n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> i64 mod = <span class="hljs-number">998244353ll</span>;<br><br><span class="hljs-function">i64 <span class="hljs-title">quickPow</span><span class="hljs-params">(i64 x, i64 n)</span> </span>&#123;<br>    i64 res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>            res = res * x % mod;<br>        &#125;<br>        x = x * x % mod;<br>        n &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">inverse</span><span class="hljs-params">(i64 x)</span> </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">quickPow</span>(x, mod - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    i64 n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (n &gt;= (<span class="hljs-number">1ll</span> &lt;&lt; (k + <span class="hljs-number">1</span>)) - <span class="hljs-number">1ll</span>) k++;<br>    i64 res = <span class="hljs-number">1ll</span>;<br>    i64 l = n, r = std::<span class="hljs-built_in">min</span>((<span class="hljs-number">1ll</span> &lt;&lt; (k + <span class="hljs-number">1</span>)) - <span class="hljs-number">1ll</span>, n + m);<br>    i64 i2 = <span class="hljs-built_in">inverse</span>(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span> (l &lt; n + m) &#123;<br>        i64 x = (<span class="hljs-number">1</span> - <span class="hljs-built_in">quickPow</span>(i2, k) + mod) % mod;<br>        res = res * <span class="hljs-built_in">quickPow</span>(x, r - l) % mod;<br>        l = r;<br>        r = std::<span class="hljs-built_in">min</span>(((r + <span class="hljs-number">1ll</span>) &lt;&lt; <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>, n + m);<br>        k++;<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="k-subdivision">K 「Subdivision」</h4><p>先从从顶点 1 出发构造 BFS 树（只延伸 k步），接下来新增顶点无非有以下两种类型：</p><ol type="1"><li><p>加在非树边上的点：</p><p>对于非树边而言，无论加多少点，都不会影响到最终结果，假设在非树边<span class="math inline">\(&lt;x, y&gt;\)</span>上加入尽可能多的点，则新增到顶点 1 的距离不超过 k 的点有 <spanclass="math inline">\(2 \times k - dist[x] - dist[y]\)</span> ，其中<span class="math inline">\(dist[v]\)</span> 表示 <spanclass="math inline">\(v\)</span> 到顶点 1 的距离。</p></li><li><p>加在树边上的点： 假设存在末端节点 <spanclass="math inline">\(v\)</span>不与其他非树边相连，则可以延长末端节点，可新增 <spanclass="math inline">\(k - dist[v]\)</span> 个点。</p></li></ol><blockquote><p>时间复杂度：<span class="math inline">\(O(n + m)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n + m)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x, y; i &lt; m; i++) &#123;<br>        std::cin &gt;&gt; x &gt;&gt; y;<br>        x--;<br>        y--;<br>        g[x].<span class="hljs-built_in">push_back</span>(y);<br>        g[y].<span class="hljs-built_in">push_back</span>(x);<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    dist[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    std::queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>    i64 cnt = <span class="hljs-number">1ll</span>; <span class="hljs-comment">// 初始状态有多少距离不超过 k 的点数</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">tree</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 构造 BFS 树</span><br>    tree[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; endVertex; <span class="hljs-comment">// BFS 树的末端节点</span><br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-type">int</span> v = q.<span class="hljs-built_in">front</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-type">int</span> d = dist[v] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (d &gt; k) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">bool</span> tag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : g[v]) &#123;<br>            <span class="hljs-keyword">if</span> (dist[x] == <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-comment">// 未发现的点</span><br>                dist[x] = d;<br>                q.<span class="hljs-built_in">push</span>(x);<br>                cnt++; <span class="hljs-comment">// d &lt;= k</span><br>                tree[x] = v;<br>                tag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!tag) endVertex.<span class="hljs-built_in">push_back</span>(v); <span class="hljs-comment">// 树的末端</span><br>    &#125;<br><br>    <span class="hljs-comment">// 加在非树边上的点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : g[i]) &#123;<br>            <span class="hljs-keyword">if</span> (i &lt; j &amp;&amp; dist[i] != <span class="hljs-number">-1</span> &amp;&amp; dist[j] != <span class="hljs-number">-1</span> &amp;&amp; tree[i] != j &amp;&amp; tree[j] != i) &#123;<br>                cnt += <span class="hljs-number">2ll</span> * k - dist[i] - dist[j];<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 加在树边上的点（树的末端）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : endVertex) &#123;<br>        <span class="hljs-type">bool</span> tag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : g[i]) &#123;<br>            <span class="hljs-keyword">if</span> (dist[i] != <span class="hljs-number">-1</span> &amp;&amp; tree[i] != j) &#123;<br>                tag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 不存在非树边与末端连接</span><br>        <span class="hljs-keyword">if</span> (!tag &amp;&amp; i != <span class="hljs-number">0</span>) cnt += <span class="hljs-number">1ll</span> * k - dist[i];<br>    &#125;<br><br>    std::cout &lt;&lt; cnt &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="h-matches">H 「Matches」</h4><p>假设交换两个下标 <span class="math inline">\(i\)</span> 和 <spanclass="math inline">\(j\)</span> ，则 <spanclass="math inline">\(\sum_{k = 1} ^ n |a_k - b_k|\)</span>在原来的基础上减小 <span class="math inline">\(|a_i - b_i| + |a_j - b_j|- |a_i - b_j| - |a_j - b_i|\)</span> ，换言之，我们只要能最大化 <spanclass="math inline">\(|a_i - b_i| + |a_j - b_j| - |a_i - b_j| - |a_j -b_i|\)</span> 即可。</p><p>我们将每一对 <span class="math inline">\((a_i， b_i)\)</span>划分为两类区间：</p><ol type="1"><li><span class="math inline">\([a_i, b_i]\)</span>，<spanclass="math inline">\((a_i \leq b_i)\)</span></li><li><span class="math inline">\([b_i, a_i]\)</span>，<spanclass="math inline">\((a_i &gt; b_i)\)</span></li></ol><p>问题就转化为我们要找到两个不同的区间，使得 <spanclass="math inline">\(f(i, j) = |a_i - b_i| + |a_j - b_j| - |a_i - b_j|- |a_j - b_i|\)</span> 的值最大。</p><p>事实上，很容易证明当区间属于同一类的时候 <spanclass="math inline">\(f(i, j) \leq 0\)</span>，因此选取的两个区间只能来自不同的类，简单计算可得 <spanclass="math inline">\(f(i, j)\)</span> 就等于两个区间相交部分的值。</p><p>所以我们只需要找到两类区间相交部分的最大值即可。</p><p>具体算法实现时可以考虑先枚举两类区间，存储到两个数组，然后分别按照区间左端点大小进行排序，同时使用两个新数组维护两类区间右端点前缀最大值，然后对任意一个区间<span class="math inline">\(r = [x, y]\)</span>，在另一类区间数组中使用二分查找找到左区间不超过 <spanclass="math inline">\(x\)</span>的最大区间下标，根据前面定义的前缀数组，于是我们就得到了左区间端点不超过<span class="math inline">\(x\)</span>的区间里右区间的最大值，通过此方式，我们可以枚举所有可能的最大区间交集。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">const</span> std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&amp; r, <span class="hljs-type">int</span> d)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到区间 r[i] 左端点不超过 d 最大 i</span><br>    <span class="hljs-keyword">if</span> (r.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = r.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// r[left].first &lt;= d &lt; r[right].first</span><br>    <span class="hljs-keyword">if</span> (r[left].first &gt; d) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (r[right].second &lt;= d) <span class="hljs-keyword">return</span> right;<br><br>    <span class="hljs-keyword">while</span> (right - left &gt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (r[mid].first &lt;= d) &#123;<br>            left = mid;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            right = mid;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; b[i];<br>    &#125;<br>    std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; r1;<br>    std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; r2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] &lt;= b[i]) &#123;<br>            r1.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(a[i], b[i]));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            r2.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(b[i], a[i]));<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> n1 = r1.<span class="hljs-built_in">size</span>(), n2 = r2.<span class="hljs-built_in">size</span>();<br><br>    std::<span class="hljs-built_in">sort</span>(r1.<span class="hljs-built_in">begin</span>(), r1.<span class="hljs-built_in">end</span>());<br>    std::<span class="hljs-built_in">sort</span>(r2.<span class="hljs-built_in">begin</span>(), r2.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxrb_1</span><span class="hljs-params">(n1)</span></span>;<br>    <span class="hljs-keyword">if</span> (n1 &gt; <span class="hljs-number">0</span>) maxrb_1[<span class="hljs-number">0</span>] = r1[<span class="hljs-number">0</span>].second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n1; i++) &#123;<br>        maxrb_1[i] = std::<span class="hljs-built_in">max</span>(maxrb_1[i - <span class="hljs-number">1</span>], r1[i].second);<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxrb_2</span><span class="hljs-params">(n2)</span></span>;<br>    <span class="hljs-keyword">if</span> (n2 &gt; <span class="hljs-number">0</span>) maxrb_2[<span class="hljs-number">0</span>] = r2[<span class="hljs-number">0</span>].second;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n2; i++) &#123;<br>        maxrb_2[i] = std::<span class="hljs-built_in">max</span>(maxrb_2[i - <span class="hljs-number">1</span>], r2[i].second);<br>    &#125;<br><br>    i64 res = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n1; i++) &#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">binary_search</span>(r2, r1[i].first);<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> l = r1[i].first;<br>        <span class="hljs-type">int</span> r = std::<span class="hljs-built_in">min</span>(r1[i].second, maxrb_2[j]);<br>        <span class="hljs-keyword">if</span> (r &gt; l) res = std::<span class="hljs-built_in">max</span>(res, (i64)r - l);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n2; i++) &#123;<br>        <span class="hljs-type">int</span> j = <span class="hljs-built_in">binary_search</span>(r1, r2[i].first);<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-type">int</span> l = r2[i].first;<br>        <span class="hljs-type">int</span> r = std::<span class="hljs-built_in">min</span>(r2[i].second, maxrb_1[j]);<br>        <span class="hljs-keyword">if</span> (r &gt; l) res = std::<span class="hljs-built_in">max</span>(res, (i64)r - l);<br>    &#125;<br><br>    i64 sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum += <span class="hljs-built_in">abs</span>((i64)a[i] - b[i]);<br>    &#125;<br><br>    std::cout &lt;&lt; sum - <span class="hljs-number">2</span> * res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="m-water">M 「Water」</h4><p>一个比较典型的问题，假设存在解（<spanclass="math inline">\(r\)</span>, <spanclass="math inline">\(s\)</span>）使得 <span class="math inline">\(rA +sB = x\)</span> 则可以实现 Walk Alone 的需求，使用 exgcd 判断即可。</p><p>若不定方程存在解 <span class="math inline">\((r,s)\)</span>，则答案为：<span class="math inline">\(max\{2(r + s), 2|r -s| - 1\}\)</span> 。只需要找到使得该式最小的整数解 <spanclass="math inline">\((r, s)\)</span> 即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(logn)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function">i64 <span class="hljs-title">exgcd</span><span class="hljs-params">(i64 a, i64 b, i64&amp; x, i64&amp; y)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>        x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br><br>    i64 g = <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>    y -= (a / b) * x;<br><br>    <span class="hljs-keyword">return</span> g;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    i64 a, b, x;<br>    std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; x;<br>    i64 r, s;<br>    i64 g = <span class="hljs-built_in">exgcd</span>(a, b, r, s);<br>    <span class="hljs-keyword">if</span> (x % g != <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    i64 c = x / g;<br>    r *= c, s *= c;<br>    <span class="hljs-comment">// ar + bs = x</span><br><br>    i64 k1 = b / g, k2 = - a / g;<br>    <span class="hljs-keyword">auto</span> minOp = [r, s, k1, k2](i64 t) -&gt; i64 &#123;<br>        i64 r0 = r + k1 * t;<br>        i64 s0 = s + k2 * t;<br>        <span class="hljs-keyword">if</span> (r0 &gt;= <span class="hljs-number">0</span> &amp;&amp; s0 &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * (r0 + s0);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * std::<span class="hljs-built_in">abs</span>(r0 - s0) - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br><br>    i64 res = INT64_MAX;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> ran = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">for</span> (i64 t0 : &#123;-r / k1, -s / k2&#125;) &#123;<br>        <span class="hljs-keyword">for</span> (i64 t = t0 - ran; t &lt;= t0 + ran; t++) &#123;<br>            res = std::<span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">minOp</span>(t));<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nowcoder</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习鱼书学习笔记</title>
    <link href="/2023/07/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%B1%BC%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/07/10/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%B1%BC%E4%B9%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="神经网络介绍">神经网络介绍</h3><h4 id="从感知机到神经网络">从感知机到神经网络</h4><p><strong>感知机（perceptron）</strong>是美国学者 Frank Rosenblatt 在1957 年提出的概念。</p><p>感知机可以理解成某个节点，接受一个或者多个信号，输出一个信号。在数字电路中常讨论的各种逻辑门，都可以看成感知机。</p><p>以下就是一个简单的感知机的例子：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-11-034427.png" alt = "有两个输入的感知机"  style="zoom:40%;" /><span class="math display">\[\begin{equation}y =\begin{cases}0 &amp; (w_1 x_1 + w_2 x_2 \leq 0) \\1 &amp; (w_1 x_1 + w_2 x_2 &gt; 0)\end{cases}\end{equation}\]</span> 而神经网络就是由很多层复杂的感知机组合而成的。</p><p>一般而言，神经网络由三个主要部分组成：</p><ul><li><strong>输入层（Input Layer）</strong></li><li><strong>隐藏层（Hidden Layer）</strong></li><li><strong>输出层（Output Layer）</strong></li></ul><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-11-035817.png" alt="三层神经网络示例" style="zoom:50%;" /></p><p>一般而言，一个 <span class="math inline">\(k\)</span> 层神经网络有<span class="math inline">\(k - 1\)</span> 个隐藏层。</p><h4 id="affine-函数">Affine 函数</h4><p>Affine函数即对上一层节点传输数值作仿射变换，一般是所有数值的线性组合加上一个常量。<span class="math display">\[y_i = \sum_{k = 1} ^ m w_{k, i} x_k + b_i\]</span> 矩阵乘法表示为： <span class="math display">\[y = X W + b\]</span></p><h4 id="激活函数">激活函数</h4><p><strong>激活函数（activationfunction）</strong>就是将输入信号转化为输出信号的函数。激活函数的作用在于决定如何来激活输入信号的总和。</p><p>下面是几种常见的激活函数：</p><h5 id="阶跃函数">阶跃函数</h5><p><span class="math display">\[\begin{equation}h(x) =\begin{cases}1 &amp; (x &gt; 0) \\0 &amp; (x \leq 0)\end{cases}\end{equation}\]</span></p><p>跃阶函数非常简单，输入值大于 0 时输出 1，否则输出 0。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">step_function</span>(<span class="hljs-params">x</span>):<br><br>    <span class="hljs-keyword">return</span> (x &gt; <span class="hljs-number">0</span>).astype(np.<span class="hljs-built_in">int</span>)<br></code></pre></td></tr></table></figure><h5 id="sigmoid-函数">Sigmoid 函数</h5><p><span class="math display">\[h(x) = \frac{1}{1 + exp(-x)}\]</span></p><p>Sigmoid 函数可以将全体实数平滑映射到 <span class="math inline">\((0,1)\)</span>，在神经网络中被广泛使用。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br></code></pre></td></tr></table></figure><p class="note note-primary">以上提及的两种激活函数都属于非线性函数，神经网络的激活函数必须使用非线性函数，如果激活函数都是线性的，那么不论神经网络有多少层，最后的激活值都是输入值的线性组合，无法发挥神经网络的作用。</p><h5 id="relu-函数">ReLU 函数</h5><p><span class="math display">\[\begin{equation}h(x) =\begin{cases}x &amp; (x &gt; 0) \\0 &amp; (x \leq 0)\end{cases}\end{equation}\]</span></p><p><strong>ReLU（Rectified LinearUnit）</strong>函数，即线性修正单元函数，当输入值大于 0时输出输入值本身，否则输出 0。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">relu</span>(<span class="hljs-params">x</span>):<br>    <br>    <span class="hljs-keyword">return</span> np.maximum(<span class="hljs-number">0</span>, x)<br></code></pre></td></tr></table></figure><h4 id="输出层设计">输出层设计</h4><p>神经网络可以用在预测问题和分类问题上，根据我们要解决的问题可以改变输出层的激活函数。</p><p>一般而言，预测问题用<strong>恒等函数</strong>，分类问题用<strong>Softmax 函数</strong>。</p><h5 id="恒等函数">恒等函数</h5><p>恒等函数会原样输出信息，不加以任何改动。一般用于像回归这样的预测问题上。</p><h5 id="softmax-函数">Softmax 函数</h5><p><span class="math display">\[y_k = \frac{exp(x_k)}{\sum_{i = 1}^n exp(x_i)}\]</span></p><p>不难发现，Softmax 函数处理后的向量元素和为1，由于指数函数爆炸式增长的性质，不同元素的差异会被放大。一般用于分类问题上，使用Softmax函数激活输出节点后某个节点的值越大，说明输入输入该类的可能性越大。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">x</span>):<br>    exp_x = np.exp(x)<br>    <br>    <span class="hljs-keyword">return</span> exp_x / np.<span class="hljs-built_in">sum</span>(exp_x)<br></code></pre></td></tr></table></figure><h4 id="神经网络代码实现">神经网络代码实现</h4><p>综上，以下给出一个简单的二层神经网络的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoLayersNetWork</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, hidden_size, output_size, init_std = <span class="hljs-number">0.01</span></span>):<br>        self.params = &#123;&#125;<br>        self.params[<span class="hljs-string">&#x27;W1&#x27;</span>] = init_std * np.random.randn(input_size, hidden_size)<br>        self.params[<span class="hljs-string">&#x27;b1&#x27;</span>] = init_std * np.random.randn(hidden_size)<br>        self.params[<span class="hljs-string">&#x27;W2&#x27;</span>] = init_std * np.random.randn(hidden_size, output_size)<br>        self.params[<span class="hljs-string">&#x27;b2&#x27;</span>] = init_std * np.random.randn(output_size)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x1 = np.dot(x, self.params[<span class="hljs-string">&#x27;W1&#x27;</span>]) + self.params[<span class="hljs-string">&#x27;b1&#x27;</span>]<br>        x1 = sigmoid(x1)<br>        x2 = np.dot(x1, self.params[<span class="hljs-string">&#x27;W2&#x27;</span>]) + self.params[<span class="hljs-string">&#x27;b2&#x27;</span>]<br>        x2 = softmax(x2)<br><br>        <span class="hljs-keyword">return</span> x2<br></code></pre></td></tr></table></figure><h3 id="神经网络的学习">神经网络的学习</h3><p>神经网络的特征就是可以从数据中学习。所谓从数据中学习，就是根据数据自动决定权重参数的值。</p><p>机器学习中，一般将数据分为训练数据和测试数据两部分来进行学习和实验，训练数据也称为监督数据，用来评价模型的<strong>泛化能力</strong>。</p><h4 id="损失函数">损失函数</h4><p><strong>损失函数（LossFunction）</strong>是用来评判神经网络性能的指标，损失函数可以使用任意函数，但一般用均方误差和交叉熵误差等。</p><h5 id="均方误差">均方误差</h5><p><strong>均方误差（Mean SquaredError）</strong>是非常著名的损失函数，其表达式如下： <spanclass="math display">\[E = \frac{1}{2}\sum_{k = 1} ^ m (y_k - t_k) ^ 2\]</span> 这里 <span class="math inline">\(y_k\)</span> 和 <spanclass="math inline">\(t_k\)</span>分别表示神经网络的输出以及正确数据，<spanclass="math inline">\(m\)</span> 表示数据的维度。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">mean_squared_error</span>(<span class="hljs-params">y, t</span>):<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / <span class="hljs-number">2</span> * np.<span class="hljs-built_in">sum</span>((y - t) ** <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h5 id="交叉熵误差">交叉熵误差</h5><p>除了均方误差之外，<strong>交叉熵误差（Cross EntropyError）</strong>也经常被用作损失函数。交叉熵误差如下式所示： <spanclass="math display">\[E = -\sum_{k = 1} ^ m t_k\ ln\ y_k\]</span> 这里 <span class="math inline">\(y_k\)</span> 和 <spanclass="math inline">\(t_k\)</span>分别表示神经网络的输出以及正确解标签，<spanclass="math inline">\(m\)</span> 表示数据的维度。对于 <spanclass="math inline">\(t_k\)</span> 而言，只有正确索引的值为 1，其余都为0。交叉熵误差一般用作分类问题的损失函数。</p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy_error</span>(<span class="hljs-params">y, t</span>):<br>    delta = <span class="hljs-number">1e-7</span><br>    <br>    <span class="hljs-keyword">return</span> -np.<span class="hljs-built_in">sum</span>(t * np.log(y + delta))<br></code></pre></td></tr></table></figure><blockquote><p>这里 <code>delta</code> 是一个微小量，防止出现 <code>log(0)</code>的情况发生。</p></blockquote><h5 id="mini-batch-学习">Mini-batch 学习</h5><p>机器学习使用训练数据进行学习，其目标就是找出参数使得损失函数的值尽可能地小。因此，计算损失函数时必须把所有的训练数据作为对象。</p><p>假设有 <span class="math inline">\(N\)</span>个数据数据，那么我们就要求所有训练的损失函数的平均值： <spanclass="math display">\[E = \frac{1}{N} \sum_{i = 1} ^ N loss(y ^ {(i)}, t ^ {(i)})\]</span> 但如果数据量过大，会导致每轮学习的时间开销过大。所以我们考虑<strong>mini-batch学习</strong>，即每次从所有数据集中随机选取批量数据进行学习，每次计算该批次的数据的损失函数的平均值即可。</p><p>在具体的代码实现中，我们可以使用 NumPy 中的<code>np.random.choice()</code> 来随机选取下标。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_mask = np.random.choice(train_size, batch_size)<br>x_batch = x_train[batch_mask]<br>t_batch = t_train[batch_mask]<br></code></pre></td></tr></table></figure><p><code>np.random.choice(train_size, batch_size)</code> 返回一个长度为<code>batch_size</code> ，数据取值范围为 <code>[0, train_size)</code>的随机正整数数组。</p><h4 id="梯度下降法">梯度下降法</h4><p>机器学习的主要任务是在学习时寻找能使损失函数值最小的最优参数。一般而言，损失函数很复杂，参数空间庞大，很难用常规方式求解最小值。</p><p>这里我们给出<strong>梯度下降法（Gradient DescentMethod）</strong>：</p><p>从数学的角度出发，函数的梯度的方向代表函数增加最快的方向，其反方向就是函数减小的最快方向，极值点梯度为0，所以我们可以在每一轮迭代中让参数往梯度方向减小，从而找到极小值点。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">numerical_gradient</span>(<span class="hljs-params">f, x</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    数值法求解梯度下降法</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    delta = <span class="hljs-number">1e-5</span><br>    grads = np.zeros_like(x)<br>    <span class="hljs-keyword">for</span> idx, val <span class="hljs-keyword">in</span> np.ndenumerate(x):<br>        x[idx] = val + delta<br>        f1 = f(x)<br>        x[idx] = val - delta<br>        f2 = f(x)<br>        grads[idx] = (f1 - f2) / (<span class="hljs-number">2</span> * delta)<br>        x[idx] = val<br>    <br>    <span class="hljs-keyword">return</span> grads<br></code></pre></td></tr></table></figure><p>每轮迭代的数学表示如下： <span class="math display">\[x_i := x_i - \eta \frac{\partial f}{\partial x_i}\]</span> 其中，<span class="math inline">\(\eta\)</span>称为<strong>学习率（LearningRate）</strong>，学习率决定在一次学习中，在多大程度更新参数。</p><p>如果我们采用 mini-batch学习法每次随机选取一批次数据量，并对其损失函数平均值采用梯度下降法，这样的梯度下降我们就称为<strong>随机梯度下降（StochasticGradient Descent）</strong>，简称 <strong>SGD</strong>。</p><h3 id="误差反向传播法">误差反向传播法</h3><p>数值法求解梯度是严格按照偏导数的定义来的，这样求解固然正确，但对于参数很大的情况下效率过低。其实有一种高效的梯度求解方法，就是误差反向传播法。</p><h4 id="计算图">计算图</h4><p>书上花了很多篇幅去讲解什么是计算图以及起作用，笔者认为计算图就是将求导的链式法则进行了一个可视化。</p><p>计算图就是通过节点和箭头表示计算过程，如下图：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-12-155743.png"  style="zoom:50%;" /></p><h4 id="链式法则和反向传播">链式法则和反向传播</h4><p>以上面的图为例，假设我们知道了 <spanclass="math inline">\(\frac{\partial L}{\partial z}\)</span>，根据链式法则可知： <span class="math display">\[\begin{array}{}\frac{\partial L}{\partial x} = \frac{\partial L}{\partial z}\frac{\partial z}{\partial x} \\\frac{\partial L}{\partial y} = \frac{\partial L}{\partial z}\frac{\partial z}{\partial y}\end{array}\]</span>不难发现，对于一个计算图而言，其数值是正向传播的，而其导数则是反向传播的。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-12-160844.png" style="zoom:30%;" /></p><p>而神经网络不就恰好是一个这样层层传递的计算图吗？</p><p>所以我们可以利用链式法则的性质快速计算梯度。</p><h4 id="各种层的实现">各种层的实现</h4><p>下面给出各种层的反向传播的实现。</p><h5 id="relu-层">ReLU 层</h5><p>通过 ReLU 激活函数的表达式，不难得出： <span class="math display">\[\begin{equation}\frac{\partial y}{\partial x} =\begin{cases}1 &amp; (x &gt; 0) \\0 &amp; (x \leq 0)\end{cases}\end{equation}\]</span> 代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Relu</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.mask = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        self.mask = (x &lt;= <span class="hljs-number">0</span>)<br>        out = x.copy()<br>        out[self.mask] = <span class="hljs-number">0</span><br><br>        <span class="hljs-keyword">return</span> out<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, dout</span>):<br>        dout[self.mask] = <span class="hljs-number">0</span><br>        dx = dout<br><br>        <span class="hljs-keyword">return</span> dx<br></code></pre></td></tr></table></figure><h5 id="sigmoid-层">Sigmoid 层</h5><p>同理，我们对原式求导： <span class="math display">\[\begin{array}{}y = \frac{1}{1 + exp(-x)} \\\frac{\partial y}{\partial x} = \frac{exp(x)}{(exp(x) + 1) ^ 2} = y (1 -y)\end{array}\]</span> 代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sigmoid</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.out = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        out = sigmoid(x)<br>        self.out = out<br>        <span class="hljs-keyword">return</span> out<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, dout</span>):<br>        dx = dout * (<span class="hljs-number">1.0</span> - self.out) * self.out<br><br>        <span class="hljs-keyword">return</span> dx<br></code></pre></td></tr></table></figure><h5 id="affine-层">Affine 层</h5><p><span class="math display">\[Y = XW + b\]</span></p><p>这里涉及到矩阵求导，采用分子布局，若已知 <spanclass="math inline">\(\frac{\partial L}{\partialy}\)</span>，根据链式求导法则，有： <span class="math display">\[\frac{\partial L}{\partial w_{i, j}} = \sum_k \frac{\partial L}{\partialy_{k, j}} \frac{\partial y_{k, j}}{\partial w_{i, j}}\]</span> 代入： <span class="math display">\[y_{k, j} = \sum_{t} w_{t, j} x_{k, t} + b_j\]</span> 可得： <span class="math display">\[\frac{\partial L}{\partial w_{i, j}} = \sum_k \frac{\partial L}{\partialy_{k, j}} x_{k, i}\]</span></p><p><span class="math display">\[\implies \frac{\partial L}{\partial W} = X ^ T \frac{\partialL}{\partial Y}\]</span></p><p>同理，有：<span class="math inline">\(\frac{\partial L}{\partial X} =\frac{\partial L}{\partial Y} W ^ T\)</span></p><p>而对于 <span class="math inline">\(b\)</span>而言，我们采取同样的方法： <span class="math display">\[\frac{\partial L}{\partial b_i} = \sum_k \frac{\partial L}{\partialy_{k, i}} \frac{\partial y_{k, i}}{\partial b_i} = \sum_k \frac{\partialL}{\partial y_{k, i}}\]</span> 这说明 <span class="math inline">\(\frac{\partial L}{\partialb}\)</span> 就等于 <span class="math inline">\(\frac{\partialL}{\partial Y}\)</span> 沿列求和。</p><p>基于以上的数学证明，我们不难写出 Affine 层的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Affine</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, W, b</span>):<br>        self.W = W<br>        self.b = b<br><br>        self.x = <span class="hljs-literal">None</span><br>        self.dW = <span class="hljs-literal">None</span><br>        self.db = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">if</span> x.ndim == <span class="hljs-number">1</span>:<br>            self.x = x.reshape((<span class="hljs-number">1</span>, x.size))<br>        <span class="hljs-keyword">else</span>:<br>            self.x = x<br>        out = np.dot(self.x, self.W) + self.b<br><br>        <span class="hljs-keyword">return</span> out<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, dout</span>):<br>        <span class="hljs-keyword">if</span> dout.ndim == <span class="hljs-number">1</span>:<br>            dout = dout.reshape((<span class="hljs-number">1</span>, dout.size))<br>        dx = np.dot(dout, self.W.T)<br>        self.dW = np.dot(self.x.T, dout)<br>        self.db = np.<span class="hljs-built_in">sum</span>(dout, axis = <span class="hljs-number">0</span>)<br><br>        <span class="hljs-keyword">return</span> dx<br></code></pre></td></tr></table></figure><h5 id="softmax-with-loss-层">Softmax-with-Loss 层</h5><p>顾名思义，Softmax-with-Loss 层就是将 Softmax 层和 Loss函数层结合在一起，以交叉熵分析为例：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-12-175120.png" style="zoom:50%;" /></p><p note note-info>事实上，对于一个用于分类的神经网络，softmax函数只有在学习的过程中会使用，如果只用于判断某个数据的类别，只需要找到最后一层输出层的最大值即可。而如果是在学习的过程中使用了softmax 函数，那就意味着马上需要计算其损失函数，于是在这里我们直接将Softmax 层和 Lost 层看成一个整体。</p><p>有意思的是将两层看做一个整体后，其偏导数相当简洁： <spanclass="math display">\[\frac{\partial E}{\partial x_i} = - \frac{\partial}{\partial x_i} \sum_kt_k\ ln\ \frac{exp(x_i)}{\sum_j exp(x_j)} = \frac{exp(x_i)}{\sum_jexp(x_j)} \sum_k t_k - t_i = y_i - t_i\]</span> 代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftmaxWithLoss</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span> (self):<br>        self.y = <span class="hljs-literal">None</span><br>        self.t = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x, t</span>):<br>        self.t = t<br>        self.y = softmax(x)<br>        out = cross_entropy_error(self.y, t)<br><br>        <span class="hljs-keyword">return</span> out<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, dout = <span class="hljs-number">1</span></span>):<br>        batch_size = self.t.shape[<span class="hljs-number">0</span>]<br>        dx = (self.y - self.t) / batch_size<br><br>        <span class="hljs-keyword">return</span> dx<br></code></pre></td></tr></table></figure><h3 id="mnist-示例">MNIST 示例</h3><p>接下来我们以 MNIST 数据集为例，展示一次完整的机器学习过程。</p><p class="note note-secondary">MNIST 数据集来自美国国家标准与技术研究所, National Institute ofStandards and Technology（NIST）。训练集（training set）由来自 250个不同人手写的数字构成, 其中 50% 是高中学生, 50%来自人口普查局的工作人员。测试集（test set）也是同样比例的手写数字数据。</p><h4 id="下载-mnist-训练集与数据预处理">下载 MNIST训练集与数据预处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.datasets <span class="hljs-keyword">import</span> mnist<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_img</span>(<span class="hljs-params">img</span>):<br>    pil_img = Image.fromarray(np.uint8(img))<br>    pil_img.show()<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    (x_train, t_train), (x_test, t_test) = mnist.load_data()<br><br>    idx = <span class="hljs-number">0</span> <span class="hljs-comment"># 打印第一个数据的图形</span><br>    show_img(x_train[idx])<br>    <span class="hljs-built_in">print</span>(t_train[idx]) <span class="hljs-comment"># 5</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-13-035611.png" alt="训练集第一个数字" style="zoom:33%;" /></p><p>直接下载的训练数据 <code>x_train</code> 是<code>(60000, 28, 28)</code> 的三维数组，且元素是 <code>[0, 256)</code>的正整数，我们要将其降维以及正规化，同时还要将监督数据转化为 one-hot形式，因此在训练前要对数据进行预处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">pre_process</span>(<span class="hljs-params">x, t</span>):<br>    shape = x.shape<br>    x_pro = x.reshape(shape[<span class="hljs-number">0</span>], shape[<span class="hljs-number">1</span>] * shape[<span class="hljs-number">2</span>]) / <span class="hljs-built_in">float</span>(<span class="hljs-number">255</span>)<br>    t_pro = np.zeros((t.size, <span class="hljs-number">10</span>), dtype = np.float64)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(t.size):<br>        t_pro[i, t[i]] = <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">return</span> x_pro, t_pro<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">(x_train, t_train), (x_test, t_test) = mnist.load_data()<br><span class="hljs-comment"># 数据预处理</span><br>x_train, t_train = pre_process(x_train, t_train)<br>x_test, t_test = pre_process(x_test, t_test)<br><br><span class="hljs-built_in">print</span>(x_train.shape) <span class="hljs-comment"># (60000, 784)</span><br><span class="hljs-built_in">print</span>(t_train.shape) <span class="hljs-comment"># (60000, 10)</span><br></code></pre></td></tr></table></figure><h4id="基于反向传播的二层神经网络实现">基于反向传播的二层神经网络实现</h4><p>基于先前得到的理论，我们在此处实现一个简单的神经网络：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoLayerNetWork</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, input_size, hidden_size, output_size, init_std = <span class="hljs-number">0.01</span></span>):<br>        self.params = &#123;&#125;<br>        self.params[<span class="hljs-string">&#x27;W1&#x27;</span>] = init_std * np.random.randn(input_size, hidden_size)<br>        self.params[<span class="hljs-string">&#x27;b1&#x27;</span>] = init_std * np.random.randn(hidden_size)<br>        self.params[<span class="hljs-string">&#x27;W2&#x27;</span>] = init_std * np.random.randn(hidden_size, output_size)<br>        self.params[<span class="hljs-string">&#x27;b2&#x27;</span>] = init_std * np.random.randn(output_size)<br><br>        self.layers = OrderedDict()<br>        self.layers[<span class="hljs-string">&#x27;Affine1&#x27;</span>] = Affine(self.params[<span class="hljs-string">&#x27;W1&#x27;</span>], self.params[<span class="hljs-string">&#x27;b1&#x27;</span>])<br>        self.layers[<span class="hljs-string">&#x27;Relu1&#x27;</span>] = Relu()<br>        self.layers[<span class="hljs-string">&#x27;Affine2&#x27;</span>] = Affine(self.params[<span class="hljs-string">&#x27;W2&#x27;</span>], self.params[<span class="hljs-string">&#x27;b2&#x27;</span>])<br>        <br>        self.last_layer = SoftmaxWithLoss()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> self.layers.values():<br>            x = layer.forward(x)<br>        <br>        <span class="hljs-keyword">return</span> x<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">loss</span>(<span class="hljs-params">self, x, t</span>):<br>        y = self.predict(x)<br><br>        <span class="hljs-keyword">return</span> self.last_layer.forward(y, t)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">self, x, t</span>):<br>        y = self.predict(x)<br>        y = np.argmax(y, axis = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> y.ndim == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br>        t = np.argmax(t, axis = <span class="hljs-number">1</span> <span class="hljs-keyword">if</span> t.ndim == <span class="hljs-number">2</span> <span class="hljs-keyword">else</span> <span class="hljs-number">0</span>)<br><br>        <span class="hljs-keyword">return</span> np.<span class="hljs-built_in">sum</span>(y == t) / <span class="hljs-built_in">float</span>(y.size)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numerical_gradient</span>(<span class="hljs-params">self, x, t</span>):<br>        grads = &#123;&#125;<br>        f = <span class="hljs-keyword">lambda</span> w : self.loss(x, t)<br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;W1&#x27;</span>, <span class="hljs-string">&#x27;b1&#x27;</span>, <span class="hljs-string">&#x27;W2&#x27;</span>, <span class="hljs-string">&#x27;b2&#x27;</span>):<br>            grads[key] = numerical_gradient(f, self.params[key])<br>        <br>        <span class="hljs-keyword">return</span> grads<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gradient</span>(<span class="hljs-params">self, x, t</span>):<br>        <span class="hljs-comment"># forward</span><br>        self.loss(x, t)<br><br>        <span class="hljs-comment"># backward</span><br>        dout = self.last_layer.backward(<span class="hljs-number">1</span>)<br>        layers = <span class="hljs-built_in">list</span>(self.layers.values())<br>        layers.reverse()<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> layers:<br>            dout = layer.backward(dout)<br><br>        grads = &#123;&#125;<br>        grads[<span class="hljs-string">&#x27;W1&#x27;</span>] = self.layers[<span class="hljs-string">&#x27;Affine1&#x27;</span>].dW<br>        grads[<span class="hljs-string">&#x27;b1&#x27;</span>] = self.layers[<span class="hljs-string">&#x27;Affine1&#x27;</span>].db<br>        grads[<span class="hljs-string">&#x27;W2&#x27;</span>] = self.layers[<span class="hljs-string">&#x27;Affine2&#x27;</span>].dW<br>        grads[<span class="hljs-string">&#x27;b2&#x27;</span>] = self.layers[<span class="hljs-string">&#x27;Affine2&#x27;</span>].db<br><br>        <span class="hljs-keyword">return</span> grads<br></code></pre></td></tr></table></figure><p class="note note-info">这里保留了 <code>numerical_gradient()</code>方法，主要用于在训练前检测反向传播所求解的梯度是否足够准确。</p><p>以 MNIST 数据集为例，我们取前 10个数据，计算两种梯度求法结果的平均差值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># gradient checking</span><br>batch_size = <span class="hljs-number">10</span><br>x_batch = x_train[: batch_size]<br>t_batch = t_train[: batch_size]<br><br>nw = TwoLayerNetWork(input_size = <span class="hljs-number">784</span>, hidden_size = <span class="hljs-number">50</span>, output_size = <span class="hljs-number">10</span>)<br>g1 = nw.gradient(x_batch, t_batch)<br>g2 = nw.numerical_gradient(x_batch, t_batch)<br><span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> g1.keys():<br>    diff = np.average(np.<span class="hljs-built_in">abs</span>(g1[key] - g2[key]))<br>    <span class="hljs-built_in">print</span>(key + <span class="hljs-string">&#x27;:&#x27;</span> + <span class="hljs-built_in">str</span>(diff))<br></code></pre></td></tr></table></figure><p>控制台输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">W1:3.0029986781580274e-10<br>b1:1.889068461072459e-09<br>W2:3.764107002402314e-09<br>b2:6.041247907677899e-08<br></code></pre></td></tr></table></figure><p>误差很小，说明反向传播求解梯度是可行的。</p><h4 id="神经网络的学习与测试">神经网络的学习与测试</h4><p>我们采取 SGD 对神经网络进行训练，<code>batch_size</code> 设置为100，迭代数设置为 10000，学习率设置为0.1，同时我们记录每轮学习的损失函数以及对测试数据预测的准确率。代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">x_train, t_train, x_test, t_test</span>):<br>    nw = TwoLayerNetWork(input_size = <span class="hljs-number">784</span>, hidden_size = <span class="hljs-number">50</span>, output_size = <span class="hljs-number">10</span>)<br>    train_size = x_train.shape[<span class="hljs-number">0</span>]<br>    batch_size = <span class="hljs-number">100</span><br>    iter_num = <span class="hljs-number">10000</span><br>    lr = <span class="hljs-number">0.1</span><br>    loss_list = []<br>    acc_list = []<br><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iter_num):<br>        batch_mask = np.random.choice(train_size, batch_size)<br>        x_batch = x_train[batch_mask]<br>        t_batch = t_train[batch_mask]<br>        grads = nw.gradient(x_batch, t_batch)<br><br>        <span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> nw.params.keys():<br>            nw.params[key] -= lr * grads[key]<br>        <br>        loss = nw.loss(x_batch, t_batch)<br>        acc = nw.accuracy(x_test, t_test)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;iter %d, loss = %lf, acc = %lf&#x27;</span> % (i, loss, acc))<br>        loss_list.append(loss)<br>        acc_list.append(acc)<br><br>    plt.subplot(<span class="hljs-number">121</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;iter_num&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;loss&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;iter_num-loss&#x27;</span>)<br>    plt.plot(np.arange(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(loss_list)), loss_list)<br>    <br><br>    plt.subplot(<span class="hljs-number">122</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;iter_num&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;acc&#x27;</span>)<br>    plt.title(<span class="hljs-string">&#x27;iter_num-acc&#x27;</span>)<br>    plt.plot(np.arange(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(acc_list)), acc_list)<br><br>    plt.show()<br></code></pre></td></tr></table></figure><p>结果如下图：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-13-063238.png" style="zoom:80%;" /></p><p>学习的效果总体呈现为先快后慢的趋势，损失函数逐渐趋于0，预测准确率逐渐趋于 1。在一万次迭代后，预测准确率可以达到约 <spanclass="math inline">\(97 \%\)</span> 。这样，我们就完成了 MINIST数据集的学习过程了。</p><h3 id="神经网络学习技巧">神经网络学习技巧</h3><h4 id="更优的梯度下降策略">更优的梯度下降策略</h4><p>神经网络的学习目的可以概括为找到使损失函数的值尽可能小的参数。这个过程被称为<strong>最优化（Optimization）</strong>。</p><p>前几章我们讨论了<strong>随机梯度下降法（Stochastic GradientDescent）</strong>，即 SGD。</p><p>本章我们将讨论其他优化的梯度下降法。</p><h5 id="sgd-的缺点">SGD 的缺点</h5><p>如果函数的形状<strong>非均向（anisotropic）</strong>，收敛会很慢。</p><p>以函数 <span class="math inline">\(f(x, y) = \frac{1}{100} x^2 +y^2\)</span> 为例子，我们采取 SGD 方法求其最小值，假设初始值为 <spanclass="math inline">\((-5, 2)\)</span>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">dat = np.array([-<span class="hljs-number">5</span>, <span class="hljs-number">2</span>], dtype = np.float64)<br>fun = <span class="hljs-keyword">lambda</span> dat : <span class="hljs-number">1</span> / <span class="hljs-number">100</span> * dat[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + dat[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iter_num):<br>    dat -= lr * numerical_grad(fun, dat)<br></code></pre></td></tr></table></figure><p>结果如下：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-11-065050.png" alt="使用 SGD 迭代 100 次的结果" style="zoom:50%;" /></p><p>如上图所示，在 100 次迭代后仍然离极小值点 <spanclass="math inline">\((0, 0)\)</span>有一定距离，最后参数的移动路径近似于 Z 字形，收敛十分缓慢。</p><p>可见，随机梯度下降在本例中效率很低。从数学的层面理解，可以认为是 x的梯度分量过小导致的。</p><h5 id="momentum">Momentum</h5><p><strong>Momentum</strong>，即动量，相当于我们给梯度下降引入了物理规则，具体算法如下：<span class="math display">\[\begin{array}{}v := \alpha v - \eta \frac{\partial L}{\partial W} \\W := W + v\end{array}\]</span> <span class="math inline">\(W\)</span> 表示参数，<spanclass="math inline">\(v\)</span>在这里是一个新的变量，用于表示速度。</p><p><span class="math inline">\(\eta\)</span> 表示学习率，<spanclass="math inline">\(\alpha\)</span>表示衰减率。不同于常规的梯度下降，动量梯度下降使用速度对参数进行更新，可以使得目标更快朝极小值点移动。</p><p>还是以刚才我们讨论的函数为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Momentum</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lr = <span class="hljs-number">0.1</span>, mom = <span class="hljs-number">0.9</span></span>):<br>        self.lr = lr<br>        self.mom = mom<br>        self.v = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, params, grads</span>):<br>        <span class="hljs-keyword">if</span> self.v <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.v = np.zeros_like(params)<br>        <br>        self.v = self.mom * self.v - self.lr * grads<br>        params += self.v<br><br>fun = <span class="hljs-keyword">lambda</span> dat : <span class="hljs-number">1</span> / <span class="hljs-number">100</span> * dat[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + dat[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span><br>momen = Momentum(lr = <span class="hljs-number">0.2</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iter_num):<br>    momen.update(dat, numerical_grad(fun, dat))<br></code></pre></td></tr></table></figure><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-11-082358.png" alt="使用 Momentum 迭代 100 次的结果" style="zoom:50%;" /></p><p>可见，动量梯度下降路径更为平缓，且在有限次迭代中更快收敛至极小值点。</p><p class="note note-primary">相较于 SGD，动量梯度下降为何能做到更快收敛呢？<br>笔者对此是这样理解的，动量梯度下降是有记忆性的，其引入了一个变量记录参数更新速度，即使函数某个点的梯度在x 分量上的值很小，但其在 x分量上的速度始终是增加的，也就是在最后其依然能在 x 分量上快速收敛。而SGD是无记忆的，这也就意味着其更新速度只取决于当前的梯度，就容易导致收敛过慢的情况。</p><h5 id="adagrad">AdaGrad</h5><p>在神经网络的学习中，学习率的选取非常重要。学习率过小，可能导致学习花费时长过多，学习率过大，可能导致学习过程无法收敛。所以我们给出AdaGrad，即适应性调整学习率的梯度下降。</p><p>我们引入<strong>学习衰减率（Learning Rate Decay）</strong><spanclass="math inline">\(h\)</span>，使得随着学习进行，学习率逐渐减小。</p><p>数学表示如下： <span class="math display">\[\begin{array}{}h := h + \frac{\partial L}{\partial W} \odot \frac{\partial L}{\partialW} \\W := W - \eta \frac{1}{\sqrt h} \frac{\partial L}{\partial W}\end{array}\]</span> 还是以上述函数为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdaGrad</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, lr = <span class="hljs-number">0.1</span></span>):<br>        self.lr = lr<br>        self.h = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">self, params, grads</span>):<br>        <span class="hljs-keyword">if</span> self.h <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self.h = np.zeros_like(params)<br>        <br>        delta = <span class="hljs-number">1e-7</span><br>        self.h = self.h + grads * grads<br>        params -= self.lr / np.sqrt(self.h + delta) * grads<br><br>fun = <span class="hljs-keyword">lambda</span> dat : <span class="hljs-number">1</span> / <span class="hljs-number">100</span> * dat[<span class="hljs-number">0</span>] ** <span class="hljs-number">2</span> + dat[<span class="hljs-number">1</span>] ** <span class="hljs-number">2</span><br>ada = AdaGrad(lr = <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(iter_num):<br>    ada.update(dat, numerical_grad(fun, dat))<br></code></pre></td></tr></table></figure><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-11-090750.png" alt="使用 AdaGrad 迭代 100 次的结果" style="zoom:50%;" /></p><p class="note note-primary">AdaGrad的思路其实就是将更新过程中变化较大的参数的学习率降低，从而调整学习的尺寸。整体而言都是先快后慢，但如果无止境地学习，更新速度就会变成0。为了改善这个问题，可以使用 RMSProp 方法。</p><h4 id="关于权重的初始值">关于权重的初始值</h4><h5 id="权重初始值是否可以设置为-0">权重初始值是否可以设置为 0 ？</h5><p>答案是否定的，假设初始状态权重为0，则第二层神经元会被传递相同的值，第二层神经元全部输入相同的值，这意味着反向传播时第二层的权重会进行相同的更新。这样一来，权重将会维持均一化，为了防止这种情况发生，必须随机生成初始值。</p><h3 id="卷积神经网络">卷积神经网络</h3><h4 id="整体结构">整体结构</h4><p><strong>卷积神经网络（Convolutional Nerual Network）</strong>，简称<strong>CNN 神经网络</strong>，相比于全连接神经网络，CNN神经网络新出现了卷积（Convolution）层和池化（Pooling）层。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-21-032718.png" alt="一个 CNN 神经网络示例" /></p><h4 id="卷积层">卷积层</h4><h5 id="卷积运算">卷积运算</h5><p>卷积层进行的处理就是卷积运算。卷积运算相当于图像处理中的“滤波器运算”。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-21-034519.png" style="zoom:67%;" /></p><p>如上图，卷积运算以一定间隔滑动滤波器的窗口，每次将滤波器的元素和输入的对应元素相乘然后求和，将这个结果保存到输出的对应位置，就可以得到卷积的结果。</p><p>对于 CNN 神经网络而言，卷积运算结束后一般会加上一个偏置，如下图：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-21-035234.png" style="zoom:67%;" /></p><h5 id="填充">填充</h5><p>在进行卷积运算的处理之前，有时要向输入数据的周围填入固定的数据，比如0等，这就称为<strong>填充（padding）</strong>。通过合适的填充，可以保证卷积运算后的结果相对于输入空间大小不变。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-21-040511.png" style="zoom:50%;" /></p><h5 id="步幅">步幅</h5><p>应用滤波器的位置间隔称为<strong>步幅（stride）</strong>，前面的例子中，滤波器的步幅都为1，若步幅设置为 2，则滤波器每次移动 2 个像素。</p><p>假设输入大小为 <span class="math inline">\((H, W)\)</span>，填充为<span class="math inline">\(P\)</span> ，步幅为 <spanclass="math inline">\(S\)</span> ，滤波器大小为 <spanclass="math inline">\((FH, FW)\)</span> 。</p><p>设输出大小为 <span class="math inline">\((OH, OW)\)</span> ，则有：<span class="math display">\[OH = \frac{H + 2P - FH}{S} + 1\]</span></p><p><span class="math display">\[OW = \frac{W + 2P - FW}{S} + 1\]</span></p><h5 id="三维数据的卷积运算">三维数据的卷积运算</h5><p>相对于二维数据的卷积运算，三维卷积运算除了处理长、宽之外还要处理通道方向。通道方向有多个特征图时，会按照通道进行数据和滤波器的卷积运算，然后相加。</p><p>输入数据和滤波器的通道数必须相等，输出数据会得到一张特征图，即通道数为1的输出数据。如果要在通道方向也拥有多个卷积运算的输出，就需要多个滤波器。</p><p>假设输入数据大小为 <span class="math inline">\((C, H, W)\)</span>，即通道数为 <span class="math inline">\(C\)</span> ，高为 <spanclass="math inline">\(H\)</span> ，宽为 <spanclass="math inline">\(W\)</span> ；滤波器数据大小为 <spanclass="math inline">\((FN, C, FH, FW)\)</span> ，即滤波器个数为 <spanclass="math inline">\(FN\)</span> 个，通道数为 <spanclass="math inline">\(C\)</span> ，高为 <spanclass="math inline">\(FH\)</span> ，宽为 <spanclass="math inline">\(FW\)</span> ；则输出数据的大小可以表示为 <spanclass="math inline">\((FN, OH, OW)\)</span>，即输出数据的通道数为滤波器的数量 <spanclass="math inline">\(FN\)</span> 。</p><h4 id="池化层">池化层</h4><p>池化是缩小高、宽方向上空间的操作。常见的池化有 Max 池化和 Average池化。</p><p>对于一个 <span class="math inline">\(n \times n\)</span> 的 Max池化操作，每次选取一个 <span class="math inline">\(n \times n\)</span>的区域，从该区域中取出最大值并记录到最终答案。一般而言，步幅和池化窗口大小会设置为同样的值。</p><p>下图演示了一个 <span class="math inline">\(2 \times 2\)</span>的池化操作：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-08-21-050234.png" style="zoom:50%;" /></p><p>池化层具有以下特征：</p><ol type="1"><li>没有需要学习的参数；</li><li>通道数不发生变化；</li><li>对微小的位置变化具有鲁棒性。</li></ol><p class="note note-primary">若输入数据发生微小变化时，池化仍然会返回相同的结果。例如 Max池化，只要在池化区域内的最大值不发生变化，那么池化就可以吸收数据的偏差，仍然返回相同的结果。</p><h4 id="卷积层和池化层的代码实现">卷积层和池化层的代码实现</h4><h5 id="维数组">4 维数组</h5><p>由于 CNN 各层间传递的是 4 维数据，所以我们需要用 4维数组来存储参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">x = np.random.rand(n, c, h, w)<br><span class="hljs-comment"># 生成 n * c * h * w 的 4 维数组</span><br></code></pre></td></tr></table></figure><h5 id="im2col-技巧"><code>im2col</code> 技巧</h5><p>如果只是按照平常的卷积运算，则会出现好几层 <code>for</code>循环，十分不利于代码的书写，我们可以考虑 <code>im2col</code>技巧，把输入数据按照滤波器的作用区域进行展开：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-02-110153.png" style="zoom:33%;" /></p><p>此后就可以将卷积运算汇总为一个大的矩阵乘积，而在 Numpy库中，矩阵计算都进行过高度优化，因此我们可以实现更高效的计算。</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-09-02-110656.png" style="zoom:40%;" /></p><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">im2col</span>(<span class="hljs-params">input_data, filter_h, filter_w, stride = <span class="hljs-number">1</span>, pad = <span class="hljs-number">0</span></span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Parameters</span><br><span class="hljs-string">    ----------</span><br><span class="hljs-string">    input_data : 由(数据量, 通道, 高, 长)的4维数组构成的输入数据</span><br><span class="hljs-string">    filter_h : 滤波器的高</span><br><span class="hljs-string">    filter_w : 滤波器的长</span><br><span class="hljs-string">    stride : 步幅</span><br><span class="hljs-string">    pad : 填充</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns</span><br><span class="hljs-string">    -------</span><br><span class="hljs-string">    col : 2维数组</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    N, C, H, W = input_data.shape<br>    out_h = (H + <span class="hljs-number">2</span> * pad - filter_h) // stride + <span class="hljs-number">1</span><br>    out_w = (W + <span class="hljs-number">2</span> * pad - filter_w) // stride + <span class="hljs-number">1</span><br><br>    img = np.pad(input_data, [(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), (pad, pad), (pad, pad)], <span class="hljs-string">&quot;constant&quot;</span>)<br>    col = np.zeros((N, C, filter_h, filter_w, out_h, out_w))<br><br>    <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(filter_h):<br>        y_max = y + stride * out_h<br>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(filter_w):<br>            x_max = x + stride * out_w<br>            col[:, :, y, x, :, :] = img[:, :, y : y_max : stride, x : x_max : stride]<br><br>    col = col.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>).reshape(N * out_h * out_w, -<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> col<br></code></pre></td></tr></table></figure><h5 id="卷积层实现">卷积层实现</h5><p>利用上述 <code>im2col</code> 技巧，我们就可以实现卷积层了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Convolution</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, W, b, stride = <span class="hljs-number">1</span>, pad = <span class="hljs-number">0</span></span>):<br>        self.W = W<br>        self.b = b<br>        self.stride = stride<br>        self.pad = pad<br><br>        <span class="hljs-comment"># 中间数据（backward时使用）</span><br>        self.x = <span class="hljs-literal">None</span><br>        self.col = <span class="hljs-literal">None</span><br>        self.col_W = <span class="hljs-literal">None</span><br><br>        <span class="hljs-comment"># 权重和偏置参数的梯度</span><br>        self.dW = <span class="hljs-literal">None</span><br>        self.db = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        FN, C, FH, FW = self.W.shape<br>        N, C, H, W = x.shape<br>        out_h = <span class="hljs-number">1</span> + <span class="hljs-built_in">int</span>((H + <span class="hljs-number">2</span> * self.pad - FH) / self.stride)<br>        out_w = <span class="hljs-number">1</span> + <span class="hljs-built_in">int</span>((W + <span class="hljs-number">2</span> * self.pad - FW) / self.stride)<br><br>        col = im2col(x, FH, FW, self.stride, self.pad)<br>        col_W = self.W.reshape(FN, -<span class="hljs-number">1</span>).T<br><br>        out = np.dot(col, col_W) + self.b<br>        out = out.reshape(N, out_h, out_w, -<span class="hljs-number">1</span>).transpose(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><br>        self.x = x<br>        self.col = col<br>        self.col_W = col_W<br><br>        <span class="hljs-keyword">return</span> out<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, dout</span>):<br>        FN, C, FH, FW = self.W.shape<br>        dout = dout.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>).reshape(-<span class="hljs-number">1</span>, FN)<br><br>        self.db = np.<span class="hljs-built_in">sum</span>(dout, axis=<span class="hljs-number">0</span>)<br>        self.dW = np.dot(self.col.T, dout)<br>        self.dW = self.dW.transpose(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>).reshape(FN, C, FH, FW)<br><br>        dcol = np.dot(dout, self.col_W.T)<br>        dx = col2im(dcol, self.x.shape, FH, FW, self.stride, self.pad)<br><br>        <span class="hljs-keyword">return</span> dx<br></code></pre></td></tr></table></figure><p class="note note-info">事实上使用 im2col 后的卷积层与 Affine层的实现是差不多的，这里在反向传播的时候需要使用 im2col 的逆操作 col2im来恢复数组。</p><h5 id="池化层实现">池化层实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pooling</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, pool_h, pool_w, stride=<span class="hljs-number">1</span>, pad=<span class="hljs-number">0</span></span>):<br>        self.pool_h = pool_h<br>        self.pool_w = pool_w<br>        self.stride = stride<br>        self.pad = pad<br><br>        self.x = <span class="hljs-literal">None</span><br>        self.arg_max = <span class="hljs-literal">None</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        N, C, H, W = x.shape<br>        out_h = <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span> + (H - self.pool_h) / self.stride)<br>        out_w = <span class="hljs-built_in">int</span>(<span class="hljs-number">1</span> + (W - self.pool_w) / self.stride)<br><br>        col = im2col(x, self.pool_h, self.pool_w, self.stride, self.pad)<br>        col = col.reshape(-<span class="hljs-number">1</span>, self.pool_h * self.pool_w)<br><br>        arg_max = np.argmax(col, axis=<span class="hljs-number">1</span>)<br>        out = np.<span class="hljs-built_in">max</span>(col, axis=<span class="hljs-number">1</span>)<br>        out = out.reshape(N, out_h, out_w, C).transpose(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><br>        self.x = x<br>        self.arg_max = arg_max<br><br>        <span class="hljs-keyword">return</span> out<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">backward</span>(<span class="hljs-params">self, dout</span>):<br>        dout = dout.transpose(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>)<br><br>        pool_size = self.pool_h * self.pool_w<br>        dmax = np.zeros((dout.size, pool_size))<br>        dmax[np.arange(self.arg_max.size), self.arg_max.flatten()] = dout.flatten()<br>        dmax = dmax.reshape(dout.shape + (pool_size, ))<br><br>        dcol = dmax.reshape(dmax.shape[<span class="hljs-number">0</span>] * dmax.shape[<span class="hljs-number">1</span>] * dmax.shape[<span class="hljs-number">2</span>], -<span class="hljs-number">1</span>)<br>        dx = col2im(dcol, self.x.shape, self.pool_h, self.pool_w, self.stride, self.pad)<br><br>        <span class="hljs-keyword">return</span> dx<br></code></pre></td></tr></table></figure><h4 id="cnn-的代码实现">CNN 的代码实现</h4><p>基于上述讨论，我们就可以实现一个完整的 CNN 神经网络了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleConvNet</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;简单的ConvNet</span><br><span class="hljs-string"></span><br><span class="hljs-string">    conv - relu - pool - affine - relu - affine - softmax</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Parameters</span><br><span class="hljs-string">    ----------</span><br><span class="hljs-string">    input_size : 输入大小（MNIST的情况下为784）</span><br><span class="hljs-string">    hidden_size_list : 隐藏层的神经元数量的列表（e.g. [100, 100, 100]）</span><br><span class="hljs-string">    output_size : 输出大小（MNIST的情况下为10）</span><br><span class="hljs-string">    activation : &#x27;relu&#x27; or &#x27;sigmoid&#x27;</span><br><span class="hljs-string">    weight_init_std : 指定权重的标准差（e.g. 0.01）</span><br><span class="hljs-string">        指定&#x27;relu&#x27;或&#x27;he&#x27;的情况下设定“He的初始值”</span><br><span class="hljs-string">        指定&#x27;sigmoid&#x27;或&#x27;xavier&#x27;的情况下设定“Xavier的初始值”</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params"></span><br><span class="hljs-params">        self,</span><br><span class="hljs-params">        input_dim=(<span class="hljs-params"><span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span></span>),</span><br><span class="hljs-params">        conv_param=&#123;<span class="hljs-string">&quot;filter_num&quot;</span>: <span class="hljs-number">30</span>, <span class="hljs-string">&quot;filter_size&quot;</span>: <span class="hljs-number">5</span>, <span class="hljs-string">&quot;pad&quot;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&quot;stride&quot;</span>: <span class="hljs-number">1</span>&#125;,</span><br><span class="hljs-params">        hidden_size=<span class="hljs-number">100</span>,</span><br><span class="hljs-params">        output_size=<span class="hljs-number">10</span>,</span><br><span class="hljs-params">        weight_init_std=<span class="hljs-number">0.01</span>,</span><br><span class="hljs-params">    </span>):<br>        filter_num = conv_param[<span class="hljs-string">&quot;filter_num&quot;</span>]<br>        filter_size = conv_param[<span class="hljs-string">&quot;filter_size&quot;</span>]<br>        filter_pad = conv_param[<span class="hljs-string">&quot;pad&quot;</span>]<br>        filter_stride = conv_param[<span class="hljs-string">&quot;stride&quot;</span>]<br>        input_size = input_dim[<span class="hljs-number">1</span>]<br>        conv_output_size = (<br>            input_size - filter_size + <span class="hljs-number">2</span> * filter_pad<br>        ) / filter_stride + <span class="hljs-number">1</span><br>        pool_output_size = <span class="hljs-built_in">int</span>(<br>            filter_num * (conv_output_size / <span class="hljs-number">2</span>) * (conv_output_size / <span class="hljs-number">2</span>)<br>        )<br><br>        <span class="hljs-comment"># 初始化权重</span><br>        self.params = &#123;&#125;<br>        self.params[<span class="hljs-string">&quot;W1&quot;</span>] = weight_init_std * np.random.randn(<br>            filter_num, input_dim[<span class="hljs-number">0</span>], filter_size, filter_size<br>        )<br>        self.params[<span class="hljs-string">&quot;b1&quot;</span>] = np.zeros(filter_num)<br>        self.params[<span class="hljs-string">&quot;W2&quot;</span>] = weight_init_std * np.random.randn(<br>            pool_output_size, hidden_size<br>        )<br>        self.params[<span class="hljs-string">&quot;b2&quot;</span>] = np.zeros(hidden_size)<br>        self.params[<span class="hljs-string">&quot;W3&quot;</span>] = weight_init_std * np.random.randn(hidden_size, output_size)<br>        self.params[<span class="hljs-string">&quot;b3&quot;</span>] = np.zeros(output_size)<br><br>        <span class="hljs-comment"># 生成层</span><br>        self.layers = OrderedDict()<br>        self.layers[<span class="hljs-string">&quot;Conv1&quot;</span>] = Convolution(<br>            self.params[<span class="hljs-string">&quot;W1&quot;</span>],<br>            self.params[<span class="hljs-string">&quot;b1&quot;</span>],<br>            conv_param[<span class="hljs-string">&quot;stride&quot;</span>],<br>            conv_param[<span class="hljs-string">&quot;pad&quot;</span>],<br>        )<br>        self.layers[<span class="hljs-string">&quot;Relu1&quot;</span>] = Relu()<br>        self.layers[<span class="hljs-string">&quot;Pool1&quot;</span>] = Pooling(pool_h = <span class="hljs-number">2</span>, pool_w = <span class="hljs-number">2</span>, stride = <span class="hljs-number">2</span>)<br>        self.layers[<span class="hljs-string">&quot;Affine1&quot;</span>] = Affine(self.params[<span class="hljs-string">&quot;W2&quot;</span>], self.params[<span class="hljs-string">&quot;b2&quot;</span>])<br>        self.layers[<span class="hljs-string">&quot;Relu2&quot;</span>] = Relu()<br>        self.layers[<span class="hljs-string">&quot;Affine2&quot;</span>] = Affine(self.params[<span class="hljs-string">&quot;W3&quot;</span>], self.params[<span class="hljs-string">&quot;b3&quot;</span>])<br><br>        self.last_layer = SoftmaxWithLoss()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">predict</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> self.layers.values():<br>            x = layer.forward(x)<br><br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">loss</span>(<span class="hljs-params">self, x, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;求损失函数</span><br><span class="hljs-string">        参数x是输入数据、t是教师标签</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        y = self.predict(x)<br>        <span class="hljs-keyword">return</span> self.last_layer.forward(y, t)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">self, x, t, batch_size = <span class="hljs-number">100</span></span>):<br>        <span class="hljs-keyword">if</span> t.ndim != <span class="hljs-number">1</span>:<br>            t = np.argmax(t, axis=<span class="hljs-number">1</span>)<br><br>        acc = <span class="hljs-number">0.0</span><br><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">int</span>(x.shape[<span class="hljs-number">0</span>] / batch_size)):<br>            tx = x[i * batch_size : (i + <span class="hljs-number">1</span>) * batch_size]<br>            tt = t[i * batch_size : (i + <span class="hljs-number">1</span>) * batch_size]<br>            y = self.predict(tx)<br>            y = np.argmax(y, axis=<span class="hljs-number">1</span>)<br>            acc += np.<span class="hljs-built_in">sum</span>(y == tt)<br><br>        <span class="hljs-keyword">return</span> acc / x.shape[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">numerical_gradient</span>(<span class="hljs-params">self, x, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;求梯度（数值微分）</span><br><span class="hljs-string">        </span><br><span class="hljs-string">        Parameters</span><br><span class="hljs-string">        ----------</span><br><span class="hljs-string">        x : 输入数据</span><br><span class="hljs-string">        t : 教师标签</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Returns</span><br><span class="hljs-string">        -------</span><br><span class="hljs-string">        具有各层的梯度的字典变量</span><br><span class="hljs-string">            grads[&#x27;W1&#x27;]、grads[&#x27;W2&#x27;]、...是各层的权重</span><br><span class="hljs-string">            grads[&#x27;b1&#x27;]、grads[&#x27;b2&#x27;]、...是各层的偏置</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        loss_w = <span class="hljs-keyword">lambda</span> w: self.loss(x, t)<br><br>        grads = &#123;&#125;<br>        <span class="hljs-keyword">for</span> idx <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>):<br>            grads[<span class="hljs-string">&quot;W&quot;</span> + <span class="hljs-built_in">str</span>(idx)] = numerical_gradient(<br>                loss_w, self.params[<span class="hljs-string">&quot;W&quot;</span> + <span class="hljs-built_in">str</span>(idx)]<br>            )<br>            grads[<span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-built_in">str</span>(idx)] = numerical_gradient(<br>                loss_w, self.params[<span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-built_in">str</span>(idx)]<br>            )<br><br>        <span class="hljs-keyword">return</span> grads<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">gradient</span>(<span class="hljs-params">self, x, t</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;求梯度（误差反向传播法）</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Parameters</span><br><span class="hljs-string">        ----------</span><br><span class="hljs-string">        x : 输入数据</span><br><span class="hljs-string">        t : 教师标签</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Returns</span><br><span class="hljs-string">        -------</span><br><span class="hljs-string">        具有各层的梯度的字典变量</span><br><span class="hljs-string">            grads[&#x27;W1&#x27;]、grads[&#x27;W2&#x27;]、...是各层的权重</span><br><span class="hljs-string">            grads[&#x27;b1&#x27;]、grads[&#x27;b2&#x27;]、...是各层的偏置</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># forward</span><br>        self.loss(x, t)<br><br>        <span class="hljs-comment"># backward</span><br>        dout = <span class="hljs-number">1</span><br>        dout = self.last_layer.backward(dout)<br><br>        layers = <span class="hljs-built_in">list</span>(self.layers.values())<br>        layers.reverse()<br>        <span class="hljs-keyword">for</span> layer <span class="hljs-keyword">in</span> layers:<br>            dout = layer.backward(dout)<br><br>        <span class="hljs-comment"># 设定</span><br>        grads = &#123;&#125;<br>        grads[<span class="hljs-string">&quot;W1&quot;</span>], grads[<span class="hljs-string">&quot;b1&quot;</span>] = self.layers[<span class="hljs-string">&quot;Conv1&quot;</span>].dW, self.layers[<span class="hljs-string">&quot;Conv1&quot;</span>].db<br>        grads[<span class="hljs-string">&quot;W2&quot;</span>], grads[<span class="hljs-string">&quot;b2&quot;</span>] = self.layers[<span class="hljs-string">&quot;Affine1&quot;</span>].dW, self.layers[<span class="hljs-string">&quot;Affine1&quot;</span>].db<br>        grads[<span class="hljs-string">&quot;W3&quot;</span>], grads[<span class="hljs-string">&quot;b3&quot;</span>] = self.layers[<span class="hljs-string">&quot;Affine2&quot;</span>].dW, self.layers[<span class="hljs-string">&quot;Affine2&quot;</span>].db<br><br>        <span class="hljs-keyword">return</span> grads<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_params</span>(<span class="hljs-params">self, file_name=<span class="hljs-string">&quot;params.pkl&quot;</span></span>):<br>        params = &#123;&#125;<br>        <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> self.params.items():<br>            params[key] = val<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;wb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            pickle.dump(params, f)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_params</span>(<span class="hljs-params">self, file_name=<span class="hljs-string">&quot;params.pkl&quot;</span></span>):<br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&quot;rb&quot;</span>) <span class="hljs-keyword">as</span> f:<br>            params = pickle.load(f)<br>        <span class="hljs-keyword">for</span> key, val <span class="hljs-keyword">in</span> params.items():<br>            self.params[key] = val<br><br>        <span class="hljs-keyword">for</span> i, key <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>([<span class="hljs-string">&quot;Conv1&quot;</span>, <span class="hljs-string">&quot;Affine1&quot;</span>, <span class="hljs-string">&quot;Affine2&quot;</span>]):<br>            self.layers[key].W = self.params[<span class="hljs-string">&quot;W&quot;</span> + <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>)]<br>            self.layers[key].b = self.params[<span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-built_in">str</span>(i + <span class="hljs-number">1</span>)]<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>NumPy</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Div.2 Round 882 总结</title>
    <link href="/2023/07/09/Div.2%20Round%20882%20%E6%80%BB%E7%BB%93/"/>
    <url>/2023/07/09/Div.2%20Round%20882%20%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1847">比赛链接</a></p><p>这一场整体下来感觉难度适中，对位运算性质的考查较多，个人感觉 A、B、C比较简单。</p><hr /><h4 id="a-the-man-who-became-a-god">A 「The Man who became a God」</h4><p>我们不妨假设起初所有村庄都是一个整体，那么 <code>suspicion</code>的值就是所有相邻村庄的怀疑值差值的绝对值总和，<em>Kars</em> 对村庄进行<span class="math inline">\(k - 1\)</span> 次分割将其划分为 <spanclass="math inline">\(k\)</span> 个部分，假设分割村庄 <spanclass="math inline">\((i, i + 1)\)</span> ，那 <code>suspicion</code>就在原来的基础上减去一个 <span class="math inline">\(|a_i - a_{i+1}|\)</span> ，要得到最小的 <code>suspicion</code>，换言之我们只需要找到最大的 <span class="math inline">\(k - 1\)</span>个相邻元素差值的绝对值即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(nlogn)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 105</span><br><br><span class="hljs-type">int</span> arr[MAX_N];<br><span class="hljs-type">int</span> diff[MAX_N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    std::cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) std::cin &gt;&gt; arr[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) diff[i] = <span class="hljs-built_in">abs</span>(arr[i] - arr[i - <span class="hljs-number">1</span>]);<br>    std::<span class="hljs-built_in">sort</span>(diff + <span class="hljs-number">1</span>, diff + n, std::<span class="hljs-built_in">greater</span>&lt;<span class="hljs-type">int</span>&gt;());<br><br>    <span class="hljs-type">int</span> s1 = std::<span class="hljs-built_in">accumulate</span>(diff + <span class="hljs-number">1</span>, diff + n, <span class="hljs-number">0</span>);<br>    <span class="hljs-type">int</span> s2 = std::<span class="hljs-built_in">accumulate</span>(diff + <span class="hljs-number">1</span>, diff + k, <span class="hljs-number">0</span>);<br><br>    std::cout &lt;&lt; s1 - s2 &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b-hamon-odyssey">B 「Hamon Odyssey」</h4><p>注意到，对于正整数 <span class="math inline">\(x\)</span>、<spanclass="math inline">\(y\)</span> 而言，一定有 <spanclass="math inline">\(x + y \geq x\ \&amp;\ y\)</span>，<spanclass="math inline">\((x, y) = (0, 0)\)</span>时取等，因此如果合并后的有两个相邻的数不全为0，则可以继续合并使结果严格减小。</p><p>综上所述，我们可以得到：</p><ul><li>若所有数的数位与不为0，那将所有数字合并为一个整体一定最小，且只能将所有数合并为一个整体时取最小值。</li><li>若所有数的数位与为0，则考虑将数组分割为尽可能多的片段，每个片段的所有数的数位与为 0。</li></ul><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, s = <span class="hljs-number">0xffffffff</span>, x; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; x;<br>        s &amp;= x;<br>        <span class="hljs-keyword">if</span> (!s) &#123;<br>            s = <span class="hljs-number">0xffffffff</span>;<br>            res++;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; (res == <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : res) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c-vampiric-powers-anyone">C 「Vampiric Powers, anyone?」</h4><p>不难证明每一次操作得到的数都是某段连续序列的异或值。因此本题只需要找到最大的连续异或值即可。暴力求解显然会超时，所以最开始我想的是怎么用DP，后面发现 <span class="math inline">\((0 \leq a_i &lt; 2 ^8)\)</span>，也就是说所有数字只有 256种取值，因此我们使用一个哈希表维护前缀异或即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    std::unordered_set&lt;<span class="hljs-type">int</span>&gt; s;<br>    s.<span class="hljs-built_in">insert</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, r = <span class="hljs-number">0</span>, x; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; x;<br>        r ^= x;<br>        s.<span class="hljs-built_in">insert</span>(r);<br>    &#125;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : s) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> y : s) &#123;<br>            res = std::<span class="hljs-built_in">max</span>(res, x ^ y);<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="d-professor-higashikata">D 「Professor Higashikata」</h4><p>贪心策略，我们假设 <span class="math inline">\(f(i)\)</span> 表示<span class="math inline">\(t(s)[i]\)</span>对应原字符串的下标，那么最右策略就是最大化 <spanclass="math inline">\(k\)</span> 使得 <spanclass="math inline">\(s_{f(0)} = 1、s_{f(1)} = 1, ..., s_{f(k)} =1\)</span>。事实上，若存在 <span class="math inline">\(i\)</span> 和<span class="math inline">\(j\)</span> 满足 <spanclass="math inline">\(f(i) = f(j) \ (i &lt; j)\)</span> ，则可以不考虑<span class="math inline">\(f(j)\)</span> ，因为 <spanclass="math inline">\(s_{f(i)}\)</span> 和 <spanclass="math inline">\(s_{f(j)}\)</span> 是一样的，且下标 <spanclass="math inline">\(i\)</span> 更靠前，若 <spanclass="math inline">\(s_{f(i)} = 1\)</span> 则必然有 <spanclass="math inline">\(s_{f(j)} = 1\)</span>，所以我们只要求每个下标第一次出现的时间顺序即可，然后将其按照从早到晚进行排序，以题目的第二个输入为例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">8 6 10<br>10011010<br>5 6<br>2 3<br>6 8<br>5 7<br>5 8<br>6 8<br>3<br>5<br>6<br>2<br>5<br>2<br>5<br>8<br>4<br>1<br></code></pre></td></tr></table></figure><p>根据题目依次输入的区间，每个下标的出现时间顺序为<code>5, 6, 2, 3, 7, 8</code>。</p><p>假设原字符串为 <spanclass="math inline">\(str\)</span>，接下来我们只需要最大化 <spanclass="math inline">\(pat =[str[5]、str[6]、str[2]、str[3]、str[7]、str[8]]\)</span>的字典序，即最大化其前缀 1 的数量，其初始状态为<u>100010</u>，第一次翻转了下标为 3 的字符，<spanclass="math inline">\(str\)</span> 更新为 <u>10111010</u>，<spanclass="math inline">\(pat\)</span> 更新为 <u>100110</u>，只需要分别将<span class="math inline">\(str[1]\)</span>、<spanclass="math inline">\(str[4]\)</span> 和 <spanclass="math inline">\(str[6]\)</span>、<spanclass="math inline">\(str[2]\)</span> 交换位置即可使得 <spanclass="math inline">\(pat\)</span>字典序最大，共需要两次操作，不难发现，每次的最小操作数量都等于 <spanclass="math inline">\(pat\)</span> 在 区间 <spanclass="math inline">\([1, min\{num\_of\_ones,\pat.size\}]\)</span>（<span class="math inline">\(num\_of\_ones\)</span>表示 <span class="math inline">\(str\)</span> 中有多少个 1）中 0的个数。</p><p>综上所述，完成本题需要两个步骤：</p><ol type="1"><li>求出每个字符串下标的出现次序。</li><li>根据出现次序构造新字符串 <spanclass="math inline">\(pat\)</span>，每一轮更新后区间 <spanclass="math inline">\([1, min\{num\_of\_ones, pat.size\}]\)</span> 中 0的个数即最小操作数。这一步涉及单点修改和区间查询，可以考虑使用线段树。</li></ol><blockquote><p>时间复杂度：<span class="math inline">\(O((n + m +q)logn)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n + m)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start == end) &#123;<br>            tree[node] = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (idx &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, leftNode, start, mid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, rightNode, mid + <span class="hljs-number">1</span>, end);<br>        &#125;<br><br>        tree[node] = tree[leftNode] + tree[rightNode];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> tree[node];<br><br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(left, right, leftNode, start, mid) + <span class="hljs-built_in">query</span>(left, right, rightNode, mid + <span class="hljs-number">1</span>, end);<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(<span class="hljs-number">4</span> * _n) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">update</span>(idx, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(left, right, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    std::cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    std::string str;<br>    std::cin &gt;&gt; str;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; pat; <span class="hljs-comment">// 记录在区间内出现过的数，按照第一次出现的时间排序</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pos</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>; <span class="hljs-comment">// 原字符串在 pat 串的索引，-1 表示不存在</span><br>    std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; ranges;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, l, r; i &lt; m; i++) &#123;<br>        std::cin &gt;&gt; l &gt;&gt; r;<br>        ranges.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">make_pair</span>(l - <span class="hljs-number">1</span>, r - <span class="hljs-number">1</span>));<br>    &#125;<br>    std::set&lt;<span class="hljs-type">int</span>&gt; s;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) s.<span class="hljs-built_in">insert</span>(i); <span class="hljs-comment">// s 存储没有目前出现过的数字</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; r : ranges) &#123;<br>        <span class="hljs-keyword">auto</span> iter = s.<span class="hljs-built_in">lower_bound</span>(r.first); <span class="hljs-comment">// *iter &gt;= r.first</span><br>        std::vector&lt;<span class="hljs-type">int</span>&gt; toErase; <span class="hljs-comment">// 将要删除的数字</span><br>        <span class="hljs-keyword">while</span> (iter != s.<span class="hljs-built_in">end</span>() &amp;&amp; *iter &lt;= r.second) &#123;<br>            toErase.<span class="hljs-built_in">push_back</span>(*iter);<br>            pat.<span class="hljs-built_in">push_back</span>(*iter);<br>            pos[*iter] = pat.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>            iter++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : toErase) &#123;<br>            s.<span class="hljs-built_in">erase</span>(x);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> np = pat.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">SegTree <span class="hljs-title">st</span><span class="hljs-params">(np)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; np; i++) st.<span class="hljs-built_in">update</span>(i, str[pat[i]] == <span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-type">int</span> cntOne = <span class="hljs-number">0</span>; <span class="hljs-comment">// 1 的数量</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : str) cntOne += ch == <span class="hljs-string">&#x27;1&#x27;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, p; i &lt; q; i++) &#123;<br>        std::cin &gt;&gt; p;<br>        <span class="hljs-type">int</span> idx = pos[p - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 对应的 pat 串下标</span><br>        <span class="hljs-keyword">if</span> (str[p - <span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            str[p - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;0&#x27;</span>;<br>            cntOne--;<br>            <span class="hljs-keyword">if</span> (idx != <span class="hljs-number">-1</span>) st.<span class="hljs-built_in">update</span>(idx, <span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            str[p - <span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>            cntOne++;<br>            <span class="hljs-keyword">if</span> (idx != <span class="hljs-number">-1</span>) st.<span class="hljs-built_in">update</span>(idx, <span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-type">int</span> d = std::<span class="hljs-built_in">min</span>(np, cntOne);<br>        std::cout &lt;&lt; d - st.<span class="hljs-built_in">query</span>(<span class="hljs-number">0</span>, d - <span class="hljs-number">1</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
      <tag>Div.2</tag>
      
      <tag>贪心算法</tag>
      
      <tag>哈希表</tag>
      
      <tag>前缀异或</tag>
      
      <tag>线段树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈尔滨避暑记</title>
    <link href="/2023/07/05/%E5%93%88%E5%B0%94%E6%BB%A8%E9%81%BF%E6%9A%91%E8%AE%B0/"/>
    <url>/2023/07/05/%E5%93%88%E5%B0%94%E6%BB%A8%E9%81%BF%E6%9A%91%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>4号晚上到哈尔滨的火车，本想着睡一觉起来就到了，奈何卧铺实在是睡得不舒服，又挤又热，半夜还有个哥们抖音外放，显然晚上是睡不着了，就这样熬了一晚上，次日凌晨终于到了哈尔滨站。</p><hr /><h4 id="中央大街">中央大街</h4><p>我们的酒店离中央大街只有不到两百米的距离，而许多景区又都是辐射性分布在中央大街附近的，故颇为便利。</p><center><img src="https://p.ipic.vip/jag828.png" style="zoom:20%;" /><img src="https://p.ipic.vip/bswz22.png" style="zoom:15%;" /><img src="https://p.ipic.vip/0bbob0.png" style="zoom:20%;" /><img src="https://p.ipic.vip/pjwuwj.png" style="zoom:20%;" /><img src="https://p.ipic.vip/umegm7.png" style="zoom:25%;" /> <br>中央大街街景，一股浓浓的俄式风格</center><center><img src="https://p.ipic.vip/sk5wk2.png"  style="zoom:20%;" /><img src="https://p.ipic.vip/wspv8l.png"  style="zoom:15%;" /> <br>工艺品商店一角的俄罗斯套娃</center><p>中央大街有一处很显眼的拜占庭风建筑，那便是坐落于索菲亚广场的圣 ·索菲亚教堂，现在已经完全对游客开放了。</p><center><img src="https://p.ipic.vip/jlcx7r.png" style="zoom:15%;" /><img src="https://p.ipic.vip/1drqrd.png" style="zoom:20%;" /><img src="https://p.ipic.vip/0925j3.png" style="zoom:25%;" /><img src="https://p.ipic.vip/xo70zy.png" style="zoom:15%;" /></center><p>再来说下这个俄餐，都是硬菜，量还不小，只能说很符合我对战斗民族的想象。😆</p><center><img src="https://p.ipic.vip/gjcis2.png" style="zoom:20%;" /><img src="https://p.ipic.vip/4fls9x.png" style="zoom:40%;" /><img src="https://p.ipic.vip/bw4ch6.png" alt="俄罗斯果汁" style="zoom:20%;" /><img src="https://p.ipic.vip/379mga.png" alt="战斗民族大拼盘" style="zoom:33%;" /></center><p>然后就是推荐品尝一下这里的鲜酿格瓦斯（到处都有），有一股独特的清香和甘甜，毕竟离原产地更近，那肯定也更正宗一些。</p><h4 id="沿江夜骑">沿江夜骑</h4><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-08-022338.png" style="zoom: 15%;" /></p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-08-022407.png" style="zoom: 25%;" /></p><h4 id="罪证陈列馆">731 罪证陈列馆</h4><center><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-08-023235.png" style="zoom:20%;" /><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-08-023310.png" style="zoom:20%;" /><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-08-023521.png" style="zoom:30%;" /><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-08-023347.png" style="zoom:20%;" /><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-08-023436.png" style="zoom:20%;" /><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-08-023658.png" style="zoom:33%;" /><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-08-023748.png" style="zoom:33%;" /></center>]]></content>
    
    
    <categories>
      
      <category>日常</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈尔滨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Educational Div.2 Round 151 总结</title>
    <link href="/2023/07/01/Educational%20Div.2%20Round%20151%20%E6%80%BB%E7%BB%93/"/>
    <url>/2023/07/01/Educational%20Div.2%20Round%20151%20%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1845">比赛链接</a></p><hr /><h4 id="a-forbidden-integer">A 「Forbidden Integer」</h4><p>这个没啥好说的，分类讨论一下就行。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(1)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, k, x;<br>    std::cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;<br>    <span class="hljs-keyword">if</span> (x != <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span> &lt;&lt; n &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) std::cout &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// x == 1</span><br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (k == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span> &lt;&lt; n / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">2</span>) &#123;<br>                std::cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n - <span class="hljs-number">2</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// k &gt;= 3</span><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// n &gt;= 2</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span> &lt;&lt; n / <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">while</span> (n) &#123;<br>        <span class="hljs-keyword">if</span> (n &amp; <span class="hljs-number">1</span>) &#123;<br>            n -= <span class="hljs-number">3</span>;<br>            std::cout &lt;&lt; <span class="hljs-number">3</span> &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[n == <span class="hljs-number">0</span>];<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            n -= <span class="hljs-number">2</span>;<br>            std::cout &lt;&lt; <span class="hljs-number">2</span> &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[n == <span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b-come-together">B 「Come Together」</h4><p>这个也没啥好说的，只需要看 B、C 和 A的相对位置然后分类讨论一下即可。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(1)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> xa, ya, xb, yb, xc, yc;<br>    std::cin &gt;&gt; xa &gt;&gt; ya &gt;&gt; xb &gt;&gt; yb &gt;&gt; xc &gt;&gt; yc;<br>    xb -= xa, xc -= xa;<br>    yb -= ya, yc -= ya;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">bool</span> same_x = (i64)xb * xc &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-type">bool</span> same_y = (i64)yb * yc &gt;= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (same_x) &#123;<br>        <span class="hljs-comment">// xb xc 同号</span><br>        <span class="hljs-keyword">if</span> (same_y) &#123;<br>            res += std::<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(xb), <span class="hljs-built_in">abs</span>(xc)) + std::<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(yb), <span class="hljs-built_in">abs</span>(yc));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            res += std::<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(xb), <span class="hljs-built_in">abs</span>(xc));<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// xb xc 异号</span><br>        <span class="hljs-keyword">if</span> (same_y) &#123;<br>            res += std::<span class="hljs-built_in">min</span>(<span class="hljs-built_in">abs</span>(yb), <span class="hljs-built_in">abs</span>(yc));<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c-strong-password">C 「Strong Password」</h4><p>考虑贪心策略，每一次从限定条件中选取最晚在<code>database string</code> 中出现的字符，这样可以尽可能快地消耗掉<code>database string</code>的前缀，如果中途出现了后缀中不存在的限定条件内的字符，则说明存在答案，反之说明不存在。</p><p>为了记录 <code>database string</code>所有后缀中字符的出现时间，我们需要一个数组来维护每个后缀所有字符出现的最小索引。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(nm)\)</span></p><p>空间复杂度：<span class="math inline">\(O(nm)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 0x7f7f7f7f</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string dat;<br>    std::cin &gt;&gt; dat;<br><br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    std::string l, r;<br>    std::cin &gt;&gt; l &gt;&gt; r;<br><br>    <span class="hljs-type">int</span> len = dat.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-comment">// 记录区间 [i, len - 1] 中每个数出现的最早下标</span><br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">nextIdx</span>(len + <span class="hljs-number">1</span>);<br>    nextIdx.<span class="hljs-built_in">back</span>() = std::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">10</span>, INF);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = len - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        nextIdx[i] = nextIdx[i + <span class="hljs-number">1</span>];<br>        nextIdx[i][dat[i] - <span class="hljs-string">&#x27;0&#x27;</span>] = i;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        p = *std::<span class="hljs-built_in">max_element</span>(nextIdx[p].<span class="hljs-built_in">begin</span>() + l[i] - <span class="hljs-string">&#x27;0&#x27;</span>, nextIdx[p].<span class="hljs-built_in">begin</span>() + r[i] - <span class="hljs-string">&#x27;0&#x27;</span> + <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>; <span class="hljs-comment">// 找到最晚出现的数字</span><br>        <span class="hljs-keyword">if</span> (p &gt;= INF) &#123;<br>            <span class="hljs-comment">// 出现无法找到的数字</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <br>    std::cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
      <tag>Div.2</tag>
      
      <tag>贪心算法</tag>
      
      <tag>分类讨论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CodeTon Round 5 总结</title>
    <link href="/2023/06/28/CodeTon%20Round%205%20%E6%80%BB%E7%BB%93/"/>
    <url>/2023/06/28/CodeTon%20Round%205%20%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1842">比赛链接</a></p><p>这一场打得一般，因为太困了。😢</p><hr /><h4 id="a-tenzing-and-tsondu">A 「Tenzing and Tsondu」</h4><p>水题，易证总和高的人必胜，总和相等则平局。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    i64 sum_1 = <span class="hljs-number">0</span>, sum_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; x;<br>        sum_1 += x;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x; i &lt; m; i++) &#123;<br>        std::cin &gt;&gt; x;<br>        sum_2 += x;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum_1 &gt; sum_2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Tsondu\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum_1 &lt; sum_2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Tenzing\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Draw\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b-tenzing-and-books">B 「Tenzing and Books」</h4><p>根据题意，如果某本书的 <code>knowledge</code> 某个 bit 位为 1 而<code>x</code> 在该位为 0，即满足 <code>knowledge &amp; ~x</code> 非0，则该书一定不能选取，根据栈的性质，该书以下的书也不能选取。</p><p>而或运算对于 3个栈的操作顺序本身而言没有影响，所以我们依次遍历每个栈即可，如果遍历过程中出现不能选择的书，那么就结束该轮循环，进入下一个栈，3轮循环中如果出现某个状态等于 <code>x</code> ，则说明可以使得<code>knowledge</code> 的值等于 <code>x</code> ，若 3轮循环结束后都没有得到目标答案，则说明无法使得 <code>knowledge</code>的值等于 <code>x</code> 。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 100005</span><br><br><span class="hljs-type">int</span> stk[<span class="hljs-number">3</span>][MAX_N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, x;<br>    std::cin &gt;&gt; n &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            std::cin &gt;&gt; stk[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> mask = ~x, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (stk[i][j] &amp; mask) <span class="hljs-keyword">break</span>;<br>            ans |= stk[i][j];<br>            <span class="hljs-keyword">if</span> (ans == x) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c-tenzing-and-balls">C 「Tenzing and Balls」</h4><p>若存在 <span class="math inline">\(i、 j、 m、 n\)</span> 使得 <spanclass="math inline">\(a_i = a_j\)</span> 且 <spanclass="math inline">\(a_m = a_n\)</span> ，则考虑区间 <spanclass="math inline">\([i, j]\)</span> 和 <span class="math inline">\([m,n]\)</span> ：</p><ul><li>若两个区间无交集，则两个区间都可以删除且互不影响；</li><li>若两个区间是包含关系，不妨设 <span class="math inline">\([i, j]\subsetneq [m, n]\)</span>，则 <span class="math inline">\([i,j]\)</span> 只能在 <span class="math inline">\([m, n]\)</span>之前删除，而删除 <span class="math inline">\([i, j]\)</span> 再删除<span class="math inline">\([m, n]\)</span> 与直接删除 <spanclass="math inline">\([m, n]\)</span> 的效果是一样的；</li><li>若两个区间相交且不为包含关系，则只能删除其中一个区间。</li></ul><p>综上所述，问题就变成了如何选取不相交的区间，使得选取的区间总长度最长。</p><p>我们假设 <span class="math inline">\(dp[i]\)</span> 表示区间 <spanclass="math inline">\([0, i]\)</span> 删除完后剩下来的数的最小值，<spanclass="math inline">\(dp[0]\)</span> 初始化为1，我们可以得到以下关系：</p><ul><li>若不删除 <span class="math inline">\(a_i\)</span> ，则 <spanclass="math inline">\(dp[i] = dp[i - 1] + 1\)</span></li><li>若能删除 <span class="math inline">\(a_i\)</span> ，则 <spanclass="math inline">\(dp[i] = \underset{j}{min}\ \{dp[j]\ |\ j &lt; i -1 \land a_{j + 1} = a_i \}\)</span></li></ul><p>于是，我们就得到了状态转移方程：<span class="math inline">\(dp[i] =min\{dp[i - 1] + 1,\ \underset{j}{min}\ \{dp[j]\ |\ j &lt; i - 1 \landa_{j + 1} = a_i \}\)</span></p><p>而对于 <span class="math inline">\(\underset{j}{min}\ \{dp[j]\ |\ j&lt; i - 1 \land a_{j + 1} = a_i \}\)</span>这一项，我们考虑使用一个数组更新每轮迭代后满足 <spanclass="math inline">\(a_{j + 1} = a_i\)</span> 的最小 <spanclass="math inline">\(dp[j]\)</span> 的值即可。迭代完后 <spanclass="math inline">\(n - dp[n - 1]\)</span> 即为可删除的最大数量。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 200005</span><br><br><span class="hljs-type">int</span> arr[MAX_N];<br><span class="hljs-type">int</span> dp[MAX_N]; <span class="hljs-comment">// 最少剩多少个</span><br><span class="hljs-type">int</span> memo[MAX_N]; <span class="hljs-comment">// memo[t] 表示满足 arr[j + 1] == t 的所有数里面 dp[j] 的最小值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; arr[i];<br>        dp[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(memo + <span class="hljs-number">1</span>, <span class="hljs-number">0x7f</span>, n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    memo[arr[<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = std::<span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, memo[arr[i]]);<br>        memo[arr[i]] = std::<span class="hljs-built_in">min</span>(memo[arr[i]], dp[i - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    std::cout &lt;&lt; n - dp[n - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="d-tenzing-and-his-animal-friends">D 「Tenzing and His AnimalFriends」</h4><p>题目有点抽象，大概就是说全部轮游戏中 <spanclass="math inline">\(u_i\)</span> 和 <spanclass="math inline">\(v_i\)</span> 的分开游戏时间总和均不超过 <spanclass="math inline">\(y_i\)</span>，即 <spanclass="math inline">\(u_i\)</span> 不和 <spanclass="math inline">\(v_i\)</span> 玩的游玩时间不超过 <spanclass="math inline">\(y_i\)</span> ，对 <spanclass="math inline">\(v_i\)</span> 也是同理。于此同时，顶点 1每轮游戏都要参加，顶点 n 每轮游戏都不能参加。</p><p>我们接下来将所有的限制看成一个无向图，若存在限制 <spanclass="math inline">\((u_i, v_i, y_i)\)</span>，那么就在顶点 <spanclass="math inline">\(u_i\)</span> 和 <spanclass="math inline">\(v_i\)</span> 之间连接一条权重为 <spanclass="math inline">\(y_i\)</span> 的边。</p><p>考虑以下两种情况：</p><ul><li><p>若顶点 1 无法在有限步内到顶点 n，就说明顶点 1 和顶点 n属于不同的分支，那我们每次可以和顶点 1所在分支全部顶点一起玩，且没有时间限制。此时答案为 <code>inf</code>。</p></li><li><p>若顶点 1 可以到达顶点 n，我们假设其中一条路径为 <spanclass="math inline">\(&lt;1, k_1, k_2, ..., k_m, n&gt;\)</span>，每个顶点的游玩时间为 <span class="math inline">\(t_1, t_{k_1},t_{k_2}, ..., t_{k_m}, t_n\)</span>。</p><p>因为顶点 1 每轮游戏都参与，所以<strong>顶点 1游玩的时间就是总的游戏时间</strong>，因此我们只要求出 <spanclass="math inline">\(t_1\)</span> 的最小值即可。</p><p>由于一对顶点 <span class="math inline">\((x, y)\)</span>分开的时间不超过 <span class="math inline">\(d(x,y)\)</span>，我们可以得到：<span class="math inline">\(t_x - t_y \leqd(x, y)\)</span>。</p><p>所以有： <span class="math display">\[  \begin{array}{}  t_1 - t_{k_1} \leq d(1, k_1) \\  t_{k_1} - t_{k_2} \leq d(k_1, k_2) \\  ... \\  t_{k_m} - t_{n} \leq d(k_m, n)  \end{array}  \]</span> 将上式求和： <span class="math display">\[  \implies t_1 - t_n \leq d(1, k_1) + d(k_1, k_2) + ... + d(k_m, n)  \]</span> 又因为顶点 n 不参与游戏，所以 <spanclass="math inline">\(t_n = 0\)</span>，综上所述： <spanclass="math display">\[  t_1 \leq d(1, k_1) + d(k_1, k_2) + ... + d(k_m, n)  \]</span> 右式其实就是顶点 1 到顶点 n的路径长度，换言之，<strong>游戏的时长必须小于等于所有顶点 1 到顶点 n的路径长度</strong>。所以我们只要求出顶点 1 到顶点 n到最短路径即可，考虑最小堆优化的 Dijkstra算法，并用一个数组记录每次出队列的顶点。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(mlog(m + n))\)</span></p><p>空间复杂度：<span class="math inline">\(O(n + m)\)</span></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, u, v, y; i &lt; m; i++) &#123;<br>        std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; y;<br>        u--;<br>        v--;<br>        g[u].<span class="hljs-built_in">push_back</span>(&#123;v, y&#125;);<br>        g[v].<span class="hljs-built_in">push_back</span>(&#123;u, y&#125;);<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;i64&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    std::priority_queue&lt;std::pair&lt;i64, <span class="hljs-type">int</span>&gt;, std::vector&lt;std::pair&lt;i64, <span class="hljs-type">int</span>&gt;&gt;, std::greater&lt;&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>    std::vector&lt;i64&gt; ans;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, to] = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (dist[to] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>        dist[to] = d;<br>        ans.<span class="hljs-built_in">push_back</span>(to);<br>        <span class="hljs-keyword">if</span> (to == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [nxt, w] : g[to]) &#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;d + w, nxt&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n - <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;inf\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    std::cout &lt;&lt; dist[n - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, len = ans.<span class="hljs-built_in">size</span>(); i &lt; len; i++) &#123;<br>        s[ans[i - <span class="hljs-number">1</span>]] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; dist[ans[i]] - dist[ans[i - <span class="hljs-number">1</span>]] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
      <tag>Div.1</tag>
      
      <tag>Div.2</tag>
      
      <tag>DP</tag>
      
      <tag>Dijkstra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制集合与状压 DP</title>
    <link href="/2023/06/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%9B%86%E5%90%88%E4%B8%8E%E7%8A%B6%E5%8E%8B%20DP/"/>
    <url>/2023/06/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%9B%86%E5%90%88%E4%B8%8E%E7%8A%B6%E5%8E%8B%20DP/</url>
    
    <content type="html"><![CDATA[<h3 id="二进制集合">二进制集合</h3><h4 id="二进制集合介绍">二进制集合介绍</h4><p>利用计算机存储数据的特点，我们可以用二进制数来表示集合。</p><p>设一个集合有 n 个元素，则可以使用一个 n bit的数来表示该集合的所有子集，若该数字第 k 个 bit 位为1，表示存在该元素，为 0 则说明不存在该元素。</p><p>例如，有集合：<span class="math inline">\(U = \{0, 1, 2,3\}\)</span>，则 <u>1111</u> 表示全集 <spanclass="math inline">\(U\)</span>，<u>0000</u> 表示空集 <spanclass="math inline">\(\emptyset\)</span>，<u>1010</u> 表示子集 <spanclass="math inline">\(\{1, 3\}\)</span>。</p><p>一般情况下，若要表示的集合元素数量较少，可以直接使用 <code>int</code>或者 <code>long long</code> 整数来表示，若集合元素的数量大于64，则可以考虑使用 C++ 中的 <code>std::bitset</code>来表示，可以参考笔者之前的文章：<ahref="https://goer17.github.io/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/">std::bitset讲解</a> 。</p><h4 id="二进制集合的运算">二进制集合的运算</h4><p>设有集合 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> ，它们的二进制表示分别为 <code>a</code>和 <code>b</code> ，则常见的集合运算规则如下：</p><table><thead><tr class="header"><th>一元运算</th><th>数学表示</th><th>二进制集合表示</th></tr></thead><tbody><tr class="odd"><td>集合的阶</td><td><span class="math inline">\(|A|\)</span></td><td><code>__builtin_popcount(a)</code>（<code>a</code> 为<code>int</code> 类）<br><code>__builtin_popcountll(a)</code>（<code>a</code> 为 <code>long long</code>类）<br><code>a.count()</code> （<code>a</code> 为<code>std::bitset</code> 类）</td></tr><tr class="even"><td>补集</td><td><span class="math inline">\(\overline{A}\)</span></td><td><code>~a</code></td></tr></tbody></table><table><thead><tr class="header"><th>二元运算</th><th>数学表示</th><th>二进制集合表示</th></tr></thead><tbody><tr class="odd"><td>集合并</td><td><span class="math inline">\(A \cup B\)</span></td><td><code>a | b</code></td></tr><tr class="even"><td>集合交</td><td><span class="math inline">\(A \cap B\)</span></td><td><code>a &amp; b</code></td></tr><tr class="odd"><td>集合差</td><td><span class="math inline">\(A - B\)</span></td><td><code>a &amp; ~b</code></td></tr></tbody></table><h4 id="二进制集合子集的遍历">二进制集合子集的遍历</h4><p>若集合 <span class="math inline">\(X\)</span> 的二进制表示为<code>x</code> ，则逆序遍历 <span class="math inline">\(X\)</span>的非空子集的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> sub = x; sub; sub = (sub - <span class="hljs-number">1</span>) &amp; x) &#123;<br>    <span class="hljs-comment">// s 为 x 的子集</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="状态压缩-dp">状态压缩 DP</h3><p>状态压缩 DP是一种在动态规划算法中使用的优化技巧。它主要应用于具有指数级别状态数的问题，通过将状态用一个整数表示，从而减少内存空间的使用和提高计算效率。这里所说的用一个整数表示状态，也就是上文提到的二进制集合。</p><h4 id="典型示例">典型示例</h4><h5 id="状压-图论">状压 + 图论</h5><p><ahref="https://leetcode.cn/problems/shortest-path-visiting-all-nodes/">ShortestPath Visiting All Nodes</a></p><p>我们设 <span class="math inline">\(dp[i][S]\)</span> 表示从顶点 <spanclass="math inline">\(i\)</span> 出发，需要走完集合 <spanclass="math inline">\(S\)</span>包含的所有点的最小步数，不难得到状态转移方程： <spanclass="math display">\[dp[i][S] = \underset{&lt;i, j&gt; \in G(V, E)}{\text{min}}\ dp[j][S - i]+ 1\]</span>基于此，我们可以用记忆化搜索来解决问题。但由于这里面是可以走回路的，则可能出现无限递归的情况，为了解决这个问题，我们可以在递归函数中对状态<span class="math inline">\((i, S)\)</span> 进行标记（代码中是将 <spanclass="math inline">\(dp[i][S]\)</span>设置为一个特殊的值），保证每个状态只经过一次，这个做法显然是合理的，因为如果从顶点<span class="math inline">\(i\)</span> 出发，走了若干步回到顶点 <spanclass="math inline">\(i\)</span> 后，需要走完的点的集合还是 <spanclass="math inline">\(S\)</span>，则说明这若干步都没有意义，顾可以舍去。</p><p>递归出口： <span class="math display">\[dp[i][S] = 0\ \ \text{if}\ S = \{i\}\]</span> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">12</span>][<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">12</span>]; <span class="hljs-comment">// dp[i][s], 起点为 i, 需要走完集合 s 所有点的最短路径</span><br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>() &#123;<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">shortestPathLength</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = graph.<span class="hljs-built_in">size</span>();<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> s) -&gt; <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-type">int</span>&amp; res = dp[i][s];<br>            <span class="hljs-keyword">if</span> (res &gt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res;<br>            res = <span class="hljs-number">-2</span>; <span class="hljs-comment">// 后续不再处理 dfs(i, s), 避免无限递归</span><br>            s &amp;= ~(<span class="hljs-number">1</span> &lt;&lt; i);<br>            <span class="hljs-keyword">if</span> (s == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> ans = inf;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : graph[i]) &#123;<br>                <span class="hljs-keyword">if</span> (dp[j][s] != <span class="hljs-number">-2</span>) ans = <span class="hljs-built_in">min</span>(ans, <span class="hljs-built_in">dfs</span>(j, s) + <span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> res = ans;<br>        &#125;;<br><br>        <span class="hljs-type">int</span> res = inf;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) res = <span class="hljs-built_in">min</span>(res, <span class="hljs-built_in">dfs</span>(i, (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>));<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="状压-背包">状压 + 背包</h5><p><ahref="https://leetcode.cn/problems/number-of-ways-to-wear-different-hats-to-each-other/">Numberof Ways to Wear Different Hats to Each Other</a></p><p>这道题是背包问题与状态压缩的结合，我们设 <spanclass="math inline">\(dp[i][S]\)</span> 表示可以使用前 <spanclass="math inline">\(i\)</span> 个帽子，分配人员集合为 <spanclass="math inline">\(S\)</span> 的方案数。</p><p>对于 <span class="math inline">\(dp[i][S]\)</span>，若 <spanclass="math inline">\(i &gt; 0\)</span> 且 <spanclass="math inline">\(S\)</span> 非空，则可以分两种情况讨论：</p><ol type="1"><li>所有人都不戴 <span class="math inline">\(\text{hat}_i\)</span>，一共有 <span class="math inline">\(dp[i - 1][S]\)</span> 种方案</li><li>有一个人戴 <span class="math inline">\(\text{hat}_i\)</span>，则我们从集合 <span class="math inline">\(S\)</span> 中选择一个喜欢<span class="math inline">\(\text{hat}_i\)</span> 的人 <spanclass="math inline">\(j\)</span>让他戴上这个帽子，找出所有符合条件的人，一共有 <spanclass="math inline">\(\sum_j dp[i - 1][S - j]\)</span> 种方案</li></ol><p>将以上二者求和即可，基于此，我们可以得到状态转移方程： <spanclass="math display">\[\begin{equation}dp[i][S] = \left\{\begin{array}{ll}\ \ dp[i - 1][S] + \sum_{j \in S \land i \in \text{hats}[j]} dp[i - 1][S- j] &amp; \text{if}\ \ S \not= \emptyset\ \ \text{and}\  \ i &gt; 0 \\\ \ 1 &amp; \text{if}\ \ S = \emptyset \\\ \ 0 &amp; \text{if}\ \ |S| &gt; i\end{array}\right.\end{equation}\]</span> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">41</span>][<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>]; <span class="hljs-comment">// dp[i][S] 表示可以使用前 i 个帽子，需要分配的人员集合为 S 的方案数</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>() &#123;<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x00</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberWays</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; hats)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = hats.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;i64&gt; <span class="hljs-title">pref</span><span class="hljs-params">(n, <span class="hljs-number">0ll</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : hats[i]) pref[i] |= (<span class="hljs-number">1ll</span> &lt;&lt; j); <span class="hljs-comment">// 记录每个人的喜好</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">40</span>; i++) &#123;<br>            dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> mask = <span class="hljs-number">1</span>, sz = (<span class="hljs-number">1</span> &lt;&lt; n); mask &lt; sz; mask++) &#123;<br>                <span class="hljs-keyword">if</span> (__builtin_popcountll(mask) &gt; i) <span class="hljs-keyword">continue</span>;<br>                dp[i][mask] = dp[i - <span class="hljs-number">1</span>][mask]; <span class="hljs-comment">// 不选择 hat_i</span><br>                <span class="hljs-comment">// 选择 hat_i</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) &amp;&amp; (pref[j] &amp; (<span class="hljs-number">1ll</span> &lt;&lt; i))) &#123;<br>                        <span class="hljs-comment">// 从当前的人员集合中找到喜欢 hat_i 的人</span><br>                        dp[i][mask] = ((i64)dp[i][mask] + dp[i - <span class="hljs-number">1</span>][mask ^ (<span class="hljs-number">1</span> &lt;&lt; j)]) % MOD;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">40</span>][(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>由于 <span class="math inline">\(dp[i][:]\)</span> 只与 <spanclass="math inline">\(dp[i - 1][:]\)</span>有关，因此我们还可以考虑使用滚动数组进一步优化空间：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br>    <span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>]; <span class="hljs-comment">// 滚动数组优化空间</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>() &#123;<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0x00</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">numberWays</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; hats)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = hats.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;i64&gt; <span class="hljs-title">pref</span><span class="hljs-params">(n, <span class="hljs-number">0ll</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j : hats[i]) pref[i] |= (<span class="hljs-number">1ll</span> &lt;&lt; j); <span class="hljs-comment">// 记录每个人的喜好</span><br>        &#125;<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">40</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> mask = (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>; mask; mask--) &#123;<br>                <span class="hljs-keyword">if</span> (__builtin_popcountll(mask) &gt; i) <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                    <span class="hljs-keyword">if</span> ((mask &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) &amp;&amp; (pref[j] &amp; (<span class="hljs-number">1ll</span> &lt;&lt; i))) &#123;<br>                        <span class="hljs-comment">// 从当前人员集合中找到喜欢 hat_i 的人</span><br>                        dp[mask] = ((i64)dp[mask] + dp[mask ^ (<span class="hljs-number">1</span> &lt;&lt; j)]) % MOD;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[(<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="其他">其他</h5><p>这里给出其他的案例链接和笔者提供的 AC代码，如果读者感兴趣可以自行尝试去完成。</p><p><ahref="https://leetcode.cn/problems/maximize-score-after-n-operations/">MaximizeScore After N Operations</a></p><p>参考代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">gcd</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x ? <span class="hljs-built_in">gcd</span> (y % x, x) : y;<br>    &#125;<br>    <span class="hljs-type">int</span> g_map[<span class="hljs-number">14</span>][<span class="hljs-number">14</span>]; <span class="hljs-comment">// 提前记录 gcd(i, j)</span><br>    <span class="hljs-type">int</span> dp[<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">14</span>]; <span class="hljs-comment">// dp[S] 表示当前剩余点的集合为 S 可以拿到的最大得分</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Solution</span>() &#123;<br>        <span class="hljs-built_in">memset</span>(g_map, <span class="hljs-number">0x00</span>, <span class="hljs-built_in">sizeof</span>(g_map));<br>        <span class="hljs-built_in">memset</span>(dp, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(dp));<br>        dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxScore</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt; n; j++) &#123;<br>                g_map[i][j] = g_map[j][i] = <span class="hljs-built_in">gcd</span>(nums[i], nums[j]);<br>            &#125;<br>        &#125;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> mask) -&gt; <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">if</span> (dp[mask] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> dp[mask];<br>            <span class="hljs-type">int</span> idx = <span class="hljs-number">1</span> + (n - __builtin_popcount(mask)) / <span class="hljs-number">2</span>; <span class="hljs-comment">// 当前游戏次数</span><br>            vector&lt;<span class="hljs-type">int</span>&gt; sub;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-keyword">if</span> (mask &amp; (<span class="hljs-number">1</span> &lt;&lt; i)) sub.<span class="hljs-built_in">push_back</span>(i);<br>            &#125;<br>            <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, sz = sub.<span class="hljs-built_in">size</span>(); i &lt; sz - <span class="hljs-number">1</span>; i++) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; sz; j++) &#123;<br>                    <span class="hljs-type">int</span> x = sub[i], y = sub[j];<br>                    res = <span class="hljs-built_in">max</span>(res, idx * g_map[x][y] + <span class="hljs-built_in">dfs</span>(mask ^ (<span class="hljs-number">1</span> &lt;&lt; x) ^ (<span class="hljs-number">1</span> &lt;&lt; y)));<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> dp[mask] = res;<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>((<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="总结">总结</h4><p>状态压缩动态规划并不是在 DP算法本身上创新，而是给某个维度为「集合」的状态提供了一种利于计算机运算的表达方式。什么时候考虑使用状压DP 呢？</p><ol type="1"><li>动态规划中的状态转移涉及到集合运算（交、并、补、差）</li><li>集合的最大阶是一个比较小的数字，即 <span class="math inline">\(2 ^{|S|}\)</span> 是计算机内存可以承受的数组大小</li></ol><p>这种情况下，就很有可能是一个状压 DP 的问题了。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NumPy 学习笔记</title>
    <link href="/2023/06/25/NumPy%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/06/25/NumPy%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>NumPy（Numerical Python）是一个用于科学计算的 Python库。它提供了高性能的多维数组对象（ndarray），以及处理这些数组的工具。NumPy是 Python科学计算生态系统中的核心库，被广泛用于数据分析、统计建模、图像处理、机器学习等领域。</p><p>由于 NumPy的高性能和丰富的功能，它成为了许多科学计算和数据处理的基础库。许多其他的Python 科学计算库，如 SciPy、 Pandas和 Scikit-learn 等，都建立在 NumPy的基础上，并通过 NumPy 的 ndarray 对象进行数据交换和共享。</p><p><ahref="https://numpy.org/doc/1.25/user/absolute_beginners.html">NumPy官网</a></p><hr /><p><strong>导包</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy<br></code></pre></td></tr></table></figure><h3 id="多维数组">多维数组</h3><p>NumPy所有的计算都是围绕着数组进行的，因此在运算之前我们需要将数据转化为数组的形式。这一点与MATLAB 十分相似，我们可以结合 Octave 的语法来理解 NumPy。</p><h4 id="数组的定义">数组的定义</h4><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>    arr2 = np.zeros((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment"># 4 行 3 列的全 0 数组</span><br>    arr3 = np.ones((<span class="hljs-number">4</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 4 行 3 列的全 1 数组</span><br><br>    <span class="hljs-built_in">print</span>(arr3.shape) <span class="hljs-comment"># 得到数组的尺寸，返回一个元组</span><br>    <span class="hljs-comment"># 输出：(4, 3)</span><br><br>    arr4 = np.arange(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-comment"># 得到一个 1 到 10 的递增数组</span><br>    <span class="hljs-comment"># arr4 == [1 2 3 4 5 6 7 8 9]</span><br><br>    arr5 = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">11</span>) <span class="hljs-comment"># 得到 0 ～ 1 等间距分布的数组</span><br>    <span class="hljs-comment"># arr5 == [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]</span><br><br>    arr6 = np.random.rand(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) <span class="hljs-comment"># 生成一个 2 行 2 列的随机数组，每个元素服从 0 ~ 1 的均匀分布</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><blockquote><p>对于 NumPy 而言，数组元素默认是 <code>np.float64</code>类型，我们也可以指定 <code>dtype</code> 参数来选择数组的类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], dtype = np.int64) <span class="hljs-comment"># 指定数组元素类型为 64 位整数</span><br></code></pre></td></tr></table></figure><p>也可以通过 <code>astype()</code> 函数转化类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.array([<span class="hljs-number">1.5</span>, <span class="hljs-number">2.5</span>, <span class="hljs-number">3.2</span>, <span class="hljs-number">4.7</span>])<br>arr2 = arr1.astype(np.int32)<br><span class="hljs-comment"># arr2 = [1 2 3 4]</span><br></code></pre></td></tr></table></figure></blockquote><h4 id="数组的运算">数组的运算</h4><ul><li><p><strong>同尺寸的数组可以直接作对应元素的基本运算</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>arr2 = np.array([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-built_in">print</span>(arr1 + arr2)<br><span class="hljs-built_in">print</span>(arr2 - arr1)<br><span class="hljs-built_in">print</span>(arr1 * arr2)<br><span class="hljs-built_in">print</span>(arr1 ** arr2)<br><span class="hljs-built_in">print</span>(arr1 / arr2)<br><span class="hljs-built_in">print</span>(arr2 // arr1)<br></code></pre></td></tr></table></figure></p><blockquote><p>控制台输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs output">[3 5 7 9]<br>[1 1 1 1]<br>[ 2  6 12 20]<br>[   1    8   81 1024]<br>[0.5        0.66666667 0.75       0.8       ]<br>[2 1 1 1]<br></code></pre></td></tr></table></figure></blockquote></li><li><p><strong>其他运算</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(np.dot(arr1, arr2)) <span class="hljs-comment"># 点乘</span><br><span class="hljs-comment"># 输出：40</span><br><br>a = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])<br>b = np.array([[<span class="hljs-number">1</span>], [<span class="hljs-number">3</span>]])<br><span class="hljs-built_in">print</span>(a @ b) <span class="hljs-comment"># 矩阵乘法，等同于 np.matmul() 函数</span><br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [[ 7]</span><br><span class="hljs-comment">#  [15]]</span><br><br><span class="hljs-comment"># NumPy 中的数组也可以像 MATLAB 那样直接做函数的参数，返回同尺寸的矩阵，矩阵所有元素是原先元素在该函数下的返回值</span><br><span class="hljs-built_in">print</span>(np.sqrt(a))<br><span class="hljs-comment"># 输出：</span><br><span class="hljs-comment"># [[1.         1.41421356]</span><br><span class="hljs-comment">#  [1.73205081 2.        ]]</span><br></code></pre></td></tr></table></figure></p><blockquote><p>注意：</p><ul><li>对于 <code>dot()</code>函数而言，如果两个参数是一维数组，那就会计算两个数组的点积；如果是两个二维数组，那就会计算矩阵的乘积；如果第一个参数是多维数组，第二个参数是一维数组，则会利用广播操作来计算点积。</li></ul></blockquote></li><li><p><strong>广播</strong></p><p>广播（broadcasting），指 NumPy可以对不同形状的数组进行运算，通过广播机制，使得形状不同的数组可以进行逐元素的操作，而无需显式循环。</p><p><img src="https://p.ipic.vip/ye4yii.png" style="zoom:33%;" /></p></li><li><p><strong>获取数组元素</strong></p><p>对于 2 维数组 <code>arr</code> 而言，获取 <code>i</code> 行<code>j</code> 列的元素的语法如下：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">arr[i, j]<br></code></pre></td></tr></table></figure></p><p>也可以按条件查找：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">arr[arr &gt; <span class="hljs-number">0</span>] <span class="hljs-comment"># 列举所有大于 0 的元素</span><br></code></pre></td></tr></table></figure></p><blockquote><p>注意：</p><p>条件语句中的与用 <code>&amp;</code> 表示，或用 <code>|</code>表示。</p></blockquote></li><li><p><strong>数组切片</strong></p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])<br><span class="hljs-built_in">print</span>(arr[<span class="hljs-number">0</span>, <span class="hljs-number">0</span> : <span class="hljs-number">2</span>])<br><span class="hljs-comment"># [1 2]</span><br></code></pre></td></tr></table></figure></p><ul><li><p><code>start : end : step</code></p><p>启始索引：终止索引：步长</p><p>步长在这里可以为负数</p></li><li><p><code>:</code></p><p>单个 <code>:</code> 表示全部元素</p></li></ul></li><li><p><strong>数组压缩</strong></p><p>在 NumPy 中，可以使用 <code>flatten()</code> 或 <code>ravel()</code>函数将多维数组压缩成一维数组。</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 创建一个多维数组</span><br>arr = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])<br><br><span class="hljs-comment"># 使用 flatten() 函数压缩成一维数组</span><br>arr_flattened = arr.flatten()<br><span class="hljs-built_in">print</span>(arr_flattened)<br><span class="hljs-comment"># 输出: [1 2 3 4 5 6 7 8 9]</span><br><br><span class="hljs-comment"># 使用 ravel() 函数压缩成一维数组</span><br>arr_raveled = arr.ravel()<br><span class="hljs-built_in">print</span>(arr_raveled)<br><span class="hljs-comment"># 输出: [1 2 3 4 5 6 7 8 9]</span><br></code></pre></td></tr></table></figure></p><p>或者使用 <code>reshape()</code> 函数：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 三维数组</span><br>arr = np.array([<br>    [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>     [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]],<br>    <br>    [[<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>],<br>     [<span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>]]<br>])<br><br><span class="hljs-comment"># 获取数组的形状</span><br>shape = arr.shape<br><span class="hljs-built_in">print</span>(shape)<br><span class="hljs-comment"># 输出: (2, 2, 3)</span><br><br><span class="hljs-comment"># 将三维数组转换成二维数组</span><br>arr_reshaped = arr.reshape((shape[<span class="hljs-number">0</span>], shape[<span class="hljs-number">1</span>] * shape[<span class="hljs-number">2</span>]))<br><span class="hljs-built_in">print</span>(arr_reshaped)<br><span class="hljs-comment"># 输出:</span><br><span class="hljs-comment"># [[ 1  2  3  4  5  6]</span><br><span class="hljs-comment">#  [ 7  8  9 10 11 12]]</span><br></code></pre></td></tr></table></figure></p></li><li><p><strong>数组拼接</strong></p><p>在 NumPy 中，你可以使用 <code>numpy.concatenate()</code>函数来实现两个矩阵的左右或上下拼接。</p><p>下面是两种常用的方法示例：</p><ol type="1"><li>左右拼接（水平拼接）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>matrix1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>                    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])<br><br>matrix2 = np.array([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>                    [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br><br>result = np.concatenate((matrix1, matrix2), axis = <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure></li></ol><p>在这个示例中，我们有两个矩阵 <code>matrix1</code> 和<code>matrix2</code>。通过使用 <code>np.concatenate()</code> 函数，并将<code>axis = 1</code>参数传递给它，我们可以将这两个矩阵在水平方向上拼接起来。输出结果如下：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs output">[[1 2 5 6]<br> [3 4 7 8]]<br></code></pre></td></tr></table></figure></p><ol start="2" type="1"><li>上下拼接（垂直拼接）： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>matrix1 = np.array([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>                    [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]])<br><br>matrix2 = np.array([[<span class="hljs-number">5</span>, <span class="hljs-number">6</span>],<br>                    [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])<br><br>result = np.concatenate((matrix1, matrix2), axis = <span class="hljs-number">0</span>)<br><br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure></li></ol><p>在这个示例中，我们仍然有两个矩阵 <code>matrix1</code> 和<code>matrix2</code>。通过使用 <code>np.concatenate()</code> 函数，并将<code>axis = 0</code>参数传递给它，我们可以将这两个矩阵在垂直方向上拼接起来。输出结果如下：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs output">[[1 2]<br> [3 4]<br> [5 6]<br> [7 8]]<br></code></pre></td></tr></table></figure></p><p>无论是左右拼接还是上下拼接，都可以使用 <code>np.concatenate()</code>函数，并指定合适的 <code>axis</code>参数来实现。注意，两个矩阵在除了指定拼接方向的轴以外的其他轴上的维度必须是一致的，这样才能成功进行拼接。</p><blockquote><p>使用 <code>row_stack()</code> 和 <code>column_stack()</code>方法实现拼接：</p><ol type="1"><li><p><code>np.row_stack</code>（也可以使用 <code>np.vstack</code> 或<code>np.concatenate</code>）：</p><ul><li><code>row_stack</code>用于将多个数组按行堆叠在一起，将它们垂直叠放，使得每个数组的行数保持不变，列数可以不同。</li><li>如果传递给 <code>row_stack</code>的数组维度不匹配，它将尝试匹配数组的列数，然后垂直堆叠它们。这通常用于将多个行向量垂直叠加成一个矩阵。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>                  <br>arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>arr2 = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br>result = np.row_stack((arr1, arr2))<br>                  <br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs output">[[1 2 3]<br> [4 5 6]]<br></code></pre></td></tr></table></figure></li><li><p><code>np.column_stack</code>（也可以使用<code>np.hstack</code>）：</p><ul><li><code>column_stack</code>用于将多个数组按列堆叠在一起，将它们水平叠放，使得每个数组的列数保持不变，行数可以不同。</li><li>如果传递给 <code>column_stack</code>的数组维度不匹配，它将尝试匹配数组的行数，然后水平堆叠它们。这通常用于将多个列向量水平叠加成一个矩阵。</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>                  <br>arr1 = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>arr2 = np.array([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br>result = np.column_stack((arr1, arr2))<br>                  <br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs output">[[1 4]<br> [2 5]<br> [3 6]]<br></code></pre></td></tr></table></figure></li></ol><p>总之，<code>row_stack</code> 和 <code>column_stack</code>是用于堆叠多个数组的方便方法，它们根据需要垂直或水平堆叠数组，使得结果数组的维度适合您的需求。</p></blockquote></li><li><p><strong>矩阵的逆</strong></p><p><code>np.linalg.inv()</code> 函数用于计算矩阵的逆。</p><p>以下是 <code>np.linalg.inv()</code> 的基本用法和一些注意事项：</p><p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 创建一个矩阵</span><br>A = np.array([[<span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>              [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]])<br><br><span class="hljs-comment"># 计算矩阵 A 的逆矩阵</span><br>A_inv = np.linalg.inv(A)<br><br><span class="hljs-comment"># 打印逆矩阵</span><br><span class="hljs-built_in">print</span>(A_inv)<br></code></pre></td></tr></table></figure></p><p>需要注意的是：</p><ol type="1"><li>矩阵必须是方阵（即行数和列数相等），才能计算逆矩阵。</li><li>如果矩阵不可逆（例如，奇异矩阵），则 <code>np.linalg.inv()</code>会引发 LinAlgError 异常。</li><li>计算逆矩阵是一个计算密集型的操作，特别是对于大型矩阵。在数值计算中，尽量避免计算逆矩阵，而是使用其他方法来解决线性方程组，如矩阵分解（LU分解、QR 分解等）或迭代方法。</li></ol><p>通常情况下，尽量避免使用逆矩阵来解决线性方程组，而是使用 NumPy的线性方程求解函数<code>np.linalg.solve()</code>，因为后者通常更稳定且计算效率更高。如果只是需要对矩阵进行逆运算以进行其他操作，那么<code>np.linalg.inv()</code> 是一个合适的选择。</p></li></ul><p>综合案例（实现一个简单的三层神经网络）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sigmoid</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> / (<span class="hljs-number">1</span> + np.exp(-x))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">x</span>):<br>    exp_x = np.exp(x)<br><br>    <span class="hljs-keyword">return</span> exp_x / np.<span class="hljs-built_in">sum</span>(exp_x)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NetWork</span>:<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    三层神经网络:</span><br><span class="hljs-string">    - 输入层有 3 个神经元</span><br><span class="hljs-string">    - 第 1 个隐藏层有 3 个神经元</span><br><span class="hljs-string">    - 第 2 个隐藏层有 3 个神经元</span><br><span class="hljs-string">    - 输出层有 2 个神经元</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.__net = &#123;&#125;<br>        self.__net[<span class="hljs-string">&#x27;W1&#x27;</span>] = np.array([[<span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.5</span>], [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.6</span>], [<span class="hljs-number">0.2</span>, <span class="hljs-number">0.95</span>, <span class="hljs-number">0.7</span>]])<br>        self.__net[<span class="hljs-string">&#x27;B1&#x27;</span>] = np.array([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.6</span>, <span class="hljs-number">0.4</span>])<br>        self.__net[<span class="hljs-string">&#x27;W2&#x27;</span>] = np.array([[<span class="hljs-number">0.2</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.6</span>], [<span class="hljs-number">0.4</span>, <span class="hljs-number">0.35</span>, <span class="hljs-number">0.6</span>], [<span class="hljs-number">0.3</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.45</span>]])<br>        self.__net[<span class="hljs-string">&#x27;B2&#x27;</span>] = np.array([<span class="hljs-number">0.35</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.9</span>])<br>        self.__net[<span class="hljs-string">&#x27;W3&#x27;</span>] = np.array([[<span class="hljs-number">0.45</span>, <span class="hljs-number">0.75</span>, <span class="hljs-number">0.15</span>], [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>]])<br>        self.__net[<span class="hljs-string">&#x27;B3&#x27;</span>] = np.array([<span class="hljs-number">1.5</span>, <span class="hljs-number">3</span>])<br><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x: np.array</span>) -&gt; np.float64:<br>        w1, w2, w3 = self.__net[<span class="hljs-string">&#x27;W1&#x27;</span>], self.__net[<span class="hljs-string">&#x27;W2&#x27;</span>], self.__net[<span class="hljs-string">&#x27;W3&#x27;</span>]<br>        b1, b2, b3 = self.__net[<span class="hljs-string">&#x27;B1&#x27;</span>], self.__net[<span class="hljs-string">&#x27;B2&#x27;</span>], self.__net[<span class="hljs-string">&#x27;B3&#x27;</span>]<br>        x1 = np.dot(w1, x) + b1<br>        x2 = np.dot(w2, sigmoid(x1)) + b2<br>        x3 = np.dot(w3, sigmoid(x2)) + b3<br><br>        <span class="hljs-keyword">return</span> softmax(x3)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    n = NetWork()<br>    <span class="hljs-built_in">print</span>(n.forward([<span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-number">17</span>])) <span class="hljs-comment"># [0.2622667 0.7377333]</span><br>    <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><h4 id="其他">其他</h4><h5 id="数组显示选项">数组显示选项</h5><p><code>np.set_printoptions()</code>用于配置NumPy在打印数组时的显示选项。它允许更改打印数组时的格式、精度、对齐方式等参数，以满足特定的需求。</p><p>下面是一些常用的 <code>np.set_printoptions()</code>参数及其说明：</p><ol type="1"><li><p><code>precision</code>（默认为8）：设置打印浮点数时的小数点后位数的精度。</p></li><li><p><code>threshold</code>（默认为1000）：用于控制在数组元素数目超过此值时，NumPy会截断并以省略号表示。</p></li><li><p><code>suppress</code>（默认为 False）：如果为True，小数值将以科学计数法的形式打印。</p></li><li><p><code>linewidth</code>（默认为75）：设置打印输出的行宽。如果行中的字符数超过此值，NumPy将自动换行。</p></li><li><p><code>edgeitems</code>（默认为3）：控制打印数组时边缘元素的数量。</p></li><li><p><code>nanstr</code>（默认为 'nan' ）：设置表示NaN（非数字）值的字符串。</p></li><li><p><code>infstr</code>（默认为 'inf'）：设置表示正无穷大值的字符串。</p></li><li><p><code>formatter</code>（默认为None）：可以指定一个格式化函数来自定义打印数组的方式。</p></li></ol><p>以下是一个示例，演示如何使用<code>np.set_printoptions()</code>来更改打印选项：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-comment"># 创建一个示例数组</span><br>arr = np.array([<span class="hljs-number">1.23456789</span>, <span class="hljs-number">2.3456789</span>, <span class="hljs-number">3.456789</span>])<br><br><span class="hljs-comment"># 设置打印选项</span><br>np.set_printoptions(precision=<span class="hljs-number">2</span>, suppress=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 打印数组</span><br><span class="hljs-built_in">print</span>(arr)<br></code></pre></td></tr></table></figure><p>在上述示例中，我们设置了小数点后的精度为2，并且将小数值以科学计数法的形式打印。</p><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">[1.23 2.35 3.46]<br></code></pre></td></tr></table></figure><h5 id="将数组保存为二进制文件">将数组保存为二进制文件</h5><p>NumPy 中的 <code>.npy</code> 文件是一种用于存储 NumPy数组数据的二进制文件格式。这个文件格式是专门为 NumPy数组设计的，可以高效地保存和加载多维数组数据。<code>.npy</code>文件格式在科学计算、数据分析和机器学习等领域中广泛使用，因为它能够保留数组的数据类型和形状，同时具有较小的存储开销。</p><p>以下是一些关于 <code>.npy</code> 文件的重要特点和用法：</p><ol type="1"><li><p><strong>数据保存与加载：</strong> 使用 NumPy 的<code>np.save</code> 和 <code>np.load</code> 函数可以方便地将 NumPy数组保存到 <code>.npy</code> 文件中，以及从 <code>.npy</code>文件中加载数组数据。</p><ul><li><p>保存数组到 <code>.npy</code> 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>arr = np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>np.save(<span class="hljs-string">&#x27;my_array.npy&#x27;</span>, arr)<br></code></pre></td></tr></table></figure></li><li><p>从 <code>.npy</code> 文件加载数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loaded_arr = np.load(<span class="hljs-string">&#x27;my_array.npy&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>高效的存储和加载：</strong> <code>.npy</code>文件采用二进制格式存储数据，因此比文本格式（如CSV）更高效。这意味着它可以更快速地保存和加载大型数组，减少了I/O操作的开销。</p></li><li><p><strong>保留数据类型和形状：</strong> <code>.npy</code>文件能够精确地保存数组的数据类型和形状，这对于科学计算任务非常重要。加载数据时，数据的类型和形状将被自动还原。</p></li><li><p><strong>多维数组支持：</strong> <code>.npy</code>文件不仅可以保存一维数组，还可以保存多维数组，包括矩阵和张量等。</p></li><li><p><strong>压缩选项：</strong> NumPy 还提供了一些压缩选项，允许您将<code>.npy</code> 文件以更小的存储空间保存。这可以在<code>np.save</code> 函数中使用 <code>allow_pickle</code> 和<code>fix_imports</code> 参数来控制。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">np.save(<span class="hljs-string">&#x27;my_array.npy&#x27;</span>, arr, allow_pickle=<span class="hljs-literal">True</span>, fix_imports=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure></li></ol><p>总之，<code>.npy</code> 文件是在 NumPy中存储和加载数组数据的一种高效和方便的方式。它不仅保留了数据的精度和形状，还允许您轻松地在不同的Python 环境中分享和传输数据。</p><h3 id="图像绘制">图像绘制</h3><p><code>matplotlib.pyplot</code> 库可以很好地与 Numpy库结合来绘制图像，以下介绍一些常用的图像绘制方法：</p><p><strong><code>plot()</code> 方法绘制连续图像</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    x = np.linspace(-<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">200</span>)<br>    y1 = x ** <span class="hljs-number">2</span><br>    y2 = np.cos(x)<br>    plt.figure()<br>    plt.title(<span class="hljs-string">&#x27;$y_1 = x^2\ &amp;\ y_2 = cos(x)$&#x27;</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.plot(x, y1, label=<span class="hljs-string">&#x27;$f(x) = x^2$&#x27;</span>)<br>    plt.plot(x, y2, label=<span class="hljs-string">&#x27;$f(x) = cos(x)$&#x27;</span>)<br>    plt.legend()<br>    plt.savefig(<span class="hljs-string">&#x27;function.png&#x27;</span>) <span class="hljs-comment"># 保存图像</span><br>    plt.show() <span class="hljs-comment"># 展示图像</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-23-101432.png" style="zoom:70%;" /></p><p><strong><code>scatter()</code> 方法绘制散点图</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    x = np.random.randn(<span class="hljs-number">100</span>)<br>    y = np.random.randn(<span class="hljs-number">100</span>)<br>    c = x * y &gt; <span class="hljs-number">0</span><br>    plt.figure()<br>    plt.scatter(x, y, c=c, cmap=<span class="hljs-string">&#x27;bwr&#x27;</span>, s=<span class="hljs-number">10</span>)<br>    plt.xlabel(<span class="hljs-string">&#x27;x&#x27;</span>)<br>    plt.ylabel(<span class="hljs-string">&#x27;y&#x27;</span>)<br>    plt.show()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    main()<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-11-23-102226.png" style="zoom:70%;" /></p><h3 id="数值运算">数值运算</h3><h4 id="回归">回归</h4><p><code>np.polyfit()</code> 函数用于多项式拟合。多</p><p><code>np.polyfit</code> 的基本语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">numpy.polyfit(x, y, deg, rcond=<span class="hljs-literal">None</span>, full=<span class="hljs-literal">False</span>, w=<span class="hljs-literal">None</span>, cov=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p>参数说明： - <code>x</code>：输入数据的 x 坐标（自变量）。 -<code>y</code>：输入数据的 y 坐标（因变量）。 -<code>deg</code>：要拟合的多项式的次数。 -<code>rcond</code>：奇异值分解的阈值，用于控制拟合过程中的数值稳定性。默认为None。 - <code>full</code>：如果为True，返回额外的诊断信息，包括拟合残差。默认为 False。 -<code>w</code>：每个数据点的权重。可以用于加权拟合，默认为 None。 -<code>cov</code>：如果为 True，返回多项式系数的协方差矩阵。默认为False。</p><p><code>np.polyfit</code>返回一个多项式的系数数组，其中最高次幂的系数位于数组的第一个元素。拟合多项式的次数由<code>deg</code> 参数指定。</p><p>以下是一个简单的示例，演示如何使用 <code>np.polyfit</code>对一组数据进行多项式拟合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br><span class="hljs-comment"># 创建一组示例数据</span><br>x = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br>y = np.array([<span class="hljs-number">0</span>, <span class="hljs-number">0.8</span>, <span class="hljs-number">0.9</span>, <span class="hljs-number">0.1</span>, -<span class="hljs-number">0.8</span>, -<span class="hljs-number">1</span>])<br><br><span class="hljs-comment"># 使用 np.polyfit 进行多项式拟合</span><br>coefficients = np.polyfit(x, y, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 拟合一个 3 次多项式</span><br><br><span class="hljs-comment"># 创建一个多项式函数</span><br>poly_function = np.poly1d(coefficients)<br><br><span class="hljs-comment"># 生成拟合后的曲线上的点</span><br>x_fit = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, <span class="hljs-number">100</span>)<br>y_fit = poly_function(x_fit)<br><br><span class="hljs-comment"># 绘制原始数据和拟合曲线</span><br>plt.scatter(x, y, label=<span class="hljs-string">&#x27;Original Data&#x27;</span>)<br>plt.plot(x_fit, y_fit, label=<span class="hljs-string">&#x27;Fitted Curve&#x27;</span>, color=<span class="hljs-string">&#x27;red&#x27;</span>)<br>plt.legend()<br>plt.xlabel(<span class="hljs-string">&#x27;X&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Y&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Polynomial Fit Example&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>np.polyfit</code> 对一组示例数据进行了 3次多项式拟合，并通过 <code>np.poly1d</code>创建了一个多项式函数。然后，我们绘制了原始数据和拟合曲线，以可视化拟合效果。</p><h4 id="线性代数">线性代数</h4><p><code>np.linalg</code> 是 NumPy库的一个子模块，提供了一系列用于线性代数的函数。</p><h5 id="求解线性方程组">求解线性方程组</h5><p><code>np.linalg.solve</code> 函数是 NumPy库中用于解决线性方程组的一个函数。这个函数可以解决形如<code>Ax = b</code> 的方程组，其中 <code>A</code>是一个已知的非奇异（即可逆）方阵，<code>b</code> 是一个已知向量，而<code>x</code> 是要求解的未知向量。</p><p><strong>使用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>A = np.array([[<span class="hljs-number">3</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]])<br>b = np.array([<span class="hljs-number">9</span>, <span class="hljs-number">8</span>])<br>x = np.linalg.solve(A, b)<br><br><span class="hljs-built_in">print</span>(x) <span class="hljs-comment"># [2. 3.]</span><br></code></pre></td></tr></table></figure><h5 id="计算行列式">计算行列式</h5><p><code>np.linalg.det</code> 是 NumPy库中用于计算矩阵行列式的函数。</p><p><strong>使用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>A = np.array([<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]<br>])<br>detA = np.linalg.det(A)<br><br><span class="hljs-built_in">print</span>(detA) <span class="hljs-comment"># 1.0</span><br></code></pre></td></tr></table></figure><h5 id="计算矩阵的秩">计算矩阵的秩</h5><p><code>np.linalg.matrix_rank</code> 是 NumPy中的一个函数，用于计算矩阵的秩（rank）。</p><p><strong>使用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>A = np.array([<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br>])<br><br>rank = np.linalg.matrix_rank(A)<br><br><span class="hljs-built_in">print</span>(rank) <span class="hljs-comment"># 2</span><br></code></pre></td></tr></table></figure><h5 id="计算矩阵的逆">计算矩阵的逆</h5><p><code>np.linalg.inv</code> 是 NumPy 库中用于计算矩阵逆的函数。</p><p><strong>使用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>A = np.array([<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>]<br>])<br>invA = np.linalg.inv(A)<br><br><span class="hljs-built_in">print</span>(invA)<br></code></pre></td></tr></table></figure><p><em>控制台输出：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs output">[[ 5. -2. -1.]<br> [-6.  3.  1.]<br> [ 8. -4. -1.]]<br></code></pre></td></tr></table></figure><h5 id="计算矩阵的特征值和特征向量">计算矩阵的特征值和特征向量</h5><p><code>np.linalg.eig</code> 是 NumPy中用于计算矩阵的特征值（eigenvalues）和特征向量（eigenvectors）的函数。函数返回一个包含两个数组的元组<code>(w, v)</code>，其中 <code>w</code> 是包含矩阵 <code>a</code>的特征值的一维数组，<code>v</code> 是包含矩阵 <code>a</code>的特征向量的二维数组。特征值数组 <code>w</code>的顺序是从小到大排列的。</p><p><strong>使用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>A = np.array([[<span class="hljs-number">4</span>, <span class="hljs-number">2</span>],<br>              [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]])<br>eigenvalues, eigenvectors = np.linalg.eig(A)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Eigenvalues:\n&quot;</span>, eigenvalues)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Eigenvectors:\n&quot;</span>, eigenvectors)<br></code></pre></td></tr></table></figure><p><em>控制台输出：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs output">Eigenvalues:<br> [5. 2.]<br>Eigenvectors:<br> [[ 0.89442719 -0.70710678]<br> [ 0.4472136   0.70710678]]<br></code></pre></td></tr></table></figure><h5 id="奇异值分解">奇异值分解</h5><p><code>np.linalg.svd</code> 是 NumPy中的一个函数，用于执行奇异值分解（Singular ValueDecomposition，SVD）。</p><p><strong>使用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>A = np.array([<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>],<br>    [<span class="hljs-number">2</span>, <span class="hljs-number">1</span>],<br>    [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]<br>])<br><br>U, S, VT = np.linalg.svd(A, full_matrices=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>A</code> 是输入的待分解矩阵，可以是一个二维 NumPy数组（矩阵）。</li><li><code>U</code> 是一个矩阵，包含了输入矩阵 <code>A</code>的左奇异向量（Left Singular Vectors）。</li><li><code>S</code> 是一个一维数组，包含了输入矩阵 <code>A</code>的奇异值（Singular Values），按照从大到小排列。</li><li><code>VT</code> 是一个矩阵，包含了输入矩阵 <code>A</code>的右奇异向量的转置（Transpose of Right Singular Vectors）。</li></ul><h5 id="计算矩阵的范数">计算矩阵的范数</h5><p><code>np.linalg.norm</code> 是 NumPy中的一个函数，用于计算向量或矩阵的范数（norm）。</p><p><strong>使用方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>norm_value = np.linalg.norm(x, <span class="hljs-built_in">ord</span>=<span class="hljs-literal">None</span>, axis=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><p>其中：</p><ul><li><code>x</code> 是要计算范数的向量或矩阵，可以是一个 NumPy数组。</li><li><code>ord</code>是一个可选参数，用于指定计算的范数类型。默认情况下，<code>ord</code> 为None，表示计算默认的二范数（L2 范数）。可以设置 <code>ord</code>为不同的值来计算不同类型的范数，例如：<ul><li>如果 <code>ord</code> 设置为 1，计算的是一范数（L1 范数）。</li><li>如果 <code>ord</code> 设置为<code>np.inf</code>，计算的是无穷范数（L∞ 范数）。</li><li>如果 <code>ord</code> 设置为<code>-np.inf</code>，计算的是负无穷范数（负无穷范数）。</li><li>如果 <code>ord</code> 设置为其他正数，计算的是 Lp 范数，其中 p为指定的正数。</li></ul></li><li><code>axis</code>是一个可选参数，用于指定在多维数组中沿哪个轴计算范数。默认情况下，计算整个数组的范数，但可以设置<code>axis</code> 来沿指定轴计算范数。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>NumPy</tag>
      
      <tag>数值运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 介绍</title>
    <link href="/2023/06/17/CMake%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/06/17/CMake%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="cmake-简介">CMake 简介</h3><p>CMake 是一个跨平台的构建工具，用于管理和构建 C++项目。它的设计目标是提供一种简化的构建过程，使开发人员能够在不同的操作系统和编译器上轻松地生成可执行文件、库和其他构建目标。</p><p>CMake的主要思想是通过描述项目的构建过程来生成构建系统所需的构建脚本。它使用一种称为<code>CMakeLists.txt</code>的文本文件来定义项目的目录结构、源文件、编译选项、依赖项和构建规则。CMake具有很好的跨平台性，可以在多种操作系统上使用，包括 Windows、Linux、macOS等。它可以生成不同的构建系统文件，如 Makefile、Ninja、Visual Studio解决方案等，从而使开发人员能够在不同的开发环境中使用适合的构建系统。</p><p>总而言之，CMake 简化了跨平台 C++项目的构建过程，使开发人员能够更轻松地管理项目的编译和构建，同时提供了灵活性和可扩展性来处理复杂的项目结构和依赖关系。</p><p>学习 CMake 的目的，是为将来<strong>处理大型的 C / C++ / Java项目</strong>做准备。</p><h4 id="cmake-安装">CMake 安装</h4><p>绝大多数 Linux 系统已经安装了 CMake，没有安装的话可以去 <ahref="http://www.cmake.org/HTML/Download.html">CMake 官网</a>进行安装。</p><p>MacOS 也可以用 Homebrew 进行快速安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install cmake<br></code></pre></td></tr></table></figure><h3 id="构建-cmake-项目">构建 CMake 项目</h3><p>构建 CMake 项目，大致分为 3 个步骤：</p><ol type="1"><li>创建 <code>CMakeLists.txt</code> 文件</li><li>使用 <code>CMake</code> 指令生成 <code>Makefile</code> 文件</li><li>使用 <code>make</code> 指令进行编译</li></ol><h4 id="一个简单示例">一个简单示例</h4><ul><li><p>创建一个 <code>demo.cpp</code> ：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello world!\n&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>同级目录下创建一个 <code>CMakeLists.txt</code>文件，输入以下文本：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(HELLO)<br><br><span class="hljs-keyword">SET</span>(SRC_LIST demo.cpp)<br><br><span class="hljs-keyword">MESSAGE</span>(STUTAS <span class="hljs-string">&quot;Configuring project...&quot;</span>)<br><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(Demo <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>终端下使用 <code>cmake</code> 指令生成 <code>Makefile</code>文件：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake .<br></code></pre></td></tr></table></figure></p><p>若运行成功，则目录下会生成 <code>Makefile</code> 文件。</p></li><li><p>使用 <code>make</code> 指令进行编译：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure></p><p>编译成功，则会生成可执行文件 <code>Demo</code> 。</p></li><li><p>运行 <code>Demo</code> 即可：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./Demo<br></code></pre></td></tr></table></figure></p></li></ul><h4 id="cmakelists.txt-基本语法介绍"><code>CMakeLists.txt</code>基本语法介绍</h4><h5 id="project-关键字"><code>PROJECT</code> 关键字</h5><p><code>PROJECT</code>关键字用于定义和配置项目。它用于指定项目的名称、版本号和语言。。</p><p>PROJECT关键字的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(&lt;project_name&gt; [VERSION &lt;version&gt;] [LANGUAGES &lt;languages&gt;])<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;project_name&gt;</code>是要定义的项目名称。<code>&lt;version&gt;</code>是可选的，用于指定项目的版本号。 <code>&lt;languages&gt;</code>也是可选的，用于指定项目所使用的编程语言。</p><p>以下是一些 <code>PROJECT</code> 关键字的示例用法：</p><ol type="1"><li><p>定义一个简单的项目：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(MyProject)<br></code></pre></td></tr></table></figure></p></li><li><p>定义一个带有版本号的项目：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(MyProject VERSION <span class="hljs-number">1.0</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>定义一个使用多种编程语言的项目：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(MyProject LANGUAGES CXX C)<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="set-关键字"><code>SET</code> 关键字</h5><p><code>SET</code> 关键字用于设置变量的值。语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(&lt;variable&gt; &lt;value&gt; [CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]])<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;variable&gt;</code>是要设置的变量名，<code>&lt;value&gt;</code>是要为变量设置的值。<code>&lt;value&gt;</code>可以是一个字符串、一个列表、一个布尔值或一个数值。SET关键字还支持一些其他选项：</p><ul><li><code>CACHE</code>：指定变量为缓存变量，即用户可以通过CMake的缓存机制进行设置或修改该变量的值。缓存变量的值可以在CMake运行期间持久保存，并在下一次运行时保持不变。</li><li><code>&lt;type&gt;</code>：指定缓存变量的类型。可以是BOOL、STRING、PATH等类型。</li><li><code>&lt;docstring&gt;</code>：可选项，用于提供变量的描述文本。</li><li><code>FORCE</code>：可选项，强制设置变量的值，即使它已经被缓存。</li></ul><p>以下是一些 <code>SET</code> 关键字的示例用法：</p><ol type="1"><li><p>设置一个字符串变量： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(my_string <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>设置一个列表变量： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(my_list <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>设置一个缓存变量： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(my_variable <span class="hljs-string">&quot;default value&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;Description of my variable&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>强制设置一个缓存变量的值： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(my_variable <span class="hljs-string">&quot;new value&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;Description of my variable&quot;</span> FORCE)<br></code></pre></td></tr></table></figure></p></li></ol><p>通过 <code>SET</code> 关键字，你可以在 CMake脚本中设置变量的值，并根据需要使用它们来控制构建过程、传递参数或处理其他逻辑。</p><p>变量取值：使用 <code>$&#123;&#125;</code> ，但是在 <code>IF</code>控制语句中直接使用变量名。</p><h5 id="message-关键字"><code>MESSAGE</code> 关键字</h5><p>在 CMake 中，<code>MESSAGE</code>是一个用于输出消息的关键字。它允许你在 CMake脚本中打印信息，以便在构建过程中向用户提供有用的反馈或调试信息。</p><p>MESSAGE关键字的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">MESSAGE</span>([&lt;mode&gt;] <span class="hljs-string">&quot;&lt;message&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;mode&gt;</code>是可选的，用于指定消息的模式。常用的消息模式有以下几种：</p><ul><li><code>STATUS</code> ：以普通状态的形式输出消息。</li><li><code>WARNING</code> ：以警告的形式输出消息。</li><li><code>AUTHOR_WARNING</code> ：以作者警告的形式输出消息。</li><li><code>SEND_ERROR</code> ：以错误的形式输出消息，并终止 CMake的配置过程。</li><li><code>FATAL_ERROR</code> ：以致命错误的形式输出消息，并终止 CMake的配置过程。</li></ul><p><code>&lt;message&gt;</code>是要输出的消息内容，可以是一个字符串或一个变量。</p><p>以下是一些MESSAGE关键字的示例用法：</p><ol type="1"><li><p>输出普通状态消息： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;Configuring project...&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>输出警告消息： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">MESSAGE</span>(WARNING <span class="hljs-string">&quot;Warning: Invalid configuration detected.&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>输出错误消息并终止配置过程： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">MESSAGE</span>(SEND_ERROR <span class="hljs-string">&quot;Error: Required library not found.&quot;</span>)<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="add_executable-关键字"><code>ADD_EXECUTABLE</code> 关键字</h5><p>在 CMake 中，<code>ADD_EXECUTABLE</code>是一个用于添加可执行文件的关键字。它用于指定要构建的可执行文件的名称和源代码文件。</p><p><code>ADD_EXECUTABLE</code> 关键字的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_EXECUTABLE</span>(&lt;executable_name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...])<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;executable_name&gt;</code>是要生成的可执行文件的名称。<code>[WIN32]</code> 和<code>[MACOSX_BUNDLE]</code> 是可选的标志，用于指定在 Windows 上构建一个GUI 应用程序或在 macOS上构建一个应用程序捆绑包。<code>[EXCLUDE_FROM_ALL]</code>也是可选的标志，表示该目标不会被默认构建，除非明确要求。</p><p><code>source1 [source2 ...]</code>是要包含在可执行文件中的源代码文件的列表。可以通过相对或绝对路径指定这些源文件。</p><p>以下是 <code>ADD_EXECUTABLE</code> 关键字的示例用法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_EXECUTABLE</span>(MyApp main.cpp utils.cpp)<br></code></pre></td></tr></table></figure><p>上述示例将创建一个名为 <code>MyApp</code> 的可执行文件，并将<code>main.cpp</code> 和 <code>utils.cpp</code>作为源代码文件包含在可执行文件中。</p><p>使用 <code>ADD_EXECUTABLE</code> 关键字时，CMake会自动检测源代码文件的编程语言，并相应地设置编译器和编译选项。</p><p><code>ADD_EXECUTABLE</code>关键字允许你定义项目中的可执行文件，并指定与之相关的源代码文件。通过<code>ADD_EXECUTABLE</code>，你可以将源代码文件与特定的可执行文件关联起来，以便在构建过程中生成所需的可执行文件。</p><h5 id="add_subdirectory-关键字"><code>ADD_SUBDIRECTORY</code>关键字</h5><p><code>ADD_SUBDIRECTORY</code> 是用于向 CMake构建系统添加子目录的关键字。它的作用是告诉 CMake在当前项目中包含另一个目录，并在该子目录中查找并处理另一个<code>CMakeLists.txt</code> 文件。</p><p><code>ADD_SUBDIRECTORY</code> 的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(directory [binary_dir] [EXCLUDE_FROM_ALL])<br></code></pre></td></tr></table></figure><ul><li><code>directory</code>：要添加的子目录的路径。这个路径可以是相对于当前 CMakeLists.txt文件的相对路径，也可以是绝对路径。</li><li><code>binary_dir</code>（可选）：指定生成的二进制文件的输出目录。如果不提供，则使用默认值（通常是当前构建目录）。</li><li><code>EXCLUDE_FROM_ALL</code>（可选）：如果指定了这个选项，将会在构建目标时排除这个子目录。这对于包含一些可选的或不常用的子项目很有用。</li></ul><p>使用 <code>ADD_SUBDIRECTORY</code> 时，CMake 会进入子目录并处理对应的<code>CMakeLists.txt</code>文件。这意味着子目录中可以有自己的构建规则、目标等。通过使用<code>ADD_SUBDIRECTORY</code>，可以将复杂的项目划分为多个子项目，并使用各自的CMakeLists.txt 文件进行管理，从而提高项目的组织性和可维护性。</p><p>请注意，在使用 <code>ADD_SUBDIRECTORY</code>之前，通常需要在子目录中准备一个有效的 CMakeLists.txt文件，以定义子项目的构建规则、目标等。</p><p>以下是一个示例，展示如何使用 <code>ADD_SUBDIRECTORY</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 主项目的 CMakeLists.txt</span><br><br><span class="hljs-comment"># 添加子目录</span><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(subdir)<br><br><span class="hljs-comment"># 主项目的构建规则和目标</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 子目录的 CMakeLists.txt</span><br><br><span class="hljs-comment"># 子目录的构建规则和目标</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>上述示例中，主项目的 <code>CMakeLists.txt</code> 文件使用<code>ADD_SUBDIRECTORY</code> 添加了一个名为 "subdir"的子目录。然后，CMake 进入子目录并处理对应的 CMakeLists.txt文件，执行子目录的构建规则和目标的设置。</p><p>通过使用 <code>ADD_SUBDIRECTORY</code>，你可以将项目组织成多个子目录，每个子目录都可以有自己的<code>CMakeLists.txt</code> 文件，方便地管理和构建大型项目。</p><h5 id="install-关键字"><code>INSTALL</code> 关键字</h5><p><code>INSTALL</code>用于定义要安装的文件、目录和相关设置。它用于在构建过程中指定将生成的文件复制到特定位置的规则。</p><p><code>INSTALL</code> 关键字的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">INSTALL</span>([CODE &lt;code&gt;]<br>        [SCRIPT &lt;<span class="hljs-keyword">file</span>&gt;]<br>        [SCRIPTS &lt;files&gt;...]<br>        [FILES &lt;files&gt;...]<br>        [PROGRAMS &lt;files&gt;...]<br>        [DIRECTORY &lt;dir&gt;...]<br>        [TARGETS &lt;targets&gt;...]<br>        [<span class="hljs-keyword">EXPORT</span> &lt;<span class="hljs-keyword">export</span>-name&gt;]<br>        [ALIAS &lt;<span class="hljs-keyword">target</span>&gt;]<br>        [FILES_MATCHING]<br>        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]<br>         [EXCLUDE] [PERMISSIONS permissions...]<br>         [CONFIGURATIONS [Debug|Release|...]]]...<br>        [...])<br></code></pre></td></tr></table></figure><p>下面是 INSTALL 关键字的一些常用选项：</p><ul><li><code>CODE &lt;code&gt;</code> ：指定自定义安装逻辑的 CMake代码。</li><li><code>SCRIPT &lt;file&gt;</code>：指定一个脚本文件，该脚本文件包含安装逻辑。</li><li><code>SCRIPTS &lt;files&gt;...</code>：指定多个脚本文件，这些脚本文件包含安装逻辑。</li><li><code>FILES &lt;files&gt;...</code> ：指定要安装的普通文件。</li><li><code>PROGRAMS &lt;files&gt;...</code>：指定要安装的可执行文件。</li><li><code>DIRECTORY &lt;dir&gt;...</code> ：指定要安装的目录。</li><li><code>TARGETS &lt;targets&gt;...</code>：指定要安装的构建目标（可执行文件、静态库、共享库等）。</li><li><code>EXPORT &lt;export-name&gt;</code>：指定要安装的导出目标。</li><li><code>ALIAS &lt;target&gt;</code>：指定要安装的构建目标的别名。</li><li><code>FILES_MATCHING</code> ：指定在安装文件时进行匹配的模式。</li><li><code>PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;</code>：指定文件匹配的模式或正则表达式。</li><li><code>EXCLUDE</code> ：排除匹配的文件。</li><li><code>PERMISSIONS permissions...</code> ：指定安装文件的权限。</li><li><code>CONFIGURATIONS [Debug|Release|...]</code>：指定仅在特定构建配置下安装文件。</li></ul><p>INSTALL关键字允许您以灵活的方式定义文件和目录的安装规则。可以使用多个 INSTALL关键字来安装多个文件和目录。例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># CMakeLists.txt</span><br><br><span class="hljs-comment"># 安装脚本文件和目录</span><br><span class="hljs-keyword">INSTALL</span>(SCRIPT my_script.cmake)<br><span class="hljs-keyword">INSTALL</span>(DIRECTORY my_directory DESTINATION /path/to/destination)<br><br><span class="hljs-comment"># 安装文件</span><br><span class="hljs-keyword">INSTALL</span>(FILES file1.txt file2.txt DESTINATION /path/to/destination)<br><br><span class="hljs-comment"># 安装可执行文件</span><br><span class="hljs-keyword">INSTALL</span>(PROGRAMS my_program DESTINATION /path/to/destination)<br><br><span class="hljs-comment"># 安装构建目标</span><br><span class="hljs-keyword">INSTALL</span>(TARGETS my_target RUNTIME DESTINATION /path/to/destination)<br></code></pre></td></tr></table></figure><p>上述示例演示了如何使用 <code>INSTALL</code>关键字来指定不同类型的文件和目录的安装位置。</p><h4 id="cmake-指令"><code>cmake</code> 指令</h4><ol type="1"><li><p><code>cmake</code> 基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake [options] &lt;path-to-source&gt;<br></code></pre></td></tr></table></figure><ul><li><code>options</code>：CMake的选项，用于配置生成过程的行为和参数。</li><li><code>&lt;path-to-source&gt;</code> ：<code>CMakeLists.txt</code>所在的源代码目录路径。</li></ul></li><li><p>常用选项：</p><ul><li><code>-G &lt;generator&gt;</code>：指定生成器，用于生成特定构建系统的文件（如 Makefile 或 Visual Studio解决方案）。例如，<code>-G "Unix Makefiles"</code> 表示生成 Unix系统下的 Makefile 文件。</li><li><code>-D &lt;var&gt;=&lt;value&gt;</code> ：设置 CMake变量的值。例如，<code>-D CMAKE_BUILD_TYPE=Release</code> 设置 CMake 变量<code>CMAKE_BUILD_TYPE</code> 的值为 <code>Release</code>。</li><li><code>-B &lt;path-to-build&gt;</code>：指定构建目录的路径。生成的构建系统文件将存储在该目录中。</li><li><code>-S &lt;path-to-source&gt;</code> ：指定源代码目录的路径。</li></ul></li><li><p>示例用法：</p><ul><li>在源代码目录中直接运行CMake（in-source build）： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /path/to/source &amp;&amp; cmake .<br></code></pre></td></tr></table></figure></li><li>在指定的构建目录中运行CMake（out-of-source build）：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /path/to/build &amp;&amp; cmake /path/to/source<br></code></pre></td></tr></table></figure></li><li>指定生成器和构建类型： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release /path/to/source<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="make-指令"><code>make</code> 指令</h4><p>Make是一个常用的构建工具，用于自动化软件项目的编译和构建过程。它使用一个名为<code>Makefile</code>的文件来定义构建规则和依赖关系，以确定如何生成目标文件（例如可执行文件、库文件等）。</p><p>以下是 <code>make</code> 指令的基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make [options] [target]<br></code></pre></td></tr></table></figure><p>其中，<code>options</code> 是可选的命令行选项，用于控制<code>make</code> 的行为。<code>target</code> 是要构建的目标，通常是在<code>Makefile</code> 中定义的一个规则。</p><p>常用的 <code>make</code> 选项包括：</p><ul><li><code>-f &lt;filename&gt;</code>：指定要使用的 <code>Makefile</code>文件的名称。如果未指定，则默认使用当前目录下的 <code>Makefile</code>文件。</li><li><code>-C &lt;dir&gt;</code>：在指定的目录下执行 <code>make</code>命令。这可以用于指定 <code>Makefile</code> 文件所在的目录。</li><li><code>-j &lt;num&gt;</code>：指定并行构建的作业数，加快构建速度。</li></ul><p>在 <code>Makefile</code>文件中，你可以定义多个目标和规则，每个规则描述了如何根据依赖关系生成目标文件。一个基本的规则结构如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">target: dependencies</span><br>    command1<br>    command2<br>    ...<br></code></pre></td></tr></table></figure><p>其中，<code>target</code> 是目标文件的名称，<code>dependencies</code>是生成目标文件所依赖的文件或目标，<code>commandX</code>是用于生成目标文件的命令。</p><p>以下是一个简单的示例 <code>Makefile</code> 文件的内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">hello: main.c hello.c</span><br>    gcc -o hello main.c hello.c<br></code></pre></td></tr></table></figure><p>上述示例中，我们定义了一个目标 <code>hello</code>，它依赖于<code>main.c</code> 和 <code>hello.c</code>这两个源代码文件。<code>make</code>指令会检查依赖关系，并在需要时执行相应的命令来生成目标文件。</p><p>要使用 <code>make</code> 指令进行构建，只需在终端中进入包含<code>Makefile</code> 文件的目录，并运行 <code>make</code>命令。如果没有指定目标，默认会构建第一个目标。</p><blockquote><p>Make工具基于目标文件和规则之间的依赖关系，通过增量构建的方式进行构建，只重新构建已修改的文件和受其影响的文件，从而提高构建效率。Make是一个强大而灵活的构建工具，它在软件开发中广泛应用。通过定义适当的规则和依赖关系，可以自动化构建过程，简化项目的管理和部署。</p></blockquote><p>CMake 与 Make 之间的关系可以简述如下：</p><ul><li>CMake负责生成适合不同平台和编译器的构建系统文件（如Makefile）。</li><li>Make 负责根据 Makefile中的规则和依赖关系来执行实际的编译和构建操作。</li></ul><h6 id="make-install-指令"><code>make install</code> 指令</h6><p><code>make install</code>用于将构建生成的文件复制到指定位置，完成软件的安装过程。这个指令通常与<code>Makefile</code> 文件一起使用，用于定义安装规则。</p><p>在 <code>Makefile</code> 中，可以定义一个名为 <code>install</code>的目标规则，该规则包含安装过程的指令。安装指令通常使用系统的<code>cp</code> 命令或类似的工具来复制文件或目录到目标位置。</p><p>以下是一个示例 <code>Makefile</code> 文件中的 <code>install</code>规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">install:</span><br>    cp myapp /usr/local/bin<br>    cp -r resources /usr/local/share/myapp<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>install</code>规则中定义了两个命令。第一个命令使用 <code>cp</code> 命令将<code>myapp</code> 可执行文件复制到 <code>/usr/local/bin</code>目录下，第二个命令将 <code>resources</code> 目录递归复制到<code>/usr/local/share/myapp</code> 目录下。</p><p>要执行安装过程，可以在命令行中运行 <code>make install</code>命令。Make 将读取 Makefile 文件，并根据 <code>install</code>目标规则中定义的指令来执行安装操作。</p><p>需要注意的是，<code>make install</code>命令通常需要使用超级用户权限（sudo）来执行，因为将文件复制到系统目录通常需要管理员权限。如果没有权限，可以尝试将文件复制到用户的个人目录或其他有权限的目录。</p><p>使用 <code>make install</code>指令可以方便地自动化软件的安装过程，将生成的文件复制到指定位置，使用户可以直接使用已安装的软件。</p><h4 id="工程化目录结构">工程化目录结构</h4><p>基本目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├─CMakeLists.txt<br>├─README.md<br>├─bulid<br>├─runhello.sh<br>├─doc<br>├─COPYRIGHT<br>├─src<br>├───CMakeLists.txt<br>└───demo.cpp<br></code></pre></td></tr></table></figure><p>每个目录下都有一个 <code>CMakeLists.txt</code> ，用于实现 CMake嵌套。</p><ul><li><p>外层 <code>CMakeLists.txt</code> ：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(HELLO) <span class="hljs-comment"># 指定项目名称</span><br><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src bin) <span class="hljs-comment"># 将 src 子目录加入工程并指定编译输出路径为 bin 目录</span><br></code></pre></td></tr></table></figure></p></li><li><p>内层 <code>CMakeLists.txt</code> ：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(SRC_LIST demo.cpp)<br><br><span class="hljs-keyword">MESSAGE</span>(STUTAS <span class="hljs-string">&quot;Configuring project...&quot;</span>)<br><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(Demo <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>) <span class="hljs-comment"># 添加可执行项目</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>bulid</code>文件夹：用于存储构建过程中生成的中间文件和最终的构建结果。</p></li><li><p><code>src</code> 文件夹：用于存放源代码</p></li><li><p><code>doc</code> 文件夹：用于存放文档</p></li><li><p><code>COPYRIGHT</code> ：版权</p></li><li><p><code>runhello.sh</code> ：安装脚本</p></li></ul><h4 id="构建库">构建库</h4><h5 id="add_library-关键字"><code>ADD_LIBRARY</code> 关键字</h5><p><code>ADD_LIBRARY</code>是一个用于定义和构建库（Library）目标的关键字。它用于创建静态库（StaticLibrary）、共享库（Shared Library）或模块库（ModuleLibrary）的规则，并将源代码文件编译成库文件。</p><p>ADD_LIBRARY 关键字的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_LIBRARY</span>(&lt;name&gt; [STATIC | SHARED | MODULE]<br>            [EXCLUDE_FROM_ALL]<br>            [source1] [source2 ...])<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;name&gt;</code>指定要创建的库的名称。可以使用自定义名称或者 CMake的变量作为库的名称。</p><p>选项 <code>[STATIC | SHARED | MODULE]</code>指定库的类型。可以选择其中一种类型： -<code>STATIC</code>：创建静态库。静态库在链接时被静态地链接到可执行文件中。-<code>SHARED</code>：创建共享库（也称为动态库）。共享库在运行时被动态地加载。- <code>MODULE</code>：创建模块库（适用于像 Apple 的 macOS平台）。模块库是一种特殊的共享库类型。</p><p>可选项 <code>[EXCLUDE_FROM_ALL]</code>表示将该库目标从生成的默认目标中排除。</p><p>后续的参数 <code>source1</code>、<code>source2</code>等指定库的源代码文件，可以是单个源文件，也可以是一个文件列表。CMake将编译这些源代码文件，并生成库文件。</p><p>以下是一个示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># CMakeLists.txt</span><br><br><span class="hljs-comment"># 创建静态库</span><br><span class="hljs-keyword">ADD_LIBRARY</span>(my_static_lib STATIC source1.cpp source2.cpp)<br><br><span class="hljs-comment"># 创建共享库</span><br><span class="hljs-keyword">ADD_LIBRARY</span>(my_shared_lib SHARED source3.cpp source4.cpp)<br></code></pre></td></tr></table></figure><h5 id="include_directories-关键字"><code>INCLUDE_DIRECTORIES</code>关键字</h5><p><code>INCLUDE_DIRECTORIES</code>是一个用于指定包含目录的关键字。它用于将一个目录添加到编译器的包含路径中，以使编译器能够找到所需的头文件。</p><p><code>INCLUDE_DIRECTORIES</code> 关键字的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>([AFTER|BEFORE] directory1 [directory2 ...])<br></code></pre></td></tr></table></figure><p>其中，<code>directory1</code>、<code>directory2</code>等参数指定要添加到包含路径中的目录。可以指定一个或多个目录。</p><p>选项 <code>[AFTER|BEFORE]</code>控制新目录的添加顺序。默认情况下，新目录会添加到已有包含目录列表的末尾，即在已有包含目录之后。如果指定了<code>AFTER</code> 选项，新目录将添加到列表的末尾。如果指定了<code>BEFORE</code> 选项，新目录将添加到列表的开头。</p><p>以下是一个示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># CMakeLists.txt</span><br><br><span class="hljs-comment"># 添加包含目录</span><br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(include_dir1 include_dir2)<br><br><span class="hljs-comment"># 添加包含目录，并将其放置在列表的开头</span><br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(BEFORE include_dir3)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>CMake</tag>
      
      <tag>跨平台项目构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字典树</title>
    <link href="/2023/05/17/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    <url>/2023/05/17/%E5%AD%97%E5%85%B8%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍">介绍</h4><p><strong>字典树（Trie）</strong>，就是像字典一样的树，可用于插入和检索字符串。</p><p>假设某字典树只需要存储单词，所有单词均由 26个小写字母组合而成，那么对于该字典树而言，每个节点都有 27 个域，分别为26 个子节点（可以为 <code>nullptr</code>）以及一个布尔标识符，表示是否存在某个单词以该字母结尾。</p><p>以下图为例：</p><p><img src="https://typora-1313035735.cos.ap-nanjing.myqcloud.com/img/2023-07-16-172405.png" style="zoom:33%;" /></p><p>该字典树一共存储了 dog、dot、dig、tea、tease、tease六个单词，其中黄色的节点表示结束节点。</p><h4 id="代码实现">代码实现</h4><p>在这里还是以 26 个字母组成的单词为例，给出字典树的代码实现。</p><h5 id="使用链式节点的字典树模版">使用链式节点的字典树模版</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trie</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    std::vector&lt;Trie*&gt; child;<br>    <span class="hljs-type">bool</span> isEnd;<br><br>    <span class="hljs-function">Trie* <span class="hljs-title">searchPrefix</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; prefix)</span> </span>&#123;<br>        Trie* p = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : prefix) &#123;<br>            p = p-&gt;child[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Trie</span>(): <span class="hljs-built_in">child</span>(<span class="hljs-number">26</span>, <span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">isEnd</span>(<span class="hljs-literal">false</span>) &#123;&#125;<br>    ~<span class="hljs-built_in">Trie</span>() &#123;<br>        <span class="hljs-keyword">for</span> (Trie* ct : child) &#123;<br>            <span class="hljs-keyword">if</span> (ct != <span class="hljs-literal">nullptr</span>) &#123;<br>                <span class="hljs-keyword">delete</span> ct;<br>                ct = <span class="hljs-literal">nullptr</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; word)</span> </span>&#123;<br>        Trie* p = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> ch : word) &#123;<br>            <span class="hljs-keyword">if</span> (p-&gt;child[ch - <span class="hljs-string">&#x27;a&#x27;</span>] == <span class="hljs-literal">nullptr</span>) &#123;<br>                p-&gt;child[ch - <span class="hljs-string">&#x27;a&#x27;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Trie</span>();<br>            &#125;<br>            p = p-&gt;child[ch - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        &#125;<br>        p-&gt;isEnd = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; word)</span> </span>&#123;<br>        Trie* p = <span class="hljs-built_in">searchPrefix</span>(word);<br>        <span class="hljs-keyword">return</span> p &amp;&amp; p-&gt;isEnd;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>字典树</tag>
      
      <tag>字符串匹配</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库规范化理论</title>
    <link href="/2023/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA/"/>
    <url>/2023/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是数据库规范化">什么是数据库规范化？</h4><p><strong>数据库规范化（Normalization）</strong>是一种数据库设计技术，其旨在实现以下两个主要目标：</p><ul><li>减少数据冗余（Redundancy）。</li><li>确保数据的依赖性是有意义的，即数据存储是有逻辑的。</li></ul><h4 id="函数依赖">函数依赖</h4><h5 id="基本定义">基本定义</h5><p><strong>函数依赖（FunctionalDependncy）</strong>是规范化中的重要概念，简而言之，函数依赖用于描述<strong>属性（Attributes）</strong>之间的关系。</p><p>概念：</p><blockquote><p>若 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 是关系模式 <spanclass="math inline">\(R\)</span> 中的两个属性集合，对于给定的 <spanclass="math inline">\(A\)</span> 值，都有唯一的 <spanclass="math inline">\(B\)</span> 值与其对应，我们就称 <spanclass="math inline">\(A\)</span> 函数决定 <spanclass="math inline">\(B\)</span>，<span class="math inline">\(B\)</span>函数依赖于 <span class="math inline">\(A\)</span>，记作：<spanclass="math inline">\(A \to B\)</span>，其中 <spanclass="math inline">\(A\)</span> 称为决定因子（Determinant）</p><p>若 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 相互依赖，即二者一一对应，则记为：<spanclass="math inline">\(A\)</span> <spanclass="math inline">\(\leftrightarrow B\)</span></p></blockquote><p>例如：</p><p>在一个学生信息的关系模型 <spanclass="math inline">\(Student(\underline{s\_id}, name, gender,age)\)</span> 中，我们假设学号 <spanclass="math inline">\(s\_id\)</span> 是关系模型中的主键，则有： <spanclass="math display">\[s\_id \to name\]</span>即：唯一的学号对应唯一的姓名，因此姓名在这里是函数依赖于学号的。</p><h5 id="平凡函数依赖和非平凡函数依赖">平凡函数依赖和非平凡函数依赖</h5><p>我们从决定因子和被决定因子的集合关系角度出发可以将函数依赖分为两类：</p><ul><li><p>平凡函数依赖（Trivial Functional Dependency）：</p><p>若 <span class="math inline">\(A \to B\)</span> ，且 <spanclass="math inline">\(B \subseteq A\)</span>，则称该依赖为平凡依赖。</p></li><li><p>非平凡函数依赖（Nontrivial Functional Dependency）：</p><p>若 <span class="math inline">\(A \to B\)</span> ，且 <spanclass="math inline">\(B \not\subseteq A\)</span>，则称该依赖为非平凡依赖。</p></li></ul><h5 id="部分函数依赖和完全函数依赖">部分函数依赖和完全函数依赖</h5><p>同时，我们从决定因子属性的必要性又可以将函数依赖分为两类：</p><ul><li><p>部分函数依赖（Partial Functional Dependency）：</p><p>若 <span class="math inline">\(A \to B\)</span> ，且存在 <spanclass="math inline">\(A\)</span> 的真子集 <spanclass="math inline">\(X\)</span> ，使得 <span class="math inline">\(X\to B\)</span> ，我们就称 <span class="math inline">\(B\)</span>部分函数依赖于 <span class="math inline">\(A\)</span> 。</p></li><li><p>完全函数依赖（Full Functional Dependency）：</p><p>若 <span class="math inline">\(A \to B\)</span> ，且不存在 <spanclass="math inline">\(A\)</span> 的真子集 <spanclass="math inline">\(X\)</span> ，使得 <span class="math inline">\(X\to B\)</span>，我们就称 <span class="math inline">\(B\)</span>完全函数依赖于 <span class="math inline">\(A\)</span> 。</p><p>即 <span class="math inline">\(A\)</span>中删去任意一个属性都无法满足 <span class="math inline">\(A \toB\)</span> 。</p></li></ul><p>例如，在上述例子中，显然有 <span class="math inline">\((s\_id, name)\to gender\)</span>， 但其决定因子的一个真子集 <spanclass="math inline">\(s\_id\)</span> 也满足被 <spanclass="math inline">\(gender\)</span>函数依赖，因此该函数依赖是一个部分函数依赖。相反，<spanclass="math inline">\(s\_id \to gender\)</span>就是一个完全函数依赖。</p><p>注意到，一般只有在 <span class="math inline">\(A\)</span>是多个特征的集合时才会考虑此分类，若 <spanclass="math inline">\(A\)</span> 为单属性，且 <spanclass="math inline">\(A \to B\)</span> ，则一定构成完全函数依赖。</p><h5 id="传递函数依赖">传递函数依赖</h5><p>函数依赖具有传递性，传递函数依赖（Transitive FunctionalDependency）描述如下：</p><p>若 <span class="math inline">\(A\)</span> ，<spanclass="math inline">\(B\)</span> ，<spanclass="math inline">\(C\)</span> 是关系模型 <spanclass="math inline">\(R\)</span> 中的三个特征集合，且满足：</p><ul><li><span class="math inline">\(A \to B\)</span> 且 <spanclass="math inline">\(B \not\to A\)</span></li><li><span class="math inline">\(B \to C\)</span></li></ul><p>则称 <span class="math inline">\(C\)</span> 通过 <spanclass="math inline">\(B\)</span> 函数依赖于 <spanclass="math inline">\(A\)</span> 。</p><h4 id="多值依赖">多值依赖</h4><p>设 <span class="math inline">\(R(U)\)</span> 是属性集 <spanclass="math inline">\(U\)</span> 上的一个关系模式。<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(Y\)</span>、<span class="math inline">\(Z\)</span>是 <span class="math inline">\(U\)</span> 的子集，若对 <spanclass="math inline">\(U\)</span> 的任意一对关系而言，给定一对 <spanclass="math inline">\((X, Z)\)</span> 的值，都有若干组 <spanclass="math inline">\(Y\)</span> 值与之对应，而 <spanclass="math inline">\(Y\)</span> 的取值仅仅与 <spanclass="math inline">\(X\)</span> 相关而与 <spanclass="math inline">\(Z\)</span>无关，这就是<strong>多值依赖（Multi-valuedDependency）</strong>。记作：<span class="math inline">\(X \to\!\!\!\toY\)</span>。</p><blockquote><p>我们也可以这样描述：给定 <span class="math inline">\(X\)</span>的值，有多组 <span class="math inline">\((Y, Z)\)</span>的值与之对应，且 <span class="math inline">\(Y\)</span> 与 <spanclass="math inline">\(Z\)</span> 的取值相互独立。</p></blockquote><p>例如：</p><p>我们给定关系 <span class="math inline">\(subject(subject\_name,teacher, text\_book)\)</span>来描述学科、老师和学科教材的关系，在该关系模型中，一门学科对应多组老师和教材，而老师和教材又是相互独立的，即老师和学科教材分别只决定于学科，所以我们有：<span class="math display">\[\begin{array}{}subject\_name \to\!\!\!\to teacher \\subject\_name \to\!\!\!\to text\_book\end{array}\]</span></p><h5 id="平凡多值依赖和非平凡多值依赖">平凡多值依赖和非平凡多值依赖</h5><p>进一步，我们又可以将多值依赖分为<strong>平凡多值依赖</strong>和<strong>非平凡多值依赖</strong>：</p><ul><li><p>平凡多值依赖（Trivial Multi-valued Dependency）：</p><p>在关系模型 <span class="math inline">\(R\)</span> 的属性集为 <spanclass="math inline">\(U\)</span>，属性 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 满足 <span class="math inline">\(A\to\!\!\!\to B\)</span> 且满足以下两个条件之一：</p><ul><li><span class="math inline">\(A \subseteq B\)</span></li><li><span class="math inline">\(A \cup B = R\)</span></li></ul><p>我们就称该多值依赖是平凡的。</p></li><li><p>非平凡多值依赖（Nontrivial Multi-valued Dependency）：</p><p>若 <span class="math inline">\(A \to\!\!\!\to B\)</span>且不满足以上任意一个条件，我们就称该多值依赖是非平凡的。</p></li></ul><h4 id="范式">范式</h4><p><strong>范式（Normal Form）</strong>，简称NF，是一种数据库规范化评级标准，范式越高，数据模型越规范。</p><p>数据库规范化技术，就是不断提高数据模型的范式等级。</p><h5 id="unf">UNF</h5><p><strong>UNF（UnormalizedForm）</strong>，即无范式，是一种未规范化的表格，表格中的数据可能包括一个或多个值。</p><p>示例：</p><p><img src="https://p.ipic.vip/4hkqj3.png" style="zoom: 33%;" /></p><h5 id="nf">1NF</h5><p><strong>1NF（First NormalForm）</strong>，即第一范式。指在一张表格中给定行和列，对应唯一的数据，且一个关系模型中的所有的属性都是不可分的基本数据项。1NF是关系型数据库的基本要求。</p><p>示例：</p><p><img src="https://p.ipic.vip/mcmetv.png" style="zoom:33%;" /></p><blockquote><p><strong>UNF <span class="math inline">\(\to\)</span> 1NF</strong></p><p>将缺省单元格的数据进行拷贝，然后对无范式表格重新划分，即可得到每个单元格仅有一个值的第一范式表格。</p></blockquote><h5 id="nf-1">2NF</h5><p><strong>2NF（Second Normal Form）</strong>，即第二范式。指在 1NF的基础上，满足所有非主属性<strong>完全依赖</strong>于<strong>候选键（Candidatekey）</strong>。</p><blockquote><p><strong>1NF <span class="math inline">\(\to\)</span> 2NF</strong></p><ol type="1"><li>确定主键：确定 1NF 关系中的主键</li><li>确定函数依赖：分析非主键列对主键的完全依赖关系。也就是说，找出哪些非主键列的值是由主键决定的，而不是由主键的一部分决定的</li><li>创建新表：对于那些非主键列存在部分依赖的情况，将其分离出来，创建一个新的表</li><li>调整关系：在新的表中，将非主键列和相应的主键列作为新表的列</li></ol></blockquote><p>示例：</p><p>上述关系中存在如下函数依赖：</p><p><img src="https://p.ipic.vip/xxd1hu.png" style="zoom:30%;" /></p><p>不难发现，我们可以指定 <span class="math inline">\((clinetNo,PropertyNo)\)</span> 作为该关系中的主键，而函数依赖 fd2 和 fd3的决定因子是主键的真子集，因此其被决定因子（图中下画线部分的属性）是部分依赖于主键的，因此我们要将其从当前关系中抽离出来：</p><p>最终建立的关系模型的 Schema 如下：</p><p><img src="https://p.ipic.vip/cdyt6d.png" style="zoom:25%;" /></p><p>该关系模型的三张表都不存在非主属性对主键的部分依赖，各自满足第二范式。</p><h5 id="nf-2">3NF</h5><p><strong>3NF（Third Normal Form）</strong>，即第三范式。指在 2NF的基础上，不存在非主属性<strong>传递依赖</strong>于候选键。</p><blockquote><p><strong>2NF <span class="math inline">\(\to\)</span> 3NF</strong></p><ol type="1"><li>确定主键</li><li>确定函数依赖</li><li>找到依赖于主键的传递函数依赖，并将其分离出来</li></ol></blockquote><p>示例：</p><p>在上述建立的 2NF 关系模型中的第二张表 <spanclass="math inline">\(PropertyOwner\)</span> 中，存在函数依赖关系 <spanclass="math inline">\(propertyNo \to ownerNo\)</span>（<spanclass="math inline">\(ownerNo \not\to propertyNo\)</span>）和 $ ownerNooName$ ，因此 <span class="math inline">\(oName\)</span>传递依赖于主键，所以我们要将其从当前关系中分离出来。</p><p>满足 3NF 的关系模型 Schema 如下所示：</p><p><img src="https://p.ipic.vip/4vfatx.png" style="zoom:25%;" /></p><p>该关系模型中的 4张表都不存在非主属性对主键的传递依赖，各自满足第三范式。</p><h5 id="bcnf">BCNF</h5><p><strong>BCNF（Boyce-Codd NormalForm）</strong>，即巴斯-科德范式。指在 3NF的基础上，清除了主属性对候选键的部分函数依赖。</p><p><strong>即满足 BCNF的充要条件是关系模型中所有函数依赖的决定因子都是候选键。</strong></p><blockquote><p><strong>3NF <span class="math inline">\(\to\)</span> BCNF</strong></p><ol type="1"><li>确定主键和主属性</li><li>确定函数依赖</li><li>消除主属性对候选键的部分函数依赖</li></ol></blockquote><p>例如，有如下关系模型： <span class="math display">\[studentGrade(\underline{class\_id}, \underline{s\_id}, t\_id, grade)\]</span>该关系模型用于储存学生某门课程的成绩，每门课有且仅有一名老师来教学，可以作为该表的候选键有<span class="math inline">\((class\_id, s\_id)\)</span> 或者 <spanclass="math inline">\((t\_id, s\_id)\)</span>，我们选取前者作为主键，那么此关系模型中唯一的非主属性就是 <spanclass="math inline">\(grade\)</span> 。</p><p>该关系模型符合 3NF，但是我们不难发现，主属性 <spanclass="math inline">\(t\_id\)</span>对主键构成部分依赖关系，因此该关系模型不符合BCNF，因此我们将其拆分为两张表： <span class="math display">\[\begin{array}{}teacher(\underline{class\_id}, t\_id) \\studentGrade(\underline{class\_id}, \underline{s\_id}, grade)\end{array}\]</span> 这样，我们就消除了主属性对候选键的部分依赖，上述两张表各自符合BCNF。</p><h5 id="nf-3">4 NF</h5><p><strong>4 NF（Forth Normal Form）</strong>，即第四范式，即在 BCNF的基础上，消除了所有决定因子不为候选键的非平凡多值依赖。换言之，满足 4NF的充要条件是对于关系 <span class="math inline">\(R\)</span>中的每一对非平凡多值依赖 <span class="math inline">\(A \to\!\!\!\toB\)</span> 而言，<span class="math inline">\(A\)</span>都是关系中的候选键。</p><blockquote><p><strong>BCNF <span class="math inline">\(\to\)</span>4NF</strong></p><ol type="1"><li>确定主键和候选键</li><li>确定关系中的非平凡多值依赖</li><li>消除所有决定因子不为候选键的非平凡多值依赖</li></ol></blockquote><p>例如，现有如下关系：</p><p><img src="https://p.ipic.vip/elwe0k.png" style="zoom:50%;" /></p><p>在如上 <span class="math inline">\(BranchStaffOwner(branchNo, sName,oName)\)</span> 关系中，一个 <spanclass="math inline">\(branchNo\)</span> 可以对应多组 <spanclass="math inline">\((sName, oName)\)</span> ，而 <spanclass="math inline">\(sName\)</span> 和 <spanclass="math inline">\(oName\)</span> 之间相互不影响，所以我们有： <spanclass="math display">\[\begin{array}{}branchNo \to\!\!\!\to sName \\branchNo \to\!\!\!\to oName\end{array}\]</span> 而 <span class="math inline">\(branchNo\)</span>在这里不是候选键，所以我们要消除消除这两对非平凡多值依赖，因此将该关系拆分为两张表：</p><p><img src="https://p.ipic.vip/nt56ny.png" style="zoom:50%;" /></p><p>这样我们就消除了上面提到的两对非平凡多值依赖，以上两张表 <spanclass="math inline">\(Branch(branchNo, sName)\)</span>、<spanclass="math inline">\(BranchOwner(BranchNo, oName)\)</span>分别满足第四范式。</p><p>事实上第四范式之上还有<strong>第五范式（Fifth NormalForm）</strong>，但第四范式已经是相当规范的等级了，因此第五范式笔者在此就不赘述了。😃</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统</tag>
      
      <tag>数据库规范化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在程序中计算定积分？—— Simpson 公式讲解</title>
    <link href="/2023/04/30/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%AE%9A%E7%A7%AF%E5%88%86%EF%BC%9F%E2%80%94%E2%80%94%20Simpson%20%E5%85%AC%E5%BC%8F%E8%AE%B2%E8%A7%A3/"/>
    <url>/2023/04/30/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%AE%9A%E7%A7%AF%E5%88%86%EF%BC%9F%E2%80%94%E2%80%94%20Simpson%20%E5%85%AC%E5%BC%8F%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>Simpson</strong>公式是一种用于求积分近似值的方法，相对于常规的矩形逼近和梯型逼近，其精度要高很多。</p><p>公式如下： <span class="math display">\[\int_a^b f(x)dx \approx \frac{b - a}{6n} (f(a) + f(b) + 2 \sum_{i = 1} ^{n - 1}f(x_i) + 4 \sum_{i = 0}^{n - 1}f(x_{i + 0.5}))\]</span> 其中 <span class="math inline">\(n\)</span>是区间分隔的数量，<span class="math inline">\(n\)</span>越大，精度越高。</p><hr /><h4 id="数学证明">数学证明</h4><p><strong>Simpson</strong>积分公式的原理就是采用二次函数逼近目标函数。</p><center><img src="https://p.ipic.vip/zm09je.png" alt="" style="zoom:40%;" /></center><p>如上图所示，我们将函数区间 <span class="math inline">\([x_1,x_2]\)</span> 近似看作是二次函数，<spanclass="math inline">\(x_{1.5}\)</span> 是区间中点，我们规定： <spanclass="math display">\[\begin{array}{}f(x_1) = c_2 x_1^2 + c_1 x_1 + c_0 \\f(x_2) = c_2 x_2^2 + c_1 x_2 + c_0 \\f(x_{1.5}) = c_0\end{array}\]</span> 则积分面积 <span class="math inline">\(S = \int_{x_1}^{x_2}f(x)dx \approx \int_{x_1}^{x_2} (c_2 x^2 + c_1 x + c_0)dx\)</span> <spanclass="math display">\[\begin{array}{}\implies S \approx  \frac{c_2}{3}(x_2^3 - x_1^3) + \frac{c1}{2}(x_2^2 -x_1^2) + c_0(x_2 - x_1) \\= \frac{x_2 - x_1}{6}(f(x_1) + f(x_2) + 4 f(x_{1.5}))\end{array}\]</span> 现在我们将函数积分区域 <span class="math inline">\([a,b]\)</span> 划分为 <span class="math inline">\(n\)</span> 段，对每一段<span class="math inline">\([x_i, x_{i + 1}]\)</span>采取同样的方式求定积分，</p><p>最后求和就可以得到我们的目标答案： <span class="math display">\[\begin{array}{}\int_a^b f(x)dx \approx \frac{b - a}{6n} (f(a) + f(b) + 2 \sum_{i = 1} ^{n - 1}f(x_i) + 4 \sum_{i = 0}^{n - 1}f(x_{i + 0.5})) \\(x_0 = a, x_n = b)\end{array}\]</span> <strong>误差</strong></p><p>最大误差为 <span class="math inline">\(\frac{(b - a)^5}{180 n^4}M\)</span>，其中 <span class="math inline">\(M\)</span> 是函数在区间<span class="math inline">\([a, b]\)</span>上四阶导的绝对值的最大值。</p><h4 id="代码实现">代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">fn</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">exp</span>(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve_rect</span><span class="hljs-params">(<span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 采用一般的矩形逼近法求定积分</span><br>    <span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> d = (right - left) / n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res += <span class="hljs-built_in">fn</span>(left + i * d);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res * d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve_simpson</span><span class="hljs-params">(<span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 采取辛普森公式求定积分</span><br>    <span class="hljs-type">double</span> res = -<span class="hljs-built_in">fn</span>(left) + <span class="hljs-built_in">fn</span>(right);<br>    <span class="hljs-type">double</span> d = (right - left) / n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res += (<span class="hljs-number">2</span> * <span class="hljs-built_in">fn</span>(left + i * d) + <span class="hljs-number">4</span> * <span class="hljs-built_in">fn</span>(left + (i + <span class="hljs-number">0.5</span>) * d));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> d * res / <span class="hljs-number">6</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, <span class="hljs-built_in">solve_rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>));      <span class="hljs-comment">// 0.245014</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, <span class="hljs-built_in">solve_rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>));     <span class="hljs-comment">// 0.262393</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, <span class="hljs-built_in">solve_rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>));    <span class="hljs-comment">// 0.264057</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, <span class="hljs-built_in">solve_simpson</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>));   <span class="hljs-comment">// 0.264241</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实际答案 <span class="math inline">\(\int_0^1 x e^{-x}dx = 1 -\frac{2}{e} \approx 0.2642411176571\)</span>，可见上述积分采用 Simpson公式计算时在 <span class="math inline">\(n = 10\)</span>时已经达到了一个较高的精度，远超常规的矩形逼近法。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算几何</tag>
      
      <tag>Simpson 公式</tag>
      
      <tag>定积分</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识点总结</title>
    <link href="/2023/04/10/MySQL%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/10/MySQL%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="mysql-基本介绍">MySQL 基本介绍</h3><p>MySQL 是一种<strong>关系型数据库管理系统</strong>，由瑞典 MySQL AB公司开发，属于 Oracle旗下产品，由于其体积小、速度快、成本低、<strong>开源</strong>等优点，使其在Web 开发中尤其受欢迎。</p><p><a href="https://www.mysql.com/">MySQL 官网</a></p><h4 id="mysql-客户端连接">MySQL 客户端连接</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql -u [用户名] -p<br></code></pre></td></tr></table></figure><p>示例：</p><p>以 <code>root</code> 用户登陆：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql -u root -p<br></code></pre></td></tr></table></figure><h3 id="mysql-command-介绍">MySQL Command 介绍</h3><p>MySQL 所使用的 SQL 语言是用于访问数据库的最常用标准化语言。</p><h4 id="sql-语句分类">SQL 语句分类</h4><p>最常见的 SQL 语句包括以下 4 大类：</p><ul><li>DDL（Data Definition Language）<ul><li>用途：对数据库对象（数据库、表、列、索引等）进行创建、删除、修改等。</li><li>常用关键字：<code>create</code>、<code>drop</code>、<code>alter</code></li></ul></li><li>DML（Data Manipulation Language）<ul><li>用途：用于添加、修改、删除和查询数据库记录，并检查数据完整性。</li><li>常用关键字：<code>insert</code>、<code>update</code>、<code>delete</code></li></ul></li><li>DQL（Data Query Language）<ul><li>用途：用于查询数据。</li><li>常用关键字：<code>select</code></li></ul></li><li>DCL（Data Control Language）<ul><li>用途：用于管理用户权限。</li></ul></li></ul><h4 id="ddl-语句">DDL 语句</h4><h5 id="数据库操作">数据库操作</h5><ul><li><p>查询所有数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show databases;<br></code></pre></td></tr></table></figure></p></li><li><p>创建数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database [数据库名称];<br>create database if not exists [数据库名称];<br>create database [数据库名称] default charset [字符集];<br></code></pre></td></tr></table></figure></p></li><li><p>删除数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database [数据库名称];<br>drop database if exists [数据库名称];<br></code></pre></td></tr></table></figure></p></li><li><p>使用数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use [数据库名称];<br></code></pre></td></tr></table></figure></p></li><li><p>查询当前数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select database();<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="表操作">表操作</h5><ul><li><p>查询当前数据库所有表：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br></code></pre></td></tr></table></figure></p></li><li><p>查询表结构：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc [表名];<br></code></pre></td></tr></table></figure></p></li><li><p>查询指定表的创建语句：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create table [表名];<br></code></pre></td></tr></table></figure></p></li><li><p>创建表：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table [表名](<br>    字段1   字段1类型   [约束]  [comment],<br>    字段2   字段2类型   [约束]  [comment],<br>    # ...<br>    字段n   字段n类型   [约束]  [comment]<br>)comment 表注释;<br></code></pre></td></tr></table></figure></p><p>例如：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建如下员工表<br>create table demo(<br>    id      int           comment &#x27;编号&#x27;,<br>    name    varchar(50)   comment &#x27;姓名&#x27;,<br>    age     int           comment &#x27;年龄&#x27;,<br>    gender  varchar(1)    comment &#x27;性别&#x27;<br>)comment &#x27;员工&#x27;;<br></code></pre></td></tr></table></figure></p></li><li><p>修改表名：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] rename to [新表名];<br></code></pre></td></tr></table></figure></p></li><li><p>删除表：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table (if exists) [表名];<br></code></pre></td></tr></table></figure></p></li><li><p>删除指定表，并重新创建该表（即删除表中所有行）：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">truncate table [表名];<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="字段操作">字段操作</h5><ul><li><p>添加字段：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] add [字段名] [类型(长度)] [约束] [comment];<br></code></pre></td></tr></table></figure></p><p>例如：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table staff<br>    add gender varchar(10) default &#x27;undefined&#x27; not null comment &#x27;性别&#x27;;<br></code></pre></td></tr></table></figure></p><blockquote><p>如上，给 <code>staff</code> 表格添加 <code>gender</code> 字段</p></blockquote></li><li><p>修改字段数据类型</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] modify [字段名] [新数据类型];<br></code></pre></td></tr></table></figure></p></li><li><p>修改字段名和字段数据类型：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] change [旧字段名] [新字段名] [类型(长度)] [约束] [comment];<br></code></pre></td></tr></table></figure></p><p>例如：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table staff<br>    change id s_id int not null comment &#x27;员工 ID&#x27;;<br></code></pre></td></tr></table></figure></p></li><li><p>删除字段：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] drop [字段名];<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="补充">补充</h5><h6 id="mysql-表格字段数据类型">MySQL 表格字段数据类型</h6><ul><li><p>基本数据类型：</p><table><thead><tr class="header"><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>tinyint</code></td><td>1 byte</td><td>整数</td></tr><tr class="even"><td><code>smallint</code></td><td>2 bytes</td><td>整数</td></tr><tr class="odd"><td><code>mediumint</code></td><td>3 bytes</td><td>整数</td></tr><tr class="even"><td><code>int</code> 或者 <code>integer</code></td><td>4 bytes</td><td>整数</td></tr><tr class="odd"><td><code>bigint</code></td><td>8 bytes</td><td>整数</td></tr><tr class="even"><td><code>float</code></td><td>4 bytes</td><td>单精度浮点数</td></tr><tr class="odd"><td><code>double</code></td><td>8 bytes</td><td>双精度浮点数</td></tr><tr class="even"><td><code>decimal</code></td><td>依赖于精度和标度的值</td><td>小数值</td></tr></tbody></table></li><li><p>字符串类型：</p><table><thead><tr class="header"><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>char</code></td><td>0 ~ 255 bytes</td><td>定长字符串</td></tr><tr class="even"><td><code>varchar</code></td><td>0 ~ 65535 bytes</td><td>变长字符串</td></tr><tr class="odd"><td><code>tinyblob</code></td><td>0 ~ 255 bytes</td><td>不超过 255 个字符的二进制数据</td></tr><tr class="even"><td><code>tinytext</code></td><td>0 ~ 255 bytes</td><td>短文本字符串</td></tr><tr class="odd"><td><code>blob</code></td><td>0 ~ 65535 bytes</td><td>二进制形式的长文本数据</td></tr><tr class="even"><td><code>text</code></td><td>0 ~ 65535 bytes</td><td>长文本数据</td></tr></tbody></table></li><li><p>日期类型：</p><table><thead><tr class="header"><th>类型</th><th>大小</th><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>date</code></td><td>3 bytes</td><td><code>YYYY-MM-DD</code></td><td>日期值</td></tr><tr class="even"><td><code>time</code></td><td>3 bytes</td><td><code>HH:MM:SS</code></td><td>持续时间值</td></tr><tr class="odd"><td><code>year</code></td><td>1 bytes</td><td><code>YYYY</code></td><td>年份值</td></tr><tr class="even"><td><code>datetime</code></td><td>8 bytes</td><td><code>YYYY-MM-DD HH:MM:SS</code></td><td>混合日期和时间值</td></tr><tr class="odd"><td><code>timestamp</code></td><td>4 bytes</td><td><code>YYYY-MM-DD HH:MM:SS</code></td><td>混合日期和时间值，时间戳</td></tr></tbody></table></li><li><p>枚举类型：</p><p>关键词：<code>enum</code></p><p>枚举范围需要在创建表格时通过枚举的方式指定，最多允许有 65535个成员。</p><p>例如：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table stu(<br>    id int primary key auto_increment,<br>    name varchar(20) not null,<br>    gender enum(&#x27;男&#x27;, &#x27;女&#x27;) not null<br>);<br></code></pre></td></tr></table></figure></p><blockquote><p>其中 <code>gender</code> 字段只能是「男」或者「女」</p></blockquote></li></ul><h6 id="mysql-约束">MySQL 约束</h6><p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p><p>分类：</p><table><thead><tr class="header"><th>约束</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>非空约束</td><td><code>not null</code></td><td>字段不能为 <code>NULL</code></td></tr><tr class="even"><td>唯一约束</td><td><code>unique</code></td><td>字段数据都是唯一的，不重复的</td></tr><tr class="odd"><td>主键约束</td><td><code>primary key</code></td><td>主键是一行数据的唯一表示，要求非空唯一</td></tr><tr class="even"><td>默认约束</td><td><code>default</code></td><td>保存数据时，如果未指定该字段的值，则采用默认值</td></tr><tr class="odd"><td>检查约束</td><td><code>check</code></td><td>保证字段满足某一个条件</td></tr><tr class="even"><td>外键约束</td><td><code>foreign key</code></td><td>用来建立两张表的数据之间的联系，保证数据的一致性和完整性</td></tr></tbody></table><p>案例：</p><p>根据以下需求完成表的创建：</p><table><thead><tr class="header"><th>字段名</th><th>字段含义</th><th>字段类型</th><th>约束条件</th><th>约束关键词</th></tr></thead><tbody><tr class="odd"><td><code>id</code></td><td>ID 唯一标识</td><td><code>int</code></td><td>主键，并且自动增长</td><td><code>primary key, auto_increment</code></td></tr><tr class="even"><td><code>name</code></td><td>姓名</td><td><code>varchar(10)</code></td><td>非空唯一</td><td><code>not null, unique</code></td></tr><tr class="odd"><td><code>age</code></td><td>年龄</td><td><code>int</code></td><td>大于 0，不大于 120</td><td><code>check</code></td></tr><tr class="even"><td><code>status</code></td><td>状态</td><td><code>char(1)</code></td><td>默认为 1</td><td><code>default</code></td></tr><tr class="odd"><td><code>gender</code></td><td>性别</td><td><code>char(1)</code></td><td>无</td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table stu(<br>    id      int             primary key auto_increment          comment &#x27;ID&#x27;,<br>    name    varchar(10)     not null unique                     comment &#x27;姓名&#x27;,<br>    age     int             check ( age &gt; 0 and age &lt;= 120 )    comment &#x27;年龄&#x27;,<br>    status  char(1)         default &#x27;1&#x27;                         comment &#x27;状态&#x27;,<br>    gender  char(1)                                             comment &#x27;性别&#x27;<br>)comment &#x27;学生&#x27;;<br></code></pre></td></tr></table></figure><p><strong>外键约束</strong></p><p>让多个表的数据产生连接，子表的外键是父表的一个候选键，如下图：</p><p><left><img src="https://p.ipic.vip/lmnwk4.png" alt="外键示意图" style="zoom:67%;" /></left></p><ul><li><p>管理外键关联：</p><ul><li><p>创建表时添加外键关联：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[外键名称] foreign key [外键字段名] references [主表(主表列名)] [指定行为];<br></code></pre></td></tr></table></figure></p></li><li><p>创建表后添加外键关系：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] add constraint [外键名称] foreign key [外键字段名] references [主表(主表列名)] [指定行为];<br></code></pre></td></tr></table></figure></p></li><li><p>删除外键关联：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] drop foreign key [外键名称];<br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>外键删除和更新行为：</p><table><thead><tr class="header"><th>行为</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>no action</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则不允许删除或更新（默认）</td></tr><tr class="even"><td><code>restrict</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则不允许删除或更新（与<code>no action</code> 一致）</td></tr><tr class="odd"><td><code>cascade</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则也删除或者更新外键在子表中的记录</td></tr><tr class="even"><td><code>set null</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则设置子表的外键值为<code>NULL</code></td></tr><tr class="odd"><td><code>set default</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则设置子表的外键值为默认值（<em>Innodb</em>不支持）</td></tr></tbody></table><p>案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 给 staff 表的 dept_id 属性添加关联 dept 表的 id 属性的外键关系，并且将更新行为和删除行为设置为级联<br>alter table staff<br>    add constraint fk_staff_dept_id foreign key (dept_id) references dept(id)<br>    on update cascade on delete cascade;<br></code></pre></td></tr></table></figure></p></li></ul><h4 id="dml-语句">DML 语句</h4><ul><li><p>添加数据：</p><ul><li><p>给指定字段添加数据：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into [表名(字段名1, 字段名2, ...)] values(值1, 值2, ...);<br></code></pre></td></tr></table></figure></p></li><li><p>给全部字段添加数据：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into [表名] values(值1, 值2, ...);<br></code></pre></td></tr></table></figure></p></li><li><p>批量添加：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into [表名] values(值1, 值2, ...), (值1, 值2, ...), ...;<br></code></pre></td></tr></table></figure></p><p>示例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into staff (s_id, name, age, gender)<br>values (1002, &#x27;Tom&#x27;, 24, &#x27;男&#x27;),<br>       (1003, &#x27;Frank&#x27;, 25, &#x27;男&#x27;);<br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>修改数据：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update [表名] set 字段名1 = 值1， 字段名2 = 值2, ... [where 条件];<br></code></pre></td></tr></table></figure></p></li><li><p>删除数据：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from [表名] [where 条件];<br></code></pre></td></tr></table></figure></p></li></ul><h4 id="dql-语句">DQL 语句</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>[字段列表]<br>from<br>[表名列表]<br>where<br>[条件列表]<br>group by<br>[分组字段列表]<br>having<br>[分组后条件列表]<br>order by<br>[排序字段列表]<br>limit<br>[分页参数];<br></code></pre></td></tr></table></figure><blockquote><p><code>select</code> 之后添加 <code>distinct</code>可以消除重复元组</p></blockquote><ul><li><p>查询多个字段：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段1, 字段2, ...] from [表名];<br><br>select * from [表名]; # 查询所有字段（不推荐）<br><br>select [字段] as [别名] from [表名];<br></code></pre></td></tr></table></figure></p></li><li><p>条件查询：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表名] where [条件列表];<br></code></pre></td></tr></table></figure></p><p>条件：</p><table><thead><tr class="header"><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>&gt;</code></td><td>大于</td></tr><tr class="even"><td><code>&gt;=</code></td><td>大于等于</td></tr><tr class="odd"><td><code>&lt;</code></td><td>小于</td></tr><tr class="even"><td><code>&lt;=</code></td><td>小于等于</td></tr><tr class="odd"><td><code>=</code></td><td>等于</td></tr><tr class="even"><td><code>&lt;&gt;</code> 或者 <code>!=</code></td><td>不等于</td></tr><tr class="odd"><td><code>between ... and ...</code></td><td>在某个范围之内（含最小、最大值）</td></tr><tr class="even"><td><code>in(...)</code></td><td>在 <code>in</code> 之后的列表中的值</td></tr><tr class="odd"><td><code>like 占位符</code></td><td>模糊匹配，<code>_</code> 匹配单个字符，<code>%</code>匹配任意个字符</td></tr><tr class="even"><td><code>is null</code></td><td>是 <code>NULL</code></td></tr></tbody></table><table><thead><tr class="header"><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>and</code> 或 <code>&amp;&amp;</code></td><td>并且</td></tr><tr class="even"><td><code>or</code> 或 <code>||</code></td><td>或者</td></tr><tr class="odd"><td><code>not</code> 或 <code>!</code></td><td>非</td></tr></tbody></table><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name, s_id from staff where age &gt;= 25;<br># 查找年龄不小于 25 的员工姓名和 ID<br><br>select name, s_id from staff where age between 20 and 30;<br># 查找年龄在 20 和 30 岁之间的员工姓名和年龄<br><br>select name, s_id from staff where gender is null;<br># 查找 gender 为 null 的员工姓名和 ID<br><br>select name, s_id from staff where age &gt;= 25 and gender = &#x27;女&#x27;;<br># 查找年龄不小于 25 的女员工姓名和 ID<br><br>select name from staff like &#x27;李%&#x27;;<br># 查找姓李的员工<br></code></pre></td></tr></table></figure></p></li><li><p>聚合函数</p><p>聚合函数是指将一列数据作为一个整体，进行纵向计算。</p><table><thead><tr class="header"><th>函数</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>count()</code></td><td>统计数量</td></tr><tr class="even"><td><code>max()</code></td><td>最大值</td></tr><tr class="odd"><td><code>min()</code></td><td>最小值</td></tr><tr class="even"><td><code>avg()</code></td><td>平均值</td></tr><tr class="odd"><td><code>sum()</code></td><td>求和</td></tr></tbody></table><blockquote><p>注：<code>NULL</code> 值不参与除 <code>count()</code>之外的聚合函数的运算</p></blockquote><p>语法：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 聚合函数(字段列表) from [表名];<br></code></pre></td></tr></table></figure></p><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(s_id) from staff;<br># s_id 数量，NULL 值不参与聚合函数计算<br><br>select max(age) from staff;<br># 查找员工年龄最大值<br></code></pre></td></tr></table></figure></p></li><li><p>分组查询</p><p>语法：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表名] where [条件列表] group by [分组字段名] having [分组后过滤条件];<br></code></pre></td></tr></table></figure></p><p>‼️ <code>where</code> 和 <code>having</code> 的区别：</p><ul><li>执行时机不同：<code>where</code> 是分组之前进行过滤，不满足<code>where</code> 条件，不参与分组；而 <code>having</code>是分组之后对结果进行过滤。</li><li>判断条件不同，<code>where</code> 不能对聚合函数进行判断，而<code>having</code> 可以。</li></ul><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select gender, count(*) as numebr from staff group by gender;<br># 查询男性员工和女性员工的数量<br></code></pre></td></tr></table></figure></p><p>结果：</p><p><left><img src="https://p.ipic.vip/k3lstv.png" alt="" style="zoom:67%;" /></left></p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select address, count(*) as address_count from emp where age &lt;= 35 group by address having address_count &gt;= 5;<br># 查询不同地区年龄小于等于 35 岁的员工且人数不小于 5 的地区及其员工数量<br></code></pre></td></tr></table></figure></p><p>‼️ <strong>执行顺序</strong>：</p><ol type="1"><li><code>where</code></li><li>聚合函数</li><li><code>having</code></li></ol></li><li><p>排序查询</p><p>语法：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表名] order by [字段1] [排序方案1], [字段2] [排序方案2] ...;<br># 多个字段时先看前面的字段，若前面的字段值相同，则看后面的字段规则<br></code></pre></td></tr></table></figure></p><p>排序方案：</p><ul><li><code>asc</code> ：升序排序</li><li><code>desc</code> ：降序排序</li></ul><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name, s_id from staff order by age asc;<br># 将员工姓名和 ID 按照年龄升序排列<br></code></pre></td></tr></table></figure></p></li><li><p>分页查询</p><p>关键词：<code>limit</code></p><p>语法：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表名] limit [起始索引], [查询记录数];<br></code></pre></td></tr></table></figure></p><blockquote><p>注：起始索引从 0 开始，若索引为 0，则 0 可以省略</p></blockquote><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from emp limit 0, 10;<br># 展示从索引 0 开始的 10 条记录<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="多表查询">‼️ 多表查询</h5><p>直接使用 <code>select</code> 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1], [表2];<br></code></pre></td></tr></table></figure><p>以上语句会直接得到 表1 和 表2 的笛卡尔积的投影字段。</p><p>自然连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1], [表2] where [表1.key] = [表2.key];<br></code></pre></td></tr></table></figure><blockquote><p><code>key</code> 在这里为主表的外键</p></blockquote><p><strong><code>JOIN</code> 语句</strong></p><ul><li><p><code>cross join</code> ：笛卡尔积</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] cross join [表2];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/uic3ax.png" alt="CROSS JOIN 示例" style="zoom:20%;" /></p></li><li><p><code>on</code> 关键字：在 <code>join</code> 语句后添加<code>on [条件列表]</code> 可以筛选特定条件的元组</p></li><li><p>内连接</p><ul><li><p><code>natural join</code> ：自然连接</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] natural join [表2];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/0oudmc.png" alt="NATURAL JOIN 示例" style="zoom:20%;" /></p></li><li><p><code>inner join</code> ：内连接，<code>join</code>不加修饰的默认连接，显示左表和右表符合条件的记录</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] (inner) join [表2] on [条件列表];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/j0vtdu.png" alt="INNER JOIN 示例" style="zoom:20%;" /></p><blockquote><p>上图使用 <code>where</code>语句的等价连接方式叫做<strong>隐式内连接</strong>。</p></blockquote></li></ul></li><li><p>外连接</p><ul><li><p><code>left join</code>：左连接，即保留左表所有元组，右表无法匹配的属性用 <code>NULL</code>取代</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] left join [表2] on [条件列表];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/2ntdt9.png" alt="LEFT JOIN 示例" style="zoom:20%;" /></p></li><li><p><code>right join</code>：右连接，即保留右表所有元组，左表无法匹配的属性用 <code>NULL</code>取代</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] right join [表2] on [条件列表];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/8eomc6.png" alt="RIGHT JOIN 示例" style="zoom:20%;" /></p></li><li><p><code>full join</code>：全连接，即保留两张表所有元组，无法匹配的属性用 <code>NULL</code>取代</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] full join [表2] on [条件列表];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/7piiru.png" alt="FULL JOIN 示例" style="zoom:20%;" /></p></li></ul></li></ul><h5 id="子查询">‼️ 子查询</h5><p>在 SQL 语句中嵌套 <code>select</code>语句，称为嵌套查询，又称子查询。</p><ul><li><p>标量子查询：子查询的结果为单个值</p></li><li><p>列子查询：子查询的结果为一列</p><p>常用操作符：<code>in</code>、<code>not in</code>、<code>any</code>、<code>some</code>、<code>all</code></p></li><li><p>行子查询：子查询的结果为一行</p><p>常用操作符：<code>=</code>、<code>!=</code>、<code>in</code>、<code>not in</code>、<code>exists</code>、<code>not exists</code></p><blockquote><p><code>exists (select ...)</code> 用来判断是否有后面的<code>select</code> 语句是否有返回值。若至少返回一行，则返回<code>true</code> ，否则返回 <code>false</code></p></blockquote></li><li><p>表子查询：子查询的结果为多行多列</p><p>常用操作符：<code>in</code></p></li></ul><p>根据子查询的位置，又可以分为：</p><ul><li><code>where</code> 之后</li><li><code>from</code> 之后</li><li><code>select</code> 之后</li></ul><h4 id="dcl-语句">DCL 语句</h4><p>DCL（Data ControlLanguage）用来管理数据库用户控制数据库的访问权限。</p><p>管理用户：</p><ul><li><p>查询用户：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br>select * from user;<br></code></pre></td></tr></table></figure></p></li><li><p>创建用户：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user [&#x27;用户名&#x27;@&#x27;主机名&#x27;] identified by [&#x27;密码&#x27;];<br></code></pre></td></tr></table></figure></p><p>示例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建用户 Jack，只能在当前主机 localhost 访问，密码 123456<br>create user &#x27;Jack&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;<br><br># 创建用户 Tina，可以在任意主机访问该数据库，密码 123456<br>create user &#x27;Tina&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;<br></code></pre></td></tr></table></figure></p></li><li><p>修改用户密码：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter user [&#x27;用户名&#x27;@&#x27;主机名&#x27;] identified with mysql_native_password by [&#x27;新密码&#x27;];<br></code></pre></td></tr></table></figure></p></li><li><p>删除用户：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop user [&#x27;用户名&#x27;@&#x27;主机名&#x27;];<br></code></pre></td></tr></table></figure></p></li></ul><p>权限控制：</p><table><thead><tr class="header"><th>权限</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>all, all privileges</code></td><td>所有权限</td></tr><tr class="even"><td><code>select</code></td><td>查询数据</td></tr><tr class="odd"><td><code>insert</code></td><td>插入数据</td></tr><tr class="even"><td><code>update</code></td><td>修改数据</td></tr><tr class="odd"><td><code>delete</code></td><td>删除数据</td></tr><tr class="even"><td><code>alter</code></td><td>修改表</td></tr><tr class="odd"><td><code>drop</code></td><td>删除数据库 / 表 / 视图</td></tr><tr class="even"><td><code>create</code></td><td>创建数据库 / 表</td></tr></tbody></table><ul><li><p>查询权限：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show grants for [&#x27;用户名&#x27;@&#x27;主机名&#x27;];<br></code></pre></td></tr></table></figure></p></li><li><p>授予权限：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant [权限列表] on [数据库名.表名] to [&#x27;用户名&#x27;@&#x27;主机名&#x27;];<br></code></pre></td></tr></table></figure></p></li><li><p>撤销权限：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">revoke [权限列表] on [数据库名.表名] to [&#x27;用户名&#x27;@&#x27;主机名&#x27;];<br></code></pre></td></tr></table></figure></p><blockquote><ol type="1"><li>多个权限之间，采取逗号分隔</li><li>授权时，数据库和表名可以使用 <code>*</code> 进行通配</li></ol></blockquote></li></ul><h3 id="mysql-函数">MySQL 函数</h3><p>函数是指一段可以直接被另一段程序调用的程序或代码。</p><h4 id="字符串函数">字符串函数</h4><table><thead><tr class="header"><th>函数</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>length(s)</code></td><td>返回字符串的长度</td></tr><tr class="even"><td><code>concat(s1, s2, ...)</code></td><td>字符串拼接</td></tr><tr class="odd"><td><code>lower(str)</code></td><td>将字符串全部小写</td></tr><tr class="even"><td><code>upper(str)</code></td><td>将字符串全部大写</td></tr><tr class="odd"><td><code>lpad(str, n, pad)</code></td><td>左填充</td></tr><tr class="even"><td><code>rpad(str, n, pad)</code></td><td>右填充</td></tr><tr class="odd"><td><code>trim(str)</code></td><td>去掉字符串头部和尾部的空格</td></tr><tr class="even"><td><code>substring(str, start, len)</code></td><td>返回字符串从 <code>start</code> 位置起的 <code>len</code>个长度的子字符串</td></tr></tbody></table><h4 id="数据函数">数据函数</h4><table><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>ceil(x)</code></td><td>向上取整</td></tr><tr class="even"><td><code>floor(x)</code></td><td>向下取整</td></tr><tr class="odd"><td><code>mod(x, y)</code></td><td>返回 <code>x mod y</code> 的值</td></tr><tr class="even"><td><code>rand()</code></td><td>返回 0 ~ 1 之间的随机数</td></tr><tr class="odd"><td><code>round(x, y)</code></td><td>求参数 <code>x</code> 的四舍五入的值，保留 <code>y</code>位小数</td></tr></tbody></table><h4 id="日期函数">日期函数</h4><table><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>curdate()</code></td><td>返回当前日期</td></tr><tr class="even"><td><code>curtime()</code></td><td>返回当前时间</td></tr><tr class="odd"><td><code>now()</code></td><td>返回当前日期和时间</td></tr><tr class="even"><td><code>year(date)</code></td><td>获取指定 <code>date</code> 的年份</td></tr><tr class="odd"><td><code>month(date)</code></td><td>获取指定 <code>date</code> 的月份</td></tr><tr class="even"><td><code>day(date)</code></td><td>获取指定 <code>date</code> 的日期</td></tr><tr class="odd"><td><code>date_add(date, interval expr type)</code></td><td>返回一个日期 / 时间值加上一个时间间隔 <code>expr</code>后的时间值</td></tr><tr class="even"><td><code>datediff(date1, date2)</code></td><td>返回结束时间 <code>date1</code> 和起始时间 <code>date2</code>之间的天数</td></tr><tr class="odd"><td><code>date_format(date, format)</code></td><td><code>date_format(date, format)</code> ：用于以不同的格式显示日期 /时间数据。<code>date</code> 参数是合法的日期，<code>format</code>规定日期/时间的输出格式。<br>例如，将 <code>2023-03-14</code> 转化为<code>2023-03</code> （即年 - 月）输出，则为：<br><code>date_format(target_date, '%Y-%m')</code></td></tr></tbody></table><h4 id="流程函数">流程函数</h4><p>流程函数也是很常用的一类函数，可以在 SQL语句中实现条件筛选，从而提高语句效率。</p><table><thead><tr class="header"><th>函数</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>if(value, t, f)</code></td><td><code>value</code> 为 <code>true</code> 返回 <code>t</code>，否则返回 <code>f</code></td></tr><tr class="even"><td><code>ifnull(value1, value2)</code></td><td>如果 <code>value1</code> 不为空，返回 <code>value1</code> ，否则返回<code>value2</code></td></tr><tr class="odd"><td><code>case when [val1] then [res1] ... else [default] end</code></td><td>如果 <code>val1</code> 为 <code>true</code> ，返回 <code>res1</code>，...，<code>default</code> 为默认值</td></tr><tr class="even"><td><code>case [expr] when [val1] then [res1] ... else [default] end</code></td><td>同上，若 <code>expr</code> 的值等于 <code>val1</code> ，则返回<code>res1</code>， ...，<code>default</code> 为默认值</td></tr></tbody></table><h3 id="mysql-事务操作">MySQL 事务操作</h3><p><strong>事务（Transaction）</strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么<strong>同时成功，要么同时失败</strong>。</p><p><strong>事务 4 大特性（ACID）</strong>：</p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h4 id="事务操作">事务操作</h4><ul><li><p>查看 / 设置事务提交方式</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select @@autocommit;<br>set @@autocommit = 0; # 将事务设置为手动提交<br></code></pre></td></tr></table></figure></p></li><li><p>开启事务</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction; # 我们也可以不更改 @@autocommit 参数<br></code></pre></td></tr></table></figure></p></li><li><p>提交事务</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">commit; # 设置为手动提交后必须要手动提交才能更新数据<br></code></pre></td></tr></table></figure></p></li><li><p>回滚事务</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">rollback; # 回滚 / 撤销事务<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素数筛</title>
    <link href="/2023/04/02/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <url>/2023/04/02/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h4 id="引入">引入</h4><p>如果我们想要求出小于 <code>n</code>的所有素数，一个很自然的想法就是从 1 到 <code>n</code>进行遍历，然后对素数进行记录，但这样的话时间复杂度为 <spanclass="math inline">\(O(n^{\frac{3}{2}})\)</span> ，当 <code>n</code>足够大的时候这个算法是较慢的，有没有更高效的算法呢？</p><p>接下来我们介绍最常见的两种素数筛，以 Leetcode 模版题为例：<ahref="https://leetcode.cn/problems/count-primes/">计数质数</a></p><h4 id="埃氏筛">埃氏筛</h4><p>埃氏筛也叫埃拉托斯特尼筛法，考虑任意素数 <code>x</code> ，则<code>x</code> 的所有倍数都是合数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 埃式筛</span><br>        <span class="hljs-type">bool</span>* notPrime = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n]();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>                res++;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> k = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i; k &lt; n; k += i) &#123;<br>                    <span class="hljs-comment">// 若 j &lt; i，则 j * i 一定已经被筛过</span><br>                    notPrime[k] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度：<span class="math inline">\(O(n\ loglogn)\)</span></p><p>如果想了解其证明，读者可以自行去 <ahref="https://oi-wiki.org/math/number-theory/sieve/">OI Wiki</a>上看。</p></blockquote><p>尽管埃氏筛法已经有较高的效率，但其仍然无法达到线性时间复杂度，因为有些数存在重复筛除的情况，例如12，其会被 2，3 分别筛除一次，有没有办法可以避免重复筛除呢？</p><h4 id="欧式筛线性筛">欧式筛（线性筛）</h4><p>欧式筛，即 Euler筛法，其避免了上述的重复筛而造成的时间浪费，真正意义上实现了线性时间复杂度。对于特别大的数据量（<spanclass="math inline">\(n &gt; 10^8\)</span>）时适用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>* primeNum = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[(<span class="hljs-type">int</span>)(<span class="hljs-number">1.5</span> * n / <span class="hljs-built_in">log</span>(n)) + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// π(n) &lt; 1.5 * n / ln(n) 素数数目的一个粗糙上界</span><br>        <span class="hljs-type">bool</span>* notPrime = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n]();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>                primeNum[res++] = i;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; res &amp;&amp; i * primeNum[j] &lt; n; j++) &#123;<br>                notPrime[i * primeNum[j]] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (i % primeNum[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 如果 i 能被 primeNum[j] 整除，则 i 的倍数一定会被 primeNum[j] 的倍数筛除</span><br>                <span class="hljs-comment">// 故此刻不需要继续再筛除，退出循环</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><p>注意到，欧式筛中被筛除的合数都是被当前记录的最小素数筛除的，所以我们我们也可以<strong>同时得到每个数的最小质因数</strong>。</p><h4 id="案例">案例</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=6954">HDU -6954</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 10000005</span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">bool</span> notPrime[MAX_NUM];<br>i64 ans[MAX_NUM];<br><span class="hljs-type">int</span> primeNum[MAX_NUM];<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; MAX_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>            ans[i] = ans[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2ll</span> * i;<br>            primeNum[cnt++] = i;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans[i] = ans[i - <span class="hljs-number">1</span>] + i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt &amp;&amp; (i64)i * primeNum[j] &lt; MAX_NUM; j++) &#123;<br>            notPrime[i * primeNum[j]] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primeNum[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        std::cin &gt;&gt; n;<br>        std::cout &lt;&lt; ans[n] - <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>素数</tag>
      
      <tag>数论</tag>
      
      <tag>素数筛</tag>
      
      <tag>埃氏筛</tag>
      
      <tag>欧式筛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2023/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是正则表达式">什么是正则表达式？</h4><p><strong>正则表达式（regularexpression）</strong>，又称为规则表达式，是一种文本模式，其拥有独特的语法和独立的处理引擎，可以帮助我们实现文本匹配，特别是当匹配模式比较复杂时，正则表达式有相当大的优势。</p><p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p><h4 id="正则表达式基本语法">正则表达式基本语法</h4><h5 id="字符类">字符类</h5><table><thead><tr class="header"><th>表达式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>[abc]</code></td><td>只能是 a, b, c</td></tr><tr class="even"><td><code>[^abc]</code></td><td>除了 a, b, c 之外的任何字符</td></tr><tr class="odd"><td><code>[a-zA-Z]</code></td><td>a 到 z，A 到 Z 的所有字符</td></tr><tr class="even"><td><code>[a-d[m-p]]</code></td><td>a 到 d，m 到 p</td></tr><tr class="odd"><td><code>[a-z&amp;&amp;[def]]</code></td><td>a-z 和 def 到交集，在这里相当于 <code>[def]</code></td></tr><tr class="even"><td><code>[a-z&amp;&amp;[^bc]]</code></td><td>a-z 和非 bc 的交集</td></tr><tr class="odd"><td><code>[a-z&amp;&amp;[^m-p]]</code></td><td>a-z 和除了 m 到 p 的交集</td></tr></tbody></table><h5 id="预定义字符">预定义字符</h5><table><thead><tr class="header"><th>表达式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>.</code></td><td>任何字符</td></tr><tr class="even"><td><code>\d</code></td><td>一个数字（<code>[0-9]</code>）</td></tr><tr class="odd"><td><code>\D</code></td><td>非数字（<code>[^0-9]</code>）</td></tr><tr class="even"><td><code>\s</code></td><td>一个空白字符（<code>[\t\n\x0B\f\r]</code>）</td></tr><tr class="odd"><td><code>\S</code></td><td>非空白字符（<code>[^\t\n\x0B\f\r]</code>）</td></tr><tr class="even"><td><code>\w</code></td><td>英文、数字、下划线（<code>[a-zA-Z0-9_]</code>）</td></tr><tr class="odd"><td><code>\W</code></td><td>一个非单词字符（<code>[^a-zA-Z0-9_]</code>）</td></tr></tbody></table><h5 id="数量词">数量词</h5><table><thead><tr class="header"><th>表达式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>X?</code></td><td><code>X</code>， 一次或者零次</td></tr><tr class="even"><td><code>X*</code></td><td><code>X</code> ，零次或者多次</td></tr><tr class="odd"><td><code>X+</code></td><td><code>X</code> ，一次或者多次</td></tr><tr class="even"><td><code>X&#123;n&#125;</code></td><td><code>X</code> ，正好 n 次</td></tr><tr class="odd"><td><code>X&#123;n,&#125;</code></td><td><code>X</code> ，至少 n 次</td></tr><tr class="even"><td><code>X&#123;n,m&#125;</code></td><td><code>X</code> ，至少 n 次，不超过 m 次</td></tr></tbody></table><h5 id="特殊字符">特殊字符</h5><table><thead><tr class="header"><th>表达式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>$</code></td><td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline属性，则 <code>$</code> 也匹配 <code>\n</code> 或<code>\r</code>。要匹配 <code>$</code> 字符本身，请使用 <code>\$</code>。</td></tr><tr class="even"><td><code>()</code></td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用<code>\(</code> 和 <code>\)</code> 。</td></tr><tr class="odd"><td><code>|</code></td><td>指明两项之间的一个选择。要匹配 <code>|</code> ，请使用<code>\|</code> 。</td></tr></tbody></table><h5 id="典型案例">典型案例</h5><ul><li>匹配网址 URL：<code>[a-zA-z]+://[^\s]*</code></li><li>匹配中国邮编编码：<code>[1-9]\d&#123;5&#125;(?!\d)</code></li><li>匹配 18位身份证：<code>^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;3&#125;)([0-9]|X)$</code></li></ul><p><ahref="https://tool.oschina.net/regex">正则表达式在线测试工具</a></p><h4 id="实际运用">实际运用</h4><p>当前大多数流行语言都有自己的正则表达式库，例如 C++11 更新的 <ahref="https://zh.cppreference.com/w/cpp/regex">Regex 库</a> 。</p><p>今天我们以 Java 为例，讲解正则表达式的一些实际运用。</p><p><strong>Java 中的 <code>String</code> 内置正则匹配方法</strong></p><ul><li><p><code>matches()</code> 方法：</p><blockquote><p><code>boolean matches(String regex)</code>，根据正则表达式，判断字符串是否能匹配成功，返回对应的布尔值</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配手机号码</span><br><span class="hljs-comment">// 以 1 开头</span><br><span class="hljs-comment">// 第二位只能是 3 到 9</span><br><span class="hljs-comment">// 任意数字 9 位</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex_1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;13170488669&quot;</span>.matches(regex_1)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 匹配座机号码</span><br><span class="hljs-comment">// 区号 以 0 开头</span><br><span class="hljs-comment">// 中间可能有 -</span><br><span class="hljs-comment">// 号码总长度 5 到 10 位</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex_2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0\\d&#123;2,3&#125;-?[1-9]\\d&#123;4,9&#125;&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;027-142424&quot;</span>.matches(regex_2)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>replaceFirst()</code> 方法和 <code>replaceAll()</code>方法：</p><blockquote><p><code>String replaceFirst(String regex, String replacement)</code>，将字符串匹配到的第一个子串进行替换，返回新字符串。</p><p><code>String replaceAll(String regex, String replacement)</code>，将字符串所有匹配成功的子串进行替换，返回新字符串。</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Isaac Newton&quot;</span>;<br><span class="hljs-comment">// 隐藏姓名</span><br>System.out.println(name.replaceFirst(<span class="hljs-string">&quot;[a-zA-Z]+&quot;</span>, <span class="hljs-string">&quot;*****&quot;</span>)); <span class="hljs-comment">// ***** Newton</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12-(900)84632&quot;</span>;<br><span class="hljs-comment">// 删除所有非数字字符</span><br>System.out.println(number.replaceAll(<span class="hljs-string">&quot;[^0-9]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// 1290084632</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>split()</code> 方法：</p><blockquote><p><code>String[] split(String regex)</code></p><p><code>String[] split(String regex, int limit)</code></p><p>根据正则表达式对字符串进行分割，返回分割后的字符串数组。</p><p>这里 <code>limit</code> 参数用来控制分割次数：</p><ul><li>若 <code>limit &gt; 0</code> ：字符串最多被分割 n - 1 次，返回长度为n 的字符串数组</li><li>若 <code>limit &lt;= 0</code>：字符串被尽可能多次分割，返回尽可能长的字符串数组</li></ul></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] member = <span class="hljs-string">&quot;张三, 李四, 王五&quot;</span>.split(<span class="hljs-string">&quot;, &quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name : member) System.out.println(name);<br><span class="hljs-comment">// 张三</span><br><span class="hljs-comment">// 李四</span><br><span class="hljs-comment">// 王五</span><br></code></pre></td></tr></table></figure></p></li></ul><p><strong>练习</strong></p><p><ahref="https://leetcode.cn/problems/camelcase-matching">驼峰匹配</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title function_">camelMatch</span><span class="hljs-params">(String[] queries, String pattern)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regexModel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[a-z]*&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = pattern.length(); i &lt; len; i++) &#123;<br>            regexModel += (pattern.charAt(i) + <span class="hljs-string">&quot;[a-z]*&quot;</span>);<br>        &#125;<br>        ArrayList&lt;Boolean&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = queries.length; i &lt; len; i++) &#123;<br>            ans.add(queries[i].matches(regexModel));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>字符串</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讲解 C++ 匿名函数</title>
    <link href="/2023/03/30/%E8%AE%B2%E8%A7%A3%20C++%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/30/%E8%AE%B2%E8%A7%A3%20C++%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>匿名函数</strong>，也叫 Lambda 表达式，是 C++ 11提出的特性，匿名函数能使得我们的程序更加灵活轻便。</p><hr /><h4 id="基本语法">基本语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture](para) -&gt; returnType &#123; body &#125;<br></code></pre></td></tr></table></figure><ul><li><code>capture</code> ：闭包</li><li><code>para</code> ：参数</li><li><code>returnType</code> ：返回类型</li><li><code>body</code> ：函数体</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fun = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h5 id="闭包">闭包</h5><p><code>capture</code>称为闭包，作用是引用匿名函数体外的变量，其有如下格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">[]<span class="hljs-comment">// 不引用外部变量，无法在函数体内使用外部变量</span><br>[x, &amp;y]<span class="hljs-comment">// x 按值捕获，y 按照引用捕获</span><br>[&amp;]<span class="hljs-comment">// 可以捕获所有外部变量，按照引用捕获</span><br>[=]<span class="hljs-comment">// 可以捕获所有外部变量，按照值捕获</span><br>[&amp;, x]<span class="hljs-comment">// x 按照值捕获，其余所有变量按照引用捕获</span><br>[=, &amp;y]<span class="hljs-comment">// y 按照引用捕获，其余所有变量按照值捕获</span><br>[<span class="hljs-keyword">this</span>]<span class="hljs-comment">// 通过引用捕获当前对象</span><br>[*<span class="hljs-keyword">this</span>]<span class="hljs-comment">// 通过传值的方式捕获当前对象</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-keyword">auto</span> fun = [&amp;sum](<span class="hljs-type">int</span> x) &#123; sum += x; &#125;;<br>    <span class="hljs-comment">// auto fun = [sum](int x) &#123; sum += x; &#125;; 报错，sum 必须是可修改的左值，故只能通过引用的方式捕获</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : arr) &#123;<br>        <span class="hljs-built_in">fun</span>(x);<br>    &#125;<br><br>    std::cout &lt;&lt; sum &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 15</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运用">运用</h4><p>匿名函数的运用十分灵活，以下我们举几个常见的例子：</p><ul><li><p>在 <code>STL</code> 的排序函数中自定义排序方式：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    std::string name;<br>    <span class="hljs-type">int</span> grade;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::vector&lt;Student&gt; s_arr = &#123;&#123;<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">99</span>&#125;, &#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">97</span>&#125;, &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">83</span>&#125;, &#123;<span class="hljs-string">&quot;Carl&quot;</span>, <span class="hljs-number">100</span>&#125;, &#123;<span class="hljs-string">&quot;Clara&quot;</span>, <span class="hljs-number">66</span>&#125;&#125;;<br>    std::<span class="hljs-built_in">sort</span>(s_arr.<span class="hljs-built_in">begin</span>(), s_arr.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Student&amp; s1, <span class="hljs-type">const</span> Student&amp; s2) &#123;<br>        <span class="hljs-keyword">return</span> s1.grade &gt; s2.grade;<br>    &#125;); <span class="hljs-comment">// 自定义学生成绩按照降序排序</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; s : s_arr) &#123;<br>        std::cout &lt;&lt; s.name &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s.grade &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">// Carl 100</span><br>    <span class="hljs-comment">// Jack 99</span><br>    <span class="hljs-comment">// Alice 97</span><br>    <span class="hljs-comment">// Bob 83</span><br>    <span class="hljs-comment">// Clara 66</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>定义一个匿名函数作为参数的函数：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">double</span>(<span class="hljs-type">double</span>)&gt; fn, <span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 求一元函数在区间 [left, right] 的定积分</span><br>    <span class="hljs-type">double</span> res = -<span class="hljs-built_in">fn</span>(left) + <span class="hljs-built_in">fn</span>(right);<br>    <span class="hljs-type">double</span> d = (right - left) / n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res += <span class="hljs-number">2</span> * <span class="hljs-built_in">fn</span>(left + i * d) + <span class="hljs-number">4</span> * <span class="hljs-built_in">fn</span>(left + (i + <span class="hljs-number">0.5</span>) * d);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> d * res / <span class="hljs-number">6</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::cout &lt;&lt; <span class="hljs-built_in">solve</span>([](<span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x * x * x; &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 0.25</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>匿名函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组和线段树</title>
    <link href="/2023/03/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2023/03/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>树状数组和线段树是两种常用的数据结构，其可以大大提升数组的区间查询的效率，同时也保证了数据修改的灵活度。</p><table><thead><tr class="header"><th></th><th>一般数组</th><th>前缀和数组</th><th>树状数组</th><th>线段树</th></tr></thead><tbody><tr class="odd"><td>单点查询</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr><tr class="even"><td>区间查询</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr><tr class="odd"><td>单点修改</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr><tr class="even"><td>区间修改</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(nlogn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr></tbody></table><h4 id="树状数组">树状数组</h4><p>树状数组的原理讲解可以参考视频：<ahref="https://www.bilibili.com/video/BV1ce411u7qP/?spm_id_from=333.337.search-card.all.click&amp;vd_source=8ba5b8b5f59444a6cbd4c3984325e82f">五分钟丝滑动画讲解| 树状数组</a></p><p><img src="https://p.ipic.vip/4rorce.png" style="zoom: 33%;" /></p><h5id="用于区间求和和单点修改的树状数组模版">用于区间求和和单点修改的树状数组模版</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 数状数组第 i 项的区间长度为 lowbit(i)</span><br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-comment">// 求前 m 项的和</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (m) &#123;<br>            res += tree[m];<br>            m -= <span class="hljs-built_in">lowbit</span>(m);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BIT</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(_n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 单点修改</span><br>        <span class="hljs-keyword">while</span> (idx &lt;= n) &#123;<br>            tree[idx] += val;<br>            idx += <span class="hljs-built_in">lowbit</span>(idx);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 区间求和</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>(right) - <span class="hljs-built_in">count</span>(left - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><ul><li>树状数组的核心就是 <code>lowbit()</code> 函数，数状数组第<code>i</code> 项代表的区间长度为 <code>lowbit(i)</code></li><li>树状数组的下标只能从 1 开始，不能从 0 开始</li></ul></blockquote><h5id="用于求前缀最大值的树状数组模版">用于求前缀最大值的树状数组模版</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BIT</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(_n + <span class="hljs-number">1</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (idx) &#123;<br>            res = std::<span class="hljs-built_in">max</span>(res, tree[idx]);<br>            idx &amp;= idx - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (idx &lt;= n) &#123;<br>            tree[idx] = std::<span class="hljs-built_in">max</span>(tree[idx], val);<br>            idx += idx &amp; -idx;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="线段树">线段树</h4><p>线段树相对于树状数组而言则更为灵活，其可以实现高效区间修改。</p><p>线段树的原理就是将数组的区间储存在二叉树的节点中，<code>[left, right]</code>区间对应的左右节点分别为 <code>[left, mid]</code> 和<code>[mid + 1, right]</code>（<code>mid = (left + right) / 2</code>)。</p><p><img src="https://p.ipic.vip/3phmiu.png" style="zoom:33%;" /></p><blockquote><p>‼️注：线段树的数组长度要开到原数组长度的 4 倍</p></blockquote><h5 id="用于区间求和的线段树模版">用于区间求和的线段树模版</h5><ul><li>单点更新</li><li>区间求和</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 单点更新</span><br>        <span class="hljs-keyword">if</span> (start == end) &#123;<br>            tree[node] = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (idx &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, leftNode, start, mid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, rightNode, mid + <span class="hljs-number">1</span>, end);<br>        &#125;<br><br>        tree[node] = tree[leftNode] + tree[rightNode];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 区间求和</span><br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> tree[node];<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeSum</span>(left, right, leftNode, start, mid) + <span class="hljs-built_in">rangeSum</span>(left, right, rightNode, mid + <span class="hljs-number">1</span>, end);<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(<span class="hljs-number">4</span> * _n, <span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">update</span>(idx, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeSum</span>(left, right, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="用于求区间极值的线段树模版">用于求区间极值的线段树模版</h5><ul><li>单点更新</li><li>区间求极值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 单点更新</span><br>        <span class="hljs-keyword">if</span> (start == end) &#123;<br>            tree[node] = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (idx &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, leftNode, start, mid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, rightNode, mid + <span class="hljs-number">1</span>, end);<br>        &#125;<br><br>        tree[node] = std::<span class="hljs-built_in">max</span>(tree[leftNode], tree[rightNode]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxVal</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 求区间极大值</span><br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span> INT_MIN;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> tree[node];<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxVal</span>(left, right, leftNode, start, mid), <span class="hljs-built_in">maxVal</span>(left, right, rightNode, mid + <span class="hljs-number">1</span>, end));<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(<span class="hljs-number">4</span> * _n, <span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">update</span>(idx, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxVal</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">maxVal</span>(left, right, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr /><p>有时候我们可能会遇到这样的需求：要多次将数组中一个区间内的每个元素都添加一个固定的值，如果逐一修改，则会消耗大量的时间，这个时候我们就可以使用带延迟标记的线段树。</p><p>什么是延迟标记？</p><p>——即对线段树的某个节点的数据更新完后不急于对其子节点进行更新，而是将更新信息存储下来，而当必须更新的时候再将信息传递给子节点。</p><h5id="使用延迟标记进行区间修改的线段树模版">使用延迟标记进行区间修改的线段树模版</h5><ul><li>区间修改</li><li>区间求和</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; lazy;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">maintain</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 传递 lazy 标签</span><br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        tree[leftNode] += (mid - start + <span class="hljs-number">1</span>) * lazy[node];<br>        lazy[leftNode] += lazy[node];<br>        tree[rightNode] += (end - mid) * lazy[node];<br>        lazy[rightNode] += lazy[node];<br>        lazy[node] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 给区间 [left, right] 的所有数添加 val</span><br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) &#123;<br>            tree[node] += (end - start + <span class="hljs-number">1</span>) * val;<br>            lazy[node] += val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lazy[node]) <span class="hljs-built_in">maintain</span>(node, start, end);<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">add</span>(left, right, val, leftNode, start, mid);<br>        <span class="hljs-built_in">add</span>(left, right, val, rightNode, mid + <span class="hljs-number">1</span>, end);<br><br>        tree[node] = tree[leftNode] + tree[rightNode];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 区间求和</span><br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> tree[node];<br>        <span class="hljs-keyword">if</span> (lazy[node]) <span class="hljs-built_in">maintain</span>(node, start, end);<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeSum</span>(left, right, leftNode, start, mid) + <span class="hljs-built_in">rangeSum</span>(left, right, rightNode, mid + <span class="hljs-number">1</span>, end);<br>    &#125;<br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(<span class="hljs-number">4</span> * _n), <span class="hljs-built_in">lazy</span>(<span class="hljs-number">4</span> * _n) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">add</span>(left, right, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeSum</span>(left, right, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="案例">案例</h4><h5 id="逆序对记数">逆序对记数</h5><p><a href="https://www.luogu.com.cn/problem/P1908">题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    <span class="hljs-type">int</span> id;<br>&#125; arr[MAX_N];<br><br><span class="hljs-type">int</span> rank[MAX_N];<br><br><span class="hljs-keyword">namespace</span> __BIT &#123;<br>    <span class="hljs-type">int</span> bit[MAX_N];<br>    <span class="hljs-type">int</span> n;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (idx) &#123;<br>            res += bit[idx];<br>            idx -= <span class="hljs-built_in">lowbit</span>(idx);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (idx &lt;= n) &#123;<br>            bit[idx] += val;<br>            idx += <span class="hljs-built_in">lowbit</span>(idx);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __BIT;<br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    std::cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        std::cin &gt;&gt; arr[i].val;<br>        arr[i].id = i;<br>    &#125;<br><br>    std::<span class="hljs-built_in">sort</span>(arr + <span class="hljs-number">1</span>, arr + n + <span class="hljs-number">1</span>, [](<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a1, <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; a2) &#123;<br>        <span class="hljs-keyword">return</span> a1.val != a2.val ? a1.val &lt; a2.val : a1.id &lt; a2.id;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) rank[arr[i].id] = i;<br>    i64 res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        res += i - <span class="hljs-number">1</span> - <span class="hljs-built_in">query</span>(rank[i]);<br>        <span class="hljs-built_in">add</span>(rank[i], <span class="hljs-number">1</span>);<br>    &#125;<br><br>    std::cout &lt;&lt; res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="二维数点">二维数点</h5><p><a href="https://www.luogu.com.cn/problem/P2163">题目链接</a></p><p>二维数点是树状数组的一个典型应用，本题的 AC 代码如下：</p><blockquote><p>注：需要开启 O2 优化</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_N = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>, MAX_M = <span class="hljs-number">5e5</span> + <span class="hljs-number">5</span>;<br><br><span class="hljs-type">int</span> n, m;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tree</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>&#125; tree[MAX_N];<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span> &#123;<br>    <span class="hljs-type">int</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">int</span> id;<br>    <span class="hljs-type">int</span> res;<br>&#125; q[<span class="hljs-number">4</span> * MAX_M];<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAX_Y = <span class="hljs-number">1e7</span> + <span class="hljs-number">7</span>;<br><span class="hljs-keyword">namespace</span> __BIT &#123;<br>    <span class="hljs-type">int</span> bit[MAX_Y];<br>    <span class="hljs-type">int</span> len;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123;<br>        idx = idx &lt;= len ? idx : len;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = idx; i; i -= <span class="hljs-built_in">lowbit</span>(i)) res += bit[i];<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = idx; i &lt;= len; i += <span class="hljs-built_in">lowbit</span>(i)) bit[i] += val;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> __BIT;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; tree[i].x &gt;&gt; tree[i].y;<br>        tree[i].x++, tree[i].y++;<br>        len = std::<span class="hljs-built_in">max</span>(len, tree[i].y);<br>    &#125;<br>    std::<span class="hljs-built_in">sort</span>(tree, tree + n, [](<span class="hljs-type">const</span> Tree&amp; t1, <span class="hljs-type">const</span> Tree&amp; t2) &#123;<br>        <span class="hljs-keyword">return</span> t1.x &lt; t2.x;<br>    &#125;);<br>    <span class="hljs-type">int</span> all = <span class="hljs-number">4</span> * m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, a, b, c, d; i &lt; all; i += <span class="hljs-number">4</span>) &#123;<br>        std::cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;<br>        a++, b++, c++, d++;<br>        q[i] = &#123;c, d, i&#125;;<br>        q[i + <span class="hljs-number">1</span>] = &#123;a - <span class="hljs-number">1</span>, d, i + <span class="hljs-number">1</span>&#125;;<br>        q[i + <span class="hljs-number">2</span>] = &#123;c, b - <span class="hljs-number">1</span>, i + <span class="hljs-number">2</span>&#125;;<br>        q[i + <span class="hljs-number">3</span>] = &#123;a - <span class="hljs-number">1</span>, b - <span class="hljs-number">1</span>, i + <span class="hljs-number">3</span>&#125;;<br>    &#125;<br>    std::<span class="hljs-built_in">sort</span>(q, q + all, [](<span class="hljs-type">const</span> Query&amp; q1, <span class="hljs-type">const</span> Query&amp; q2) &#123;<br>        <span class="hljs-keyword">return</span> q1.x &lt; q2.x;<br>    &#125;);<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span> (j &lt; all &amp;&amp; tree[i].x &gt; q[j].x) &#123;<br>            <span class="hljs-comment">// 当前范围已经统计结束</span><br>            q[j].res = <span class="hljs-built_in">query</span>(q[j].y);<br>            j++;<br>        &#125;<br>        <span class="hljs-built_in">add</span>(tree[i].y, <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (j &lt; all) &#123;<br>        q[j].res = <span class="hljs-built_in">query</span>(q[j].y);<br>        j++;<br>    &#125;<br><br>    std::<span class="hljs-built_in">sort</span>(q, q + all, [](<span class="hljs-type">const</span> Query&amp; q1, <span class="hljs-type">const</span> Query&amp; q2) &#123;<br>        <span class="hljs-keyword">return</span> q1.id &lt; q2.id;<br>    &#125;);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; all; i += <span class="hljs-number">4</span>) &#123;<br>        std::cout &lt;&lt; q[i].res - q[i + <span class="hljs-number">1</span>].res - q[i + <span class="hljs-number">2</span>].res + q[i + <span class="hljs-number">3</span>].res &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="统计最长递增子序列">统计最长递增子序列</h5><p><ahref="https://leetcode.cn/problems/longest-increasing-subsequence/">题目链接</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span> </span>&#123;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (idx) &#123;<br>            res = std::<span class="hljs-built_in">max</span>(res, tree[idx]);<br>            idx &amp;= idx - <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (idx &lt;= n) &#123;<br>            tree[idx] = std::<span class="hljs-built_in">max</span>(tree[idx], val);<br>            idx += idx &amp; -idx;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">this</span>-&gt;n = n;<br>        tree.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>        std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">p</span>(n);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            p[i].first = nums[i];<br>            p[i].second = i + <span class="hljs-number">1</span>;<br>        &#125;<br>        std::<span class="hljs-built_in">sort</span>(p.<span class="hljs-built_in">begin</span>(), p.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p1, <span class="hljs-type">const</span> std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&amp; p2) &#123;<br>            <span class="hljs-keyword">return</span> p1.first != p2.first ? p1.first &lt; p2.first : p1.second &gt; p2.second;<br>        &#125;);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; [_, idx] : p) &#123;<br>            <span class="hljs-built_in">update</span>(idx, <span class="hljs-built_in">query</span>(idx) + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(n);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="其他">其他</h5><p><ahref="https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid">网格图中最少访问的格子数（线段树单点修改 + 区间查询）</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTree</span> &#123;<br><span class="hljs-comment">// 单点修改 + 区间查询</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start == end) &#123;<br>            tree[node] = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (idx &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, leftNode, start, mid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, rightNode, mid + <span class="hljs-number">1</span>, end);<br>        &#125;<br><br>        tree[node] = <span class="hljs-built_in">min</span>(tree[leftNode], tree[rightNode]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span> INT_MAX;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> tree[node];<br><br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">query</span>(left, right, leftNode, start, mid), <span class="hljs-built_in">query</span>(left, right, rightNode, mid + <span class="hljs-number">1</span>, end));<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(<span class="hljs-number">4</span> * _n, INT_MAX) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">update</span>(idx, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(left, right, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumVisitedCells</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">SegTree <span class="hljs-title">trRow</span><span class="hljs-params">(m * n)</span></span>;<br>        <span class="hljs-function">SegTree <span class="hljs-title">trCol</span><span class="hljs-params">(n * m)</span></span>;<br>        trRow.<span class="hljs-built_in">update</span>(m * n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        trCol.<span class="hljs-built_in">update</span>(n * m - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-type">int</span> resRow = trRow.<span class="hljs-built_in">query</span>(n * i + j, n * i + <span class="hljs-built_in">min</span>(j + grid[i][j], n - <span class="hljs-number">1</span>));<br>                <span class="hljs-comment">// (i, j) ~ (i, j + grid[i][j]) 中的最小值</span><br>                <span class="hljs-type">int</span> resCol = trCol.<span class="hljs-built_in">query</span>(m * j + i, m * j + <span class="hljs-built_in">min</span>(i + grid[i][j], m - <span class="hljs-number">1</span>));<br>                <span class="hljs-comment">// (i, j) ~ (i + grid[i][j], j) 中的最小值</span><br>                <span class="hljs-type">int</span> res = <span class="hljs-built_in">min</span>(resRow, resCol);<br>                <span class="hljs-keyword">if</span> (res != INT_MAX) &#123;<br>                    trRow.<span class="hljs-built_in">update</span>(n * i + j, res + <span class="hljs-number">1</span>);<br>                    trCol.<span class="hljs-built_in">update</span>(m * j + i, res + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = trRow.<span class="hljs-built_in">query</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans != INT_MAX ? ans : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线段树</tag>
      
      <tag>树状数组</tag>
      
      <tag>区间查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::bitset 讲解</title>
    <link href="/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍">介绍</h4><p><code>std::bitset</code> 是 C++ 提供的一种 n-bit固定大小序列的模版，可以用于标准逻辑运算，并且可以与字符串和整数相互转换，还可以使用标准流输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; std::<span class="hljs-type">size_t</span> N &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bitset</span>;<br></code></pre></td></tr></table></figure><blockquote><p>模版形参 <code>N</code> ：要为 <code>bitset</code> 分配储存的 bit位数</p></blockquote><p><strong>头文件：<code>&lt;bitset&gt;</code></strong></p><h4 id="构造方法">构造方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 1. 无参构造</span><br>    std::bitset&lt;5&gt; testCase_1;<br>    std::cout &lt;&lt; testCase_1 &lt;&lt; std::endl; <span class="hljs-comment">// 00000</span><br><br>    <span class="hljs-comment">// 2. 传入整数</span><br>    std::bitset&lt;4&gt; testCase_2&#123;<span class="hljs-number">0xb</span>&#125;;<br>    std::cout &lt;&lt; testCase_2 &lt;&lt; std::endl; <span class="hljs-comment">// 1011</span><br><br>    std::bitset&lt;4&gt; testCase_3&#123;<span class="hljs-number">0x10</span>&#125;; <span class="hljs-comment">// 溢出位自动截断</span><br>    std::cout &lt;&lt; testCase_3 &lt;&lt; std::endl; <span class="hljs-comment">// 0000</span><br><br>    <span class="hljs-comment">// 3. 传入字符串</span><br>    std::bitset&lt;8&gt; testCase_4&#123;<span class="hljs-string">&quot;10010101&quot;</span>&#125;; <span class="hljs-comment">// 传入 0-1 字符串</span><br>    std::cout &lt;&lt; testCase_4 &lt;&lt; std::endl; <span class="hljs-comment">// 10010101</span><br><br>    std::bitset&lt;4&gt; testCase_5&#123;<span class="hljs-string">&quot;10010101&quot;</span>&#125;; <span class="hljs-comment">// 溢出位截断，只取前 4 位</span><br>    std::cout &lt;&lt; testCase_5 &lt;&lt; std::endl; <span class="hljs-comment">// 1001</span><br><br>    std::bitset&lt;8&gt; testCase_6&#123;<span class="hljs-string">&quot;ABABA&quot;</span>, <span class="hljs-comment">/* 读取长度 */</span><span class="hljs-number">4</span>, <span class="hljs-comment">/* 代表 0 的字符 */</span><span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-comment">/* 代表 1 的字符 */</span><span class="hljs-string">&#x27;B&#x27;</span>&#125;; <span class="hljs-comment">// 00000101</span><br>    std::cout &lt;&lt; testCase_6 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 4. 支持赋值构造以及整数和字符串到 bitset 的强制类型转化</span><br>    std::bitset&lt;8&gt; testCase_7 = testCase_6;<br>    std::cout &lt;&lt; testCase_7 &lt;&lt; std::endl; <span class="hljs-comment">// 00000101</span><br><br>    std::cout &lt;&lt; (std::bitset&lt;<span class="hljs-number">8</span>&gt;)<span class="hljs-number">0xf</span> &lt;&lt; std::endl; <span class="hljs-comment">// 00001111</span><br>    std::cout &lt;&lt; (std::bitset&lt;<span class="hljs-number">8</span>&gt;)<span class="hljs-string">&quot;1111&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 00001111</span><br><br>    std::bitset&lt;10&gt; testCase_8 = <span class="hljs-number">0x7f</span>;<br>    std::cout &lt;&lt; testCase_8 &lt;&lt; std::endl; <span class="hljs-comment">// 0001111111</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员方法">成员方法</h4><ul><li><p>支持下标 <code>operator[]</code></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-string">&quot;111011&quot;</span>;<br>std::cout &lt;&lt; num[<span class="hljs-number">2</span>] &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 从低位开始</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>bitset</code> 支持所有常规位运算操作</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = <span class="hljs-number">0xf</span>;<br><br>std::cout &lt;&lt; (num &amp; (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-number">0x12</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000000010</span><br>std::cout &lt;&lt; (num | (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-number">0x12</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000011111</span><br>std::cout &lt;&lt; (num ^ (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-number">0x12</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000011101</span><br>std::cout &lt;&lt; (num &lt;&lt; <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000111100</span><br>std::cout &lt;&lt; (num &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000000011</span><br><br>num = <span class="hljs-number">-1</span>;<br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111111111</span><br>std::cout &lt;&lt; (num &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0011111111</span><br><span class="hljs-comment">// 对 bitset 的右移都是逻辑右移</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>set()</code> ：设置单独位的值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = <span class="hljs-number">-1</span>;<br>num.<span class="hljs-built_in">set</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 将下标为 0 的位设置为 0</span><br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111111110</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>flip()</code> ：取反，无参数时默认对全部位</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = <span class="hljs-number">0xf</span>;<br>num.<span class="hljs-built_in">flip</span>();<br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111110000</span><br>num.<span class="hljs-built_in">flip</span>(<span class="hljs-number">1</span>);<br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111110010</span><br></code></pre></td></tr></table></figure></p></li><li><p>检查位</p><ul><li><code>all()</code> ：判断是否所有位都为 1</li><li><code>any()</code> ：判断是否有任意一位为 1</li><li><code>none()</code> ：判断是否所有位为 0</li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;4&gt; num = <span class="hljs-number">0x7</span>;<br><br>std::cout &lt;&lt; num.<span class="hljs-built_in">all</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br>std::cout &lt;&lt; num.<span class="hljs-built_in">any</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 1</span><br>std::cout &lt;&lt; num.<span class="hljs-built_in">none</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>count()</code> ：返回 1 的数量</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;4&gt; num = <span class="hljs-number">0x7</span>;<br><br>std::cout &lt;&lt; num.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>size()</code> ：返回位数</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num;<br>std::cout &lt;&lt; num.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></p></li><li><p>转换：</p><ul><li><code>to_string()</code> ：返回数据的字符串类型</li><li><code>to_ulong</code> ：返回数据的 <code>unsigned long</code>整数表示</li><li><code>to_ullong</code> ：返回数据的 <code>unsigned long long</code>整数表示</li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;8&gt; num_bit = <span class="hljs-number">0xf</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> num_1 = num_bit.<span class="hljs-built_in">to_ulong</span>();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> num_2 = num_bit.<span class="hljs-built_in">to_ullong</span>();<br>std::string str = num_bit.<span class="hljs-built_in">to_string</span>();<br><br>std::cout &lt;&lt; num_1 &lt;&lt; std::endl; <span class="hljs-comment">// 15</span><br>std::cout &lt;&lt; num_2 &lt;&lt; std::endl; <span class="hljs-comment">// 15</span><br>std::cout &lt;&lt; str &lt;&lt; std::endl; <span class="hljs-comment">// 00001111</span><br></code></pre></td></tr></table></figure></p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>位运算</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链式前向星介绍</title>
    <link href="/2023/03/06/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/03/06/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是链式前向星">什么是链式前向星？</h4><p><strong>链式前向星</strong>是一种常用的图存储结构，其思路类似于邻接链表法，只是实现方式有所不同，链式向前星更像是<strong>用数组模拟链表</strong>。</p><p>与一般的邻接链表法不同，链式向前星储存的图的<strong>每条边都有编号</strong>。</p><p>以下是链式前向星的存储结构：</p><ul><li><p><code>cnt</code> ：用来记录当前所有边的数量</p></li><li><p><code>first</code> 数组：用来存储从某个节点出发的第一条边，例如<code>first[0] == 3</code> 可以得出从 <code>0</code>号节点出发的第一条边的编号为 <code>3</code></p></li><li><p><code>edges</code> 数组：用来记录每条边的信息，对于每个<code>edges[i]</code> 都有 3 个域：</p><ul><li><code>to</code> ：记录边的终点</li><li><code>weight</code> ：记录边的权重</li><li><code>next</code> ：记录从当前起点出发下一条边的编号，例如：若<code>edges[i]</code> 的起点为 <code>j</code> 号节点，则<code>edges[i].next</code> 表示从 <code>j</code> 出发的下一条边</li></ul></li></ul><p>示例：</p><p><img src="https://p.ipic.vip/wvox68.png" alt="链式向前星存储图示例" style="zoom:67%;" /></p><blockquote><p>如上图，这就是链式向前星存储图的方式了，其中编号为 -1的边表示不存在，即没有其他的出边。</p><p>若我们需要新增一条从 <code>i</code> 到 <code>j</code>的边，只需更新在 <code>edges</code> 数组内增加元素并且使其新增边的<code>next</code> 等于 <code>first[i]</code> ，然后更新<code>first[i]</code> 为新增的边的编号即可。</p></blockquote><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX 100000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EDGE 100000</span><br><br><span class="hljs-type">int</span> cnt; <span class="hljs-comment">// 边的数量</span><br><br><span class="hljs-type">int</span> first[MAX_VERTEX]; <span class="hljs-comment">// first 数组</span><br><br><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> next;<br>&#125; edges[MAX_EDGE]; <span class="hljs-comment">// 记录边</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initEdge</span><span class="hljs-params">()</span> </span>&#123;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 初始化，将 first 数组全初始化为 -1</span><br>    <span class="hljs-built_in">memset</span>(first, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(first));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> weight)</span> </span>&#123;<br>    edges[cnt] = &#123;to, weight, first[from]&#125;; <span class="hljs-comment">// 新增边</span><br>    first[from] = cnt; <span class="hljs-comment">// 更新 first 数组</span><br>    cnt++; <span class="hljs-comment">// 边数增加</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverseEdgeFrom</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历从 v 出发的所有边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = first[v]; p != <span class="hljs-number">-1</span>; p = edges[p].next) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;eNo: &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; to: &quot;</span> &lt;&lt; edges[p].to &lt;&lt; <span class="hljs-string">&quot; weight: &quot;</span> &lt;&lt; edges[p].weight &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>链式前向星</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICG 游戏博弈问题与 SG 定理</title>
    <link href="/2023/03/02/ICG%20%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98%E4%B8%8E%20SG%20%E5%AE%9A%E7%90%86/"/>
    <url>/2023/03/02/ICG%20%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98%E4%B8%8E%20SG%20%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="icg-游戏">ICG 游戏</h3><h4 id="定义">定义</h4><p><strong>ICG</strong> 游戏是博弈游戏的一种，其定义如下：</p><ol type="1"><li>游戏由两人参加，两人轮流做出决策</li><li>当有一人无法决策即无论如何都必败时对手胜出，且 ICG游戏一定会在有限步内完成，游戏没有平局</li><li>游戏的状态转移是单向的，同一个状态只能达到一次</li></ol><h4 id="必胜点和必败点">必胜点和必败点</h4><p>必胜点 N ( Next ) 和必败点 P ( Previous )描述的是某个游戏状态当前的胜负。</p><p>若当前状态为必胜点 N ，则先手必胜，反之，若当前状态为必败点 P，则先手必败。</p><p>可能到这里为止大家还是会觉得比较抽象，所以我们给出一个实际例子：</p><p>假设有一堆石头，两人轮流从这堆石头中取走 1 ~ 5 块石头，初始状态下有 n块石头，问 n 为何值时先手必胜？</p><p>先说结论：<code>n % 6 != 0</code> 时先手必胜。</p><p>原因十分简单，若 n 不是 6 的倍数，则先手一定可以取走 1 ～ 5块内的石头使得取走石头后这堆石头的数量能被 6 整除，此后，对手只要取走 m块石头，我们就取走 6 - m块石头，<strong>可以保证我们每次取完后石头的数量都是 6的倍数</strong>。如此一来，最后的石头一定是被我们取走。</p><p>于是，我们可以得到石头数量 n 对应的 NP 状态：</p><table style="width:100%;"><thead><tr class="header"><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>...</th></tr></thead><tbody><tr class="odd"><td><strong>state</strong></td><td><strong>P</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>P</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>...</strong></td></tr></tbody></table><p>在这里，我们不难得出结论：</p><ul><li><strong>所有必胜点必然可以在一步操作内转移到必败点</strong></li><li><strong>所有必败点无论如何操作只能转移到必胜点</strong></li></ul><h3 id="sg-定理">SG 定理</h3><p>SG 是 Sprague-Grundy 的缩写，SG 定理是处理 ICG博弈问题的重要方法，在讲解其使用之前，我们先简要介绍一下 SG函数的定义。</p><h4 id="sg-函数">SG 函数</h4><p>首先我们定义 <strong><span class="math inline">\(mex\)</span> (minimal excludant )</strong> 运算，<spanclass="math inline">\(mex(F)\)</span> 即表示不属于非负整数集 <spanclass="math inline">\(F\)</span> 中最小的元素：</p><p>例如： <span class="math display">\[\begin{array}{}mex(\{1, 2, 3\}) = 0 \\mex(\{0, 1, 3, 4\}) = 2 \\mex(\emptyset) = 0\end{array}\]</span> 什么是 SG 值？</p><p>SG值是一种通过递归定义的值，它一般情况下是一个非负整数，可以用来描述游戏状态是必胜点还是必败点，假设游戏状态<span class="math inline">\(V_i\)</span> 的 SG 值为 <spanclass="math inline">\(SG(V_i)\)</span> ，那么其状态转移方程如下： <spanclass="math display">\[SG(V_i) = mex(\{SG(V_j) \ | \ V_i \rightarrow V_j \})\]</span> 其数值上等于与 <span class="math inline">\(V_i\)</span>所有后继状态的 SG 值不相等的最小非负整数。</p><p>基于此，我们得到一条重要结论：<strong>SG 值不为 0 的状态为必胜点，SG值为 0 的状态为必败点</strong>。</p><p>这个结论很好证明：若 SG 值不为 0，说明该状态一定能一步转移到 SG 值为0 的状态，即可以一步转移到必败点，所以该状态一定为必胜点；反之，若 SG值为0，则该状态无法一步转移到必败点，只能转移到必胜点或者无法决策，故该点一定为必败点。</p><p>我们还是用上述的取石头问题来举例说明，则不同石头数量 n 对应的 SG值如下：</p><table style="width:100%;"><thead><tr class="header"><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr class="odd"><td><strong>SG(n)</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p><span class="math display">\[\begin{array}{}SG(0) = mex(\emptyset) = 0 \\SG(1) = mex(\{0\}) = 1 \\SG(2) = mex(\{0, 1\}) = 2 \\SG(3) = mex(\{0, 1, 2\}) = 3 \\SG(4) = mex(\{0, 1, 2, 3\}) = 4 \\SG(5) = mex(\{0, 1, 2, 3, 4\}) = 5 \\SG(6) = mex(\{1, 2, 3, 4, 5\}) = 0 \\... \newlineSG(10) = mex(\{5, 0, 1, 2, 3\}) = 4 \\...\end{array}\]</span></p><h4 id="sg-定理详解">SG 定理详解</h4><p>现在我们已经知道了 SG 函数的定义，那 SG 定理又是什么呢？</p><hr /><h5 id="什么是-sg-定理">什么是 SG 定理 ?</h5><p>SG 定理指的是<strong>若一个 ICG博弈游戏的游戏状态可以分为多个子状态，且子状态互相独立，则该游戏状态下的SG 值等于所有子状态的 SG 值的异或值</strong>。</p><p>这又是什么意思呢？别急，我们还是用取石头的例子来说明：</p><p>假设现在有 <span class="math inline">\(k\)</span> 堆石头，每堆石头有<span class="math inline">\(n_i(i = 1, 2, ...,k)\)</span> 块石头，两个人轮流从每一堆石头中取走 <span class="math inline">\([1,m]\)</span> 块石头，先取完所有石头的一方获胜。我们设此刻游戏状态的 SG值为 <span class="math inline">\(SG((n_1, n_2, ..., n_k))\)</span> ，由SG 定理可得： <span class="math display">\[SG((n_1, n_2, ..., n_k)) = SG(n_1) \oplus SG(n_2) \oplus ... \oplusSG(n_k)\]</span></p><ul><li><span class="math inline">\(SG((n_1, n_2, ..., n_k)) \neq 0\)</span>：先手胜</li><li><span class="math inline">\(SG((n_1, n_2, ..., n_k)) = 0\)</span>：先手败</li></ul><p>以上就是完整的 SG 定理了。</p><h5 id="sg-定理的合理性">SG 定理的合理性</h5><p>为什么 SG定理会与位运算的异或有关呢？它们是如何联系上的？为什么这种计算是合理的呢？</p><p>以下我们给出简要的证明：</p><p>根据 SG 值的定义，必败点的 SG 值一定为0，对于此题而言，游戏的终点就是所有的石头被取完，此时 SG 值是 k 个 0的异或值，显然为 0。</p><p>若当前的 SG 值不为 0，我们假设： <span class="math display">\[SG((n_1, n_2, ..., n_k)) = {001010..}_2\]</span> 我们找到该 SG 值数值为 1的最高位，由异或运算符的性质，必然存在奇数个子状态的 SG 值该位为1，我们不妨假设其中一个子状态对应的 SG 值为 <spanclass="math inline">\(SG_0\)</span> ，由 SG值的定义，该状态一定可以一步之内转变为任何 SG 值小于 <spanclass="math inline">\(SG_0\)</span> 的状态，<spanclass="math inline">\(SG_0\)</span> 对应母状态下数值为 1的最高位的值也为 1，我们让其变为0，然后从这一位开始之后全部位取反，则一定可以将母状态的 SG 值变为0。</p><center>0 1 0 1 1 1<br> <strong>0 1 1 0 0 0</strong><br> <ins>0 1 0 1 01</ins><br> 0 1 1 0 1 0<br> 如上，我们将第二个子状态 的 SG 值转移到 0 00 1 1 1，就将母状态的 SG 值转化为 0 了<br> 0 1 0 1 1 1<br> <strong>0 0 01 1 1</strong><br> <ins>0 1 0 1 0 1</ins><br> 0 0 0 0 0 0<br></center><p>反之，如果母状态的 SG 值为0，则改变任何一个子状态，由于异或运算的性质，母状态的 SG值一定无法维持为 0。</p><p>而根据 ICG 博弈游戏的定义，游戏一定会在有限步内完成，故所有子状态 SG值的异或运算不为 0 的母状态一定是必胜点。</p><h3 id="实际应用">实际应用</h3><blockquote><p><strong>Fibonacci again and again</strong></p><p>Problem Description 任何一个大学生对菲波那契数列(Fibonaccinumbers)应该都不会陌生，它是这样定义的： F(1) = 1； F(2) = 2； F(n) =F(n - 1) + F(n - 2) ( n &gt;= 3 )； 所以，1, 2, 3, 5, 8, 13, ...就是菲波那契数列。 今天，又一个关于 Fibonacci的题目出现了，它是一个小游戏，定义如下：</p><ol type="1"><li>这是一个二人游戏；</li><li>一共有 3 堆石子，数量分别是 m, n, p 个；</li><li>两人轮流走；</li><li>每走一步可以选择任意一堆石子，然后取走f个；</li><li>f 只能是菲波那契数列中的元素 ( 即每次只能取1，2，3，5，8 … 等数量)；</li><li>最先取光所有石子的人为胜者；</li></ol><p>假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。</p><p><strong>Input</strong>输入数据包含多个测试用例，每个测试用例占一行，包含 3 个整数 m, n, p ( 1&lt;= m, n, p &lt;= 1000 )。 m = n = p = 0 则表示输入结束。</p><p><strong>Output</strong>如果先手的人能赢，请输出“Fibo”，否则请输出“Nacci”，每个实例的输出占一行。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs input">1 1 1<br>1 4 1<br>0 0 0<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs output">Fibo<br>Nacci<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析</strong>：</p><p>本题所描述的游戏就是一种 ICG博弈，且三堆石头互不影响，所以我们可以直接使用 SG 定理求解，再加上记忆化DFS 优化，很容易就能求解此问题。废话不多说，直接上代码😎。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FIB_NUM 50</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_AMOUNT 1005</span><br><br><span class="hljs-type">int</span> Fibonacci[MAX_FIB_NUM]; <span class="hljs-comment">// 储存 Fibonacci 数列的值</span><br><span class="hljs-type">int</span> SG[MAX_AMOUNT]; <span class="hljs-comment">// 记录 SG 值，初始化为 -1</span><br><br><span class="hljs-comment">// 记忆化搜索</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Fibonacci[n]) &#123;<br>        <span class="hljs-keyword">return</span> Fibonacci[n];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        Fibonacci[n] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        Fibonacci[n] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    Fibonacci[n] = <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>); <span class="hljs-comment">// 记忆</span><br><br>    <span class="hljs-keyword">return</span> Fibonacci[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sg</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 返回 SG 值</span><br>    <span class="hljs-keyword">if</span> (SG[n] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> SG[n];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        SG[n] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> vis[MAX_AMOUNT] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 记录当前状态可达状态的 SG 值是否出现过</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; n - <span class="hljs-built_in">fib</span>(i) &gt;= <span class="hljs-number">0</span>; i++) &#123;<br>        vis[<span class="hljs-built_in">sg</span>(n - <span class="hljs-built_in">fib</span>(i))] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 记录已出现的 SG 值</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_AMOUNT; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>            SG[n] = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> SG[n];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-built_in">memset</span>(SG, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(SG)); <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-type">int</span> m, n, p;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; m &gt;&gt; n &gt;&gt; p, m != <span class="hljs-number">0</span> || n != <span class="hljs-number">0</span> || p != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sg</span>(m) ^ <span class="hljs-built_in">sg</span>(n) ^ <span class="hljs-built_in">sg</span>(p)) &#123;<br>            <span class="hljs-comment">// SG 定理</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;Fibo&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Nacci&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SG 定理</tag>
      
      <tag>SG 函数</tag>
      
      <tag>组合博弈</tag>
      
      <tag>组合数学</tag>
      
      <tag>记忆化搜索</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化 DFS</title>
    <link href="/2023/02/26/%E8%AE%B0%E5%BF%86%E5%8C%96%20DFS/"/>
    <url>/2023/02/26/%E8%AE%B0%E5%BF%86%E5%8C%96%20DFS/</url>
    
    <content type="html"><![CDATA[<h4 id="引入">引入</h4><p>记忆化DFS，顾名思义，就是<strong>带有记忆的深度优先搜索</strong>。</p><p>总所周知，用程序实现 Fibonacci 数列求值有两种常见方式：</p><ul><li><p>通过迭代即非递归的方式：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">1</span>, next = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">2</span>) &#123;<br>        sum = pre + next;<br>        pre = next;<br>        next = sum;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>通过递归方式：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul><p>上述两种方式各有优缺点，迭代方式效率更高，但是写起来比较麻烦；递归方式运行效率低，但是代码实现容易。</p><p><em>有没有一种方式可以结合两者的优点呢？</em></p><p>对于第二种递归方式，其主要的时间开销在于计算了许多重复内容，我们是否可以使用一个数组来维护已经计算过的值呢？</p><p>答案是显然的，于是我们就有了 —— <strong>记忆化 DFS</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> fib[MAX_NUM]; <span class="hljs-comment">// 记忆数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (fib[n]) &#123;<br>        <span class="hljs-keyword">return</span> fib[n]; <span class="hljs-comment">// 已经计算过的值直接返回</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        fib[n] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        fib[n] = <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> fib[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码以递归的方式实现，但是时间复杂度可以降到线性，和迭代形式一样，不同的地方在于我们需要额外的空间开销来记录已经计算过的值。</p><p>可能有同学就有疑问了：</p><p><em>上述例子很容易用 DP 来实现，为什么还需要记忆化 DFS 呢？</em></p><p>接下来我们将给出几个实际例子加以说明。</p><h4 id="实例分析">实例分析</h4><h5 id="案例一">案例一</h5><blockquote><p><strong>猫和老鼠</strong></p><p>Problem Description 有个小老鼠在校园里收藏了一些它最爱吃的奶酪。校园可以看成一个长度为n的正方形网格，每个网格可以标记为 (p, q) ，其中，0&lt;= p , q &lt; n。每个网格都有一个洞，里面储存了 k（0 &lt;= k &lt;=100）块奶酪。</p><p>现在，小老鼠准备享用这些美味啦。</p><p>开始的时候，他在 (0, 0)这个位置，每到一个地方，它都会吃光这个地方的奶酪，然后沿着水平或者垂直的方向到达另外一个地方。麻烦的是，有个很凶的猫总是在它的洞口附近，所以他每次最多移动k个位置，否则就会被这只猫吃掉。更糟糕的是，每在一个地方吃过奶酪，小老鼠都会变胖，所以，为了获得足够下一次逃跑的能量，它每次只能去比当前位置的奶酪更多的格子。现在已知 n 和 k，以及在每个网格的洞中小老鼠储存的奶酪的数量，请计算小老鼠在无法移动之前，一共最多能吃到多少块奶酪。</p><p>Input 题目包含多组测试数据。</p><p>每组测试数据组成如下： 首先一行包含2个不超过100的正整数 n 和 k ;接下来 n 行，每行包含n个数： 第一行 n 个数分别表示 (0, 0), (0, 1), … (0,n - 1) 这些位置储存的奶酪数量； 第二行 n 个数分别表示 (1, 0), (1, 1), …(1, n - 1) 这些位置储存的奶酪数量； 以此类推...</p><p>输入数据以两个 -1 结束。</p><p>Output 请输出小老鼠最多 能够吃到的奶酪数量，每组数据输出一行。</p><p>输入案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs input">3 1<br>1 2 5<br>10 11 6<br>12 12 7<br>-1 -1<br></code></pre></td></tr></table></figure><p>输出案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">37<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析</strong>：</p><p>根据题意，我们假设从 <span class="math inline">\((x, y)\)</span>出发的老鼠可以吃到的最大奶酪数量为 <span class="math inline">\(ans(x,y)\)</span>，<span class="math inline">\((x, y)\)</span> 处的芝士储量为<span class="math inline">\(cheese(x, y)\)</span>，老鼠可以从 <spanclass="math inline">\((x, y)\)</span> 出发在一次 <spanclass="math inline">\(k\)</span> 步以内的移动中到达的坐标的集合为 <spanclass="math inline">\(S = \{(x_1, y_1), (x_2, y_2), (x_3, y_3),...\}\)</span>，不难得出状态转移方程： <span class="math display">\[ans(x, y) = max_{(x_n, y_n) \in S} ans(x_n, y_n) \ + \ cheese(x, y)\]</span>如果直接用动态规划求解，这个问题的处理会相当复杂，因为我们难以从该状态转移方程中确定DP 的起点和 DP 的方向，所以直接采用迭代的方式恐怕不现实。</p><p>于是我们便考虑到可以使用记忆化DFS，既保证了效率，又降低了编码难度。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENG 105</span><br><br><span class="hljs-type">int</span> cheese[MAX_LENG][MAX_LENG];<br><span class="hljs-type">int</span> ans[MAX_LENG][MAX_LENG]; <span class="hljs-comment">// 储存结果，初始化为 -1</span><br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">const</span> vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; dirs = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;<br>&#125;; <span class="hljs-comment">// 运动方向</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// 记忆化 DFS</span><br>    <span class="hljs-comment">// 返回以 (x, y) 为起点可以吃到最多的奶酪</span><br>    <span class="hljs-keyword">if</span> (ans[x][y] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 已经计算过的值</span><br>        <span class="hljs-keyword">return</span> ans[x][y];<br>    &#125;<br>    ans[x][y] = cheese[x][y];<br>    <span class="hljs-type">int</span> plusCheese = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dir :dirs) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>; s &lt;= k; s++) &#123;<br>            <span class="hljs-type">int</span> nx = x + s * dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ny = y + s * dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n &amp;&amp; cheese[nx][ny] &gt; cheese[x][y]) &#123;<br>                plusCheese = <span class="hljs-built_in">max</span>(plusCheese, <span class="hljs-built_in">dfs</span>(nx, ny));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ans[x][y] += plusCheese;<br>    <span class="hljs-keyword">return</span> ans[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; k, n != <span class="hljs-number">-1</span> || k != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(ans));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                cin &gt;&gt; cheese[i][j];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="案例二">案例二</h5><blockquote><p><strong>How many ways</strong></p><p>Problem Description这是一个简单的生存游戏，你控制一个机器人从一个棋盘的起始点 (1, 1)走到棋盘的终点 (n, m)。游戏的规则描述如下：</p><ol type="1"><li>机器人一开始在棋盘的起始点并有起始点所标有的能量。</li><li>机器人只能向右或者向下走，并且每走一步消耗一单位能量。</li><li>机器人不能在原地停留。</li><li>当机器人选择了一条可行路径后，当他走到这条路径的终点时，他将只有终点所标记的能量。</li></ol><figure><img src="http://acm.hdu.edu.cn/data/images/C113-1003-1.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如上图，机器人一开始在 (1, 1)点，并拥有4单位能量，蓝色方块表示他所能到达的点，如果他在这次路径选择中选择的终点是(2, 4) ，当他到达 (2, 4)点时将拥有1单位的能量，并开始下一次路径选择，直到到达 (6, 6) 点。我们的问题是机器人有多少种方式从起点走到终点。这可能是一个很大的数，输出的结果对10000 取模。</p><p>Input 第一行输入一个整数T,表示数据的组数。对于每一组数据第一行输入两个整数 n, m (1 &lt;= n, m &lt;=100)。表示棋盘的大小。接下来输入 n 行,每行 m 个整数 e (0 &lt;= e &lt;20)。</p><p>Output 对于每一组数据输出方式总数对10000取模的结果。</p><p>输入案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs input">1<br>6 6<br>4 5 6 6 4 3<br>2 2 3 1 7 2<br>1 1 4 6 2 7<br>5 8 4 3 9 5<br>7 6 6 2 1 5<br>3 1 1 3 7 2<br></code></pre></td></tr></table></figure><p>输出案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3948<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析</strong>：</p><p>同案例一，我们只需找到状态转移方程后使用记忆化 DFS即可，这里不再赘述。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> T; <span class="hljs-comment">// 数据组数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENG 105</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 10000</span><br><br><span class="hljs-type">int</span> energy[MAX_LENG][MAX_LENG]; <span class="hljs-comment">// 记录每个格点点能量</span><br><span class="hljs-type">int</span> ans[MAX_LENG][MAX_LENG]; <span class="hljs-comment">// 记录答案，初始化为 -1</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// 表示从 (x, y) 出发到终点又多少种走法</span><br>    <span class="hljs-keyword">if</span> (ans[x][y] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> ans[x][y];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) &#123;<br>        ans[x][y] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> ans[x][y];<br>    &#125;<br>    <span class="hljs-type">int</span> power = energy[x][y]; <span class="hljs-comment">// 能量</span><br>    ans[x][y] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= power; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= power - i; j++) &#123;<br>            <span class="hljs-comment">// 遍历所有可能位置</span><br>            <span class="hljs-type">int</span> nx = x + i, ny = y + j;<br>            <span class="hljs-keyword">if</span> (nx != x || ny != y) &#123;<br>                <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m) &#123;<br>                    ans[x][y] = (ans[x][y] + <span class="hljs-built_in">dfs</span>(nx, ny)) % MAX_NUM;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                cin &gt;&gt; energy[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(ans));<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="在-python-中的简单实现">在 Python 中的简单实现</h4><p>在 Python 中，实现记忆化搜索的一个简单方式是使用<code>functools</code> 模块中的 <code>lru_cache</code>装饰器。这个装饰器可以告诉 Python缓存函数的输出值，以便相同的输入参数在后续调用中不需要重新计算。</p><p>基本的函数声明如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> lru_cache<br><br><span class="hljs-meta">@lru_cache(<span class="hljs-params">maxsize=<span class="hljs-literal">None</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-comment"># 函数体</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>@lru_cache(maxsize=None)</code>是一个装饰器，它应用于函数 <code>f</code>。这个装饰器会缓存<code>f</code> 的调用结果，以便相同的输入 <code>x</code>在将来的调用中可以直接从缓存中获取结果，而不需要重新计算。</p><ul><li><code>maxsize</code> 参数用于指定缓存的大小。如果设置为<code>None</code>，缓存的大小是无限的，这意味着除非显式清除，否则所有的调用都会被缓存。</li><li>如果你想限制缓存的大小，可以设置 <code>maxsize</code>为一个正整数，这将限制缓存的大小，当达到最大值时，最旧的结果将被移除。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分匹配问题 —— 匈牙利算法</title>
    <link href="/2023/02/25/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/25/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="问题介绍">问题介绍</h3><p><strong>什么是二分图？</strong></p><p>对于图 <span class="math inline">\(G(V,E)\)</span> 而言，若 <spanclass="math inline">\(G\)</span> 中的所有点可以划分为两个子集 <spanclass="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span> ，且图中每条边 <spanclass="math inline">\(e\)</span>关联的两个顶点都属于不同的顶点子集，这样的图我们称为<strong>二分图（Bipartite Graph ）</strong>，或者二部图。</p><p><img src="https://p.ipic.vip/ueiehn.png" style="zoom:67%;" /></p><p><strong>最大匹配问题和最小点覆盖问题</strong></p><p>什么是<strong>最大匹配问题</strong>？给定一个二分图 <spanclass="math inline">\(G(V,E)\)</span>，若 <spanclass="math inline">\((a_i,b_j) \in E\)</span> ，我们就称 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(b_j\)</span>是可配对的，已知该图中任意顶点至多匹配一个顶点，求最大匹配数。如下图，不难看出该图的最大匹配数为2。其中一种匹配方式为 <span class="math inline">\((a_1,b_1)\)</span>、<span class="math inline">\((a_3, b_4)\)</span> 。</p><p>什么又是<strong>最小点覆盖问题</strong>呢？即从二分图中删除最少的顶点，使得图<span class="math inline">\(G\)</span>中任何一对点都无法匹配。删除顶点的最小数量称为最小点覆盖数。如下图，不难看出最小覆盖数也是2。我们可以删去 <span class="math inline">\(a_3\)</span> 和 <spanclass="math inline">\(b_1\)</span> 使得图中任何一对点都无法匹配。</p><p>这两个问题看似不一样，实际上实际上是处理一个相同的问题。为什么这么说呢？因为我们可以证明一条重要性质：</p><center><strong>最大匹配数 = 最小覆盖数</strong></center><p>具体证明就不在这里说明了，笔者打算以后单独出一期文章来证明该性质。</p><p><img src="https://p.ipic.vip/5pnk5n.png" style="zoom:45%;" /></p><p>那我们该如何给出二分匹配问题的一般解决方案呢？1955 年，库恩（W.W.Kuhn ）利用一个匈牙利数学家康哥尼（ D.Kőnig）的一个定理构造了一种二分匹配问题的解法，后人称之为<strong>匈牙利算法</strong>。</p><h3 id="匈牙利算法">匈牙利算法</h3><p>在介绍匈牙利算法之前，我们先介绍几个概念：</p><ul><li><p><strong>交替路</strong>：</p><p>从未匹配点出发，依次经过未匹配的边和已匹配的边的路径称为交替路。</p></li><li><p><strong>增广路</strong>：</p><p>经过除出发点之外其他未匹配点的交替路称为增广路。</p><p><strong>当且仅当不存在关于图 <span class="math inline">\(G\)</span>的增广路径时当前的匹配为图 <span class="math inline">\(G\)</span>的最大匹配。</strong></p></li></ul><h4 id="算法讲解">算法讲解</h4><p>如下图所示，我们接下来将使用匈牙利算法来计算该二分图的最大匹配数。</p><p>我们从 <span class="math inline">\(a_1\)</span> 开始匹配，<spanclass="math inline">\(a_1\)</span> 与 <spanclass="math inline">\(b_1\)</span> 匹配成功，即当前匹配对数为 1。</p><p><left><img src="https://p.ipic.vip/phzd9z.png" alt="(1)" style="zoom:100%; margin-right: 30px;" /><img src="https://p.ipic.vip/wfjof3.png" alt="(2)" style="zoom:100%; margin-right: 30px;" /></left></p><p>然后再对 <span class="math inline">\(a_2\)</span> 进行匹配，我们发现<span class="math inline">\(a_2\)</span> 只能匹配 <spanclass="math inline">\(b_1\)</span> ，而 <spanclass="math inline">\(b_1\)</span> 已经与 <spanclass="math inline">\(a_1\)</span> 匹配成功了，此时我们发现 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(b_3\)</span> 可以成功匹配，于是我们可以取消 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(b_1\)</span> 的匹配，然后匹配 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(b_3\)</span> ，这个时候 <spanclass="math inline">\(a_2\)</span> 就可以匹配 <spanclass="math inline">\(b_1\)</span> 了。匹配对数加一，当前匹配对数为2。</p><p>其实这一步相当于找到了一条增广路 <span class="math inline">\((a_2,b_1, a_1, b_3)\)</span> ，然后对该增广路取反。</p><p><left><img src="https://p.ipic.vip/0dm74v.png" alt="(3)" style="zoom:100%;" /></left></p><p>接下来对 <span class="math inline">\(a_3\)</span> 进行匹配，<spanclass="math inline">\(a_3\)</span> 与 <spanclass="math inline">\(b_2\)</span>成功匹配，匹配对数加一，当前匹配对数为 3。</p><p><left><img src="https://p.ipic.vip/zhjyss.png" alt="(4)" style="zoom:100%;" /></left></p><p>最后对 <span class="math inline">\(a_4\)</span>进行匹配，发现其只能与 <span class="math inline">\(b_1\)</span> 匹配，而<span class="math inline">\(b_1\)</span> 已经与 <spanclass="math inline">\(a_1\)</span> 匹配过了，而且无法从 <spanclass="math inline">\(a_4\)</span> 出发构造一条增广路，因此 <spanclass="math inline">\(a_4\)</span> 无法与任何一个顶点成功匹配。</p><p><strong>综上所述，展示的二分图的最大匹配数为 3</strong>。</p><p><strong>伪代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pseudo-code">// 判断 ai 是否能匹配成功<br>for bj 与 ai 相连:<br>if bj 未被访问:<br>更新 bj 访问状态;<br>        if bj 未被匹配或者 bj 的配对点可以出发找到增广路径:<br>        将 bj 的配对点改为 ai;<br>        return true;<br><br>return false;<br></code></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(VE)\)</span></p><h4 id="代码实现">代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NOT_MATCH 0x3f3f3f3f</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> numA, numB; <span class="hljs-comment">// numA、numB 分别表示两个集合的元素个数</span><br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; G; <span class="hljs-comment">// 假设这里用邻接链表储存图 G，G[i] 表示和 ai 相邻的所有 B 集合的顶点编号</span><br>  <span class="hljs-type">int</span> match[numB]; <span class="hljs-comment">// 记录 B 集合的元素的匹配点在 A 集合的编号</span><br>  <span class="hljs-type">bool</span> vis[numB]; <span class="hljs-comment">// 记录 B 集合的元素是否被访问过</span><br><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>      <span class="hljs-comment">// 判断 A 集合中编号为 index 的顶点是否能匹配成功</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[index].<span class="hljs-built_in">size</span>(); i++) &#123;<br>          <span class="hljs-keyword">if</span> (!vis[G[i]]) &#123;<br>              vis[G[i]] = <span class="hljs-literal">true</span>;<br>              <span class="hljs-keyword">if</span> (match[G[i]] == NOT_MATCH || <span class="hljs-built_in">isMatch</span>(match[[G[i]]])) &#123;<br>                <span class="hljs-comment">// 该顶点未被匹配或着原来匹配该点的顶点可以匹配其他顶点</span><br>                  match[G[i]] = index;<br>                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hungarian</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numA; i++) &#123;<br>          <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isMatch</span>(i)) &#123;<br>              cnt++;<br>            &#125;<br>        &#125;<br>      <br>      <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实际应用">实际应用</h4><blockquote><p><strong>Machine Schedule</strong></p><p>Problem Description As we all know, machine scheduling is a veryclassical problem in computer science and has been studied for a verylong history. Scheduling problems differ widely in the nature of theconstraints that must be satisfied and the type of schedule desired.Here we consider a 2-machine scheduling problem.</p><p>There are two machines A and B. Machine A has n kinds of workingmodes, which is called <span class="math inline">\(mode_0\)</span> ,<span class="math inline">\(mode_1\)</span> , …, <spanclass="math inline">\(mode_{n-1}\)</span> , likewise machine B has mkinds of working modes, <span class="math inline">\(mode_0\)</span>,<span class="math inline">\(mode_1\)</span> , … , <spanclass="math inline">\(mode_{m-1}\)</span> . At the beginning they areboth work at <span class="math inline">\(mode_0\)</span>.</p><p>For k jobs given, each of them can be processed in either one of thetwo machines in particular mode. For example, job 0 can either beprocessed in machine A at <span class="math inline">\(mode_3\)</span> orin machine B at <span class="math inline">\(mode_4\)</span> , job 1 caneither be processed in machine A at <spanclass="math inline">\(mode_2\)</span> or in machine B at <spanclass="math inline">\(mode_4\)</span> , and so on. Thus, for job i, theconstraint can be represent as a triple (i, x, y), which means it can beprocessed either in machine A at <spanclass="math inline">\(mode_x\)</span>, or in machine B at <spanclass="math inline">\(mode_y\)</span> .</p><p>Obviously, to accomplish all the jobs, we need to change themachine’s working mode from time to time, but unfortunately, themachine’s working mode can only be changed by restarting it manually. Bychanging the sequence of the jobs and assigning each job to a suitablemachine, please write a program to minimize the times of restartingmachines.</p><p>Input The input file for this program consists of severalconfigurations. The first line of one configuration contains threepositive integers: n, m (n, m &lt; 100) and k (k &lt; 1000). Thefollowing k lines give the constrains of the k jobs, each line is atriple: i, x, y.</p><p>The input will be terminated by a line containing a single zero.</p><p>Output The output should be one integer per line, which means theminimal times of restarting machine.</p><p>输入案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs input">5 5 10<br>0 1 1<br>1 1 2<br>2 1 3<br>3 1 4<br>4 2 1<br>5 2 2<br>6 2 3<br>7 2 4<br>8 3 3<br>9 4 3<br>0<br></code></pre></td></tr></table></figure><p>输出案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3<br></code></pre></td></tr></table></figure></blockquote><p>对于此题，我们可以将 A、B机器的所有模式看成二部图看成两个子集，若某个工作需要机器 A 的 x模式和机器 B 的 y 模式来完成，就将 <span class="math inline">\((a_x,b_y)\)</span>连接起来。最后我们的问题就变成了：<strong>应该如何找到该二部图的最小点覆盖数？</strong></p><p>而根据我们之前提到的结论可知，最小点覆盖数在数值上等于最大匹配数。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 105</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NOT_FOUND 0x3f3f3f3f</span><br><br><span class="hljs-type">int</span> G[MAX_NUM][MAX_NUM];<br><span class="hljs-type">bool</span> vis[MAX_NUM];<br><span class="hljs-type">int</span> match[MAX_NUM];<br><br><span class="hljs-type">int</span> n, m, k;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (G[index][i] &amp;&amp; !vis[i]) &#123;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[i] == NOT_FOUND || <span class="hljs-built_in">isMatch</span>(match[i])) &#123;<br>                match[i] = index;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cin &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-built_in">memset</span>(G, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G));<br>        <span class="hljs-built_in">memset</span>(match, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(match));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-type">int</span> t, ax, by;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            cin &gt;&gt; t &gt;&gt; ax &gt;&gt; by;<br>            <span class="hljs-keyword">if</span> (ax != <span class="hljs-number">0</span> &amp;&amp; by != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 0 号模式下可以完成的任务不用添加</span><br>                G[ax][by] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isMatch</span>(i)) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 求出最小点覆盖数</span><br><br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二分图博弈问题">二分图博弈问题</h3><p>二分图博弈是一类博弈模型，他可以抽象为：给出一张二分图和起点 <spanclass="math inline">\(S\)</span>，两人轮流进行操作，每次操作只能选择与上一个被选的点相邻的点，且不能选择已经选择过的点，无法选点的人输掉。问先手是否必胜。</p><p>结论：<strong>考虑二分图的所有最大匹配，如果在所有的最大匹配的方案中都包含了起点<span class="math inline">\(S\)</span>，那么先手必胜，否则先手必败。</strong></p><p>证明：</p><ol type="1"><li>若所有最大匹配方案包括了 <span class="math inline">\(S\)</span>，则先手可以走到一个匹配点 <span class="math inline">\(p_1\)</span>，<strong>每一步后手都会走到一个新匹配点</strong>。假设后手走到了未匹配点<span class="math inline">\(p_n\)</span> ，考虑当前所走步：<spanclass="math inline">\(S \to p_1 \to p_2 \to ... \to p_{n - 1} \top_{n}\)</span> ，则 <span class="math inline">\((p_1, p_2), (p_3, p_4),... (p_{n - 1}, p_{n})\)</span> 以及其他匹配对构成了不包含 <spanclass="math inline">\(S\)</span>的最大匹配，矛盾。因此后手一定会走到一个匹配点，综上所述，先手一定会选择完最后一个匹配点，后手将无路可走，先手必胜。</li><li>若存在一种最大匹配不包含 <span class="math inline">\(S\)</span>，<strong>则先手每一步只能走到新匹配点</strong>，假设先手在某一步走到了非匹配点<span class="math inline">\(p_n\)</span> ，则当前路径为 <spanclass="math inline">\(S \to p_1 \to p_2 \to ... \to p_{n - 1} \top_{n}\)</span> ，此时 <span class="math inline">\((S, p_1), (p_1, p_2),... , (p_{n - 1}, p_n)\)</span>加上其他匹配对构成了更大的匹配对数，这与假设矛盾。因此每一步先手后会走到新匹配点，后手走与该点匹配的点即可，最终后手一定会选择完最后一个匹配点，先手将无路可走，后手必胜。</li></ol><p>如何确定某个点 <span class="math inline">\(S\)</span>在最大匹配中不可或缺呢？</p><p>考虑先求该二分图的最大匹配，然后删除 <spanclass="math inline">\(S\)</span> 点，再算一次最大匹配，若二者相等说明<span class="math inline">\(S\)</span>不是最大匹配中不可或缺的点，反之这说明所有的最大匹配方案中都有 <spanclass="math inline">\(S\)</span> 。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>二分匹配</tag>
      
      <tag>匈牙利算法</tag>
      
      <tag>二分图博弈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLDB 快速入门</title>
    <link href="/2023/02/22/LLDB%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/22/LLDB%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><strong><em>如果调试是删除 bug 的过程，那么编程就是引入 bug的过程。</em></strong></p><p><strong>—— Edsger W. Dijkstra</strong></p><hr /><h4 id="lldb-是什么">LLDB 是什么？</h4><p>LLDB（ Low level Debug ）是 MacOS 默认进行调试 C/C++程序的调试工具，能帮开发者进行更加丰富地流程控制和栈帧数据监测。</p><p><strong>简言之，LLDB 是一个有着 REPL 的特性和 C++ 、Python插件的开源调试器。</strong></p><p>在此，我们以几个简单的程序为例子，对 LLDB 进行快速入门。</p><p><strong>目录</strong></p><ul><li><p>启动 LLDB</p></li><li><p>断点操作</p><ul><li>设置断点</li><li>查看断点</li><li>删除断点</li></ul></li><li><p>分步调试</p><ul><li>启动调试</li><li>进入，跳过和继续</li><li>跳出当前函数</li></ul></li><li><p>查看变量</p></li><li><p>结束调试</p></li></ul><h4 id="启动-lldb">启动 LLDB</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">fact</span>(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> z = x + y;<br><br>    cout &lt;&lt; <span class="hljs-built_in">fact</span>(z) &lt;&lt; endl;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译 C/C++ 程序时使其可以被 LLDB 调试工具设置断点，需要添加<code>-g</code> ，以 C++ 文件 <code>demo.cpp</code> 为例：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">clang++ -g demo.cpp<br><br>lldb a.out<br></code></pre></td></tr></table></figure><h4 id="断点操作">断点操作</h4><h6 id="设置断点">设置断点</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">br s -f [文件名] -l [行号]# 在文件的某一行设置断点<br>br s -n [函数名]# 给函数设置断点<br></code></pre></td></tr></table></figure><h6 id="查看断点">查看断点</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">br list# 显示所有断点和其序号<br></code></pre></td></tr></table></figure><h6 id="删除断点">删除断点</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">br <span class="hljs-built_in">del</span> [断点序号]<br>br <span class="hljs-built_in">del</span> # 删除所有断点<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cmd">(lldb) br s -f demo.cpp -l <span class="hljs-number">17</span><br>Breakpoint <span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">28</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span>, address = <span class="hljs-number">0</span>x0000000100003d80<br>(lldb) br s -f demo.cpp -l <span class="hljs-number">21</span><br>Breakpoint <span class="hljs-number">2</span>: where = a.out`main + <span class="hljs-number">56</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span>, address = <span class="hljs-number">0</span>x0000000100003d9c<br>(lldb) br s -n fact<br>Breakpoint <span class="hljs-number">3</span>: where = a.out`fact(int) + <span class="hljs-number">16</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">6</span>:<span class="hljs-number">9</span>, address = <span class="hljs-number">0</span>x0000000100003d18<br>(lldb) br list<br>Current breakpoints:<br><span class="hljs-number">1</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">17</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">1</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">28</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d80], unresolved, hit count = <span class="hljs-number">0</span> <br><br><span class="hljs-number">2</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">21</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">2</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">56</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d9c], unresolved, hit count = <span class="hljs-number">0</span> <br><br><span class="hljs-number">3</span>: name = &#x27;fact&#x27;, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">3</span>.<span class="hljs-number">1</span>: where = a.out`fact(int) + <span class="hljs-number">16</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">6</span>:<span class="hljs-number">9</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d18], unresolved, hit count = <span class="hljs-number">0</span> <br><br>(lldb) br <span class="hljs-built_in">del</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> breakpoints deleted; <span class="hljs-number">0</span> breakpoint locations disabled.<br>(lldb) br list<br>Current breakpoints:<br><span class="hljs-number">1</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">17</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">1</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">28</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d80], unresolved, hit count = <span class="hljs-number">0</span> <br><br><span class="hljs-number">2</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">21</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">2</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">56</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d9c], unresolved, hit count = <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><h4 id="分步调试">分步调试</h4><h6 id="启动调试">启动调试</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">r<br></code></pre></td></tr></table></figure><blockquote><p>输入 <code>run</code> 或者 <code>r</code> 后程序便会开始启动调试</p></blockquote><h6 id="进入跳过和继续">进入，跳过和继续</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 进入单步执行，中间如果有函数调用会跳转到目标函数<br>s<br><br># 跳过单步执行，中间的函数执行过程会跳过<br>n<br><br># 继续跳转到下一个断点<br>c<br></code></pre></td></tr></table></figure><h6 id="跳出当前函数">跳出当前函数</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">finish<br></code></pre></td></tr></table></figure><h4 id="查看变量">查看变量</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 查看某个变量：<br>p [变量名]<br><br><br># 查看当前栈帧所有变量<br>fr v<br><br><br># 切换栈帧<br>fr s [栈帧序号]<br><br><br># 打印当前线程的栈帧信息<br>bt<br><br><br># 打印所有线程的栈帧信息<br>bt all<br></code></pre></td></tr></table></figure><p>综合案例：在 <code>demo.cpp</code> 的 17 行和 21 行设置断点，使用<code>r</code> 开始调试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cmd">* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint <span class="hljs-number">1</span>.<span class="hljs-number">1</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d80 a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span><br>   <span class="hljs-number">14</span>  <br>   <span class="hljs-number">15</span>   int main() &#123;<br>   <span class="hljs-number">16</span>  <br>-&gt; <span class="hljs-number">17</span>       int x = <span class="hljs-number">2</span>;<br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step <span class="hljs-keyword">in</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d88 a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">18</span>:<span class="hljs-number">9</span><br>   <span class="hljs-number">15</span>   int main() &#123;<br>   <span class="hljs-number">16</span>  <br>   <span class="hljs-number">17</span>       int x = <span class="hljs-number">2</span>;<br>-&gt; <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>   <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step <span class="hljs-keyword">in</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d8c a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">19</span>:<span class="hljs-number">13</span><br>   <span class="hljs-number">16</span>  <br>   <span class="hljs-number">17</span>       int x = <span class="hljs-number">2</span>;<br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>-&gt; <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>   <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>   <span class="hljs-number">22</span>  <br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint <span class="hljs-number">2</span>.<span class="hljs-number">1</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d9c a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span><br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>-&gt; <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>   <span class="hljs-number">22</span>  <br>   <span class="hljs-number">23</span>       return <span class="hljs-number">0</span>;<br>   <span class="hljs-number">24</span>   &#125;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) fr v<br>(int) x = <span class="hljs-number">2</span><br>(int) y = <span class="hljs-number">3</span><br>(int) z = <span class="hljs-number">5</span><br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step <span class="hljs-keyword">in</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d18 a.out`fact(n=<span class="hljs-number">5</span>) <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">6</span>:<span class="hljs-number">9</span><br>   <span class="hljs-number">3</span>    using namespace std;<br>   <span class="hljs-number">4</span>   <br>   <span class="hljs-number">5</span>    int fact(int n) &#123;<br>-&gt; <span class="hljs-number">6</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-number">7</span>            return <span class="hljs-number">1</span>;<br>   <span class="hljs-number">8</span>        &#125;<br>   <span class="hljs-number">9</span>        <span class="hljs-keyword">else</span> &#123;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) finish<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step out<br>Return value: (int) $<span class="hljs-number">0</span> = <span class="hljs-number">120</span><br><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003da4 a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">13</span><br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>-&gt; <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>   <span class="hljs-number">22</span>  <br>   <span class="hljs-number">23</span>       return <span class="hljs-number">0</span>;<br>   <span class="hljs-number">24</span>   &#125;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) c<br>Process <span class="hljs-number">31435</span> resuming<br><span class="hljs-number">120</span><br>Process <span class="hljs-number">31435</span> exited with status = <span class="hljs-number">0</span> (<span class="hljs-number">0</span>x00000000)<br></code></pre></td></tr></table></figure><h4 id="结束调试">结束调试</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">q<br></code></pre></td></tr></table></figure><blockquote><p>输入 <code>quit</code> 或者 <code>q</code> 结束 LLDB 调试</p></blockquote><p><strong>以上就是对 LLDB 的一个简单介绍了，如果想了解更多 LLDB指令，可以查看官网的 <a href="https://lldb.llvm.org/use/map.html">LLDBcommand map</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>调试器</tag>
      
      <tag>LLDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 脚手架配置代理的方法</title>
    <link href="/2023/02/07/React%20%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/02/07/React%20%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="方法一直接在-package.json-中追加配置">方法一：直接在<code>package.json</code> 中追加配置</h4><p>例如，当前服务器端口为 3000，若要向端口 5000的服务器发送请求，我们可以在 <code>package.json</code>中添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:5000&quot;</span><br></code></pre></td></tr></table></figure><p>此后，当请求了 3000 端口不存在的资源时，那么请求就会转发给 5000端口。</p><p>示例：</p><p>例如一个 <code>create-react-app</code> 创建项目在 3001端口运行，我们使用 <code>json-server</code> 模拟了一个 3000端口的服务器，其中 JSON 数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;students&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0001&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Tom&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0002&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jack&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">19</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0003&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Frank&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>students</code> 数据的 URL 为<code>http://localhost:3000/students</code>，若我们要向 3001 端口发送GET 请求来获取 <code>students</code> 的 JSON 数据，则可以在<code>package.json</code> 中添加配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:3000&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>获取 3001 端口有的资源：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br><br>  getInfo = <span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:3001/index.html&quot;</span>).<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>      &#125;<br>    );<br>  &#125;<br><br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.getInfo&#125;</span>&gt;</span>点击发送请求获取数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时控制台输出当前项目下的 <code>index.html</code> 文件：</p><p><left><img src="https://p.ipic.vip/vyhdeu.png" alt="image-20230207230919387" style="zoom: 33%;" /></left></p></li><li><p>获取 3001 端口没有而 3000 端口有的资源：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br><br>  getInfo = <span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:3001/students&quot;</span>).<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>      &#125;<br>    );<br>  &#125;<br><br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.getInfo&#125;</span>&gt;</span>点击发送请求获取数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时控制台输出 3000 端口下的 <code>students</code> 数据：</p><p><left><img src="https://p.ipic.vip/hxjhru.png" alt="image-20230207231130393" style="zoom:50%;" /></left></p></li><li><p>若获取的资源 3001 端口和 3000端口都没有，则控制台会报错。</p></li></ul><blockquote><p>方法一优缺点：</p><ul><li>优点：配置简单，前端请求资源时可以不加任何前缀</li><li>缺点：不能配置多个代理</li></ul></blockquote><h4 id="方法二创建-setupproxy.js-文件">方法二：创建<code>setupProxy.js</code> 文件</h4><ol type="1"><li><p>首先在 src 目录下创建 <code>setupProxy.js</code> 文件</p></li><li><p>编写 <code>setupProxy.js</code> 配置具体代码规范：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 配置端口 8000 和端口 5001 的服务器代理</span><br><span class="hljs-comment">// setupProxy.js</span><br><br><span class="hljs-keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><span class="hljs-comment">// 引入内置模块: HTTP 代理中间件</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">app</span>) &#123;<br>    <span class="hljs-comment">// app 为服务对象</span><br>    app.<span class="hljs-title function_">use</span>(<br>        <span class="hljs-title function_">createProxyMiddleware</span>(<span class="hljs-string">&#x27;/api1&#x27;</span>, &#123;<span class="hljs-comment">// 遇见 /api1 前缀的请求，就会触发该代理</span><br>            <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8000&#x27;</span>,<span class="hljs-comment">// 请求转发的端口地址</span><br>            <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 控制服务器收到响应头中 Host 字段的值</span><br>            <span class="hljs-attr">pathRewrite</span>: &#123;<br>                <span class="hljs-string">&#x27;^/api1&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">// 去除请求前缀，保证交给后台服务器的是正常请求地址</span><br>            &#125;<br>        &#125;)<br>    );<br>    <br>    app.<span class="hljs-title function_">use</span>(<br>        <span class="hljs-title function_">createProxyMiddleware</span>(<span class="hljs-string">&#x27;/api2&#x27;</span>, &#123;<br>            <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>,<br>            <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">pathRewrite</span>: &#123;<br>                <span class="hljs-string">&#x27;^/api2&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>            &#125;<br>        &#125;)<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>http-proxy-middleware</code> 1.x 版本后配置代理使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br></code></pre></td></tr></table></figure><p>此前使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>向不同端口发送请求的方法：</p><ul><li><p>如果要向 8000 端口发送请求，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/api1/teachers&#x27;</span>).<span class="hljs-title function_">then</span>(<br>  <span class="hljs-comment">// ...</span><br>);<br></code></pre></td></tr></table></figure></li><li><p>如果要向 5001 端口发送请求，同理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/api2/students&#x27;</span>).<span class="hljs-title function_">then</span>(<br><span class="hljs-comment">// ...</span><br>);<br></code></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>方法二优缺点：</p><ul><li>优点：可以配置多个代理，可以更加灵活地控制是否走代理请求</li><li>缺点：配置繁琐，前端发送代理请求时必须加前缀</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

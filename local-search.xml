<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CodeTon Round_5 总结</title>
    <link href="/2023/06/28/CodeTon%20Round_5%20%E6%80%BB%E7%BB%93/"/>
    <url>/2023/06/28/CodeTon%20Round_5%20%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p><a href="https://codeforces.com/contest/1842">比赛链接</a></p><p>这一场打得一般，因为太困了。😢</p><hr /><h4 id="a-tenzing-and-tsondu">A 「Tenzing and Tsondu」</h4><p>水题，易证总和高的人必胜，总和相等则平局。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(1)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    i64 sum_1 = <span class="hljs-number">0</span>, sum_2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; x;<br>        sum_1 += x;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, x; i &lt; m; i++) &#123;<br>        std::cin &gt;&gt; x;<br>        sum_2 += x;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (sum_1 &gt; sum_2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Tsondu\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sum_1 &lt; sum_2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Tenzing\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Draw\n&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="b-tenzing-and-books">B 「Tenzing and Books」</h4><p>根据题意，如果某本书的 <code>knowledge</code> 某个 bit 位为 1 而<code>x</code> 在该位为 0，即满足 <code>knowledge &amp; ~x</code> 非0，则该书一定不能选取，根据栈的性质，该书以下的书也不能选取。</p><p>而或运算对于 3个栈的操作顺序本身而言没有影响，所以我们依次遍历每个栈即可，如果遍历过程中出现不能选择的书，那么就结束该轮循环，进入下一个栈，3轮循环中如果出现某个状态等于 <code>x</code> ，则说明可以使得<code>knowledge</code> 的值等于 <code>x</code> ，若 3轮循环结束后都没有得到目标答案，则说明无法使得 <code>knowledge</code>的值等于 <code>x</code> 。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 100005</span><br><br><span class="hljs-type">int</span> stk[<span class="hljs-number">3</span>][MAX_N];<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, x;<br>    std::cin &gt;&gt; n &gt;&gt; x;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            std::cin &gt;&gt; stk[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> mask = ~x, ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">if</span> (stk[i][j] &amp; mask) <span class="hljs-keyword">break</span>;<br>            ans |= stk[i][j];<br>            <span class="hljs-keyword">if</span> (ans == x) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;Yes\n&quot;</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;No\n&quot;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="c-tenzing-and-balls">C 「Tenzing and Balls」</h4><p>若存在 <span class="math inline">\(i、 j、 m、 n\)</span> 使得 <spanclass="math inline">\(a_i = a_j\)</span> 且 <spanclass="math inline">\(a_m = a_n\)</span> ，则考虑区间 <spanclass="math inline">\([i, j]\)</span> 和 <span class="math inline">\([m,n]\)</span> ：</p><ul><li>若两个区间无交集，则两个区间都可以删除且互不影响；</li><li>若两个区间是包含关系，不妨设 <span class="math inline">\([i, j]\subsetneq [m, n]\)</span>，则 <span class="math inline">\([i,j]\)</span> 只能在 <span class="math inline">\([m, n]\)</span>之前删除，而删除 <span class="math inline">\([i, j]\)</span> 再删除<span class="math inline">\([m, n]\)</span> 与直接删除 <spanclass="math inline">\([m, n]\)</span> 的效果是一样的；</li><li>若两个区间相交且不为包含关系，则只能删除其中一个区间。</li></ul><p>综上所述，问题就变成了如何选取不相交的区间，使得选取的区间总长度最长。</p><p>我们假设 <span class="math inline">\(dp[i]\)</span> 表示区间 <spanclass="math inline">\([0, i]\)</span> 删除完后剩下来的数的最小值，<spanclass="math inline">\(dp[0]\)</span> 初始化为1，我们可以得到以下关系：</p><ul><li>若不删除 <span class="math inline">\(a_i\)</span> ，则 <spanclass="math inline">\(dp[i] = dp[i - 1] + 1\)</span></li><li>若能删除 <span class="math inline">\(a_i\)</span> ，则 <spanclass="math inline">\(dp[i] = \underset{j}{min}\ \{dp[j]\ |\ j &lt; i -1 \land a_{j + 1} = a_i \}\)</span></li></ul><p>于是，我们就得到了状态转移方程：<span class="math inline">\(dp[i] =min\{dp[i - 1] + 1,\ \underset{j}{min}\ \{dp[j]\ |\ j &lt; i - 1 \landa_{j + 1} = a_i \}\)</span></p><p>而对于 <span class="math inline">\(\underset{j}{min}\ \{dp[j]\ |\ j&lt; i - 1 \land a_{j + 1} = a_i \}\)</span>这一项，我们考虑使用一个数组更新每轮迭代后满足 <spanclass="math inline">\(a_{j + 1} = a_i\)</span> 的最小 <spanclass="math inline">\(dp[j]\)</span> 的值即可。迭代完后 <spanclass="math inline">\(n - dp[n - 1]\)</span> 即为可删除的最大数量。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p><p>空间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_N 200005</span><br><br><span class="hljs-type">int</span> arr[MAX_N];<br><span class="hljs-type">int</span> dp[MAX_N]; <span class="hljs-comment">// 最少剩多少个</span><br><span class="hljs-type">int</span> memo[MAX_N]; <span class="hljs-comment">// memo[t] 表示满足 arr[j + 1] == t 的所有数里面 dp[j] 的最小值</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    std::cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        std::cin &gt;&gt; arr[i];<br>        dp[i] = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">memset</span>(memo + <span class="hljs-number">1</span>, <span class="hljs-number">0x7f</span>, n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    memo[arr[<span class="hljs-number">0</span>]] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        dp[i] = std::<span class="hljs-built_in">min</span>(dp[i - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>, memo[arr[i]]);<br>        memo[arr[i]] = std::<span class="hljs-built_in">min</span>(memo[arr[i]], dp[i - <span class="hljs-number">1</span>]);<br>    &#125;<br><br>    std::cout &lt;&lt; n - dp[n - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        <span class="hljs-built_in">solve</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="d-tenzing-and-his-animal-friends">D 「Tenzing and His AnimalFriends」</h4><p>题目有点抽象，大概就是说全部轮游戏中 <spanclass="math inline">\(u_i\)</span> 和 <spanclass="math inline">\(v_i\)</span> 的分开游戏时间总和均不超过 <spanclass="math inline">\(y_i\)</span>，即 <spanclass="math inline">\(u_i\)</span> 不和 <spanclass="math inline">\(v_i\)</span> 玩的游玩时间不超过 <spanclass="math inline">\(y_i\)</span> ，对 <spanclass="math inline">\(v_i\)</span> 也是同理。于此同时，顶点 1每轮游戏都要参加，顶点 n 每轮游戏都不能参加。</p><p>我们接下来将所有的限制看成一个无向图，若存在限制 <spanclass="math inline">\((u_i, v_i, y_i)\)</span>，那么就在顶点 <spanclass="math inline">\(u_i\)</span> 和 <spanclass="math inline">\(v_i\)</span> 之间连接一条权重为 <spanclass="math inline">\(y_i\)</span> 的边。</p><p>考虑以下两种情况：</p><ul><li><p>若顶点 1 无法在有限步内到顶点 n，就说明顶点 1 和顶点 n属于不同的分支，那我们每次可以和顶点 1所在分支全部顶点一起玩，且没有时间限制。此时答案为 <code>inf</code>。</p></li><li><p>若顶点 1 可以到达顶点 n，我们假设其中一条路径为 <spanclass="math inline">\(&lt;1, k_1, k_2, ..., k_m, n&gt;\)</span>，每个顶点的游玩时间为 <span class="math inline">\(t_1, t_{k_1},t_{k_2}, ..., t_{k_m}, t_n\)</span>。</p><p>因为顶点 1 每轮游戏都参与，所以<strong>顶点 1游玩的时间就是总的游戏时间</strong>，因此我们只要求出 <spanclass="math inline">\(t_1\)</span> 的最小值即可。</p><p>由于一对顶点 <span class="math inline">\((x, y)\)</span>分开的时间不超过 <span class="math inline">\(d(x,y)\)</span>，我们可以得到：<span class="math inline">\(t_x - t_y \leqd(x, y)\)</span>。</p><p>所以有： <span class="math display">\[  \begin{array}{}  t_1 - t_{k_1} \leq d(1, k_1) \\  t_{k_1} - t_{k_2} \leq d(k_1, k_2) \\  ... \\  t_{k_m} - t_{n} \leq d(k_m, n)  \end{array}  \]</span> 将上式求和： <span class="math display">\[  \implies t_1 - t_n \leq d(1, k_1) + d(k_1, k_2) + ... + d(k_m, n)  \]</span> 又因为顶点 n 不参与游戏，所以 <spanclass="math inline">\(t_n = 0\)</span>，综上所述： <spanclass="math display">\[  t_1 \leq d(1, k_1) + d(k_1, k_2) + ... + d(k_m, n)  \]</span> 右式其实就是顶点 1 到顶点 n的路径长度，换言之，<strong>游戏的时长必须小于等于所有顶点 1 到顶点 n的路径长度</strong>。所以我们只要求出顶点 1 到顶点 n到最短路径即可，考虑最小堆优化的 Dijkstra算法，并用一个数组记录每次出队列的顶点。</p><blockquote><p>时间复杂度：<span class="math inline">\(O(mlog(m + n))\)</span></p><p>空间复杂度：<span class="math inline">\(O(n + m)\)</span></p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span></span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    std::vector&lt;std::vector&lt;std::pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, u, v, y; i &lt; m; i++) &#123;<br>        std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; y;<br>        u--;<br>        v--;<br>        g[u].<span class="hljs-built_in">push_back</span>(&#123;v, y&#125;);<br>        g[v].<span class="hljs-built_in">push_back</span>(&#123;u, y&#125;);<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;i64&gt; <span class="hljs-title">dist</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    std::priority_queue&lt;std::pair&lt;i64, <span class="hljs-type">int</span>&gt;, std::vector&lt;std::pair&lt;i64, <span class="hljs-type">int</span>&gt;&gt;, std::greater&lt;&gt;&gt; q;<br>    q.<span class="hljs-built_in">push</span>(&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;);<br>    std::vector&lt;i64&gt; ans;<br>    <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, to] = q.<span class="hljs-built_in">top</span>();<br>        q.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (dist[to] != <span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;<br>        dist[to] = d;<br>        ans.<span class="hljs-built_in">push_back</span>(to);<br>        <span class="hljs-keyword">if</span> (to == n - <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [nxt, w] : g[to]) &#123;<br>            q.<span class="hljs-built_in">push</span>(&#123;d + w, nxt&#125;);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (dist[n - <span class="hljs-number">1</span>] == <span class="hljs-number">-1</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;inf\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    std::cout &lt;&lt; dist[n - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-function">std::string <span class="hljs-title">s</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;0&#x27;</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, len = ans.<span class="hljs-built_in">size</span>(); i &lt; len; i++) &#123;<br>        s[ans[i - <span class="hljs-number">1</span>]] = <span class="hljs-string">&#x27;1&#x27;</span>;<br>        std::cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; dist[ans[i]] - dist[ans[i - <span class="hljs-number">1</span>]] &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br><br>    <span class="hljs-built_in">solve</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>ACM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Codeforces</tag>
      
      <tag>Div.1</tag>
      
      <tag>Div.2</tag>
      
      <tag>DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二进制集合与状压 DP</title>
    <link href="/2023/06/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%9B%86%E5%90%88%E4%B8%8E%E7%8A%B6%E5%8E%8B%20DP/"/>
    <url>/2023/06/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E9%9B%86%E5%90%88%E4%B8%8E%E7%8A%B6%E5%8E%8B%20DP/</url>
    
    <content type="html"><![CDATA[<h3 id="二进制集合">二进制集合</h3><h4 id="二进制集合介绍">二进制集合介绍</h4><p>利用计算机存储数据的特点，我们可以用二进制数来表示集合。</p><p>设一个集合有 n 个元素，则可以使用一个 n bit的数来表示该集合的所有子集，若该数字第 k 个 bit 位为1，表示存在该元素，为 0 则说明不存在该元素。</p><p>例如，有集合：<span class="math inline">\(U = \{0, 1, 2,3\}\)</span>，则 <u>1111</u> 表示全集 <spanclass="math inline">\(U\)</span>，<u>0000</u> 表示空集 <spanclass="math inline">\(\emptyset\)</span>，<u>1010</u> 表示子集 <spanclass="math inline">\(\{1, 3\}\)</span>。</p><p>一般情况下，若要表示的集合元素数量较少，可以直接使用 <code>int</code>或者 <code>long long</code> 整数来表示，若集合元素的数量大于64，则可以考虑使用 C++ 中的 <code>std::bitset</code>来表示，可以参考笔者之前的文章：<ahref="https://goer17.github.io/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/">std::bitset讲解</a> 。</p><h4 id="二进制集合的运算">二进制集合的运算</h4><p>设有集合 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> ，它们的二进制表示分别为 <code>a</code>和 <code>b</code> ，则常见的集合运算规则如下：</p><table><thead><tr class="header"><th>一元运算</th><th>数学表示</th><th>二进制集合表示</th></tr></thead><tbody><tr class="odd"><td>集合的阶</td><td><span class="math inline">\(|A|\)</span></td><td><code>__builtin_popcount(a)</code>（<code>a</code> 为<code>int</code> 类）<br><code>__builtin_popcount(a)</code>（<code>a</code> 为 <code>long long</code>类）<br><code>a.count()</code> （<code>a</code> 为<code>std::bitset</code> 类）</td></tr><tr class="even"><td>补集</td><td><span class="math inline">\(\overline{A}\)</span></td><td><code>~a</code></td></tr></tbody></table><table><thead><tr class="header"><th>二元运算</th><th>数学表示</th><th>二进制集合表示</th></tr></thead><tbody><tr class="odd"><td>集合并</td><td><span class="math inline">\(A \cup B\)</span></td><td><code>a | b</code></td></tr><tr class="even"><td>集合交</td><td><span class="math inline">\(A \cap B\)</span></td><td><code>a &amp; b</code></td></tr><tr class="odd"><td>集合差</td><td><span class="math inline">\(A - B\)</span></td><td><code>a &amp; ~b</code></td></tr></tbody></table><h4 id="二进制集合子集的遍历">二进制集合子集的遍历</h4><p>若集合 <span class="math inline">\(X\)</span> 的二进制表示为<code>x</code> ，则逆序遍历 <span class="math inline">\(X\)</span>的非空子集的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> sub = x; sub; sub = (sub - <span class="hljs-number">1</span>) &amp; x) &#123;<br>    <span class="hljs-comment">// s 为 x 的子集</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="状态压缩-dp">状态压缩 DP</h3><p>状态压缩 DP是一种在动态规划算法中使用的优化技巧。它主要应用于具有指数级别状态数的问题，通过将状态用一个整数表示，从而减少内存空间的使用和提高计算效率。这里所说的用一个整数表示状态，也就是上文提到的二进制集合。</p><p><strong>示例</strong></p><p><ahref="https://leetcode.cn/problems/minimum-cost-to-connect-two-groups-of-points/">连通两组点的最小成本</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connectTwoGroups</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; cost)</span> </span>&#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x3f3f3f3f</span>;<br>        <span class="hljs-type">int</span> size_1 = cost.<span class="hljs-built_in">size</span>(), size_2 = cost[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-type">int</span> stateNumber = <span class="hljs-number">1</span> &lt;&lt; size_2;<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(size_1 + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(stateNumber, inf));<br>        dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= size_1; i++) &#123;<br>            <span class="hljs-comment">// 前 i 个点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>; s &lt; stateNumber; s++) &#123;<br>                <span class="hljs-comment">// s 表示状态</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; size_2; k++) &#123;<br>                    <span class="hljs-keyword">if</span> ((s &amp; (<span class="hljs-number">1</span> &lt;&lt; k)) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// k 不属于 s</span><br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    dp[i][s] = <span class="hljs-built_in">min</span>(dp[i][s], dp[i][s ^ (<span class="hljs-number">1</span> &lt;&lt; k)] + cost[i - <span class="hljs-number">1</span>][k]);<br>                    dp[i][s] = <span class="hljs-built_in">min</span>(dp[i][s], dp[i - <span class="hljs-number">1</span>][s] + cost[i - <span class="hljs-number">1</span>][k]);<br>                    dp[i][s] = <span class="hljs-built_in">min</span>(dp[i][s], dp[i - <span class="hljs-number">1</span>][s ^ (<span class="hljs-number">1</span> &lt;&lt; k)] + cost[i - <span class="hljs-number">1</span>][k]);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> dp[size_1][stateNumber - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
      <tag>C++</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 介绍</title>
    <link href="/2023/06/17/CMake%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/06/17/CMake%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="cmake-简介">CMake 简介</h3><p>CMake 是一个跨平台的构建工具，用于管理和构建 C++项目。它的设计目标是提供一种简化的构建过程，使开发人员能够在不同的操作系统和编译器上轻松地生成可执行文件、库和其他构建目标。</p><p>CMake的主要思想是通过描述项目的构建过程来生成构建系统所需的构建脚本。它使用一种称为<code>CMakeLists.txt</code>的文本文件来定义项目的目录结构、源文件、编译选项、依赖项和构建规则。CMake具有很好的跨平台性，可以在多种操作系统上使用，包括 Windows、Linux、macOS等。它可以生成不同的构建系统文件，如 Makefile、Ninja、Visual Studio解决方案等，从而使开发人员能够在不同的开发环境中使用适合的构建系统。</p><p>总而言之，CMake 简化了跨平台 C++项目的构建过程，使开发人员能够更轻松地管理项目的编译和构建，同时提供了灵活性和可扩展性来处理复杂的项目结构和依赖关系。</p><p>学习 CMake 的目的，是为将来<strong>处理大型的 C / C++ / Java项目</strong>做准备。</p><h4 id="cmake-安装">CMake 安装</h4><p>绝大多数 Linux 系统已经安装了 CMake，没有安装的话可以去 <ahref="http://www.cmake.org/HTML/Download.html">CMake 官网</a>进行安装。</p><p>MacOS 也可以用 Homebrew 进行快速安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install cmake<br></code></pre></td></tr></table></figure><h3 id="构建-cmake-项目">构建 CMake 项目</h3><p>构建 CMake 项目，大致分为 3 个步骤：</p><ol type="1"><li>创建 <code>CMakeLists.txt</code> 文件</li><li>使用 <code>CMake</code> 指令生成 <code>Makefile</code> 文件</li><li>使用 <code>make</code> 指令进行编译</li></ol><h4 id="一个简单示例">一个简单示例</h4><ul><li><p>创建一个 <code>demo.cpp</code> ：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello world!\n&quot;</span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>同级目录下创建一个 <code>CMakeLists.txt</code>文件，输入以下文本：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(HELLO)<br><br><span class="hljs-keyword">SET</span>(SRC_LIST demo.cpp)<br><br><span class="hljs-keyword">MESSAGE</span>(STUTAS <span class="hljs-string">&quot;Configuring project...&quot;</span>)<br><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(Demo <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>终端下使用 <code>cmake</code> 指令生成 <code>Makefile</code>文件：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake .<br></code></pre></td></tr></table></figure></p><p>若运行成功，则目录下会生成 <code>Makefile</code> 文件。</p></li><li><p>使用 <code>make</code> 指令进行编译：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br></code></pre></td></tr></table></figure></p><p>编译成功，则会生成可执行文件 <code>Demo</code> 。</p></li><li><p>运行 <code>Demo</code> 即可：</p><p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./Demo<br></code></pre></td></tr></table></figure></p></li></ul><h4 id="cmakelists.txt-基本语法介绍"><code>CMakeLists.txt</code>基本语法介绍</h4><h5 id="project-关键字"><code>PROJECT</code> 关键字</h5><p><code>PROJECT</code>关键字用于定义和配置项目。它用于指定项目的名称、版本号和语言。。</p><p>PROJECT关键字的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(&lt;project_name&gt; [VERSION &lt;version&gt;] [LANGUAGES &lt;languages&gt;])<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;project_name&gt;</code>是要定义的项目名称。<code>&lt;version&gt;</code>是可选的，用于指定项目的版本号。 <code>&lt;languages&gt;</code>也是可选的，用于指定项目所使用的编程语言。</p><p>以下是一些 <code>PROJECT</code> 关键字的示例用法：</p><ol type="1"><li><p>定义一个简单的项目：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(MyProject)<br></code></pre></td></tr></table></figure></p></li><li><p>定义一个带有版本号的项目：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(MyProject VERSION <span class="hljs-number">1.0</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>定义一个使用多种编程语言的项目：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(MyProject LANGUAGES CXX C)<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="set-关键字"><code>SET</code> 关键字</h5><p><code>SET</code> 关键字用于设置变量的值。语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(&lt;variable&gt; &lt;value&gt; [CACHE &lt;type&gt; &lt;docstring&gt; [FORCE]])<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;variable&gt;</code>是要设置的变量名，<code>&lt;value&gt;</code>是要为变量设置的值。<code>&lt;value&gt;</code>可以是一个字符串、一个列表、一个布尔值或一个数值。SET关键字还支持一些其他选项：</p><ul><li><code>CACHE</code>：指定变量为缓存变量，即用户可以通过CMake的缓存机制进行设置或修改该变量的值。缓存变量的值可以在CMake运行期间持久保存，并在下一次运行时保持不变。</li><li><code>&lt;type&gt;</code>：指定缓存变量的类型。可以是BOOL、STRING、PATH等类型。</li><li><code>&lt;docstring&gt;</code>：可选项，用于提供变量的描述文本。</li><li><code>FORCE</code>：可选项，强制设置变量的值，即使它已经被缓存。</li></ul><p>以下是一些 <code>SET</code> 关键字的示例用法：</p><ol type="1"><li><p>设置一个字符串变量： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(my_string <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>设置一个列表变量： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(my_list <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>设置一个缓存变量： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(my_variable <span class="hljs-string">&quot;default value&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;Description of my variable&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>强制设置一个缓存变量的值： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(my_variable <span class="hljs-string">&quot;new value&quot;</span> CACHE <span class="hljs-keyword">STRING</span> <span class="hljs-string">&quot;Description of my variable&quot;</span> FORCE)<br></code></pre></td></tr></table></figure></p></li></ol><p>通过 <code>SET</code> 关键字，你可以在 CMake脚本中设置变量的值，并根据需要使用它们来控制构建过程、传递参数或处理其他逻辑。</p><p>变量取值：使用 <code>$&#123;&#125;</code> ，但是在 <code>IF</code>控制语句中直接使用变量名。</p><h5 id="message-关键字"><code>MESSAGE</code> 关键字</h5><p>在 CMake 中，<code>MESSAGE</code>是一个用于输出消息的关键字。它允许你在 CMake脚本中打印信息，以便在构建过程中向用户提供有用的反馈或调试信息。</p><p>MESSAGE关键字的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">MESSAGE</span>([&lt;mode&gt;] <span class="hljs-string">&quot;&lt;message&gt;&quot;</span>)<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;mode&gt;</code>是可选的，用于指定消息的模式。常用的消息模式有以下几种：</p><ul><li><code>STATUS</code> ：以普通状态的形式输出消息。</li><li><code>WARNING</code> ：以警告的形式输出消息。</li><li><code>AUTHOR_WARNING</code> ：以作者警告的形式输出消息。</li><li><code>SEND_ERROR</code> ：以错误的形式输出消息，并终止 CMake的配置过程。</li><li><code>FATAL_ERROR</code> ：以致命错误的形式输出消息，并终止 CMake的配置过程。</li></ul><p><code>&lt;message&gt;</code>是要输出的消息内容，可以是一个字符串或一个变量。</p><p>以下是一些MESSAGE关键字的示例用法：</p><ol type="1"><li><p>输出普通状态消息： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">MESSAGE</span>(STATUS <span class="hljs-string">&quot;Configuring project...&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>输出警告消息： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">MESSAGE</span>(WARNING <span class="hljs-string">&quot;Warning: Invalid configuration detected.&quot;</span>)<br></code></pre></td></tr></table></figure></p></li><li><p>输出错误消息并终止配置过程： <figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">MESSAGE</span>(SEND_ERROR <span class="hljs-string">&quot;Error: Required library not found.&quot;</span>)<br></code></pre></td></tr></table></figure></p></li></ol><h5 id="add_executable-关键字"><code>ADD_EXECUTABLE</code> 关键字</h5><p>在 CMake 中，<code>ADD_EXECUTABLE</code>是一个用于添加可执行文件的关键字。它用于指定要构建的可执行文件的名称和源代码文件。</p><p><code>ADD_EXECUTABLE</code> 关键字的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_EXECUTABLE</span>(&lt;executable_name&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] source1 [source2 ...])<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;executable_name&gt;</code>是要生成的可执行文件的名称。<code>[WIN32]</code> 和<code>[MACOSX_BUNDLE]</code> 是可选的标志，用于指定在 Windows 上构建一个GUI 应用程序或在 macOS上构建一个应用程序捆绑包。<code>[EXCLUDE_FROM_ALL]</code>也是可选的标志，表示该目标不会被默认构建，除非明确要求。</p><p><code>source1 [source2 ...]</code>是要包含在可执行文件中的源代码文件的列表。可以通过相对或绝对路径指定这些源文件。</p><p>以下是 <code>ADD_EXECUTABLE</code> 关键字的示例用法：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_EXECUTABLE</span>(MyApp main.cpp utils.cpp)<br></code></pre></td></tr></table></figure><p>上述示例将创建一个名为 <code>MyApp</code> 的可执行文件，并将<code>main.cpp</code> 和 <code>utils.cpp</code>作为源代码文件包含在可执行文件中。</p><p>使用 <code>ADD_EXECUTABLE</code> 关键字时，CMake会自动检测源代码文件的编程语言，并相应地设置编译器和编译选项。</p><p><code>ADD_EXECUTABLE</code>关键字允许你定义项目中的可执行文件，并指定与之相关的源代码文件。通过<code>ADD_EXECUTABLE</code>，你可以将源代码文件与特定的可执行文件关联起来，以便在构建过程中生成所需的可执行文件。</p><h5 id="add_subdirectory-关键字"><code>ADD_SUBDIRECTORY</code>关键字</h5><p><code>ADD_SUBDIRECTORY</code> 是用于向 CMake构建系统添加子目录的关键字。它的作用是告诉 CMake在当前项目中包含另一个目录，并在该子目录中查找并处理另一个<code>CMakeLists.txt</code> 文件。</p><p><code>ADD_SUBDIRECTORY</code> 的语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(directory [binary_dir] [EXCLUDE_FROM_ALL])<br></code></pre></td></tr></table></figure><ul><li><code>directory</code>：要添加的子目录的路径。这个路径可以是相对于当前 CMakeLists.txt文件的相对路径，也可以是绝对路径。</li><li><code>binary_dir</code>（可选）：指定生成的二进制文件的输出目录。如果不提供，则使用默认值（通常是当前构建目录）。</li><li><code>EXCLUDE_FROM_ALL</code>（可选）：如果指定了这个选项，将会在构建目标时排除这个子目录。这对于包含一些可选的或不常用的子项目很有用。</li></ul><p>使用 <code>ADD_SUBDIRECTORY</code> 时，CMake 会进入子目录并处理对应的<code>CMakeLists.txt</code>文件。这意味着子目录中可以有自己的构建规则、目标等。通过使用<code>ADD_SUBDIRECTORY</code>，可以将复杂的项目划分为多个子项目，并使用各自的CMakeLists.txt 文件进行管理，从而提高项目的组织性和可维护性。</p><p>请注意，在使用 <code>ADD_SUBDIRECTORY</code>之前，通常需要在子目录中准备一个有效的 CMakeLists.txt文件，以定义子项目的构建规则、目标等。</p><p>以下是一个示例，展示如何使用 <code>ADD_SUBDIRECTORY</code>：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 主项目的 CMakeLists.txt</span><br><br><span class="hljs-comment"># 添加子目录</span><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(subdir)<br><br><span class="hljs-comment"># 主项目的构建规则和目标</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 子目录的 CMakeLists.txt</span><br><br><span class="hljs-comment"># 子目录的构建规则和目标</span><br><span class="hljs-comment"># ...</span><br></code></pre></td></tr></table></figure><p>上述示例中，主项目的 <code>CMakeLists.txt</code> 文件使用<code>ADD_SUBDIRECTORY</code> 添加了一个名为 "subdir"的子目录。然后，CMake 进入子目录并处理对应的 CMakeLists.txt文件，执行子目录的构建规则和目标的设置。</p><p>通过使用 <code>ADD_SUBDIRECTORY</code>，你可以将项目组织成多个子目录，每个子目录都可以有自己的<code>CMakeLists.txt</code> 文件，方便地管理和构建大型项目。</p><h5 id="install-关键字"><code>INSTALL</code> 关键字</h5><p><code>INSTALL</code>用于定义要安装的文件、目录和相关设置。它用于在构建过程中指定将生成的文件复制到特定位置的规则。</p><p><code>INSTALL</code> 关键字的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">INSTALL</span>([CODE &lt;code&gt;]<br>        [SCRIPT &lt;<span class="hljs-keyword">file</span>&gt;]<br>        [SCRIPTS &lt;files&gt;...]<br>        [FILES &lt;files&gt;...]<br>        [PROGRAMS &lt;files&gt;...]<br>        [DIRECTORY &lt;dir&gt;...]<br>        [TARGETS &lt;targets&gt;...]<br>        [<span class="hljs-keyword">EXPORT</span> &lt;<span class="hljs-keyword">export</span>-name&gt;]<br>        [ALIAS &lt;<span class="hljs-keyword">target</span>&gt;]<br>        [FILES_MATCHING]<br>        [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]<br>         [EXCLUDE] [PERMISSIONS permissions...]<br>         [CONFIGURATIONS [Debug|Release|...]]]...<br>        [...])<br></code></pre></td></tr></table></figure><p>下面是 INSTALL 关键字的一些常用选项：</p><ul><li><code>CODE &lt;code&gt;</code> ：指定自定义安装逻辑的 CMake代码。</li><li><code>SCRIPT &lt;file&gt;</code>：指定一个脚本文件，该脚本文件包含安装逻辑。</li><li><code>SCRIPTS &lt;files&gt;...</code>：指定多个脚本文件，这些脚本文件包含安装逻辑。</li><li><code>FILES &lt;files&gt;...</code> ：指定要安装的普通文件。</li><li><code>PROGRAMS &lt;files&gt;...</code>：指定要安装的可执行文件。</li><li><code>DIRECTORY &lt;dir&gt;...</code> ：指定要安装的目录。</li><li><code>TARGETS &lt;targets&gt;...</code>：指定要安装的构建目标（可执行文件、静态库、共享库等）。</li><li><code>EXPORT &lt;export-name&gt;</code>：指定要安装的导出目标。</li><li><code>ALIAS &lt;target&gt;</code>：指定要安装的构建目标的别名。</li><li><code>FILES_MATCHING</code> ：指定在安装文件时进行匹配的模式。</li><li><code>PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;</code>：指定文件匹配的模式或正则表达式。</li><li><code>EXCLUDE</code> ：排除匹配的文件。</li><li><code>PERMISSIONS permissions...</code> ：指定安装文件的权限。</li><li><code>CONFIGURATIONS [Debug|Release|...]</code>：指定仅在特定构建配置下安装文件。</li></ul><p>INSTALL关键字允许您以灵活的方式定义文件和目录的安装规则。可以使用多个 INSTALL关键字来安装多个文件和目录。例如：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># CMakeLists.txt</span><br><br><span class="hljs-comment"># 安装脚本文件和目录</span><br><span class="hljs-keyword">INSTALL</span>(SCRIPT my_script.cmake)<br><span class="hljs-keyword">INSTALL</span>(DIRECTORY my_directory DESTINATION /path/to/destination)<br><br><span class="hljs-comment"># 安装文件</span><br><span class="hljs-keyword">INSTALL</span>(FILES file1.txt file2.txt DESTINATION /path/to/destination)<br><br><span class="hljs-comment"># 安装可执行文件</span><br><span class="hljs-keyword">INSTALL</span>(PROGRAMS my_program DESTINATION /path/to/destination)<br><br><span class="hljs-comment"># 安装构建目标</span><br><span class="hljs-keyword">INSTALL</span>(TARGETS my_target RUNTIME DESTINATION /path/to/destination)<br></code></pre></td></tr></table></figure><p>上述示例演示了如何使用 <code>INSTALL</code>关键字来指定不同类型的文件和目录的安装位置。</p><h4 id="cmake-指令"><code>cmake</code> 指令</h4><ol type="1"><li><p><code>cmake</code> 基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake [options] &lt;path-to-source&gt;<br></code></pre></td></tr></table></figure><ul><li><code>options</code>：CMake的选项，用于配置生成过程的行为和参数。</li><li><code>&lt;path-to-source&gt;</code> ：<code>CMakeLists.txt</code>所在的源代码目录路径。</li></ul></li><li><p>常用选项：</p><ul><li><code>-G &lt;generator&gt;</code>：指定生成器，用于生成特定构建系统的文件（如 Makefile 或 Visual Studio解决方案）。例如，<code>-G "Unix Makefiles"</code> 表示生成 Unix系统下的 Makefile 文件。</li><li><code>-D &lt;var&gt;=&lt;value&gt;</code> ：设置 CMake变量的值。例如，<code>-D CMAKE_BUILD_TYPE=Release</code> 设置 CMake 变量<code>CMAKE_BUILD_TYPE</code> 的值为 <code>Release</code>。</li><li><code>-B &lt;path-to-build&gt;</code>：指定构建目录的路径。生成的构建系统文件将存储在该目录中。</li><li><code>-S &lt;path-to-source&gt;</code> ：指定源代码目录的路径。</li></ul></li><li><p>示例用法：</p><ul><li>在源代码目录中直接运行CMake（in-source build）： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /path/to/source &amp;&amp; cmake .<br></code></pre></td></tr></table></figure></li><li>在指定的构建目录中运行CMake（out-of-source build）：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /path/to/build &amp;&amp; cmake /path/to/source<br></code></pre></td></tr></table></figure></li><li>指定生成器和构建类型： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cmake -G &quot;Unix Makefiles&quot; -DCMAKE_BUILD_TYPE=Release /path/to/source<br></code></pre></td></tr></table></figure></li></ul></li></ol><h4 id="make-指令"><code>make</code> 指令</h4><p>Make是一个常用的构建工具，用于自动化软件项目的编译和构建过程。它使用一个名为<code>Makefile</code>的文件来定义构建规则和依赖关系，以确定如何生成目标文件（例如可执行文件、库文件等）。</p><p>以下是 <code>make</code> 指令的基本语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">make [options] [target]<br></code></pre></td></tr></table></figure><p>其中，<code>options</code> 是可选的命令行选项，用于控制<code>make</code> 的行为。<code>target</code> 是要构建的目标，通常是在<code>Makefile</code> 中定义的一个规则。</p><p>常用的 <code>make</code> 选项包括：</p><ul><li><code>-f &lt;filename&gt;</code>：指定要使用的 <code>Makefile</code>文件的名称。如果未指定，则默认使用当前目录下的 <code>Makefile</code>文件。</li><li><code>-C &lt;dir&gt;</code>：在指定的目录下执行 <code>make</code>命令。这可以用于指定 <code>Makefile</code> 文件所在的目录。</li><li><code>-j &lt;num&gt;</code>：指定并行构建的作业数，加快构建速度。</li></ul><p>在 <code>Makefile</code>文件中，你可以定义多个目标和规则，每个规则描述了如何根据依赖关系生成目标文件。一个基本的规则结构如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">target: dependencies</span><br>    command1<br>    command2<br>    ...<br></code></pre></td></tr></table></figure><p>其中，<code>target</code> 是目标文件的名称，<code>dependencies</code>是生成目标文件所依赖的文件或目标，<code>commandX</code>是用于生成目标文件的命令。</p><p>以下是一个简单的示例 <code>Makefile</code> 文件的内容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">hello: main.c hello.c</span><br>    gcc -o hello main.c hello.c<br></code></pre></td></tr></table></figure><p>上述示例中，我们定义了一个目标 <code>hello</code>，它依赖于<code>main.c</code> 和 <code>hello.c</code>这两个源代码文件。<code>make</code>指令会检查依赖关系，并在需要时执行相应的命令来生成目标文件。</p><p>要使用 <code>make</code> 指令进行构建，只需在终端中进入包含<code>Makefile</code> 文件的目录，并运行 <code>make</code>命令。如果没有指定目标，默认会构建第一个目标。</p><blockquote><p>Make工具基于目标文件和规则之间的依赖关系，通过增量构建的方式进行构建，只重新构建已修改的文件和受其影响的文件，从而提高构建效率。Make是一个强大而灵活的构建工具，它在软件开发中广泛应用。通过定义适当的规则和依赖关系，可以自动化构建过程，简化项目的管理和部署。</p></blockquote><p>CMake 与 Make 之间的关系可以简述如下：</p><ul><li>CMake负责生成适合不同平台和编译器的构建系统文件（如Makefile）。</li><li>Make 负责根据 Makefile中的规则和依赖关系来执行实际的编译和构建操作。</li></ul><h6 id="make-install-指令"><code>make install</code> 指令</h6><p><code>make install</code>用于将构建生成的文件复制到指定位置，完成软件的安装过程。这个指令通常与<code>Makefile</code> 文件一起使用，用于定义安装规则。</p><p>在 <code>Makefile</code> 中，可以定义一个名为 <code>install</code>的目标规则，该规则包含安装过程的指令。安装指令通常使用系统的<code>cp</code> 命令或类似的工具来复制文件或目录到目标位置。</p><p>以下是一个示例 <code>Makefile</code> 文件中的 <code>install</code>规则：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">install:</span><br>    cp myapp /usr/local/bin<br>    cp -r resources /usr/local/share/myapp<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>install</code>规则中定义了两个命令。第一个命令使用 <code>cp</code> 命令将<code>myapp</code> 可执行文件复制到 <code>/usr/local/bin</code>目录下，第二个命令将 <code>resources</code> 目录递归复制到<code>/usr/local/share/myapp</code> 目录下。</p><p>要执行安装过程，可以在命令行中运行 <code>make install</code>命令。Make 将读取 Makefile 文件，并根据 <code>install</code>目标规则中定义的指令来执行安装操作。</p><p>需要注意的是，<code>make install</code>命令通常需要使用超级用户权限（sudo）来执行，因为将文件复制到系统目录通常需要管理员权限。如果没有权限，可以尝试将文件复制到用户的个人目录或其他有权限的目录。</p><p>使用 <code>make install</code>指令可以方便地自动化软件的安装过程，将生成的文件复制到指定位置，使用户可以直接使用已安装的软件。</p><h4 id="工程化目录结构">工程化目录结构</h4><p>基本目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">.<br>├─CMakeLists.txt<br>├─README.md<br>├─bulid<br>├─runhello.sh<br>├─doc<br>├─COPYRIGHT<br>├─src<br>├───CMakeLists.txt<br>└───demo.cpp<br></code></pre></td></tr></table></figure><p>每个目录下都有一个 <code>CMakeLists.txt</code> ，用于实现 CMake嵌套。</p><ul><li><p>外层 <code>CMakeLists.txt</code> ：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">PROJECT</span>(HELLO) <span class="hljs-comment"># 指定项目名称</span><br><br><span class="hljs-keyword">ADD_SUBDIRECTORY</span>(src bin) <span class="hljs-comment"># 将 src 子目录加入工程并指定编译输出路径为 bin 目录</span><br></code></pre></td></tr></table></figure></p></li><li><p>内层 <code>CMakeLists.txt</code> ：</p><p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">SET</span>(SRC_LIST demo.cpp)<br><br><span class="hljs-keyword">MESSAGE</span>(STUTAS <span class="hljs-string">&quot;Configuring project...&quot;</span>)<br><br><span class="hljs-keyword">ADD_EXECUTABLE</span>(Demo <span class="hljs-variable">$&#123;SRC_LIST&#125;</span>) <span class="hljs-comment"># 添加可执行项目</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>bulid</code>文件夹：用于存储构建过程中生成的中间文件和最终的构建结果。</p></li><li><p><code>src</code> 文件夹：用于存放源代码</p></li><li><p><code>doc</code> 文件夹：用于存放文档</p></li><li><p><code>COPYRIGHT</code> ：版权</p></li><li><p><code>runhello.sh</code> ：安装脚本</p></li></ul><h4 id="构建库">构建库</h4><h5 id="add_library-关键字"><code>ADD_LIBRARY</code> 关键字</h5><p><code>ADD_LIBRARY</code>是一个用于定义和构建库（Library）目标的关键字。它用于创建静态库（StaticLibrary）、共享库（Shared Library）或模块库（ModuleLibrary）的规则，并将源代码文件编译成库文件。</p><p>ADD_LIBRARY 关键字的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">ADD_LIBRARY</span>(&lt;name&gt; [STATIC | SHARED | MODULE]<br>            [EXCLUDE_FROM_ALL]<br>            [source1] [source2 ...])<br></code></pre></td></tr></table></figure><p>其中，<code>&lt;name&gt;</code>指定要创建的库的名称。可以使用自定义名称或者 CMake的变量作为库的名称。</p><p>选项 <code>[STATIC | SHARED | MODULE]</code>指定库的类型。可以选择其中一种类型： -<code>STATIC</code>：创建静态库。静态库在链接时被静态地链接到可执行文件中。-<code>SHARED</code>：创建共享库（也称为动态库）。共享库在运行时被动态地加载。- <code>MODULE</code>：创建模块库（适用于像 Apple 的 macOS平台）。模块库是一种特殊的共享库类型。</p><p>可选项 <code>[EXCLUDE_FROM_ALL]</code>表示将该库目标从生成的默认目标中排除。</p><p>后续的参数 <code>source1</code>、<code>source2</code>等指定库的源代码文件，可以是单个源文件，也可以是一个文件列表。CMake将编译这些源代码文件，并生成库文件。</p><p>以下是一个示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># CMakeLists.txt</span><br><br><span class="hljs-comment"># 创建静态库</span><br><span class="hljs-keyword">ADD_LIBRARY</span>(my_static_lib STATIC source1.cpp source2.cpp)<br><br><span class="hljs-comment"># 创建共享库</span><br><span class="hljs-keyword">ADD_LIBRARY</span>(my_shared_lib SHARED source3.cpp source4.cpp)<br></code></pre></td></tr></table></figure><h5 id="include_directories-关键字"><code>INCLUDE_DIRECTORIES</code>关键字</h5><p><code>INCLUDE_DIRECTORIES</code>是一个用于指定包含目录的关键字。它用于将一个目录添加到编译器的包含路径中，以使编译器能够找到所需的头文件。</p><p><code>INCLUDE_DIRECTORIES</code> 关键字的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>([AFTER|BEFORE] directory1 [directory2 ...])<br></code></pre></td></tr></table></figure><p>其中，<code>directory1</code>、<code>directory2</code>等参数指定要添加到包含路径中的目录。可以指定一个或多个目录。</p><p>选项 <code>[AFTER|BEFORE]</code>控制新目录的添加顺序。默认情况下，新目录会添加到已有包含目录列表的末尾，即在已有包含目录之后。如果指定了<code>AFTER</code> 选项，新目录将添加到列表的末尾。如果指定了<code>BEFORE</code> 选项，新目录将添加到列表的开头。</p><p>以下是一个示例：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># CMakeLists.txt</span><br><br><span class="hljs-comment"># 添加包含目录</span><br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(include_dir1 include_dir2)<br><br><span class="hljs-comment"># 添加包含目录，并将其放置在列表的开头</span><br><span class="hljs-keyword">INCLUDE_DIRECTORIES</span>(BEFORE include_dir3)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>CMake</tag>
      
      <tag>跨平台项目构建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库规范化理论</title>
    <link href="/2023/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA/"/>
    <url>/2023/05/15/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是数据库规范化">什么是数据库规范化？</h4><p><strong>数据库规范化（Normalization）</strong>是一种数据库设计技术，其旨在实现以下两个主要目标：</p><ul><li>减少数据冗余（Redundancy）。</li><li>确保数据的依赖性是有意义的，即数据存储是有逻辑的。</li></ul><h4 id="函数依赖">函数依赖</h4><h5 id="基本定义">基本定义</h5><p><strong>函数依赖（FunctionalDependncy）</strong>是规范化中的重要概念，简而言之，函数依赖用于描述<strong>属性（Attributes）</strong>之间的关系。</p><p>概念：</p><blockquote><p>若 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 是关系模式 <spanclass="math inline">\(R\)</span> 中的两个属性集合，对于给定的 <spanclass="math inline">\(A\)</span> 值，都有唯一的 <spanclass="math inline">\(B\)</span> 值与其对应，我们就称 <spanclass="math inline">\(A\)</span> 函数决定 <spanclass="math inline">\(B\)</span>，<span class="math inline">\(B\)</span>函数依赖于 <span class="math inline">\(A\)</span>，记作：<spanclass="math inline">\(A \to B\)</span>，其中 <spanclass="math inline">\(A\)</span> 称为决定因子（Determinant）</p><p>若 <span class="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 相互依赖，即二者一一对应，则记为：<spanclass="math inline">\(A\)</span> <spanclass="math inline">\(\leftrightarrow B\)</span></p></blockquote><p>例如：</p><p>在一个学生信息的关系模型 <spanclass="math inline">\(Student(\underline{s\_id}, name, gender,age)\)</span> 中，我们假设学号 <spanclass="math inline">\(s\_id\)</span> 是关系模型中的主键，则有： <spanclass="math display">\[s\_id \to name\]</span>即：唯一的学号对应唯一的姓名，因此姓名在这里是函数依赖于学号的。</p><h5 id="平凡函数依赖和非平凡函数依赖">平凡函数依赖和非平凡函数依赖</h5><p>我们从决定因子和被决定因子的集合关系角度出发可以将函数依赖分为两类：</p><ul><li><p>平凡函数依赖（Trivial Functional Dependency）：</p><p>若 <span class="math inline">\(A \to B\)</span> ，且 <spanclass="math inline">\(B \subseteq A\)</span>，则称该依赖为平凡依赖。</p></li><li><p>非平凡函数依赖（Nontrivial Functional Dependency）：</p><p>若 <span class="math inline">\(A \to B\)</span> ，且 <spanclass="math inline">\(B \not\subseteq A\)</span>，则称该依赖为非平凡依赖。</p></li></ul><h5 id="部分函数依赖和完全函数依赖">部分函数依赖和完全函数依赖</h5><p>同时，我们从决定因子属性的必要性又可以将函数依赖分为两类：</p><ul><li><p>部分函数依赖（Partial Functional Dependency）：</p><p>若 <span class="math inline">\(A \to B\)</span> ，且存在 <spanclass="math inline">\(A\)</span> 的真子集 <spanclass="math inline">\(X\)</span> ，使得 <span class="math inline">\(X\to B\)</span> ，我们就称 <span class="math inline">\(B\)</span>部分函数依赖于 <span class="math inline">\(A\)</span> 。</p></li><li><p>完全函数依赖（Full Functional Dependency）：</p><p>若 <span class="math inline">\(A \to B\)</span> ，且不存在 <spanclass="math inline">\(A\)</span> 的真子集 <spanclass="math inline">\(X\)</span> ，使得 <span class="math inline">\(X\to B\)</span>，我们就称 <span class="math inline">\(B\)</span>完全函数依赖于 <span class="math inline">\(A\)</span> 。</p><p>即 <span class="math inline">\(A\)</span>中删去任意一个属性都无法满足 <span class="math inline">\(A \toB\)</span> 。</p></li></ul><p>例如，在上述例子中，显然有 <span class="math inline">\((s\_id, name)\to gender\)</span>， 但其决定因子的一个真子集 <spanclass="math inline">\(s\_id\)</span> 也满足被 <spanclass="math inline">\(gender\)</span>函数依赖，因此该函数依赖是一个部分函数依赖。相反，<spanclass="math inline">\(s\_id \to gender\)</span>就是一个完全函数依赖。</p><p>注意到，一般只有在 <span class="math inline">\(A\)</span>是多个特征的集合时才会考虑此分类，若 <spanclass="math inline">\(A\)</span> 为单属性，且 <spanclass="math inline">\(A \to B\)</span> ，则一定构成完全函数依赖。</p><h5 id="传递函数依赖">传递函数依赖</h5><p>函数依赖具有传递性，传递函数依赖（Transitive FunctionalDependency）描述如下：</p><p>若 <span class="math inline">\(A\)</span> ，<spanclass="math inline">\(B\)</span> ，<spanclass="math inline">\(C\)</span> 是关系模型 <spanclass="math inline">\(R\)</span> 中的三个特征集合，且满足：</p><ul><li><span class="math inline">\(A \to B\)</span> 且 <spanclass="math inline">\(B \not\to A\)</span></li><li><span class="math inline">\(B \to C\)</span></li></ul><p>则称 <span class="math inline">\(C\)</span> 通过 <spanclass="math inline">\(B\)</span> 函数依赖于 <spanclass="math inline">\(A\)</span> 。</p><h4 id="多值依赖">多值依赖</h4><p>设 <span class="math inline">\(R(U)\)</span> 是属性集 <spanclass="math inline">\(U\)</span> 上的一个关系模式。<spanclass="math inline">\(X\)</span>、<spanclass="math inline">\(Y\)</span>、<span class="math inline">\(Z\)</span>是 <span class="math inline">\(U\)</span> 的子集，若对 <spanclass="math inline">\(U\)</span> 的任意一对关系而言，给定一对 <spanclass="math inline">\((X, Z)\)</span> 的值，都有若干组 <spanclass="math inline">\(Y\)</span> 值与之对应，而 <spanclass="math inline">\(Y\)</span> 的取值仅仅与 <spanclass="math inline">\(X\)</span> 相关而与 <spanclass="math inline">\(Z\)</span>无关，这就是<strong>多值依赖（Multi-valuedDependency）</strong>。记作：<span class="math inline">\(X \to\!\!\!\toY\)</span>。</p><blockquote><p>我们也可以这样描述：给定 <span class="math inline">\(X\)</span>的值，有多组 <span class="math inline">\((Y, Z)\)</span>的值与之对应，且 <span class="math inline">\(Y\)</span> 与 <spanclass="math inline">\(Z\)</span> 的取值相互独立。</p></blockquote><p>例如：</p><p>我们给定关系 <span class="math inline">\(subject(subject\_name,teacher, text\_book)\)</span>来描述学科、老师和学科教材的关系，在该关系模型中，一门学科对应多组老师和教材，而老师和教材又是相互独立的，即老师和学科教材分别只决定于学科，所以我们有：<span class="math display">\[\begin{array}{}subject\_name \to\!\!\!\to teacher \\subject\_name \to\!\!\!\to text\_book\end{array}\]</span></p><h5 id="平凡多值依赖和非平凡多值依赖">平凡多值依赖和非平凡多值依赖</h5><p>进一步，我们又可以将多值依赖分为<strong>平凡多值依赖</strong>和<strong>非平凡多值依赖</strong>：</p><ul><li><p>平凡多值依赖（Trivial Multi-valued Dependency）：</p><p>在关系模型 <span class="math inline">\(R\)</span> 的属性集为 <spanclass="math inline">\(U\)</span>，属性 <spanclass="math inline">\(A\)</span> 和 <spanclass="math inline">\(B\)</span> 满足 <span class="math inline">\(A\to\!\!\!\to B\)</span> 且满足以下两个条件之一：</p><ul><li><span class="math inline">\(A \subseteq B\)</span></li><li><span class="math inline">\(A \cup B = R\)</span></li></ul><p>我们就称该多值依赖是平凡的。</p></li><li><p>非平凡多值依赖（Nontrivial Multi-valued Dependency）：</p><p>若 <span class="math inline">\(A \to\!\!\!\to B\)</span>且不满足以上任意一个条件，我们就称该多值依赖是非平凡的。</p></li></ul><h4 id="范式">范式</h4><p><strong>范式（Normal Form）</strong>，简称NF，是一种数据库规范化评级标准，范式越高，数据模型越规范。</p><p>数据库规范化技术，就是不断提高数据模型的范式等级。</p><h5 id="unf">UNF</h5><p><strong>UNF（UnormalizedForm）</strong>，即无范式，是一种未规范化的表格，表格中的数据可能包括一个或多个值。</p><p>示例：</p><p><img src="https://p.ipic.vip/4hkqj3.png" style="zoom: 33%;" /></p><h5 id="nf">1NF</h5><p><strong>1NF（First NormalForm）</strong>，即第一范式。指在一张表格中给定行和列，对应唯一的数据，且一个关系模型中的所有的属性都是不可分的基本数据项。1NF是关系型数据库的基本要求。</p><p>示例：</p><p><img src="https://p.ipic.vip/mcmetv.png" style="zoom:33%;" /></p><blockquote><p><strong>UNF <span class="math inline">\(\to\)</span> 1NF</strong></p><p>将缺省单元格的数据进行拷贝，然后对无范式表格重新划分，即可得到每个单元格仅有一个值的第一范式表格。</p></blockquote><h5 id="nf-1">2NF</h5><p><strong>2NF（Second Normal Form）</strong>，即第二范式。指在 1NF的基础上，满足所有非主属性<strong>完全依赖</strong>于<strong>候选键（Candidatekey）</strong>。</p><blockquote><p><strong>1NF <span class="math inline">\(\to\)</span> 2NF</strong></p><ol type="1"><li>确定主键：确定 1NF 关系中的主键</li><li>确定函数依赖：分析非主键列对主键的完全依赖关系。也就是说，找出哪些非主键列的值是由主键决定的，而不是由主键的一部分决定的</li><li>创建新表：对于那些非主键列存在部分依赖的情况，将其分离出来，创建一个新的表</li><li>调整关系：在新的表中，将非主键列和相应的主键列作为新表的列</li></ol></blockquote><p>示例：</p><p>上述关系中存在如下函数依赖：</p><p><img src="https://p.ipic.vip/xxd1hu.png" style="zoom:30%;" /></p><p>不难发现，我们可以指定 <span class="math inline">\((clinetNo,PropertyNo)\)</span> 作为该关系中的主键，而函数依赖 fd2 和 fd3的决定因子是主键的真子集，因此其被决定因子（图中下画线部分的属性）是部分依赖于主键的，因此我们要将其从当前关系中抽离出来：</p><p>最终建立的关系模型的 Schema 如下：</p><p><img src="https://p.ipic.vip/cdyt6d.png" style="zoom:25%;" /></p><p>该关系模型的三张表都不存在非主属性对主键的部分依赖，各自满足第二范式。</p><h5 id="nf-2">3NF</h5><p><strong>3NF（Third Normal Form）</strong>，即第三范式。指在 2NF的基础上，不存在非主属性<strong>传递依赖</strong>于候选键。</p><blockquote><p><strong>2NF <span class="math inline">\(\to\)</span> 3NF</strong></p><ol type="1"><li>确定主键</li><li>确定函数依赖</li><li>找到依赖于主键的传递函数依赖，并将其分离出来</li></ol></blockquote><p>示例：</p><p>在上述建立的 2NF 关系模型中的第二张表 <spanclass="math inline">\(PropertyOwner\)</span> 中，存在函数依赖关系 <spanclass="math inline">\(propertyNo \to ownerNo\)</span>（<spanclass="math inline">\(ownerNo \not\to propertyNo\)</span>）和 $ ownerNooName$ ，因此 <span class="math inline">\(oName\)</span>传递依赖于主键，所以我们要将其从当前关系中分离出来。</p><p>满足 3NF 的关系模型 Schema 如下所示：</p><p><img src="https://p.ipic.vip/4vfatx.png" style="zoom:25%;" /></p><p>该关系模型中的 4张表都不存在非主属性对主键的传递依赖，各自满足第三范式。</p><h5 id="bcnf">BCNF</h5><p><strong>BCNF（Boyce-Codd NormalForm）</strong>，即巴斯-科德范式。指在 3NF的基础上，清除了主属性对候选键的部分函数依赖。</p><p><strong>即满足 BCNF的充要条件是关系模型中所有函数依赖的决定因子都是候选键。</strong></p><blockquote><p><strong>3NF <span class="math inline">\(\to\)</span> BCNF</strong></p><ol type="1"><li>确定主键和主属性</li><li>确定函数依赖</li><li>消除主属性对候选键的部分函数依赖</li></ol></blockquote><p>例如，有如下关系模型： <span class="math display">\[studentGrade(\underline{class\_id}, \underline{s\_id}, t\_id, grade)\]</span>该关系模型用于储存学生某门课程的成绩，每门课有且仅有一名老师来教学，可以作为该表的候选键有<span class="math inline">\((class\_id, s\_id)\)</span> 或者 <spanclass="math inline">\((t\_id, s\_id)\)</span>，我们选取前者作为主键，那么此关系模型中唯一的非主属性就是 <spanclass="math inline">\(grade\)</span> 。</p><p>该关系模型符合 3NF，但是我们不难发现，主属性 <spanclass="math inline">\(t\_id\)</span>对主键构成部分依赖关系，因此该关系模型不符合BCNF，因此我们将其拆分为两张表： <span class="math display">\[\begin{array}{}teacher(\underline{class\_id}, t\_id) \\studentGrade(\underline{class\_id}, \underline{s\_id}, grade)\end{array}\]</span> 这样，我们就消除了主属性对候选键的部分依赖，上述两张表各自符合BCNF。</p><h5 id="nf-3">4 NF</h5><p><strong>4 NF（Forth Normal Form）</strong>，即第四范式，即在 BCNF的基础上，消除了所有决定因子不为候选键的非平凡多值依赖。换言之，满足 4NF的充要条件是对于关系 <span class="math inline">\(R\)</span>中的每一对非平凡多值依赖 <span class="math inline">\(A \to\!\!\!\toB\)</span> 而言，<span class="math inline">\(A\)</span>都是关系中的候选键。</p><blockquote><p><strong>BCNF <span class="math inline">\(\to\)</span>4NF</strong></p><ol type="1"><li>确定主键和候选键</li><li>确定关系中的非平凡多值依赖</li><li>消除所有决定因子不为候选键的非平凡多值依赖</li></ol></blockquote><p>例如，现有如下关系：</p><p><img src="https://p.ipic.vip/elwe0k.png" style="zoom:50%;" /></p><p>在如上 <span class="math inline">\(BranchStaffOwner(branchNo, sName,oName)\)</span> 关系中，一个 <spanclass="math inline">\(branchNo\)</span> 可以对应多组 <spanclass="math inline">\((sName, oName)\)</span> ，而 <spanclass="math inline">\(sName\)</span> 和 <spanclass="math inline">\(oName\)</span> 之间相互不影响，所以我们有： <spanclass="math display">\[\begin{array}{}branchNo \to\!\!\!\to sName \\branchNo \to\!\!\!\to oName\end{array}\]</span> 而 <span class="math inline">\(branchNo\)</span>在这里不是候选键，所以我们要消除消除这两对非平凡多值依赖，因此将该关系拆分为两张表：</p><p><img src="https://p.ipic.vip/nt56ny.png" style="zoom:50%;" /></p><p>这样我们就消除了上面提到的两对非平凡多值依赖，以上两张表 <spanclass="math inline">\(Branch(branchNo, sName)\)</span>、<spanclass="math inline">\(BranchOwner(BranchNo, oName)\)</span>分别满足第四范式。</p><p>事实上第四范式之上还有<strong>第五范式（Fifth NormalForm）</strong>，但第四范式已经是相当规范的等级了，因此第五范式笔者在此就不赘述了。😃</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库系统</tag>
      
      <tag>数据库规范化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在程序中计算定积分？—— Simpson 公式讲解</title>
    <link href="/2023/04/30/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%AE%9A%E7%A7%AF%E5%88%86%EF%BC%9F%E2%80%94%E2%80%94%20Simpson%20%E5%85%AC%E5%BC%8F%E8%AE%B2%E8%A7%A3/"/>
    <url>/2023/04/30/%E5%A6%82%E4%BD%95%E5%9C%A8%E7%A8%8B%E5%BA%8F%E4%B8%AD%E8%AE%A1%E7%AE%97%E5%AE%9A%E7%A7%AF%E5%88%86%EF%BC%9F%E2%80%94%E2%80%94%20Simpson%20%E5%85%AC%E5%BC%8F%E8%AE%B2%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>Simpson</strong>公式是一种用于求积分近似值的方法，相对于常规的矩形逼近和梯型逼近，其精度要高很多。</p><p>公式如下： <span class="math display">\[\int_a^b f(x)dx \approx \frac{b - a}{6n} (f(a) + f(b) + 2 \sum_{i = 1} ^{n - 1}f(x_i) + 4 \sum_{i = 0}^{n - 1}f(x_{i + 0.5}))\]</span> 其中 <span class="math inline">\(n\)</span>是区间分隔的数量，<span class="math inline">\(n\)</span>越大，精度越高。</p><hr /><h4 id="数学证明">数学证明</h4><p><strong>Simpson</strong>积分公式的原理就是采用二次函数逼近目标函数。</p><center><img src="https://p.ipic.vip/zm09je.png" alt="" style="zoom:40%;" /></center><p>如上图所示，我们将函数区间 <span class="math inline">\([x_1,x_2]\)</span> 近似看作是二次函数，<spanclass="math inline">\(x_{1.5}\)</span> 是区间中点，我们规定： <spanclass="math display">\[\begin{array}{}f(x_1) = c_2 x_1^2 + c_1 x_1 + c_0 \\f(x_2) = c_2 x_2^2 + c_1 x_2 + c_0 \\f(x_{1.5}) = c_0\end{array}\]</span> 则积分面积 <span class="math inline">\(S = \int_{x_1}^{x_2}f(x)dx \approx \int_{x_1}^{x_2} (c_2 x^2 + c_1 x + c_0)dx\)</span> <spanclass="math display">\[\begin{array}{}\implies S \approx  \frac{c_2}{3}(x_2^3 - x_1^3) + \frac{c1}{2}(x_2^2 -x_1^2) + c_0(x_2 - x_1) \\= \frac{x_2 - x_1}{6}(f(x_1) + f(x_2) + 4 f(x_{1.5}))\end{array}\]</span> 现在我们将函数积分区域 <span class="math inline">\([a,b]\)</span> 划分为 <span class="math inline">\(n\)</span> 段，对每一段<span class="math inline">\([x_i, x_{i + 1}]\)</span>采取同样的方式求定积分，</p><p>最后求和就可以得到我们的目标答案： <span class="math display">\[\begin{array}{}\int_a^b f(x)dx \approx \frac{b - a}{6n} (f(a) + f(b) + 2 \sum_{i = 1} ^{n - 1}f(x_i) + 4 \sum_{i = 0}^{n - 1}f(x_{i + 0.5})) \\(x_0 = a, x_n = b)\end{array}\]</span> <strong>误差</strong></p><p>最大误差为 <span class="math inline">\(\frac{(b - a)^5}{180 n^4}M\)</span>，其中 <span class="math inline">\(M\)</span> 是函数在区间<span class="math inline">\([a, b]\)</span>上四阶导的绝对值的最大值。</p><h4 id="代码实现">代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">double</span> <span class="hljs-title">fn</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">exp</span>(-x);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve_rect</span><span class="hljs-params">(<span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 采用一般的矩形逼近法求定积分</span><br>    <span class="hljs-type">double</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">double</span> d = (right - left) / n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res += <span class="hljs-built_in">fn</span>(left + i * d);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res * d;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve_simpson</span><span class="hljs-params">(<span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 采取辛普森公式求定积分</span><br>    <span class="hljs-type">double</span> res = -<span class="hljs-built_in">fn</span>(left) + <span class="hljs-built_in">fn</span>(right);<br>    <span class="hljs-type">double</span> d = (right - left) / n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res += (<span class="hljs-number">2</span> * <span class="hljs-built_in">fn</span>(left + i * d) + <span class="hljs-number">4</span> * <span class="hljs-built_in">fn</span>(left + (i + <span class="hljs-number">0.5</span>) * d));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> d * res / <span class="hljs-number">6</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, <span class="hljs-built_in">solve_rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>));      <span class="hljs-comment">// 0.245014</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, <span class="hljs-built_in">solve_rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>));     <span class="hljs-comment">// 0.262393</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, <span class="hljs-built_in">solve_rect</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1000</span>));    <span class="hljs-comment">// 0.264057</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lf\n&quot;</span>, <span class="hljs-built_in">solve_simpson</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>));   <span class="hljs-comment">// 0.264241</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实际答案 <span class="math inline">\(\int_0^1 x e^{-x}dx = 1 -\frac{2}{e} \approx 0.2642411176571\)</span>，可见上述积分采用 Simpson公式计算时在 <span class="math inline">\(n = 10\)</span>时已经达到了一个较高的精度，远超常规的矩形逼近法。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数学</category>
      
      <category>微积分</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Simpson 公式</tag>
      
      <tag>定积分</tag>
      
      <tag>计算几何</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL 知识点总结</title>
    <link href="/2023/04/10/MySQL%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/10/MySQL%20%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h3 id="mysql-基本介绍">MySQL 基本介绍</h3><p>MySQL 是一种<strong>关系型数据库管理系统</strong>，由瑞典 MySQL AB公司开发，属于 Oracle旗下产品，由于其体积小、速度快、成本低、<strong>开源</strong>等优点，使其在Web 开发中尤其受欢迎。</p><p><a href="https://www.mysql.com/">MySQL 官网</a></p><h4 id="mysql-客户端连接">MySQL 客户端连接</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql -u [用户名] -p<br></code></pre></td></tr></table></figure><p>示例：</p><p>以 <code>root</code> 用户登陆：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">mysql -u root -p<br></code></pre></td></tr></table></figure><h3 id="mysql-command-介绍">MySQL Command 介绍</h3><p>MySQL 所使用的 SQL 语言是用于访问数据库的最常用标准化语言。</p><h4 id="sql-语句分类">SQL 语句分类</h4><p>最常见的 SQL 语句包括以下 4 大类：</p><ul><li>DDL（Data Definition Language）<ul><li>用途：对数据库对象（数据库、表、列、索引等）进行创建、删除、修改等。</li><li>常用关键字：<code>create</code>、<code>drop</code>、<code>alter</code></li></ul></li><li>DML（Data Manipulation Language）<ul><li>用途：用于添加、修改、删除和查询数据库记录，并检查数据完整性。</li><li>常用关键字：<code>insert</code>、<code>update</code>、<code>delete</code></li></ul></li><li>DQL（Data Query Language）<ul><li>用途：用于查询数据。</li><li>常用关键字：<code>select</code></li></ul></li><li>DCL（Data Control Language）<ul><li>用途：用于管理用户权限。</li></ul></li></ul><h4 id="ddl-语句">DDL 语句</h4><h5 id="数据库操作">数据库操作</h5><ul><li><p>查询所有数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show databases;<br></code></pre></td></tr></table></figure></p></li><li><p>创建数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database [数据库名称];<br>create database if not exists [数据库名称];<br>create database [数据库名称] default charset [字符集];<br></code></pre></td></tr></table></figure></p></li><li><p>删除数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database [数据库名称];<br>drop database if exists [数据库名称];<br></code></pre></td></tr></table></figure></p></li><li><p>使用数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use [数据库名称];<br></code></pre></td></tr></table></figure></p></li><li><p>查询当前数据库：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select database();<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="表操作">表操作</h5><ul><li><p>查询当前数据库所有表：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br></code></pre></td></tr></table></figure></p></li><li><p>查询表结构：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc [表名];<br></code></pre></td></tr></table></figure></p></li><li><p>查询指定表的创建语句：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show create table [表名];<br></code></pre></td></tr></table></figure></p></li><li><p>创建表：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table [表名](<br>    字段1   字段1类型   [约束]  [comment],<br>    字段2   字段2类型   [约束]  [comment],<br>    # ...<br>    字段n   字段n类型   [约束]  [comment]<br>)comment 表注释;<br></code></pre></td></tr></table></figure></p><p>例如：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建如下员工表<br>create table demo(<br>    id      int           comment &#x27;编号&#x27;,<br>    name    varchar(50)   comment &#x27;姓名&#x27;,<br>    age     int           comment &#x27;年龄&#x27;,<br>    gender  varchar(1)    comment &#x27;性别&#x27;<br>)comment &#x27;员工&#x27;;<br></code></pre></td></tr></table></figure></p></li><li><p>修改表名：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] rename to [新表名];<br></code></pre></td></tr></table></figure></p></li><li><p>删除表：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table (if exists) [表名];<br></code></pre></td></tr></table></figure></p></li><li><p>删除指定表，并重新创建该表（即删除表中所有行）：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">truncate table [表名];<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="字段操作">字段操作</h5><ul><li><p>添加字段：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] add [字段名] [类型(长度)] [约束] [comment];<br></code></pre></td></tr></table></figure></p><p>例如：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table staff<br>    add gender varchar(10) default &#x27;undefined&#x27; not null comment &#x27;性别&#x27;;<br></code></pre></td></tr></table></figure></p><blockquote><p>如上，给 <code>staff</code> 表格添加 <code>gender</code> 字段</p></blockquote></li><li><p>修改字段数据类型</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] modify [字段名] [新数据类型];<br></code></pre></td></tr></table></figure></p></li><li><p>修改字段名和字段数据类型：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] change [旧字段名] [新字段名] [类型(长度)] [约束] [comment];<br></code></pre></td></tr></table></figure></p><p>例如：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table staff<br>    change id s_id int not null comment &#x27;员工 ID&#x27;;<br></code></pre></td></tr></table></figure></p></li><li><p>删除字段：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] drop [字段名];<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="补充">补充</h5><h6 id="mysql-表格字段数据类型">MySQL 表格字段数据类型</h6><ul><li><p>基本数据类型：</p><table><thead><tr class="header"><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>tinyint</code></td><td>1 byte</td><td>整数</td></tr><tr class="even"><td><code>smallint</code></td><td>2 bytes</td><td>整数</td></tr><tr class="odd"><td><code>mediumint</code></td><td>3 bytes</td><td>整数</td></tr><tr class="even"><td><code>int</code> 或者 <code>integer</code></td><td>4 bytes</td><td>整数</td></tr><tr class="odd"><td><code>bigint</code></td><td>8 bytes</td><td>整数</td></tr><tr class="even"><td><code>float</code></td><td>4 bytes</td><td>单精度浮点数</td></tr><tr class="odd"><td><code>double</code></td><td>8 bytes</td><td>双精度浮点数</td></tr><tr class="even"><td><code>decimal</code></td><td>依赖于精度和标度的值</td><td>小数值</td></tr></tbody></table></li><li><p>字符串类型：</p><table><thead><tr class="header"><th>类型</th><th>大小</th><th>描述</th></tr></thead><tbody><tr class="odd"><td><code>char</code></td><td>0 ~ 255 bytes</td><td>定长字符串</td></tr><tr class="even"><td><code>varchar</code></td><td>0 ~ 65535 bytes</td><td>变长字符串</td></tr><tr class="odd"><td><code>tinyblob</code></td><td>0 ~ 255 bytes</td><td>不超过 255 个字符的二进制数据</td></tr><tr class="even"><td><code>tinytext</code></td><td>0 ~ 255 bytes</td><td>短文本字符串</td></tr><tr class="odd"><td><code>blob</code></td><td>0 ~ 65535 bytes</td><td>二进制形式的长文本数据</td></tr><tr class="even"><td><code>text</code></td><td>0 ~ 65535 bytes</td><td>长文本数据</td></tr></tbody></table></li><li><p>日期类型：</p><table><thead><tr class="header"><th>类型</th><th>大小</th><th>格式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>date</code></td><td>3 bytes</td><td><code>YYYY-MM-DD</code></td><td>日期值</td></tr><tr class="even"><td><code>time</code></td><td>3 bytes</td><td><code>HH:MM:SS</code></td><td>持续时间值</td></tr><tr class="odd"><td><code>year</code></td><td>1 bytes</td><td><code>YYYY</code></td><td>年份值</td></tr><tr class="even"><td><code>datetime</code></td><td>8 bytes</td><td><code>YYYY-MM-DD HH:MM:SS</code></td><td>混合日期和时间值</td></tr><tr class="odd"><td><code>timestamp</code></td><td>4 bytes</td><td><code>YYYY-MM-DD HH:MM:SS</code></td><td>混合日期和时间值，时间戳</td></tr></tbody></table></li><li><p>枚举类型：</p><p>关键词：<code>enum</code></p><p>枚举范围需要在创建表格时通过枚举的方式指定，最多允许有 65535个成员。</p><p>例如：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table stu(<br>    id int primary key auto_increment,<br>    name varchar(20) not null,<br>    gender enum(&#x27;男&#x27;, &#x27;女&#x27;) not null<br>);<br></code></pre></td></tr></table></figure></p><blockquote><p>其中 <code>gender</code> 字段只能是「男」或者「女」</p></blockquote></li></ul><h6 id="mysql-约束">MySQL 约束</h6><p>约束是作用于表中字段上的规则，用于限制存储在表中的数据。</p><p>分类：</p><table><thead><tr class="header"><th>约束</th><th>关键字</th><th>描述</th></tr></thead><tbody><tr class="odd"><td>非空约束</td><td><code>not null</code></td><td>字段不能为 <code>NULL</code></td></tr><tr class="even"><td>唯一约束</td><td><code>unique</code></td><td>字段数据都是唯一的，不重复的</td></tr><tr class="odd"><td>主键约束</td><td><code>primary key</code></td><td>主键是一行数据的唯一表示，要求非空唯一</td></tr><tr class="even"><td>默认约束</td><td><code>default</code></td><td>保存数据时，如果未指定该字段的值，则采用默认值</td></tr><tr class="odd"><td>检查约束</td><td><code>check</code></td><td>保证字段满足某一个条件</td></tr><tr class="even"><td>外键约束</td><td><code>foreign key</code></td><td>用来建立两张表的数据之间的联系，保证数据的一致性和完整性</td></tr></tbody></table><p>案例：</p><p>根据以下需求完成表的创建：</p><table><thead><tr class="header"><th>字段名</th><th>字段含义</th><th>字段类型</th><th>约束条件</th><th>约束关键词</th></tr></thead><tbody><tr class="odd"><td><code>id</code></td><td>ID 唯一标识</td><td><code>int</code></td><td>主键，并且自动增长</td><td><code>primary key, auto_increment</code></td></tr><tr class="even"><td><code>name</code></td><td>姓名</td><td><code>varchar(10)</code></td><td>非空唯一</td><td><code>not null, unique</code></td></tr><tr class="odd"><td><code>age</code></td><td>年龄</td><td><code>int</code></td><td>大于 0，不大于 120</td><td><code>check</code></td></tr><tr class="even"><td><code>status</code></td><td>状态</td><td><code>char(1)</code></td><td>默认为 1</td><td><code>default</code></td></tr><tr class="odd"><td><code>gender</code></td><td>性别</td><td><code>char(1)</code></td><td>无</td><td></td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table stu(<br>    id      int             primary key auto_increment          comment &#x27;ID&#x27;,<br>    name    varchar(10)     not null unique                     comment &#x27;姓名&#x27;,<br>    age     int             check ( age &gt; 0 and age &lt;= 120 )    comment &#x27;年龄&#x27;,<br>    status  char(1)         default &#x27;1&#x27;                         comment &#x27;状态&#x27;,<br>    gender  char(1)                                             comment &#x27;性别&#x27;<br>)comment &#x27;学生&#x27;;<br></code></pre></td></tr></table></figure><p><strong>外键约束</strong></p><p>让多个表的数据产生连接，子表的外键是父表的一个候选键，如下图：</p><p><left><img src="https://p.ipic.vip/lmnwk4.png" alt="外键示意图" style="zoom:67%;" /></left></p><ul><li><p>管理外键关联：</p><ul><li><p>创建表时添加外键关联：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">[外键名称] foreign key [外键字段名] references [主表(主表列名)] [指定行为];<br></code></pre></td></tr></table></figure></p></li><li><p>创建表后添加外键关系：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] add constraint [外键名称] foreign key [外键字段名] references [主表(主表列名)] [指定行为];<br></code></pre></td></tr></table></figure></p></li><li><p>删除外键关联：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter table [表名] drop foreign key [外键名称];<br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>外键删除和更新行为：</p><table><thead><tr class="header"><th>行为</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>no action</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则不允许删除或更新（默认）</td></tr><tr class="even"><td><code>restrict</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则不允许删除或更新（与<code>no action</code> 一致）</td></tr><tr class="odd"><td><code>cascade</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则也删除或者更新外键在子表中的记录</td></tr><tr class="even"><td><code>set null</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则设置子表的外键值为<code>NULL</code></td></tr><tr class="odd"><td><code>set default</code></td><td>当父表中删除或更新对应记录时，首先检查是否有对应外键，如果有则设置子表的外键值为默认值（<em>Innodb</em>不支持）</td></tr></tbody></table><p>案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 给 staff 表的 dept_id 属性添加关联 dept 表的 id 属性的外键关系，并且将更新行为和删除行为设置为级联<br>alter table staff<br>    add constraint fk_staff_dept_id foreign key (dept_id) references dept(id)<br>    on update cascade on delete cascade;<br></code></pre></td></tr></table></figure></p></li></ul><h4 id="dml-语句">DML 语句</h4><ul><li><p>添加数据：</p><ul><li><p>给指定字段添加数据：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into [表名(字段名1, 字段名2, ...)] values(值1, 值2, ...);<br></code></pre></td></tr></table></figure></p></li><li><p>给全部字段添加数据：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into [表名] values(值1, 值2, ...);<br></code></pre></td></tr></table></figure></p></li><li><p>批量添加：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into [表名] values(值1, 值2, ...), (值1, 值2, ...), ...;<br></code></pre></td></tr></table></figure></p><p>示例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into staff (s_id, name, age, gender)<br>values (1002, &#x27;Tom&#x27;, 24, &#x27;男&#x27;),<br>       (1003, &#x27;Frank&#x27;, 25, &#x27;男&#x27;);<br></code></pre></td></tr></table></figure></p></li></ul></li><li><p>修改数据：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update [表名] set 字段名1 = 值1， 字段名2 = 值2, ... [where 条件];<br></code></pre></td></tr></table></figure></p></li><li><p>删除数据：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from [表名] [where 条件];<br></code></pre></td></tr></table></figure></p></li></ul><h4 id="dql-语句">DQL 语句</h4><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>[字段列表]<br>from<br>[表名列表]<br>where<br>[条件列表]<br>group by<br>[分组字段列表]<br>having<br>[分组后条件列表]<br>order by<br>[排序字段列表]<br>limit<br>[分页参数];<br></code></pre></td></tr></table></figure><blockquote><p><code>select</code> 之后添加 <code>distinct</code>可以消除重复元组</p></blockquote><ul><li><p>查询多个字段：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段1, 字段2, ...] from [表名];<br><br>select * from [表名]; # 查询所有字段（不推荐）<br><br>select [字段] as [别名] from [表名];<br></code></pre></td></tr></table></figure></p></li><li><p>条件查询：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表名] where [条件列表];<br></code></pre></td></tr></table></figure></p><p>条件：</p><table><thead><tr class="header"><th>比较运算符</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>&gt;</code></td><td>大于</td></tr><tr class="even"><td><code>&gt;=</code></td><td>大于等于</td></tr><tr class="odd"><td><code>&lt;</code></td><td>小于</td></tr><tr class="even"><td><code>&lt;=</code></td><td>小于等于</td></tr><tr class="odd"><td><code>=</code></td><td>等于</td></tr><tr class="even"><td><code>&lt;&gt;</code> 或者 <code>!=</code></td><td>不等于</td></tr><tr class="odd"><td><code>between ... and ...</code></td><td>在某个范围之内（含最小、最大值）</td></tr><tr class="even"><td><code>in(...)</code></td><td>在 <code>in</code> 之后的列表中的值</td></tr><tr class="odd"><td><code>like 占位符</code></td><td>模糊匹配，<code>_</code> 匹配单个字符，<code>%</code>匹配任意个字符</td></tr><tr class="even"><td><code>is null</code></td><td>是 <code>NULL</code></td></tr></tbody></table><table><thead><tr class="header"><th>逻辑运算符</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>and</code> 或 <code>&amp;&amp;</code></td><td>并且</td></tr><tr class="even"><td><code>or</code> 或 <code>||</code></td><td>或者</td></tr><tr class="odd"><td><code>not</code> 或 <code>!</code></td><td>非</td></tr></tbody></table><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name, s_id from staff where age &gt;= 25;<br># 查找年龄不小于 25 的员工姓名和 ID<br><br>select name, s_id from staff where age between 20 and 30;<br># 查找年龄在 20 和 30 岁之间的员工姓名和年龄<br><br>select name, s_id from staff where gender is null;<br># 查找 gender 为 null 的员工姓名和 ID<br><br>select name, s_id from staff where age &gt;= 25 and gender = &#x27;女&#x27;;<br># 查找年龄不小于 25 的女员工姓名和 ID<br><br>select name from staff like &#x27;李%&#x27;;<br># 查找姓李的员工<br></code></pre></td></tr></table></figure></p></li><li><p>聚合函数</p><p>聚合函数是指将一列数据作为一个整体，进行纵向计算。</p><table><thead><tr class="header"><th>函数</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>count()</code></td><td>统计数量</td></tr><tr class="even"><td><code>max()</code></td><td>最大值</td></tr><tr class="odd"><td><code>min()</code></td><td>最小值</td></tr><tr class="even"><td><code>avg()</code></td><td>平均值</td></tr><tr class="odd"><td><code>sum()</code></td><td>求和</td></tr></tbody></table><blockquote><p>注：<code>NULL</code> 值不参与除 <code>count()</code>之外的聚合函数的运算</p></blockquote><p>语法：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 聚合函数(字段列表) from [表名];<br></code></pre></td></tr></table></figure></p><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(s_id) from staff;<br># s_id 数量，NULL 值不参与聚合函数计算<br><br>select max(age) from staff;<br># 查找员工年龄最大值<br></code></pre></td></tr></table></figure></p></li><li><p>分组查询</p><p>语法：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表名] where [条件列表] group by [分组字段名] having [分组后过滤条件];<br></code></pre></td></tr></table></figure></p><p>‼️ <code>where</code> 和 <code>having</code> 的区别：</p><ul><li>执行时机不同：<code>where</code> 是分组之前进行过滤，不满足<code>where</code> 条件，不参与分组；而 <code>having</code>是分组之后对结果进行过滤。</li><li>判断条件不同，<code>where</code> 不能对聚合函数进行判断，而<code>having</code> 可以。</li></ul><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select gender, count(*) as numebr from staff group by gender;<br># 查询男性员工和女性员工的数量<br></code></pre></td></tr></table></figure></p><p>结果：</p><p><left><img src="https://p.ipic.vip/k3lstv.png" alt="" style="zoom:67%;" /></left></p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select address, count(*) as address_count from emp where age &lt;= 35 group by address having address_count &gt;= 5;<br># 查询不同地区年龄小于等于 35 岁的员工且人数不小于 5 的地区及其员工数量<br></code></pre></td></tr></table></figure></p><p>‼️ <strong>执行顺序</strong>：</p><ol type="1"><li><code>where</code></li><li>聚合函数</li><li><code>having</code></li></ol></li><li><p>排序查询</p><p>语法：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表名] order by [字段1] [排序方案1], [字段2] [排序方案2] ...;<br># 多个字段时先看前面的字段，若前面的字段值相同，则看后面的字段规则<br></code></pre></td></tr></table></figure></p><p>排序方案：</p><ul><li><code>asc</code> ：升序排序</li><li><code>desc</code> ：降序排序</li></ul><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select name, s_id from staff order by age asc;<br># 将员工姓名和 ID 按照年龄升序排列<br></code></pre></td></tr></table></figure></p></li><li><p>分页查询</p><p>关键词：<code>limit</code></p><p>语法：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表名] limit [起始索引], [查询记录数];<br></code></pre></td></tr></table></figure></p><blockquote><p>注：起始索引从 0 开始，若索引为 0，则 0 可以省略</p></blockquote><p>几个案例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from emp limit 0, 10;<br># 展示从索引 0 开始的 10 条记录<br></code></pre></td></tr></table></figure></p></li></ul><h5 id="多表查询">‼️ 多表查询</h5><p>直接使用 <code>select</code> 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1], [表2];<br></code></pre></td></tr></table></figure><p>以上语句会直接得到 表1 和 表2 的笛卡尔积的投影字段。</p><p>自然连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1], [表2] where [表1.key] = [表2.key];<br></code></pre></td></tr></table></figure><blockquote><p><code>key</code> 在这里为主表的外键</p></blockquote><p><strong><code>JOIN</code> 语句</strong></p><ul><li><p><code>cross join</code> ：笛卡尔积</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] cross join [表2];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/uic3ax.png" alt="CROSS JOIN 示例" style="zoom:20%;" /></p></li><li><p><code>on</code> 关键字：在 <code>join</code> 语句后添加<code>on [条件列表]</code> 可以筛选特定条件的元组</p></li><li><p>内连接</p><ul><li><p><code>natural join</code> ：自然连接</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] natural join [表2];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/0oudmc.png" alt="NATURAL JOIN 示例" style="zoom:20%;" /></p></li><li><p><code>inner join</code> ：内连接，<code>join</code>不加修饰的默认连接，显示左表和右表符合条件的记录</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] (inner) join [表2] on [条件列表];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/j0vtdu.png" alt="INNER JOIN 示例" style="zoom:20%;" /></p><blockquote><p>上图使用 <code>where</code>语句的等价连接方式叫做<strong>隐式内连接</strong>。</p></blockquote></li></ul></li><li><p>外连接</p><ul><li><p><code>left join</code>：左连接，即保留左表所有元组，右表无法匹配的属性用 <code>NULL</code>取代</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] left join [表2] on [条件列表];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/2ntdt9.png" alt="LEFT JOIN 示例" style="zoom:20%;" /></p></li><li><p><code>right join</code>：右连接，即保留右表所有元组，左表无法匹配的属性用 <code>NULL</code>取代</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] right join [表2] on [条件列表];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/8eomc6.png" alt="RIGHT JOIN 示例" style="zoom:20%;" /></p></li><li><p><code>full join</code>：全连接，即保留两张表所有元组，无法匹配的属性用 <code>NULL</code>取代</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select [字段列表] from [表1] full join [表2] on [条件列表];<br></code></pre></td></tr></table></figure></p><p><img src="https://p.ipic.vip/7piiru.png" alt="FULL JOIN 示例" style="zoom:20%;" /></p></li></ul></li></ul><h5 id="子查询">‼️ 子查询</h5><p>在 SQL 语句中嵌套 <code>select</code>语句，称为嵌套查询，又称子查询。</p><ul><li><p>标量子查询：子查询的结果为单个值</p></li><li><p>列子查询：子查询的结果为一列</p><p>常用操作符：<code>in</code>、<code>not in</code>、<code>any</code>、<code>some</code>、<code>all</code></p></li><li><p>行子查询：子查询的结果为一行</p><p>常用操作符：<code>=</code>、<code>!=</code>、<code>in</code>、<code>not in</code>、<code>exists</code>、<code>not exists</code></p><blockquote><p><code>exists (select ...)</code> 用来判断是否有后面的<code>select</code> 语句是否有返回值。若至少返回一行，则返回<code>true</code> ，否则返回 <code>false</code></p></blockquote></li><li><p>表子查询：子查询的结果为多行多列</p><p>常用操作符：<code>in</code></p></li></ul><p>根据子查询的位置，又可以分为：</p><ul><li><code>where</code> 之后</li><li><code>from</code> 之后</li><li><code>select</code> 之后</li></ul><h4 id="dcl-语句">DCL 语句</h4><p>DCL（Data ControlLanguage）用来管理数据库用户控制数据库的访问权限。</p><p>管理用户：</p><ul><li><p>查询用户：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br>select * from user;<br></code></pre></td></tr></table></figure></p></li><li><p>创建用户：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user [&#x27;用户名&#x27;@&#x27;主机名&#x27;] identified by [&#x27;密码&#x27;];<br></code></pre></td></tr></table></figure></p><p>示例：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 创建用户 Jack，只能在当前主机 localhost 访问，密码 123456<br>create user &#x27;Jack&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;<br><br># 创建用户 Tina，可以在任意主机访问该数据库，密码 123456<br>create user &#x27;Tina&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;<br></code></pre></td></tr></table></figure></p></li><li><p>修改用户密码：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">alter user [&#x27;用户名&#x27;@&#x27;主机名&#x27;] identified with mysql_native_password by [&#x27;新密码&#x27;];<br></code></pre></td></tr></table></figure></p></li><li><p>删除用户：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop user [&#x27;用户名&#x27;@&#x27;主机名&#x27;];<br></code></pre></td></tr></table></figure></p></li></ul><p>权限控制：</p><table><thead><tr class="header"><th>权限</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>all, all privileges</code></td><td>所有权限</td></tr><tr class="even"><td><code>select</code></td><td>查询数据</td></tr><tr class="odd"><td><code>insert</code></td><td>插入数据</td></tr><tr class="even"><td><code>update</code></td><td>修改数据</td></tr><tr class="odd"><td><code>delete</code></td><td>删除数据</td></tr><tr class="even"><td><code>alter</code></td><td>修改表</td></tr><tr class="odd"><td><code>drop</code></td><td>删除数据库 / 表 / 视图</td></tr><tr class="even"><td><code>create</code></td><td>创建数据库 / 表</td></tr></tbody></table><ul><li><p>查询权限：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show grants for [&#x27;用户名&#x27;@&#x27;主机名&#x27;];<br></code></pre></td></tr></table></figure></p></li><li><p>授予权限：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">grant [权限列表] on [数据库名.表名] to [&#x27;用户名&#x27;@&#x27;主机名&#x27;];<br></code></pre></td></tr></table></figure></p></li><li><p>撤销权限：</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">revoke [权限列表] on [数据库名.表名] to [&#x27;用户名&#x27;@&#x27;主机名&#x27;];<br></code></pre></td></tr></table></figure></p><blockquote><ol type="1"><li>多个权限之间，采取逗号分隔</li><li>授权时，数据库和表名可以使用 <code>*</code> 进行通配</li></ol></blockquote></li></ul><h3 id="mysql-函数">MySQL 函数</h3><p>函数是指一段可以直接被另一段程序调用的程序或代码。</p><h4 id="字符串函数">字符串函数</h4><table><thead><tr class="header"><th>函数</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>length(s)</code></td><td>返回字符串的长度</td></tr><tr class="even"><td><code>concat(s1, s2, ...)</code></td><td>字符串拼接</td></tr><tr class="odd"><td><code>lower(str)</code></td><td>将字符串全部小写</td></tr><tr class="even"><td><code>upper(str)</code></td><td>将字符串全部大写</td></tr><tr class="odd"><td><code>lpad(str, n, pad)</code></td><td>左填充</td></tr><tr class="even"><td><code>rpad(str, n, pad)</code></td><td>右填充</td></tr><tr class="odd"><td><code>trim(str)</code></td><td>去掉字符串头部和尾部的空格</td></tr><tr class="even"><td><code>substring(str, start, len)</code></td><td>返回字符串从 <code>start</code> 位置起的 <code>len</code>个长度的子字符串</td></tr></tbody></table><h4 id="数据函数">数据函数</h4><table><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>ceil(x)</code></td><td>向上取整</td></tr><tr class="even"><td><code>floor(x)</code></td><td>向下取整</td></tr><tr class="odd"><td><code>mod(x, y)</code></td><td>返回 <code>x mod y</code> 的值</td></tr><tr class="even"><td><code>rand()</code></td><td>返回 0 ~ 1 之间的随机数</td></tr><tr class="odd"><td><code>round(x, y)</code></td><td>求参数 <code>x</code> 的四舍五入的值，保留 <code>y</code>位小数</td></tr></tbody></table><h4 id="日期函数">日期函数</h4><table><thead><tr class="header"><th>函数</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>curdate()</code></td><td>返回当前日期</td></tr><tr class="even"><td><code>curtime()</code></td><td>返回当前时间</td></tr><tr class="odd"><td><code>now()</code></td><td>返回当前日期和时间</td></tr><tr class="even"><td><code>year(date)</code></td><td>获取指定 <code>date</code> 的年份</td></tr><tr class="odd"><td><code>month(date)</code></td><td>获取指定 <code>date</code> 的月份</td></tr><tr class="even"><td><code>day(date)</code></td><td>获取指定 <code>date</code> 的日期</td></tr><tr class="odd"><td><code>date_add(date, interval expr type)</code></td><td>返回一个日期 / 时间值加上一个时间间隔 <code>expr</code>后的时间值</td></tr><tr class="even"><td><code>datediff(date1, date2)</code></td><td>返回结束时间 <code>date1</code> 和起始时间 <code>date2</code>之间的天数</td></tr><tr class="odd"><td><code>date_format(date, format)</code></td><td><code>date_format(date, format)</code> ：用于以不同的格式显示日期 /时间数据。<code>date</code> 参数是合法的日期，<code>format</code>规定日期/时间的输出格式。<br>例如，将 <code>2023-03-14</code> 转化为<code>2023-03</code> （即年 - 月）输出，则为：<br><code>date_format(target_date, '%Y-%m')</code></td></tr></tbody></table><h4 id="流程函数">流程函数</h4><p>流程函数也是很常用的一类函数，可以在 SQL语句中实现条件筛选，从而提高语句效率。</p><table><thead><tr class="header"><th>函数</th><th>功能</th></tr></thead><tbody><tr class="odd"><td><code>if(value, t, f)</code></td><td><code>value</code> 为 <code>true</code> 返回 <code>t</code>，否则返回 <code>f</code></td></tr><tr class="even"><td><code>ifnull(value1, value2)</code></td><td>如果 <code>value1</code> 不为空，返回 <code>value1</code> ，否则返回<code>value2</code></td></tr><tr class="odd"><td><code>case when [val1] then [res1] ... else [default] end</code></td><td>如果 <code>val1</code> 为 <code>true</code> ，返回 <code>res1</code>，...，<code>default</code> 为默认值</td></tr><tr class="even"><td><code>case [expr] when [val1] then [res1] ... else [default] end</code></td><td>同上，若 <code>expr</code> 的值等于 <code>val1</code> ，则返回<code>res1</code>， ...，<code>default</code> 为默认值</td></tr></tbody></table><h3 id="mysql-事务操作">MySQL 事务操作</h3><p><strong>事务（Transaction）</strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么<strong>同时成功，要么同时失败</strong>。</p><p><strong>事务 4 大特性（ACID）</strong>：</p><ul><li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败</li><li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态</li><li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h4 id="事务操作">事务操作</h4><ul><li><p>查看 / 设置事务提交方式</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select @@autocommit;<br>set @@autocommit = 0; # 将事务设置为手动提交<br></code></pre></td></tr></table></figure></p></li><li><p>开启事务</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction; # 我们也可以不更改 @@autocommit 参数<br></code></pre></td></tr></table></figure></p></li><li><p>提交事务</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">commit; # 设置为手动提交后必须要手动提交才能更新数据<br></code></pre></td></tr></table></figure></p></li><li><p>回滚事务</p><p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">rollback; # 回滚 / 撤销事务<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>素数筛</title>
    <link href="/2023/04/02/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <url>/2023/04/02/%E7%B4%A0%E6%95%B0%E7%AD%9B/</url>
    
    <content type="html"><![CDATA[<h4 id="引入">引入</h4><p>如果我们想要求出小于 <code>n</code>的所有素数，一个很自然的想法就是从 1 到 <code>n</code>进行遍历，然后对素数进行记录，但这样的话时间复杂度为 <spanclass="math inline">\(O(n^{\frac{3}{2}})\)</span> ，当 <code>n</code>足够大的时候这个算法是较慢的，有没有更高效的算法呢？</p><p>接下来我们介绍最常见的两种素数筛，以 Leetcode 模版题为例：<ahref="https://leetcode.cn/problems/count-primes/">计数质数</a></p><h4 id="埃氏筛">埃氏筛</h4><p>埃氏筛也叫埃拉托斯特尼筛法，考虑任意素数 <code>x</code> ，则<code>x</code> 的所有倍数都是合数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 埃式筛</span><br>        <span class="hljs-type">bool</span>* notPrime = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n]();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>                res++;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-type">long</span> k = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)i * i; k &lt; n; k += i) &#123;<br>                    <span class="hljs-comment">// 若 j &lt; i，则 j * i 一定已经被筛过</span><br>                    notPrime[k] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度：<span class="math inline">\(O(n\ loglogn)\)</span></p><p>如果想了解其证明，读者可以自行去 <ahref="https://oi-wiki.org/math/number-theory/sieve/">OI Wiki</a>上看。</p></blockquote><p>尽管埃氏筛法已经有较高的效率，但其仍然无法达到线性时间复杂度，因为有些数存在重复筛除的情况，例如12，其会被 2，3 分别筛除一次，有没有办法可以避免重复筛除呢？</p><h4 id="欧式筛线性筛">欧式筛（线性筛）</h4><p>欧式筛，即 Euler筛法，其避免了上述的重复筛而造成的时间浪费，真正意义上实现了线性时间复杂度。对于特别大的数据量（<spanclass="math inline">\(n &gt; 10^8\)</span>）时适用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countPrimes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>* primeNum = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[(<span class="hljs-type">int</span>)(<span class="hljs-number">1.5</span> * n / <span class="hljs-built_in">log</span>(n)) + <span class="hljs-number">1</span>];<br>        <span class="hljs-comment">// π(n) &lt; 1.5 * n / ln(n) 素数数目的一个粗糙上界</span><br>        <span class="hljs-type">bool</span>* notPrime = <span class="hljs-keyword">new</span> <span class="hljs-type">bool</span>[n]();<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>                primeNum[res++] = i;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; res &amp;&amp; i * primeNum[j] &lt; n; j++) &#123;<br>                notPrime[i * primeNum[j]] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">if</span> (i % primeNum[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 如果 i 能被 primeNum[j] 整除，则 i 的倍数一定会被 primeNum[j] 的倍数筛除</span><br>                <span class="hljs-comment">// 故此刻不需要继续再筛除，退出循环</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><p>时间复杂度：<span class="math inline">\(O(n)\)</span></p></blockquote><p>注意到，欧式筛中被筛除的合数都是被当前记录的最小素数筛除的，所以我们我们也可以<strong>同时得到每个数的最小质因数</strong>。</p><h4 id="案例">案例</h4><p><a href="https://acm.hdu.edu.cn/showproblem.php?pid=6954">HDU -6954</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 10000005</span><br><br><span class="hljs-keyword">using</span> i64 = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><br><span class="hljs-type">bool</span> notPrime[MAX_NUM];<br>i64 ans[MAX_NUM];<br><span class="hljs-type">int</span> primeNum[MAX_NUM];<br><span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    std::cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt; MAX_NUM; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!notPrime[i]) &#123;<br>            ans[i] = ans[i - <span class="hljs-number">1</span>] + <span class="hljs-number">2ll</span> * i;<br>            primeNum[cnt++] = i;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            ans[i] = ans[i - <span class="hljs-number">1</span>] + i;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cnt &amp;&amp; (i64)i * primeNum[j] &lt; MAX_NUM; j++) &#123;<br>            notPrime[i * primeNum[j]] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (i % primeNum[j] == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> numTest;<br>    std::cin &gt;&gt; numTest;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span> (numTest--) &#123;<br>        std::cin &gt;&gt; n;<br>        std::cout &lt;&lt; ans[n] - <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数论</tag>
      
      <tag>素数</tag>
      
      <tag>素数筛</tag>
      
      <tag>埃氏筛</tag>
      
      <tag>欧式筛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2023/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/04/01/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是正则表达式">什么是正则表达式？</h4><p><strong>正则表达式（regularexpression）</strong>，又称为规则表达式，是一种文本模式，其拥有独特的语法和独立的处理引擎，可以帮助我们实现文本匹配，特别是当匹配模式比较复杂时，正则表达式有相当大的优势。</p><p>构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。</p><h4 id="正则表达式基本语法">正则表达式基本语法</h4><h5 id="字符类">字符类</h5><table><thead><tr class="header"><th>表达式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>[abc]</code></td><td>只能是 a, b, c</td></tr><tr class="even"><td><code>[^abc]</code></td><td>除了 a, b, c 之外的任何字符</td></tr><tr class="odd"><td><code>[a-zA-Z]</code></td><td>a 到 z，A 到 Z 的所有字符</td></tr><tr class="even"><td><code>[a-d[m-p]]</code></td><td>a 到 d，m 到 p</td></tr><tr class="odd"><td><code>[a-z&amp;&amp;[def]]</code></td><td>a-z 和 def 到交集，在这里相当于 <code>[def]</code></td></tr><tr class="even"><td><code>[a-z&amp;&amp;[^bc]]</code></td><td>a-z 和非 bc 的交集</td></tr><tr class="odd"><td><code>[a-z&amp;&amp;[^m-p]]</code></td><td>a-z 和除了 m 到 p 的交集</td></tr></tbody></table><h5 id="预定义字符">预定义字符</h5><table><thead><tr class="header"><th>表达式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>.</code></td><td>任何字符</td></tr><tr class="even"><td><code>\d</code></td><td>一个数字（<code>[0-9]</code>）</td></tr><tr class="odd"><td><code>\D</code></td><td>非数字（<code>[^0-9]</code>）</td></tr><tr class="even"><td><code>\s</code></td><td>一个空白字符（<code>[\t\n\x0B\f\r]</code>）</td></tr><tr class="odd"><td><code>\S</code></td><td>非空白字符（<code>[^\t\n\x0B\f\r]</code>）</td></tr><tr class="even"><td><code>\w</code></td><td>英文、数字、下划线（<code>[a-zA-Z0-9_]</code>）</td></tr><tr class="odd"><td><code>\W</code></td><td>一个非单词字符（<code>[^a-zA-Z0-9_]</code>）</td></tr></tbody></table><h5 id="数量词">数量词</h5><table><thead><tr class="header"><th>表达式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>X?</code></td><td><code>X</code>， 一次或者零次</td></tr><tr class="even"><td><code>X*</code></td><td><code>X</code> ，零次或者多次</td></tr><tr class="odd"><td><code>X+</code></td><td><code>X</code> ，一次或者多次</td></tr><tr class="even"><td><code>X&#123;n&#125;</code></td><td><code>X</code> ，正好 n 次</td></tr><tr class="odd"><td><code>X&#123;n,&#125;</code></td><td><code>X</code> ，至少 n 次</td></tr><tr class="even"><td><code>X&#123;n,m&#125;</code></td><td><code>X</code> ，至少 n 次，不超过 m 次</td></tr></tbody></table><h5 id="特殊字符">特殊字符</h5><table><thead><tr class="header"><th>表达式</th><th>说明</th></tr></thead><tbody><tr class="odd"><td><code>$</code></td><td>匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline属性，则 <code>$</code> 也匹配 <code>\n</code> 或<code>\r</code>。要匹配 <code>$</code> 字符本身，请使用 <code>\$</code>。</td></tr><tr class="even"><td><code>()</code></td><td>标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用<code>\(</code> 和 <code>\)</code> 。</td></tr><tr class="odd"><td><code>|</code></td><td>指明两项之间的一个选择。要匹配 <code>|</code> ，请使用<code>\|</code> 。</td></tr></tbody></table><h5 id="典型案例">典型案例</h5><ul><li>匹配网址 URL：<code>[a-zA-z]+://[^\s]*</code></li><li>匹配中国邮编编码：<code>[1-9]\d&#123;5&#125;(?!\d)</code></li><li>匹配 18位身份证：<code>^(\d&#123;6&#125;)(\d&#123;4&#125;)(\d&#123;2&#125;)(\d&#123;2&#125;)(\d&#123;3&#125;)([0-9]|X)$</code></li></ul><p><ahref="https://tool.oschina.net/regex">正则表达式在线测试工具</a></p><h4 id="实际运用">实际运用</h4><p>当前大多数流行语言都有自己的正则表达式库，例如 C++11 更新的 <ahref="https://zh.cppreference.com/w/cpp/regex">Regex 库</a> 。</p><p>今天我们以 Java 为例，讲解正则表达式的一些实际运用。</p><p><strong>Java 中的 <code>String</code> 内置正则匹配方法</strong></p><ul><li><p><code>matches()</code> 方法：</p><blockquote><p><code>boolean matches(String regex)</code>，根据正则表达式，判断字符串是否能匹配成功，返回对应的布尔值</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 匹配手机号码</span><br><span class="hljs-comment">// 以 1 开头</span><br><span class="hljs-comment">// 第二位只能是 3 到 9</span><br><span class="hljs-comment">// 任意数字 9 位</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex_1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1[3-9]\\d&#123;9&#125;&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;13170488669&quot;</span>.matches(regex_1)); <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 匹配座机号码</span><br><span class="hljs-comment">// 区号 以 0 开头</span><br><span class="hljs-comment">// 中间可能有 -</span><br><span class="hljs-comment">// 号码总长度 5 到 10 位</span><br><span class="hljs-type">String</span> <span class="hljs-variable">regex_2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;0\\d&#123;2,3&#125;-?[1-9]\\d&#123;4,9&#125;&quot;</span>;<br>System.out.println(<span class="hljs-string">&quot;027-142424&quot;</span>.matches(regex_2)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>replaceFirst()</code> 方法和 <code>replaceAll()</code>方法：</p><blockquote><p><code>String replaceFirst(String regex, String replacement)</code>，将字符串匹配到的第一个子串进行替换，返回新字符串。</p><p><code>String replaceAll(String regex, String replacement)</code>，将字符串所有匹配成功的子串进行替换，返回新字符串。</p></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Isaac Newton&quot;</span>;<br><span class="hljs-comment">// 隐藏姓名</span><br>System.out.println(name.replaceFirst(<span class="hljs-string">&quot;[a-zA-Z]+&quot;</span>, <span class="hljs-string">&quot;*****&quot;</span>)); <span class="hljs-comment">// ***** Newton</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12-(900)84632&quot;</span>;<br><span class="hljs-comment">// 删除所有非数字字符</span><br>System.out.println(number.replaceAll(<span class="hljs-string">&quot;[^0-9]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)); <span class="hljs-comment">// 1290084632</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>split()</code> 方法：</p><blockquote><p><code>String[] split(String regex)</code></p><p><code>String[] split(String regex, int limit)</code></p><p>根据正则表达式对字符串进行分割，返回分割后的字符串数组。</p><p>这里 <code>limit</code> 参数用来控制分割次数：</p><ul><li>若 <code>limit &gt; 0</code> ：字符串最多被分割 n - 1 次，返回长度为n 的字符串数组</li><li>若 <code>limit &lt;= 0</code>：字符串被尽可能多次分割，返回尽可能长的字符串数组</li></ul></blockquote><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] member = <span class="hljs-string">&quot;张三, 李四, 王五&quot;</span>.split(<span class="hljs-string">&quot;, &quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> name : member) System.out.println(name);<br><span class="hljs-comment">// 张三</span><br><span class="hljs-comment">// 李四</span><br><span class="hljs-comment">// 王五</span><br></code></pre></td></tr></table></figure></p></li></ul><p><strong>练习</strong></p><p><ahref="https://leetcode.cn/problems/camelcase-matching">驼峰匹配</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> List&lt;Boolean&gt; <span class="hljs-title function_">camelMatch</span><span class="hljs-params">(String[] queries, String pattern)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">regexModel</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;[a-z]*&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = pattern.length(); i &lt; len; i++) &#123;<br>            regexModel += (pattern.charAt(i) + <span class="hljs-string">&quot;[a-z]*&quot;</span>);<br>        &#125;<br>        ArrayList&lt;Boolean&gt; ans = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, len = queries.length; i &lt; len; i++) &#123;<br>            ans.add(queries[i].matches(regexModel));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>正则表达式</tag>
      
      <tag>字符串</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>讲解 C++ 匿名函数</title>
    <link href="/2023/03/30/%E8%AE%B2%E8%A7%A3%20C++%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <url>/2023/03/30/%E8%AE%B2%E8%A7%A3%20C++%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><strong>匿名函数</strong>，也叫 Lambda 表达式，是 C++ 11提出的特性，匿名函数能使得我们的程序更加灵活轻便。</p><hr /><h4 id="基本语法">基本语法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">[capture](para) -&gt; returnType &#123; body &#125;<br></code></pre></td></tr></table></figure><ul><li><code>capture</code> ：闭包</li><li><code>para</code> ：参数</li><li><code>returnType</code> ：返回类型</li><li><code>body</code> ：函数体</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">auto</span> fun = [](<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y) &#123; <span class="hljs-keyword">return</span> x + y; &#125;;<br>std::cout &lt;&lt; <span class="hljs-built_in">fun</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h5 id="闭包">闭包</h5><p><code>capture</code>称为闭包，作用是引用匿名函数体外的变量，其有如下格式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">[]<span class="hljs-comment">// 不引用外部变量，无法在函数体内使用外部变量</span><br>[x, &amp;y]<span class="hljs-comment">// x 按值捕获，y 按照引用捕获</span><br>[&amp;]<span class="hljs-comment">// 可以捕获所有外部变量，按照引用捕获</span><br>[=]<span class="hljs-comment">// 可以捕获所有外部变量，按照值捕获</span><br>[&amp;, x]<span class="hljs-comment">// x 按照值捕获，其余所有变量按照引用捕获</span><br>[=, &amp;y]<span class="hljs-comment">// y 按照引用捕获，其余所有变量按照值捕获</span><br>[<span class="hljs-keyword">this</span>]<span class="hljs-comment">// 通过引用捕获当前对象</span><br>[*<span class="hljs-keyword">this</span>]<span class="hljs-comment">// 通过传值的方式捕获当前对象</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; arr = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><br>    <span class="hljs-keyword">auto</span> fun = [&amp;sum](<span class="hljs-type">int</span> x) &#123; sum += x; &#125;;<br>    <span class="hljs-comment">// auto fun = [sum](int x) &#123; sum += x; &#125;; 报错，sum 必须是可修改的左值，故只能通过引用的方式捕获</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : arr) &#123;<br>        <span class="hljs-built_in">fun</span>(x);<br>    &#125;<br><br>    std::cout &lt;&lt; sum &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 15</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="运用">运用</h4><p>匿名函数的运用十分灵活，以下我们举几个常见的例子：</p><ul><li><p>在 <code>STL</code> 的排序函数中自定义排序方式：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Student</span> &#123;<br>    std::string name;<br>    <span class="hljs-type">int</span> grade;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::vector&lt;Student&gt; s_arr = &#123;&#123;<span class="hljs-string">&quot;Jack&quot;</span>, <span class="hljs-number">99</span>&#125;, &#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">97</span>&#125;, &#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">83</span>&#125;, &#123;<span class="hljs-string">&quot;Carl&quot;</span>, <span class="hljs-number">100</span>&#125;, &#123;<span class="hljs-string">&quot;Clara&quot;</span>, <span class="hljs-number">66</span>&#125;&#125;;<br>    std::<span class="hljs-built_in">sort</span>(s_arr.<span class="hljs-built_in">begin</span>(), s_arr.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Student&amp; s1, <span class="hljs-type">const</span> Student&amp; s2) &#123;<br>        <span class="hljs-keyword">return</span> s1.grade &gt; s2.grade;<br>    &#125;); <span class="hljs-comment">// 自定义学生成绩按照降序排序</span><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; s : s_arr) &#123;<br>        std::cout &lt;&lt; s.name &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span> &lt;&lt; s.grade &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-comment">// Carl 100</span><br>    <span class="hljs-comment">// Jack 99</span><br>    <span class="hljs-comment">// Alice 97</span><br>    <span class="hljs-comment">// Bob 83</span><br>    <span class="hljs-comment">// Clara 66</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>定义一个匿名函数作为参数的函数：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">solve</span><span class="hljs-params">(std::function&lt;<span class="hljs-type">double</span>(<span class="hljs-type">double</span>)&gt; fn, <span class="hljs-type">double</span> left, <span class="hljs-type">double</span> right, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 求一元函数在区间 [left, right] 的定积分</span><br>    <span class="hljs-type">double</span> res = -<span class="hljs-built_in">fn</span>(left) + <span class="hljs-built_in">fn</span>(right);<br>    <span class="hljs-type">double</span> d = (right - left) / n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        res += <span class="hljs-number">2</span> * <span class="hljs-built_in">fn</span>(left + i * d) + <span class="hljs-number">4</span> * <span class="hljs-built_in">fn</span>(left + (i + <span class="hljs-number">0.5</span>) * d);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> d * res / <span class="hljs-number">6</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    std::cout &lt;&lt; <span class="hljs-built_in">solve</span>([](<span class="hljs-type">double</span> x) &#123; <span class="hljs-keyword">return</span> x * x * x; &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>; <span class="hljs-comment">// 0.25</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>匿名函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树状数组和线段树</title>
    <link href="/2023/03/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    <url>/2023/03/30/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E5%92%8C%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>树状数组和线段树是两种常用的数据结构，其可以大大提升数组的区间查询的效率，同时也保证了数据修改的灵活度。</p><table><thead><tr class="header"><th></th><th>一般数组</th><th>前缀和数组</th><th>树状数组</th><th>线段树</th></tr></thead><tbody><tr class="odd"><td>单点查询</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr><tr class="even"><td>区间查询</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr><tr class="odd"><td>单点修改</td><td><span class="math inline">\(O(1)\)</span></td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr><tr class="even"><td>区间修改</td><td><span class="math inline">\(O(n)\)</span></td><td><span class="math inline">\(O(n^2)\)</span></td><td><span class="math inline">\(O(nlogn)\)</span></td><td><span class="math inline">\(O(logn)\)</span></td></tr></tbody></table><h4 id="树状数组">树状数组</h4><p>树状数组的原理讲解可以参考视频：<ahref="https://www.bilibili.com/video/BV1ce411u7qP/?spm_id_from=333.337.search-card.all.click&amp;vd_source=8ba5b8b5f59444a6cbd4c3984325e82f">五分钟丝滑动画讲解| 树状数组</a></p><p><img src="https://p.ipic.vip/4rorce.png" style="zoom: 33%;" /></p><h5id="用于区间求和和单点修改的数状数组模版">用于区间求和和单点修改的数状数组模版</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BIT</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">lowbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-comment">// 数状数组第 i 项的区间长度为 lowbit(i)</span><br>        <span class="hljs-keyword">return</span> x &amp; -x;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-type">int</span> m)</span> </span>&#123;<br>        <span class="hljs-comment">// 求前 m 项的和</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (m) &#123;<br>            res += tree[m];<br>            m -= <span class="hljs-built_in">lowbit</span>(m);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">BIT</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(_n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 单点修改</span><br>        <span class="hljs-keyword">while</span> (idx &lt;= n) &#123;<br>            tree[idx] += val;<br>            idx += <span class="hljs-built_in">lowbit</span>(idx);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-comment">// 区间求和</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">count</span>(right) - <span class="hljs-built_in">count</span>(left - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><ul><li>树状数组的核心就是 <code>lowbit()</code> 函数，数状数组第<code>i</code> 项代表的区间长度为 <code>lowbit(i)</code></li><li>树状数组的下标只能从 1 开始，不能从 0 开始</li></ul></blockquote><h4 id="线段树">线段树</h4><p>线段树相对于树状数组而言则更为灵活，其可以实现高效区间修改。</p><p>线段树的原理就是将数组的区间储存在二叉树的节点中，<code>[left, right]</code>区间对应的左右节点分别为 <code>[left, mid]</code> 和<code>[mid + 1, right]</code>（<code>mid = (left + right) / 2</code>)。</p><p><img src="https://p.ipic.vip/3phmiu.png" style="zoom:33%;" /></p><blockquote><p>‼️注：线段树的数组长度要开到原数组长度的 4 倍</p></blockquote><h5 id="用于区间求和的线段树模版">用于区间求和的线段树模版</h5><ul><li>单点更新</li><li>区间求和</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 单点更新</span><br>        <span class="hljs-keyword">if</span> (start == end) &#123;<br>            tree[node] = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (idx &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, leftNode, start, mid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, rightNode, mid + <span class="hljs-number">1</span>, end);<br>        &#125;<br><br>        tree[node] = tree[leftNode] + tree[rightNode];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 区间求和</span><br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> tree[node];<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeSum</span>(left, right, leftNode, start, mid) + <span class="hljs-built_in">rangeSum</span>(left, right, rightNode, mid + <span class="hljs-number">1</span>, end);<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(<span class="hljs-number">4</span> * _n, <span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">update</span>(idx, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeSum</span>(left, right, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="用于求区间极值的线段树模版">用于求区间极值的线段树模版</h5><ul><li>单点更新</li><li>区间求极值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 单点更新</span><br>        <span class="hljs-keyword">if</span> (start == end) &#123;<br>            tree[node] = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (idx &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, leftNode, start, mid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, rightNode, mid + <span class="hljs-number">1</span>, end);<br>        &#125;<br><br>        tree[node] = std::<span class="hljs-built_in">max</span>(tree[leftNode], tree[rightNode]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxVal</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 求区间极大值</span><br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span> INT_MIN;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> tree[node];<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <br>        <span class="hljs-keyword">return</span> std::<span class="hljs-built_in">max</span>(<span class="hljs-built_in">maxVal</span>(left, right, leftNode, start, mid), <span class="hljs-built_in">maxVal</span>(left, right, rightNode, mid + <span class="hljs-number">1</span>, end));<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(<span class="hljs-number">4</span> * _n, <span class="hljs-number">0</span>) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">update</span>(idx, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxVal</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">maxVal</span>(left, right, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><hr /><p>有时候我们可能会遇到这样的需求：要多次将数组中一个区间内的每个元素都添加一个固定的值，如果逐一修改，则会消耗大量的时间，这个时候我们就可以使用带延迟标记的线段树。</p><p>什么是延迟标记？</p><p>——即对线段树的某个节点的数据更新完后不急于对其子节点进行更新，而是将更新信息存储下来，而当必须更新的时候再将信息传递给子节点。</p><h5id="使用延迟标记进行区间修改的线段树模版">使用延迟标记进行区间修改的线段树模版</h5><ul><li>区间修改</li><li>区间求和</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; tree;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; lazy;<br><br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">maintain</span><span class="hljs-params">(<span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 传递 lazy 标签</span><br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        tree[leftNode] += (mid - start + <span class="hljs-number">1</span>) * lazy[node];<br>        lazy[leftNode] += lazy[node];<br>        tree[rightNode] += (end - mid) * lazy[node];<br>        lazy[rightNode] += lazy[node];<br>        lazy[node] = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 给区间 [left, right] 的所有数添加 val</span><br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) &#123;<br>            tree[node] += (end - start + <span class="hljs-number">1</span>) * val;<br>            lazy[node] += val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (lazy[node]) <span class="hljs-built_in">maintain</span>(node, start, end);<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">add</span>(left, right, val, leftNode, start, mid);<br>        <span class="hljs-built_in">add</span>(left, right, val, rightNode, mid + <span class="hljs-number">1</span>, end);<br><br>        tree[node] = tree[leftNode] + tree[rightNode];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-comment">// 区间求和</span><br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> tree[node];<br>        <span class="hljs-keyword">if</span> (lazy[node]) <span class="hljs-built_in">maintain</span>(node, start, end);<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeSum</span>(left, right, leftNode, start, mid) + <span class="hljs-built_in">rangeSum</span>(left, right, rightNode, mid + <span class="hljs-number">1</span>, end);<br>    &#125;<br><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegmentTree</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(<span class="hljs-number">4</span> * _n), <span class="hljs-built_in">lazy</span>(<span class="hljs-number">4</span> * _n) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">add</span>(left, right, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">rangeSum</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">rangeSum</span>(left, right, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="案例">案例</h4><ul><li><p><ahref="https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid">网格图中最少访问的格子数（线段树单点修改 + 区间查询）</a></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SegTree</span> &#123;<br><span class="hljs-comment">// 单点修改 + 区间查询</span><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> n;<br>    vector&lt;<span class="hljs-type">int</span>&gt; tree;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start == end) &#123;<br>            tree[node] = val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (idx &lt;= mid) &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, leftNode, start, mid);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">update</span>(idx, val, rightNode, mid + <span class="hljs-number">1</span>, end);<br>        &#125;<br><br>        tree[node] = <span class="hljs-built_in">min</span>(tree[leftNode], tree[rightNode]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> node, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (start &gt; right || end &lt; left) <span class="hljs-keyword">return</span> INT_MAX;<br>        <span class="hljs-keyword">if</span> (start &gt;= left &amp;&amp; end &lt;= right) <span class="hljs-keyword">return</span> tree[node];<br><br>        <span class="hljs-type">int</span> leftNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">1</span>, rightNode = <span class="hljs-number">2</span> * node + <span class="hljs-number">2</span>;<br>        <span class="hljs-type">int</span> mid = (start + end) / <span class="hljs-number">2</span>;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">min</span>(<span class="hljs-built_in">query</span>(left, right, leftNode, start, mid), <span class="hljs-built_in">query</span>(left, right, rightNode, mid + <span class="hljs-number">1</span>, end));<br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">SegTree</span>(<span class="hljs-type">int</span> _n): <span class="hljs-built_in">n</span>(_n), <span class="hljs-built_in">tree</span>(<span class="hljs-number">4</span> * _n, INT_MAX) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> val)</span> </span>&#123;<br>        <span class="hljs-built_in">update</span>(idx, val, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(left, right, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">minimumVisitedCells</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;<br>        <span class="hljs-type">int</span> m = grid.<span class="hljs-built_in">size</span>(), n = grid[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">SegTree <span class="hljs-title">trRow</span><span class="hljs-params">(m * n)</span></span>;<br>        <span class="hljs-function">SegTree <span class="hljs-title">trCol</span><span class="hljs-params">(n * m)</span></span>;<br>        trRow.<span class="hljs-built_in">update</span>(m * n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        trCol.<span class="hljs-built_in">update</span>(n * m - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = m - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = n - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-type">int</span> resRow = trRow.<span class="hljs-built_in">query</span>(n * i + j, n * i + <span class="hljs-built_in">min</span>(j + grid[i][j], n - <span class="hljs-number">1</span>));<br>                <span class="hljs-comment">// (i, j) ~ (i, j + grid[i][j]) 中的最小值</span><br>                <span class="hljs-type">int</span> resCol = trCol.<span class="hljs-built_in">query</span>(m * j + i, m * j + <span class="hljs-built_in">min</span>(i + grid[i][j], m - <span class="hljs-number">1</span>));<br>                <span class="hljs-comment">// (i, j) ~ (i + grid[i][j], j) 中的最小值</span><br>                <span class="hljs-type">int</span> res = <span class="hljs-built_in">min</span>(resRow, resCol);<br>                <span class="hljs-keyword">if</span> (res != INT_MAX) &#123;<br>                    trRow.<span class="hljs-built_in">update</span>(n * i + j, res + <span class="hljs-number">1</span>);<br>                    trCol.<span class="hljs-built_in">update</span>(m * j + i, res + <span class="hljs-number">1</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-type">int</span> ans = trRow.<span class="hljs-built_in">query</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> ans != INT_MAX ? ans : <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数状数组</tag>
      
      <tag>线段树</tag>
      
      <tag>区间查询</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>std::bitset 讲解</title>
    <link href="/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/03/08/std-bitset%20%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h4 id="介绍">介绍</h4><p><code>std::bitset</code> 是 C++ 提供的一种 n-bit固定大小序列的模版，可以用于标准逻辑运算，并且可以与字符串和整数相互转换，还可以使用标准流输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span>&lt; std::<span class="hljs-type">size_t</span> N &gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">bitset</span>;<br></code></pre></td></tr></table></figure><blockquote><p>模版形参 <code>N</code> ：要为 <code>bitset</code> 分配储存的 bit位数</p></blockquote><p><strong>头文件：<code>&lt;bitset&gt;</code></strong></p><h4 id="构造方法">构造方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bitset&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-comment">// 1. 无参构造</span><br>    std::bitset&lt;5&gt; testCase_1;<br>    std::cout &lt;&lt; testCase_1 &lt;&lt; std::endl; <span class="hljs-comment">// 00000</span><br><br>    <span class="hljs-comment">// 2. 传入整数</span><br>    std::bitset&lt;4&gt; testCase_2&#123;<span class="hljs-number">0xb</span>&#125;;<br>    std::cout &lt;&lt; testCase_2 &lt;&lt; std::endl; <span class="hljs-comment">// 1011</span><br><br>    std::bitset&lt;4&gt; testCase_3&#123;<span class="hljs-number">0x10</span>&#125;; <span class="hljs-comment">// 溢出位自动截断</span><br>    std::cout &lt;&lt; testCase_3 &lt;&lt; std::endl; <span class="hljs-comment">// 0000</span><br><br>    <span class="hljs-comment">// 3. 传入字符串</span><br>    std::bitset&lt;8&gt; testCase_4&#123;<span class="hljs-string">&quot;10010101&quot;</span>&#125;; <span class="hljs-comment">// 传入 0-1 字符串</span><br>    std::cout &lt;&lt; testCase_4 &lt;&lt; std::endl; <span class="hljs-comment">// 10010101</span><br><br>    std::bitset&lt;4&gt; testCase_5&#123;<span class="hljs-string">&quot;10010101&quot;</span>&#125;; <span class="hljs-comment">// 溢出位截断，只取前 4 位</span><br>    std::cout &lt;&lt; testCase_5 &lt;&lt; std::endl; <span class="hljs-comment">// 1001</span><br><br>    std::bitset&lt;8&gt; testCase_6&#123;<span class="hljs-string">&quot;ABABA&quot;</span>, <span class="hljs-comment">/* 读取长度 */</span><span class="hljs-number">4</span>, <span class="hljs-comment">/* 代表 0 的字符 */</span><span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-comment">/* 代表 1 的字符 */</span><span class="hljs-string">&#x27;B&#x27;</span>&#125;; <span class="hljs-comment">// 00000101</span><br>    std::cout &lt;&lt; testCase_6 &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 4. 支持赋值构造以及整数和字符串到 bitset 的强制类型转化</span><br>    std::bitset&lt;8&gt; testCase_7 = testCase_6;<br>    std::cout &lt;&lt; testCase_7 &lt;&lt; std::endl; <span class="hljs-comment">// 00000101</span><br><br>    std::cout &lt;&lt; (std::bitset&lt;<span class="hljs-number">8</span>&gt;)<span class="hljs-number">0xf</span> &lt;&lt; std::endl; <span class="hljs-comment">// 00001111</span><br>    std::cout &lt;&lt; (std::bitset&lt;<span class="hljs-number">8</span>&gt;)<span class="hljs-string">&quot;1111&quot;</span> &lt;&lt; std::endl; <span class="hljs-comment">// 00001111</span><br><br>    std::bitset&lt;10&gt; testCase_8 = <span class="hljs-number">0x7f</span>;<br>    std::cout &lt;&lt; testCase_8 &lt;&lt; std::endl; <span class="hljs-comment">// 0001111111</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="成员方法">成员方法</h4><ul><li><p>支持下标 <code>operator[]</code></p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-string">&quot;111011&quot;</span>;<br>std::cout &lt;&lt; num[<span class="hljs-number">2</span>] &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 从低位开始</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>bitset</code> 支持所有常规位运算操作</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = <span class="hljs-number">0xf</span>;<br><br>std::cout &lt;&lt; (num &amp; (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-number">0x12</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000000010</span><br>std::cout &lt;&lt; (num | (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-number">0x12</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000011111</span><br>std::cout &lt;&lt; (num ^ (std::bitset&lt;<span class="hljs-number">10</span>&gt;)<span class="hljs-number">0x12</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000011101</span><br>std::cout &lt;&lt; (num &lt;&lt; <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000111100</span><br>std::cout &lt;&lt; (num &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0000000011</span><br><br>num = <span class="hljs-number">-1</span>;<br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111111111</span><br>std::cout &lt;&lt; (num &gt;&gt; <span class="hljs-number">2</span>) &lt;&lt; std::endl; <span class="hljs-comment">// 0011111111</span><br><span class="hljs-comment">// 对 bitset 的右移都是逻辑右移</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>set()</code> ：设置单独位的值</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = <span class="hljs-number">-1</span>;<br>num.<span class="hljs-built_in">set</span>(<span class="hljs-number">0</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 将下标为 0 的位设置为 0</span><br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111111110</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>flip()</code> ：取反，无参数时默认对全部位</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num = <span class="hljs-number">0xf</span>;<br>num.<span class="hljs-built_in">flip</span>();<br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111110000</span><br>num.<span class="hljs-built_in">flip</span>(<span class="hljs-number">1</span>);<br>std::cout &lt;&lt; num &lt;&lt; std::endl; <span class="hljs-comment">// 1111110010</span><br></code></pre></td></tr></table></figure></p></li><li><p>检查位</p><ul><li><code>all()</code> ：判断是否所有位都为 1</li><li><code>any()</code> ：判断是否有任意一位为 1</li><li><code>none()</code> ：判断是否所有位为 0</li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;4&gt; num = <span class="hljs-number">0x7</span>;<br><br>std::cout &lt;&lt; num.<span class="hljs-built_in">all</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br>std::cout &lt;&lt; num.<span class="hljs-built_in">any</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 1</span><br>std::cout &lt;&lt; num.<span class="hljs-built_in">none</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>count()</code> ：返回 1 的数量</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;4&gt; num = <span class="hljs-number">0x7</span>;<br><br>std::cout &lt;&lt; num.<span class="hljs-built_in">count</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure></p></li><li><p><code>size()</code> ：返回位数</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;10&gt; num;<br>std::cout &lt;&lt; num.<span class="hljs-built_in">size</span>() &lt;&lt; std::endl; <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure></p></li><li><p>转换：</p><ul><li><code>to_string()</code> ：返回数据的字符串类型</li><li><code>to_ulong</code> ：返回数据的 <code>unsigned long</code>整数表示</li><li><code>to_ullong</code> ：返回数据的 <code>unsigned long long</code>整数表示</li></ul><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">std::bitset&lt;8&gt; num_bit = <span class="hljs-number">0xf</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> num_1 = num_bit.<span class="hljs-built_in">to_ulong</span>();<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> num_2 = num_bit.<span class="hljs-built_in">to_ullong</span>();<br>std::string str = num_bit.<span class="hljs-built_in">to_string</span>();<br><br>std::cout &lt;&lt; num_1 &lt;&lt; std::endl; <span class="hljs-comment">// 15</span><br>std::cout &lt;&lt; num_2 &lt;&lt; std::endl; <span class="hljs-comment">// 15</span><br>std::cout &lt;&lt; str &lt;&lt; std::endl; <span class="hljs-comment">// 00001111</span><br></code></pre></td></tr></table></figure></p><p>​</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>位运算</tag>
      
      <tag>C++</tag>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链式前向星介绍</title>
    <link href="/2023/03/06/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/03/06/%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是链式前向星">什么是链式前向星？</h4><p><strong>链式前向星</strong>是一种常用的图存储结构，其思路类似于邻接链表法，只是实现方式有所不同，链式向前星更像是<strong>用数组模拟链表</strong>。</p><p>与一般的邻接链表法不同，链式向前星储存的图的<strong>每条边都有编号</strong>。</p><p>以下是链式前向星的存储结构：</p><ul><li><p><code>cnt</code> ：用来记录当前所有边的数量</p></li><li><p><code>first</code> 数组：用来存储从某个节点出发的第一条边，例如<code>first[0] == 3</code> 可以得出从 <code>0</code>号节点出发的第一条边的编号为 <code>3</code></p></li><li><p><code>edges</code> 数组：用来记录每条边的信息，对于每个<code>edges[i]</code> 都有 3 个域：</p><ul><li><code>to</code> ：记录边的终点</li><li><code>weight</code> ：记录边的权重</li><li><code>next</code> ：记录从当前起点出发下一条边的编号，例如：若<code>edges[i]</code> 的起点为 <code>j</code> 号节点，则<code>edges[i].next</code> 表示从 <code>j</code> 出发的下一条边</li></ul></li></ul><p>示例：</p><p><img src="https://p.ipic.vip/wvox68.png" alt="链式向前星存储图示例" style="zoom:67%;" /></p><blockquote><p>如上图，这就是链式向前星存储图的方式了，其中编号为 -1的边表示不存在，即没有其他的出边。</p><p>若我们需要新增一条从 <code>i</code> 到 <code>j</code>的边，只需更新在 <code>edges</code> 数组内增加元素并且使其新增边的<code>next</code> 等于 <code>first[i]</code> ，然后更新<code>first[i]</code> 为新增的边的编号即可。</p></blockquote><h4 id="代码">代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_VERTEX 100000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_EDGE 100000</span><br><br><span class="hljs-type">int</span> cnt; <span class="hljs-comment">// 边的数量</span><br><br><span class="hljs-type">int</span> first[MAX_VERTEX]; <span class="hljs-comment">// first 数组</span><br><br><span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> to;<br>    <span class="hljs-type">int</span> weight;<br>    <span class="hljs-type">int</span> next;<br>&#125; edges[MAX_EDGE]; <span class="hljs-comment">// 记录边</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">initEdge</span><span class="hljs-params">()</span> </span>&#123;<br>    cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 初始化，将 first 数组全初始化为 -1</span><br>    <span class="hljs-built_in">memset</span>(first, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(first));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(<span class="hljs-type">int</span> from, <span class="hljs-type">int</span> to, <span class="hljs-type">int</span> weight)</span> </span>&#123;<br>    edges[cnt] = &#123;to, weight, first[from]&#125;; <span class="hljs-comment">// 新增边</span><br>    first[from] = cnt; <span class="hljs-comment">// 更新 first 数组</span><br>    cnt++; <span class="hljs-comment">// 边数增加</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverseEdgeFrom</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> </span>&#123;<br>    <span class="hljs-comment">// 遍历从 v 出发的所有边</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = first[v]; p != <span class="hljs-number">-1</span>; p = edges[p].next) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;eNo: &quot;</span> &lt;&lt; p &lt;&lt; <span class="hljs-string">&quot; to: &quot;</span> &lt;&lt; edges[p].to &lt;&lt; <span class="hljs-string">&quot; weight: &quot;</span> &lt;&lt; edges[p].weight &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图论</tag>
      
      <tag>链式前向星</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ICG 游戏博弈问题与 SG 定理</title>
    <link href="/2023/03/02/ICG%20%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98%E4%B8%8E%20SG%20%E5%AE%9A%E7%90%86/"/>
    <url>/2023/03/02/ICG%20%E6%B8%B8%E6%88%8F%E5%8D%9A%E5%BC%88%E9%97%AE%E9%A2%98%E4%B8%8E%20SG%20%E5%AE%9A%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="icg-游戏">ICG 游戏</h3><h4 id="定义">定义</h4><p><strong>ICG</strong> 游戏是博弈游戏的一种，其定义如下：</p><ol type="1"><li>游戏由两人参加，两人轮流做出决策</li><li>当有一人无法决策即无论如何都必败时对手胜出，且 ICG游戏一定会在有限步内完成，游戏没有平局</li><li>游戏的状态转移是单向的，同一个状态只能达到一次</li></ol><h4 id="必胜点和必败点">必胜点和必败点</h4><p>必胜点 N ( Next ) 和必败点 P ( Previous )描述的是某个游戏状态当前的胜负。</p><p>若当前状态为必胜点 N ，则先手必胜，反之，若当前状态为必败点 P，则先手必败。</p><p>可能到这里为止大家还是会觉得比较抽象，所以我们给出一个实际例子：</p><p>假设有一堆石头，两人轮流从这堆石头中取走 1 ~ 5 块石头，初始状态下有 n块石头，问 n 为何值时先手必胜？</p><p>先说结论：<code>n % 6 != 0</code> 时先手必胜。</p><p>原因十分简单，若 n 不是 6 的倍数，则先手一定可以取走 1 ～ 5块内的石头使得取走石头后这堆石头的数量能被 6 整除，此后，对手只要取走 m块石头，我们就取走 6 - m块石头，<strong>可以保证我们每次取完后石头的数量都是 6的倍数</strong>。如此一来，最后的石头一定是被我们取走。</p><p>于是，我们可以得到石头数量 n 对应的 NP 状态：</p><table style="width:100%;"><thead><tr class="header"><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>...</th></tr></thead><tbody><tr class="odd"><td><strong>state</strong></td><td><strong>P</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>P</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>N</strong></td><td><strong>...</strong></td></tr></tbody></table><p>在这里，我们不难得出结论：</p><ul><li><strong>所有必胜点必然可以在一步操作内转移到必败点</strong></li><li><strong>所有必败点无论如何操作只能转移到必胜点</strong></li></ul><h3 id="sg-定理">SG 定理</h3><p>SG 是 Sprague-Grundy 的缩写，SG 定理是处理 ICG博弈问题的重要方法，在讲解其使用之前，我们先简要介绍一下 SG函数的定义。</p><h4 id="sg-函数">SG 函数</h4><p>首先我们定义 <strong><span class="math inline">\(mex\)</span> (minimal excludant )</strong> 运算，<spanclass="math inline">\(mex(F)\)</span> 即表示不属于非负整数集 <spanclass="math inline">\(F\)</span> 中最小的元素：</p><p>例如： <span class="math display">\[\begin{array}{}mex(\{1, 2, 3\}) = 0 \\mex(\{0, 1, 3, 4\}) = 2 \\mex(\emptyset) = 0\end{array}\]</span> 什么是 SG 值？</p><p>SG值是一种通过递归定义的值，它一般情况下是一个非负整数，可以用来描述游戏状态是必胜点还是必败点，假设游戏状态<span class="math inline">\(V_i\)</span> 的 SG 值为 <spanclass="math inline">\(SG(V_i)\)</span> ，那么其状态转移方程如下： <spanclass="math display">\[SG(V_i) = mex(\{SG(V_j) \ | \ V_i \rightarrow V_j \})\]</span> 其数值上等于与 <span class="math inline">\(V_i\)</span>所有后继状态的 SG 值不相等的最小非负整数。</p><p>基于此，我们得到一条重要结论：<strong>SG 值不为 0 的状态为必胜点，SG值为 0 的状态为必败点</strong>。</p><p>这个结论很好证明：若 SG 值不为 0，说明该状态一定能一步转移到 SG 值为0 的状态，即可以一步转移到必败点，所以该状态一定为必胜点；反之，若 SG值为0，则该状态无法一步转移到必败点，只能转移到必胜点或者无法决策，故该点一定为必败点。</p><p>我们还是用上述的取石头问题来举例说明，则不同石头数量 n 对应的 SG值如下：</p><table style="width:100%;"><thead><tr class="header"><th>n</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th><th>9</th><th>10</th></tr></thead><tbody><tr class="odd"><td><strong>SG(n)</strong></td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td></tr></tbody></table><p><span class="math display">\[\begin{array}{}SG(0) = mex(\emptyset) = 0 \\SG(1) = mex(\{0\}) = 1 \\SG(2) = mex(\{0, 1\}) = 2 \\SG(3) = mex(\{0, 1, 2\}) = 3 \\SG(4) = mex(\{0, 1, 2, 3\}) = 4 \\SG(5) = mex(\{0, 1, 2, 3, 4\}) = 5 \\SG(6) = mex(\{1, 2, 3, 4, 5\}) = 0 \\... \newlineSG(10) = mex(\{5, 0, 1, 2, 3\}) = 4 \\...\end{array}\]</span></p><h4 id="sg-定理详解">SG 定理详解</h4><p>现在我们已经知道了 SG 函数的定义，那 SG 定理又是什么呢？</p><hr /><h5 id="什么是-sg-定理">什么是 SG 定理 ?</h5><p>SG 定理指的是<strong>若一个 ICG博弈游戏的游戏状态可以分为多个子状态，且子状态互相独立，则该游戏状态下的SG 值等于所有子状态的 SG 值的异或值</strong>。</p><p>这又是什么意思呢？别急，我们还是用取石头的例子来说明：</p><p>假设现在有 <span class="math inline">\(k\)</span> 堆石头，每堆石头有<span class="math inline">\(n_i(i = 1, 2, ...,k)\)</span> 块石头，两个人轮流从每一堆石头中取走 <span class="math inline">\([1,m]\)</span> 块石头，先取完所有石头的一方获胜。我们设此刻游戏状态的 SG值为 <span class="math inline">\(SG((n_1, n_2, ..., n_k))\)</span> ，由SG 定理可得： <span class="math display">\[SG((n_1, n_2, ..., n_k)) = SG(n_1) \oplus SG(n_2) \oplus ... \oplusSG(n_k)\]</span></p><ul><li><span class="math inline">\(SG((n_1, n_2, ..., n_k)) \neq 0\)</span>：先手胜</li><li><span class="math inline">\(SG((n_1, n_2, ..., n_k)) = 0\)</span>：先手败</li></ul><p>以上就是完整的 SG 定理了。</p><h5 id="sg-定理的合理性">SG 定理的合理性</h5><p>为什么 SG定理会与位运算的异或有关呢？它们是如何联系上的？为什么这种计算是合理的呢？</p><p>以下我们给出简要的证明：</p><p>根据 SG 值的定义，必败点的 SG 值一定为0，对于此题而言，游戏的终点就是所有的石头被取完，此时 SG 值是 k 个 0的异或值，显然为 0。</p><p>若当前的 SG 值不为 0，我们假设： <span class="math display">\[SG((n_1, n_2, ..., n_k)) = {001010..}_2\]</span> 我们找到该 SG 值数值为 1的最高位，由异或运算符的性质，必然存在奇数个子状态的 SG 值该位为1，我们不妨假设其中一个子状态对应的 SG 值为 <spanclass="math inline">\(SG_0\)</span> ，由 SG值的定义，该状态一定可以一步之内转变为任何 SG 值小于 <spanclass="math inline">\(SG_0\)</span> 的状态，<spanclass="math inline">\(SG_0\)</span> 对应母状态下数值为 1的最高位的值也为 1，我们让其变为0，然后从这一位开始之后全部位取反，则一定可以将母状态的 SG 值变为0。</p><center>0 1 0 1 1 1<br> <strong>0 1 1 0 0 0</strong><br> <ins>0 1 0 1 01</ins><br> 0 1 1 0 1 0<br> 如上，我们将第二个子状态 的 SG 值转移到 0 00 1 1 1，就将母状态的 SG 值转化为 0 了<br> 0 1 0 1 1 1<br> <strong>0 0 01 1 1</strong><br> <ins>0 1 0 1 0 1</ins><br> 0 0 0 0 0 0<br></center><p>反之，如果母状态的 SG 值为0，则改变任何一个子状态，由于异或运算的性质，母状态的 SG值一定无法维持为 0。</p><p>而根据 ICG 博弈游戏的定义，游戏一定会在有限步内完成，故所有子状态 SG值的异或运算不为 0 的母状态一定是必胜点。</p><h3 id="实际应用">实际应用</h3><blockquote><p><strong>Fibonacci again and again</strong></p><p>Problem Description 任何一个大学生对菲波那契数列(Fibonaccinumbers)应该都不会陌生，它是这样定义的： F(1) = 1； F(2) = 2； F(n) =F(n - 1) + F(n - 2) ( n &gt;= 3 )； 所以，1, 2, 3, 5, 8, 13, ...就是菲波那契数列。 今天，又一个关于 Fibonacci的题目出现了，它是一个小游戏，定义如下：</p><ol type="1"><li>这是一个二人游戏；</li><li>一共有 3 堆石子，数量分别是 m, n, p 个；</li><li>两人轮流走；</li><li>每走一步可以选择任意一堆石子，然后取走f个；</li><li>f 只能是菲波那契数列中的元素 ( 即每次只能取1，2，3，5，8 … 等数量)；</li><li>最先取光所有石子的人为胜者；</li></ol><p>假设双方都使用最优策略，请判断先手的人会赢还是后手的人会赢。</p><p><strong>Input</strong>输入数据包含多个测试用例，每个测试用例占一行，包含 3 个整数 m, n, p ( 1&lt;= m, n, p &lt;= 1000 )。 m = n = p = 0 则表示输入结束。</p><p><strong>Output</strong>如果先手的人能赢，请输出“Fibo”，否则请输出“Nacci”，每个实例的输出占一行。</p><p><strong>输入样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs input">1 1 1<br>1 4 1<br>0 0 0<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs output">Fibo<br>Nacci<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析</strong>：</p><p>本题所描述的游戏就是一种 ICG博弈，且三堆石头互不影响，所以我们可以直接使用 SG 定理求解，再加上记忆化DFS 优化，很容易就能求解此问题。废话不多说，直接上代码😎。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_FIB_NUM 50</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_AMOUNT 1005</span><br><br><span class="hljs-type">int</span> Fibonacci[MAX_FIB_NUM]; <span class="hljs-comment">// 储存 Fibonacci 数列的值</span><br><span class="hljs-type">int</span> SG[MAX_AMOUNT]; <span class="hljs-comment">// 记录 SG 值，初始化为 -1</span><br><br><span class="hljs-comment">// 记忆化搜索</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Fibonacci[n]) &#123;<br>        <span class="hljs-keyword">return</span> Fibonacci[n];<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        Fibonacci[n] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        Fibonacci[n] = <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br><br>    Fibonacci[n] = <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">fib</span>(n - <span class="hljs-number">2</span>); <span class="hljs-comment">// 记忆</span><br><br>    <span class="hljs-keyword">return</span> Fibonacci[n];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sg</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 返回 SG 值</span><br>    <span class="hljs-keyword">if</span> (SG[n] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> SG[n];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        SG[n] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-type">bool</span> vis[MAX_AMOUNT] = &#123;<span class="hljs-number">0</span>&#125;; <span class="hljs-comment">// 记录当前状态可达状态的 SG 值是否出现过</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; n - <span class="hljs-built_in">fib</span>(i) &gt;= <span class="hljs-number">0</span>; i++) &#123;<br>        vis[<span class="hljs-built_in">sg</span>(n - <span class="hljs-built_in">fib</span>(i))] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 记录已出现的 SG 值</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; MAX_AMOUNT; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!vis[i]) &#123;<br>            SG[n] = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> SG[n];<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-built_in">memset</span>(SG, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(SG)); <span class="hljs-comment">// 初始化</span><br>    <span class="hljs-type">int</span> m, n, p;<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; m &gt;&gt; n &gt;&gt; p, m != <span class="hljs-number">0</span> || n != <span class="hljs-number">0</span> || p != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">sg</span>(m) ^ <span class="hljs-built_in">sg</span>(n) ^ <span class="hljs-built_in">sg</span>(p)) &#123;<br>            <span class="hljs-comment">// SG 定理</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;Fibo&quot;</span> &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;Nacci&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SG 定理</tag>
      
      <tag>SG 函数</tag>
      
      <tag>组合博弈</tag>
      
      <tag>组合数学</tag>
      
      <tag>记忆化搜索</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记忆化 DFS</title>
    <link href="/2023/02/26/%E8%AE%B0%E5%BF%86%E5%8C%96%20DFS/"/>
    <url>/2023/02/26/%E8%AE%B0%E5%BF%86%E5%8C%96%20DFS/</url>
    
    <content type="html"><![CDATA[<h4 id="引入">引入</h4><p>记忆化DFS，顾名思义，就是<strong>带有记忆的深度优先搜索</strong>。</p><p>总所周知，用程序实现 Fibonacci 数列求值有两种常见方式：</p><ul><li><p>通过迭代即非递归的方式：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> pre = <span class="hljs-number">1</span>, next = <span class="hljs-number">1</span>, sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n-- &gt; <span class="hljs-number">2</span>) &#123;<br>        sum = pre + next;<br>        pre = next;<br>        next = sum;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>通过递归方式：</p><p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ul><p>上述两种方式各有优缺点，迭代方式效率更高，但是写起来比较麻烦；递归方式运行效率低，但是代码实现容易。</p><p><em>有没有一种方式可以结合两者的优点呢？</em></p><p>对于第二种递归方式，其主要的时间开销在于计算了许多重复内容，我们是否可以使用一个数组来维护已经计算过的值呢？</p><p>答案是显然的，于是我们就有了 —— <strong>记忆化 DFS</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> fib[MAX_NUM]; <span class="hljs-comment">// 记忆数组</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (fib[n]) &#123;<br>        <span class="hljs-keyword">return</span> fib[n]; <span class="hljs-comment">// 已经计算过的值直接返回</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">2</span>) &#123;<br>        fib[n] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        fib[n] = <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(n - <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> fib[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码以递归的方式实现，但是时间复杂度可以降到线性，和迭代形式一样，不同的地方在于我们需要额外的空间开销来记录已经计算过的值。</p><p>可能有同学就有疑问了：</p><p><em>上述例子很容易用 DP 来实现，为什么还需要记忆化 DFS 呢？</em></p><p>接下来我们将给出几个实际例子加以说明。</p><h4 id="实例分析">实例分析</h4><h5 id="案例一">案例一</h5><blockquote><p><strong>猫和老鼠</strong></p><p>Problem Description 有个小老鼠在校园里收藏了一些它最爱吃的奶酪。校园可以看成一个长度为n的正方形网格，每个网格可以标记为 (p, q) ，其中，0&lt;= p , q &lt; n。每个网格都有一个洞，里面储存了 k（0 &lt;= k &lt;=100）块奶酪。</p><p>现在，小老鼠准备享用这些美味啦。</p><p>开始的时候，他在 (0, 0)这个位置，每到一个地方，它都会吃光这个地方的奶酪，然后沿着水平或者垂直的方向到达另外一个地方。麻烦的是，有个很凶的猫总是在它的洞口附近，所以他每次最多移动k个位置，否则就会被这只猫吃掉。更糟糕的是，每在一个地方吃过奶酪，小老鼠都会变胖，所以，为了获得足够下一次逃跑的能量，它每次只能去比当前位置的奶酪更多的格子。现在已知 n 和 k，以及在每个网格的洞中小老鼠储存的奶酪的数量，请计算小老鼠在无法移动之前，一共最多能吃到多少块奶酪。</p><p>Input 题目包含多组测试数据。</p><p>每组测试数据组成如下： 首先一行包含2个不超过100的正整数 n 和 k ;接下来 n 行，每行包含n个数： 第一行 n 个数分别表示 (0, 0), (0, 1), … (0,n - 1) 这些位置储存的奶酪数量； 第二行 n 个数分别表示 (1, 0), (1, 1), …(1, n - 1) 这些位置储存的奶酪数量； 以此类推...</p><p>输入数据以两个 -1 结束。</p><p>Output 请输出小老鼠最多 能够吃到的奶酪数量，每组数据输出一行。</p><p>输入案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs input">3 1<br>1 2 5<br>10 11 6<br>12 12 7<br>-1 -1<br></code></pre></td></tr></table></figure><p>输出案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">37<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析</strong>：</p><p>根据题意，我们假设从 <span class="math inline">\((x, y)\)</span>出发的老鼠可以吃到的最大奶酪数量为 <span class="math inline">\(ans(x,y)\)</span>，<span class="math inline">\((x, y)\)</span> 处的芝士储量为<span class="math inline">\(cheese(x, y)\)</span>，老鼠可以从 <spanclass="math inline">\((x, y)\)</span> 出发在一次 <spanclass="math inline">\(k\)</span> 步以内的移动中到达的坐标的集合为 <spanclass="math inline">\(S = \{(x_1, y_1), (x_2, y_2), (x_3, y_3),...\}\)</span>，不难得出状态转移方程： <span class="math display">\[ans(x, y) = max_{(x_n, y_n) \in S} ans(x_n, y_n) \ + \ cheese(x, y)\]</span>如果直接用动态规划求解，这个问题的处理会相当复杂，因为我们难以从该状态转移方程中确定DP 的起点和 DP 的方向，所以直接采用迭代的方式恐怕不现实。</p><p>于是我们便考虑到可以使用记忆化DFS，既保证了效率，又降低了编码难度。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;array&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENG 105</span><br><br><span class="hljs-type">int</span> cheese[MAX_LENG][MAX_LENG];<br><span class="hljs-type">int</span> ans[MAX_LENG][MAX_LENG]; <span class="hljs-comment">// 储存结果，初始化为 -1</span><br><br><span class="hljs-type">int</span> n, k;<br><span class="hljs-type">const</span> vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt;&gt; dirs = &#123;<br>    &#123;<span class="hljs-number">1</span>, <span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>&#125;,<br>    &#123;<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>&#125;<br>&#125;; <span class="hljs-comment">// 运动方向</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// 记忆化 DFS</span><br>    <span class="hljs-comment">// 返回以 (x, y) 为起点可以吃到最多的奶酪</span><br>    <span class="hljs-keyword">if</span> (ans[x][y] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 已经计算过的值</span><br>        <span class="hljs-keyword">return</span> ans[x][y];<br>    &#125;<br>    ans[x][y] = cheese[x][y];<br>    <span class="hljs-type">int</span> plusCheese = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; dir :dirs) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> s = <span class="hljs-number">1</span>; s &lt;= k; s++) &#123;<br>            <span class="hljs-type">int</span> nx = x + s * dir[<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ny = y + s * dir[<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; n &amp;&amp; cheese[nx][ny] &gt; cheese[x][y]) &#123;<br>                plusCheese = <span class="hljs-built_in">max</span>(plusCheese, <span class="hljs-built_in">dfs</span>(nx, ny));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    ans[x][y] += plusCheese;<br>    <span class="hljs-keyword">return</span> ans[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n &gt;&gt; k, n != <span class="hljs-number">-1</span> || k != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(ans));<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>                cin &gt;&gt; cheese[i][j];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="案例二">案例二</h5><blockquote><p><strong>How many ways</strong></p><p>Problem Description这是一个简单的生存游戏，你控制一个机器人从一个棋盘的起始点 (1, 1)走到棋盘的终点 (n, m)。游戏的规则描述如下：</p><ol type="1"><li>机器人一开始在棋盘的起始点并有起始点所标有的能量。</li><li>机器人只能向右或者向下走，并且每走一步消耗一单位能量。</li><li>机器人不能在原地停留。</li><li>当机器人选择了一条可行路径后，当他走到这条路径的终点时，他将只有终点所标记的能量。</li></ol><figure><img src="http://acm.hdu.edu.cn/data/images/C113-1003-1.gif"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>如上图，机器人一开始在 (1, 1)点，并拥有4单位能量，蓝色方块表示他所能到达的点，如果他在这次路径选择中选择的终点是(2, 4) ，当他到达 (2, 4)点时将拥有1单位的能量，并开始下一次路径选择，直到到达 (6, 6) 点。我们的问题是机器人有多少种方式从起点走到终点。这可能是一个很大的数，输出的结果对10000 取模。</p><p>Input 第一行输入一个整数T,表示数据的组数。对于每一组数据第一行输入两个整数 n, m (1 &lt;= n, m &lt;=100)。表示棋盘的大小。接下来输入 n 行,每行 m 个整数 e (0 &lt;= e &lt;20)。</p><p>Output 对于每一组数据输出方式总数对10000取模的结果。</p><p>输入案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs input">1<br>6 6<br>4 5 6 6 4 3<br>2 2 3 1 7 2<br>1 1 4 6 2 7<br>5 8 4 3 9 5<br>7 6 6 2 1 5<br>3 1 1 3 7 2<br></code></pre></td></tr></table></figure><p>输出案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3948<br></code></pre></td></tr></table></figure></blockquote><p><strong>分析</strong>：</p><p>同案例一，我们只需找到状态转移方程后使用记忆化 DFS即可，这里不再赘述。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">int</span> T; <span class="hljs-comment">// 数据组数</span><br><span class="hljs-type">int</span> n, m;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENG 105</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 10000</span><br><br><span class="hljs-type">int</span> energy[MAX_LENG][MAX_LENG]; <span class="hljs-comment">// 记录每个格点点能量</span><br><span class="hljs-type">int</span> ans[MAX_LENG][MAX_LENG]; <span class="hljs-comment">// 记录答案，初始化为 -1</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>    <span class="hljs-comment">// 表示从 (x, y) 出发到终点又多少种走法</span><br>    <span class="hljs-keyword">if</span> (ans[x][y] &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> ans[x][y];<br>    &#125;<br>    <span class="hljs-keyword">if</span> (x == n - <span class="hljs-number">1</span> &amp;&amp; y == m - <span class="hljs-number">1</span>) &#123;<br>        ans[x][y] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> ans[x][y];<br>    &#125;<br>    <span class="hljs-type">int</span> power = energy[x][y]; <span class="hljs-comment">// 能量</span><br>    ans[x][y] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= power; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= power - i; j++) &#123;<br>            <span class="hljs-comment">// 遍历所有可能位置</span><br>            <span class="hljs-type">int</span> nx = x + i, ny = y + j;<br>            <span class="hljs-keyword">if</span> (nx != x || ny != y) &#123;<br>                <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; m) &#123;<br>                    ans[x][y] = (ans[x][y] + <span class="hljs-built_in">dfs</span>(nx, ny)) % MAX_NUM;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans[x][y];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin &gt;&gt; T;<br>    <span class="hljs-keyword">while</span> (T--) &#123;<br>        cin &gt;&gt; n &gt;&gt; m;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; j++) &#123;<br>                cin &gt;&gt; energy[i][j];<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">memset</span>(ans, <span class="hljs-number">0xff</span>, <span class="hljs-built_in">sizeof</span>(ans));<br>        cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>记忆化搜索</tag>
      
      <tag>DFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分匹配问题 —— 匈牙利算法</title>
    <link href="/2023/02/25/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/25/%E4%BA%8C%E5%88%86%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="问题介绍">问题介绍</h3><p><strong>什么是二分图？</strong></p><p>对于图 <span class="math inline">\(G(V,E)\)</span> 而言，若 <spanclass="math inline">\(G\)</span> 中的所有点可以划分为两个子集 <spanclass="math inline">\(G_1\)</span>、<spanclass="math inline">\(G_2\)</span> ，且图中每条边 <spanclass="math inline">\(e\)</span>关联的两个顶点都属于不同的顶点子集，这样的图我们称为<strong>二分图（Bipartite Graph ）</strong>，或者二部图。</p><p><img src="https://p.ipic.vip/ueiehn.png" style="zoom:67%;" /></p><p><strong>最大匹配问题和最小点覆盖问题</strong></p><p>什么是<strong>最大匹配问题</strong>？给定一个二分图 <spanclass="math inline">\(G(V,E)\)</span>，若 <spanclass="math inline">\((a_i,b_j) \in E\)</span> ，我们就称 <spanclass="math inline">\(a_i\)</span> 和 <spanclass="math inline">\(b_j\)</span>是可配对的，已知该图中任意顶点至多匹配一个顶点，求最大匹配数。如下图，不难看出该图的最大匹配数为2。其中一种匹配方式为 <span class="math inline">\((a_1,b_1)\)</span>、<span class="math inline">\((a_3, b_4)\)</span> 。</p><p>什么又是<strong>最小点覆盖问题</strong>呢？即从二分图中删除最少的顶点，使得图<span class="math inline">\(G\)</span>中任何一对点都无法匹配。删除顶点的最小数量称为最小点覆盖数。如下图，不难看出最小覆盖数也是2。我们可以删去 <span class="math inline">\(a_3\)</span> 和 <spanclass="math inline">\(b_1\)</span> 使得图中任何一对点都无法匹配。</p><p>这两个问题看似不一样，实际上实际上是处理一个相同的问题。为什么这么说呢？因为我们可以证明一条重要性质：</p><center><strong>最大匹配数 = 最小覆盖数</strong></center><p>具体证明就不在这里说明了，笔者打算以后单独出一期文章来证明该性质。</p><p><img src="https://p.ipic.vip/5pnk5n.png" style="zoom:45%;" /></p><p>那我们该如何给出二分匹配问题的一般解决方案呢？1955 年，库恩（W.W.Kuhn ）利用一个匈牙利数学家康哥尼（ D.Kőnig）的一个定理构造了一种二分匹配问题的解法，后人称之为<strong>匈牙利算法</strong>。</p><h3 id="匈牙利算法">匈牙利算法</h3><p>在介绍匈牙利算法之前，我们先介绍几个概念：</p><ul><li><p><strong>交替路</strong>：</p><p>从未匹配点出发，依次经过未匹配的边和已匹配的边的路径称为交替路。</p></li><li><p><strong>增广路</strong>：</p><p>经过除出发点之外其他未匹配点的交替路称为增广路。</p><p><strong>当且仅当不存在关于图 <span class="math inline">\(G\)</span>的增广路径时当前的匹配为图 <span class="math inline">\(G\)</span>的最大匹配。</strong></p></li></ul><h4 id="算法讲解">算法讲解</h4><p>如下图所示，我们接下来将使用匈牙利算法来计算该二分图的最大匹配数。</p><p>我们从 <span class="math inline">\(a_1\)</span> 开始匹配，<spanclass="math inline">\(a_1\)</span> 与 <spanclass="math inline">\(b_1\)</span> 匹配成功，即当前匹配对数为 1。</p><p><left><img src="https://p.ipic.vip/phzd9z.png" alt="(1)" style="zoom:100%; margin-right: 30px;" /><img src="https://p.ipic.vip/wfjof3.png" alt="(2)" style="zoom:100%; margin-right: 30px;" /></left></p><p>然后再对 <span class="math inline">\(a_2\)</span> 进行匹配，我们发现<span class="math inline">\(a_2\)</span> 只能匹配 <spanclass="math inline">\(b_1\)</span> ，而 <spanclass="math inline">\(b_1\)</span> 已经与 <spanclass="math inline">\(a_1\)</span> 匹配成功了，此时我们发现 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(b_3\)</span> 可以成功匹配，于是我们可以取消 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(b_1\)</span> 的匹配，然后匹配 <spanclass="math inline">\(a_1\)</span> 和 <spanclass="math inline">\(b_3\)</span> ，这个时候 <spanclass="math inline">\(a_2\)</span> 就可以匹配 <spanclass="math inline">\(b_1\)</span> 了。匹配对数加一，当前匹配对数为2。</p><p>其实这一步相当于找到了一条增广路 <span class="math inline">\((a_2,b_1, a_1, b_3)\)</span> ，然后对该增广路取反。</p><p><left><img src="https://p.ipic.vip/0dm74v.png" alt="(3)" style="zoom:100%;" /></left></p><p>接下来对 <span class="math inline">\(a_3\)</span> 进行匹配，<spanclass="math inline">\(a_3\)</span> 与 <spanclass="math inline">\(b_2\)</span>成功匹配，匹配对数加一，当前匹配对数为 3。</p><p><left><img src="https://p.ipic.vip/zhjyss.png" alt="(4)" style="zoom:100%;" /></left></p><p>最后对 <span class="math inline">\(a_4\)</span>进行匹配，发现其只能与 <span class="math inline">\(b_1\)</span> 匹配，而<span class="math inline">\(b_1\)</span> 已经与 <spanclass="math inline">\(a_1\)</span> 匹配过了，而且无法从 <spanclass="math inline">\(a_4\)</span> 出发构造一条增广路，因此 <spanclass="math inline">\(a_4\)</span> 无法与任何一个顶点成功匹配。</p><p><strong>综上所述，展示的二分图的最大匹配数为 3</strong>。</p><p><strong>伪代码：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pseudo-code">// 判断 ai 是否能匹配成功<br>for bj 与 ai 相连:<br>if bj 未被访问:<br>更新 bj 访问状态;<br>        if bj 未被匹配或者 bj 的配对点可以出发找到增广路径:<br>        将 bj 的配对点改为 ai;<br>        return true;<br><br>return false;<br></code></pre></td></tr></table></figure><p>时间复杂度：<span class="math inline">\(O(VE)\)</span></p><h4 id="代码实现">代码实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NOT_MATCH 0x3f3f3f3f</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">private</span>:<br>  <span class="hljs-type">int</span> numA, numB; <span class="hljs-comment">// numA、numB 分别表示两个集合的元素个数</span><br>  vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; G; <span class="hljs-comment">// 假设这里用邻接链表储存图 G，G[i] 表示和 ai 相邻的所有 B 集合的顶点编号</span><br>  <span class="hljs-type">int</span> match[numB]; <span class="hljs-comment">// 记录 B 集合的元素的匹配点在 A 集合的编号</span><br>  <span class="hljs-type">bool</span> vis[numB]; <span class="hljs-comment">// 记录 B 集合的元素是否被访问过</span><br><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>      <span class="hljs-comment">// 判断 A 集合中编号为 index 的顶点是否能匹配成功</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; G[index].<span class="hljs-built_in">size</span>(); i++) &#123;<br>          <span class="hljs-keyword">if</span> (!vis[G[i]]) &#123;<br>              vis[G[i]] = <span class="hljs-literal">true</span>;<br>              <span class="hljs-keyword">if</span> (match[G[i]] == NOT_MATCH || <span class="hljs-built_in">isMatch</span>(match[[G[i]]])) &#123;<br>                <span class="hljs-comment">// 该顶点未被匹配或着原来匹配该点的顶点可以匹配其他顶点</span><br>                  match[G[i]] = index;<br>                  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>      <br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">hungarian</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; numA; i++) &#123;<br>          <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isMatch</span>(i)) &#123;<br>              cnt++;<br>            &#125;<br>        &#125;<br>      <br>      <span class="hljs-keyword">return</span> cnt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实际应用">实际应用</h4><blockquote><p><strong>Machine Schedule</strong></p><p>Problem Description As we all know, machine scheduling is a veryclassical problem in computer science and has been studied for a verylong history. Scheduling problems differ widely in the nature of theconstraints that must be satisfied and the type of schedule desired.Here we consider a 2-machine scheduling problem.</p><p>There are two machines A and B. Machine A has n kinds of workingmodes, which is called <span class="math inline">\(mode_0\)</span> ,<span class="math inline">\(mode_1\)</span> , …, <spanclass="math inline">\(mode_{n-1}\)</span> , likewise machine B has mkinds of working modes, <span class="math inline">\(mode_0\)</span>,<span class="math inline">\(mode_1\)</span> , … , <spanclass="math inline">\(mode_{m-1}\)</span> . At the beginning they areboth work at <span class="math inline">\(mode_0\)</span>.</p><p>For k jobs given, each of them can be processed in either one of thetwo machines in particular mode. For example, job 0 can either beprocessed in machine A at <span class="math inline">\(mode_3\)</span> orin machine B at <span class="math inline">\(mode_4\)</span> , job 1 caneither be processed in machine A at <spanclass="math inline">\(mode_2\)</span> or in machine B at <spanclass="math inline">\(mode_4\)</span> , and so on. Thus, for job i, theconstraint can be represent as a triple (i, x, y), which means it can beprocessed either in machine A at <spanclass="math inline">\(mode_x\)</span>, or in machine B at <spanclass="math inline">\(mode_y\)</span> .</p><p>Obviously, to accomplish all the jobs, we need to change themachine’s working mode from time to time, but unfortunately, themachine’s working mode can only be changed by restarting it manually. Bychanging the sequence of the jobs and assigning each job to a suitablemachine, please write a program to minimize the times of restartingmachines.</p><p>Input The input file for this program consists of severalconfigurations. The first line of one configuration contains threepositive integers: n, m (n, m &lt; 100) and k (k &lt; 1000). Thefollowing k lines give the constrains of the k jobs, each line is atriple: i, x, y.</p><p>The input will be terminated by a line containing a single zero.</p><p>Output The output should be one integer per line, which means theminimal times of restarting machine.</p><p>输入案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs input">5 5 10<br>0 1 1<br>1 1 2<br>2 1 3<br>3 1 4<br>4 2 1<br>5 2 2<br>6 2 3<br>7 2 4<br>8 3 3<br>9 4 3<br>0<br></code></pre></td></tr></table></figure><p>输出案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs output">3<br></code></pre></td></tr></table></figure></blockquote><p>对于此题，我们可以将 A、B机器的所有模式看成二部图看成两个子集，若某个工作需要机器 A 的 x模式和机器 B 的 y 模式来完成，就将 <span class="math inline">\((a_x,b_y)\)</span>连接起来。最后我们的问题就变成了：<strong>应该如何找到该二部图的最小点覆盖数？</strong></p><p>而根据我们之前提到的结论可知，最小点覆盖数在数值上等于最大匹配数。</p><p><strong>代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NUM 105</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NOT_FOUND 0x3f3f3f3f</span><br><br><span class="hljs-type">int</span> G[MAX_NUM][MAX_NUM];<br><span class="hljs-type">bool</span> vis[MAX_NUM];<br><span class="hljs-type">int</span> match[MAX_NUM];<br><br><span class="hljs-type">int</span> n, m, k;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-keyword">if</span> (G[index][i] &amp;&amp; !vis[i]) &#123;<br>            vis[i] = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (match[i] == NOT_FOUND || <span class="hljs-built_in">isMatch</span>(match[i])) &#123;<br>                match[i] = index;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">while</span> (cin &gt;&gt; n) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        cin &gt;&gt; m &gt;&gt; k;<br>        <span class="hljs-built_in">memset</span>(G, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(G));<br>        <span class="hljs-built_in">memset</span>(match, <span class="hljs-number">0x3f</span>, <span class="hljs-built_in">sizeof</span>(match));<br>        <span class="hljs-comment">// 初始化</span><br>        <span class="hljs-type">int</span> t, ax, by;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            cin &gt;&gt; t &gt;&gt; ax &gt;&gt; by;<br>            <span class="hljs-keyword">if</span> (ax != <span class="hljs-number">0</span> &amp;&amp; by != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 0 号模式下可以完成的任务不用添加</span><br>                G[ax][by] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-built_in">memset</span>(vis, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(vis));<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isMatch</span>(i)) &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 求出最小点覆盖数</span><br><br>        cout &lt;&lt; cnt &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构与算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DFS</tag>
      
      <tag>二分匹配</tag>
      
      <tag>匈牙利算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LLDB 快速入门</title>
    <link href="/2023/02/22/LLDB%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2023/02/22/LLDB%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><strong><em>如果调试是删除 bug 的过程，那么编程就是引入 bug的过程。</em></strong></p><p><strong>—— Edsger W. Dijkstra</strong></p><hr /><h4 id="lldb-是什么">LLDB 是什么？</h4><p>LLDB（ Low level Debug ）是 MacOS 默认进行调试 C/C++程序的调试工具，能帮开发者进行更加丰富地流程控制和栈帧数据监测。</p><p><strong>简言之，LLDB 是一个有着 REPL 的特性和 C++ 、Python插件的开源调试器。</strong></p><p>在此，我们以几个简单的程序为例子，对 LLDB 进行快速入门。</p><p><strong>目录</strong></p><ul><li><p>启动 LLDB</p></li><li><p>断点操作</p><ul><li>设置断点</li><li>查看断点</li><li>删除断点</li></ul></li><li><p>分步调试</p><ul><li>启动调试</li><li>进入，跳过和继续</li><li>跳出当前函数</li></ul></li><li><p>查看变量</p></li><li><p>结束调试</p></li></ul><h4 id="启动-lldb">启动 LLDB</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// demo.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fact</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">fact</span>(n - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-type">int</span> x = <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> y = <span class="hljs-number">3</span>;<br>    <span class="hljs-type">int</span> z = x + y;<br><br>    cout &lt;&lt; <span class="hljs-built_in">fact</span>(z) &lt;&lt; endl;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译 C/C++ 程序时使其可以被 LLDB 调试工具设置断点，需要添加<code>-g</code> ，以 C++ 文件 <code>demo.cpp</code> 为例：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">clang++ -g demo.cpp<br><br>lldb a.out<br></code></pre></td></tr></table></figure><h4 id="断点操作">断点操作</h4><h6 id="设置断点">设置断点</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">br s -f [文件名] -l [行号]# 在文件的某一行设置断点<br>br s -n [函数名]# 给函数设置断点<br></code></pre></td></tr></table></figure><h6 id="查看断点">查看断点</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">br list# 显示所有断点和其序号<br></code></pre></td></tr></table></figure><h6 id="删除断点">删除断点</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">br <span class="hljs-built_in">del</span> [断点序号]<br>br <span class="hljs-built_in">del</span> # 删除所有断点<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cmd">(lldb) br s -f demo.cpp -l <span class="hljs-number">17</span><br>Breakpoint <span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">28</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span>, address = <span class="hljs-number">0</span>x0000000100003d80<br>(lldb) br s -f demo.cpp -l <span class="hljs-number">21</span><br>Breakpoint <span class="hljs-number">2</span>: where = a.out`main + <span class="hljs-number">56</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span>, address = <span class="hljs-number">0</span>x0000000100003d9c<br>(lldb) br s -n fact<br>Breakpoint <span class="hljs-number">3</span>: where = a.out`fact(int) + <span class="hljs-number">16</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">6</span>:<span class="hljs-number">9</span>, address = <span class="hljs-number">0</span>x0000000100003d18<br>(lldb) br list<br>Current breakpoints:<br><span class="hljs-number">1</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">17</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">1</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">28</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d80], unresolved, hit count = <span class="hljs-number">0</span> <br><br><span class="hljs-number">2</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">21</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">2</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">56</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d9c], unresolved, hit count = <span class="hljs-number">0</span> <br><br><span class="hljs-number">3</span>: name = &#x27;fact&#x27;, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">3</span>.<span class="hljs-number">1</span>: where = a.out`fact(int) + <span class="hljs-number">16</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">6</span>:<span class="hljs-number">9</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d18], unresolved, hit count = <span class="hljs-number">0</span> <br><br>(lldb) br <span class="hljs-built_in">del</span> <span class="hljs-number">3</span><br><span class="hljs-number">1</span> breakpoints deleted; <span class="hljs-number">0</span> breakpoint locations disabled.<br>(lldb) br list<br>Current breakpoints:<br><span class="hljs-number">1</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">17</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">1</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">28</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d80], unresolved, hit count = <span class="hljs-number">0</span> <br><br><span class="hljs-number">2</span>: file = &#x27;demo.cpp&#x27;, line = <span class="hljs-number">21</span>, exact_match = <span class="hljs-number">0</span>, locations = <span class="hljs-number">1</span><br>  <span class="hljs-number">2</span>.<span class="hljs-number">1</span>: where = a.out`main + <span class="hljs-number">56</span> <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span>, address = a.out[<span class="hljs-number">0</span>x0000000100003d9c], unresolved, hit count = <span class="hljs-number">0</span> <br></code></pre></td></tr></table></figure><h4 id="分步调试">分步调试</h4><h6 id="启动调试">启动调试</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">r<br></code></pre></td></tr></table></figure><blockquote><p>输入 <code>run</code> 或者 <code>r</code> 后程序便会开始启动调试</p></blockquote><h6 id="进入跳过和继续">进入，跳过和继续</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 进入单步执行，中间如果有函数调用会跳转到目标函数<br>s<br><br># 跳过单步执行，中间的函数执行过程会跳过<br>n<br><br># 继续跳转到下一个断点<br>c<br></code></pre></td></tr></table></figure><h6 id="跳出当前函数">跳出当前函数</h6><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">finish<br></code></pre></td></tr></table></figure><h4 id="查看变量">查看变量</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cmd"># 查看某个变量：<br>p [变量名]<br><br><br># 查看当前栈帧所有变量<br>fr v<br><br><br># 切换栈帧<br>fr s [栈帧序号]<br><br><br># 打印当前线程的栈帧信息<br>bt<br><br><br># 打印所有线程的栈帧信息<br>bt all<br></code></pre></td></tr></table></figure><p>综合案例：在 <code>demo.cpp</code> 的 17 行和 21 行设置断点，使用<code>r</code> 开始调试</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs cmd">* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint <span class="hljs-number">1</span>.<span class="hljs-number">1</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d80 a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">17</span>:<span class="hljs-number">9</span><br>   <span class="hljs-number">14</span>  <br>   <span class="hljs-number">15</span>   int main() &#123;<br>   <span class="hljs-number">16</span>  <br>-&gt; <span class="hljs-number">17</span>       int x = <span class="hljs-number">2</span>;<br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step <span class="hljs-keyword">in</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d88 a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">18</span>:<span class="hljs-number">9</span><br>   <span class="hljs-number">15</span>   int main() &#123;<br>   <span class="hljs-number">16</span>  <br>   <span class="hljs-number">17</span>       int x = <span class="hljs-number">2</span>;<br>-&gt; <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>   <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step <span class="hljs-keyword">in</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d8c a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">19</span>:<span class="hljs-number">13</span><br>   <span class="hljs-number">16</span>  <br>   <span class="hljs-number">17</span>       int x = <span class="hljs-number">2</span>;<br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>-&gt; <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>   <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>   <span class="hljs-number">22</span>  <br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = breakpoint <span class="hljs-number">2</span>.<span class="hljs-number">1</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d9c a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">18</span><br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>-&gt; <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>   <span class="hljs-number">22</span>  <br>   <span class="hljs-number">23</span>       return <span class="hljs-number">0</span>;<br>   <span class="hljs-number">24</span>   &#125;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) fr v<br>(int) x = <span class="hljs-number">2</span><br>(int) y = <span class="hljs-number">3</span><br>(int) z = <span class="hljs-number">5</span><br>(lldb) s<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step <span class="hljs-keyword">in</span><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003d18 a.out`fact(n=<span class="hljs-number">5</span>) <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">6</span>:<span class="hljs-number">9</span><br>   <span class="hljs-number">3</span>    using namespace std;<br>   <span class="hljs-number">4</span>   <br>   <span class="hljs-number">5</span>    int fact(int n) &#123;<br>-&gt; <span class="hljs-number">6</span>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-number">7</span>            return <span class="hljs-number">1</span>;<br>   <span class="hljs-number">8</span>        &#125;<br>   <span class="hljs-number">9</span>        <span class="hljs-keyword">else</span> &#123;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) finish<br>Process <span class="hljs-number">31435</span> stopped<br>* thread #<span class="hljs-number">1</span>, queue = &#x27;com.apple.main-thread&#x27;, stop reason = step out<br>Return value: (int) $<span class="hljs-number">0</span> = <span class="hljs-number">120</span><br><br>    frame #<span class="hljs-number">0</span>: <span class="hljs-number">0</span>x0000000100003da4 a.out`main <span class="hljs-built_in">at</span> demo.cpp:<span class="hljs-number">21</span>:<span class="hljs-number">13</span><br>   <span class="hljs-number">18</span>       int y = <span class="hljs-number">3</span>;<br>   <span class="hljs-number">19</span>       int z = x + y;<br>   <span class="hljs-number">20</span>  <br>-&gt; <span class="hljs-number">21</span>       cout &lt;&lt; fact(z) &lt;&lt; endl;<br>   <span class="hljs-number">22</span>  <br>   <span class="hljs-number">23</span>       return <span class="hljs-number">0</span>;<br>   <span class="hljs-number">24</span>   &#125;<br>Target <span class="hljs-number">0</span>: (a.out) stopped.<br>(lldb) c<br>Process <span class="hljs-number">31435</span> resuming<br><span class="hljs-number">120</span><br>Process <span class="hljs-number">31435</span> exited with status = <span class="hljs-number">0</span> (<span class="hljs-number">0</span>x00000000)<br></code></pre></td></tr></table></figure><h4 id="结束调试">结束调试</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">q<br></code></pre></td></tr></table></figure><blockquote><p>输入 <code>quit</code> 或者 <code>q</code> 结束 LLDB 调试</p></blockquote><p><strong>以上就是对 LLDB 的一个简单介绍了，如果想了解更多 LLDB指令，可以查看官网的 <a href="https://lldb.llvm.org/use/map.html">LLDBcommand map</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>调试器</tag>
      
      <tag>LLDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React 脚手架配置代理的方法</title>
    <link href="/2023/02/07/React%20%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <url>/2023/02/07/React%20%E8%84%9A%E6%89%8B%E6%9E%B6%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h4 id="方法一直接在-package.json-中追加配置">方法一：直接在<code>package.json</code> 中追加配置</h4><p>例如，当前服务器端口为 3000，若要向端口 5000的服务器发送请求，我们可以在 <code>package.json</code>中添加如下配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:5000&quot;</span><br></code></pre></td></tr></table></figure><p>此后，当请求了 3000 端口不存在的资源时，那么请求就会转发给 5000端口。</p><p>示例：</p><p>例如一个 <code>create-react-app</code> 创建项目在 3001端口运行，我们使用 <code>json-server</code> 模拟了一个 3000端口的服务器，其中 JSON 数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;students&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0001&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Tom&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0002&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Jack&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">19</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;0003&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Frank&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><code>students</code> 数据的 URL 为<code>http://localhost:3000/students</code>，若我们要向 3001 端口发送GET 请求来获取 <code>students</code> 的 JSON 数据，则可以在<code>package.json</code> 中添加配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://localhost:3000&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>获取 3001 端口有的资源：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br><br>  getInfo = <span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:3001/index.html&quot;</span>).<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>      &#125;<br>    );<br>  &#125;<br><br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.getInfo&#125;</span>&gt;</span>点击发送请求获取数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时控制台输出当前项目下的 <code>index.html</code> 文件：</p><p><left><img src="https://p.ipic.vip/vyhdeu.png" alt="image-20230207230919387" style="zoom: 33%;" /></left></p></li><li><p>获取 3001 端口没有而 3000 端口有的资源：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> &#123;<br><br>  getInfo = <span class="hljs-function">() =&gt;</span> &#123;<br>    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;http://localhost:3001/students&quot;</span>).<span class="hljs-title function_">then</span>(<br>      <span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(response.<span class="hljs-property">data</span>);<br>      &#125;,<br>      <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);<br>      &#125;<br>    );<br>  &#125;<br><br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.getInfo&#125;</span>&gt;</span>点击发送请求获取数据<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时控制台输出 3000 端口下的 <code>students</code> 数据：</p><p><left><img src="https://p.ipic.vip/hxjhru.png" alt="image-20230207231130393" style="zoom:50%;" /></left></p></li><li><p>若获取的资源 3001 端口和 3000端口都没有，则控制台会报错。</p></li></ul><blockquote><p>方法一优缺点：</p><ul><li>优点：配置简单，前端请求资源时可以不加任何前缀</li><li>缺点：不能配置多个代理</li></ul></blockquote><h4 id="方法二创建-setupproxy.js-文件">方法二：创建<code>setupProxy.js</code> 文件</h4><ol type="1"><li><p>首先在 src 目录下创建 <code>setupProxy.js</code> 文件</p></li><li><p>编写 <code>setupProxy.js</code> 配置具体代码规范：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 配置端口 8000 和端口 5001 的服务器代理</span><br><span class="hljs-comment">// setupProxy.js</span><br><br><span class="hljs-keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><span class="hljs-comment">// 引入内置模块: HTTP 代理中间件</span><br><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">app</span>) &#123;<br>    <span class="hljs-comment">// app 为服务对象</span><br>    app.<span class="hljs-title function_">use</span>(<br>        <span class="hljs-title function_">createProxyMiddleware</span>(<span class="hljs-string">&#x27;/api1&#x27;</span>, &#123;<span class="hljs-comment">// 遇见 /api1 前缀的请求，就会触发该代理</span><br>            <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8000&#x27;</span>,<span class="hljs-comment">// 请求转发的端口地址</span><br>            <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<span class="hljs-comment">// 控制服务器收到响应头中 Host 字段的值</span><br>            <span class="hljs-attr">pathRewrite</span>: &#123;<br>                <span class="hljs-string">&#x27;^/api1&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">// 去除请求前缀，保证交给后台服务器的是正常请求地址</span><br>            &#125;<br>        &#125;)<br>    );<br>    <br>    app.<span class="hljs-title function_">use</span>(<br>        <span class="hljs-title function_">createProxyMiddleware</span>(<span class="hljs-string">&#x27;/api2&#x27;</span>, &#123;<br>            <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5001&#x27;</span>,<br>            <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">pathRewrite</span>: &#123;<br>                <span class="hljs-string">&#x27;^/api2&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span><br>            &#125;<br>        &#125;)<br>    );<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><code>http-proxy-middleware</code> 1.x 版本后配置代理使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br></code></pre></td></tr></table></figure><p>此前使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br></code></pre></td></tr></table></figure></blockquote></li><li><p>向不同端口发送请求的方法：</p><ul><li><p>如果要向 8000 端口发送请求，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/api1/teachers&#x27;</span>).<span class="hljs-title function_">then</span>(<br>  <span class="hljs-comment">// ...</span><br>);<br></code></pre></td></tr></table></figure></li><li><p>如果要向 5001 端口发送请求，同理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://localhost:3000/api2/students&#x27;</span>).<span class="hljs-title function_">then</span>(<br><span class="hljs-comment">// ...</span><br>);<br></code></pre></td></tr></table></figure></li></ul></li></ol><blockquote><p>方法二优缺点：</p><ul><li>优点：可以配置多个代理，可以更加灵活地控制是否走代理请求</li><li>缺点：配置繁琐，前端发送代理请求时必须加前缀</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
